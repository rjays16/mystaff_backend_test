{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nvar $n = Object.defineProperty;\nvar Tn = (t, e, l) => e in t ? $n(t, e, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: l\n}) : t[e] = l;\nvar ze = (t, e, l) => (Tn(t, typeof e != \"symbol\" ? e + \"\" : e, l), l);\nimport { computed as w, toValue as Se, unref as O, ref as x, shallowRef as bt, watch as ue, getCurrentScope as Ml, onScopeDispose as xl, shallowReadonly as kt, isRef as Sn, toRef as k, readonly as We, customRef as _n, onMounted as Xe, nextTick as Ve, getCurrentInstance as gt, reactive as nl, defineComponent as H, watchEffect as Rt, mergeModels as pe, useModel as he, onBeforeUnmount as Fa, openBlock as b, createElementBlock as _, Fragment as de, createElementVNode as J, renderSlot as T, createBlock as I, Teleport as ht, mergeProps as K, normalizeClass as D, normalizeStyle as Ee, createTextVNode as ne, toDisplayString as Y, createCommentVNode as ae, render as Dl, h as Ne, inject as _e, onActivated as Vn, Transition as An, withCtx as E, useAttrs as Mt, resolveDynamicComponent as re, provide as at, createVNode as ve, useSlots as Le, normalizeProps as ge, guardReactiveProps as we, withDirectives as ut, vShow as xt, renderList as Ce, TransitionGroup as jl, withModifiers as ft, vModelCheckbox as On, vModelRadio as Nn, vModelSelect as In, createSlots as La, onUnmounted as Pn, withKeys as Wt } from \"vue\";\nconst Dt = t => w(() => {\n    const e = Se(t);\n    return e ? `justify-content-${e}` : \"\";\n  }),\n  ua = (t, e) => w(() => {\n    const l = Se(t),\n      a = Se(e);\n    return l === !0 ? \"true\" : typeof l == \"string\" ? l : a === !1 ? \"true\" : l === !1 ? \"false\" : void 0;\n  });\nclass nt {\n  constructor(e, l = {}) {\n    ze(this, \"cancelable\", !0);\n    ze(this, \"componentId\", null);\n    ze(this, \"_defaultPrevented\", !1);\n    ze(this, \"eventType\", \"\");\n    ze(this, \"nativeEvent\", null);\n    ze(this, \"_preventDefault\");\n    ze(this, \"relatedTarget\", null);\n    ze(this, \"target\", null);\n    if (!e) throw new TypeError(`Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`);\n    Object.assign(this, nt.Defaults, l, {\n      eventType: e\n    }), this._preventDefault = function () {\n      this.cancelable && (this.defaultPrevented = !0);\n    };\n  }\n  // Readable by everyone,\n  // But only overwritten by inherrited constructors\n  get defaultPrevented() {\n    return this._defaultPrevented;\n  }\n  set defaultPrevented(e) {\n    this._defaultPrevented = e;\n  }\n  // I think this is right\n  // We want to be able to have it callable to everyone,\n  // But only overwritten by inherrited constructors\n  get preventDefault() {\n    return this._preventDefault;\n  }\n  // This may not be correct, because it doesn't get correct type inferences in children\n  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue\n  set preventDefault(e) {\n    this._preventDefault = e;\n  }\n  static get Defaults() {\n    return {\n      cancelable: !0,\n      componentId: null,\n      eventType: \"\",\n      nativeEvent: null,\n      relatedTarget: null,\n      target: null\n    };\n  }\n}\nclass Bt extends nt {\n  constructor(l, a = {}) {\n    super(l, a);\n    ze(this, \"trigger\", null);\n    Object.assign(this, nt.Defaults, a, {\n      eventType: l\n    });\n  }\n  static get Defaults() {\n    return {\n      ...super.Defaults,\n      trigger: null\n    };\n  }\n}\nclass ql extends nt {\n  constructor(l, a) {\n    super(l, a);\n    ze(this, \"from\");\n    ze(this, \"to\");\n    ze(this, \"direction\");\n    Object.assign(this, nt.Defaults, a, {\n      eventType: l\n    });\n    const {\n      from: o,\n      direction: r,\n      to: s\n    } = a;\n    this.from = o, this.to = s, this.direction = r;\n  }\n  static get Defaults() {\n    return {\n      ...super.Defaults\n    };\n  }\n}\nconst En = (t, e = {}) => {\n    const l = (o = []) => {\n        const {\n          activeElement: r\n        } = document;\n        return r && !o.some(s => s === r) ? r : null;\n      },\n      a = o => o === l();\n    try {\n      t.focus(e);\n    } catch (o) {\n      console.error(o);\n    }\n    return a(t);\n  },\n  Ae = t => ((t == null ? void 0 : t()) ?? []).length === 0,\n  Fn = t => {\n    if (t.getAttribute(\"display\") === \"none\") return !1;\n    const e = t.getBoundingClientRect();\n    return !!(e && e.height > 0 && e.width > 0);\n  },\n  wa = t => {\n    const e = window.getComputedStyle(t),\n      l = e.transitionDelay.split(\",\")[0] || \"\",\n      a = e.transitionDuration.split(\",\")[0] || \"\",\n      o = Number(l.slice(0, -1)) * 1e3,\n      r = Number(a.slice(0, -1)) * 1e3;\n    return o + r;\n  },\n  za = typeof window < \"u\" && typeof document < \"u\" && typeof navigator < \"u\",\n  Ln = t => (() => {\n    let l = !1;\n    if (za) try {\n      const a = {\n        // This function will be called when the browser\n        // attempts to access the passive property\n        get passive() {\n          l = !0;\n        }\n      };\n      WINDOW.addEventListener(\"test\", a, a), WINDOW.removeEventListener(\"test\", a, a);\n    } catch {\n      l = !1;\n    }\n    return l;\n  })() ? typeof t == \"object\" ? t : {\n    capture: !!t || !1\n  } : typeof t == \"object\" ? t.capture : t,\n  zn = (t, e, l, a) => {\n    t && t.addEventListener && t.addEventListener(e, l, Ln(a));\n  },\n  Hn = (t, e, l, a) => {\n    t && t.removeEventListener && t.removeEventListener(e, l, a);\n  },\n  sl = (t, e) => {\n    (t ? zn : Hn)(...e);\n  },\n  Rn = [\"TD\", \"TH\", \"TR\"],\n  Mn = [\"a\", \"a *\",\n  // Include content inside links\n  \"button\", \"button *\",\n  // Include content inside buttons\n  \"input:not(.disabled):not([disabled])\", \"select:not(.disabled):not([disabled])\", \"textarea:not(.disabled):not([disabled])\", '[role=\"link\"]', '[role=\"link\"] *', '[role=\"button\"]', '[role=\"button\"] *', \"[tabindex]:not(.disabled):not([disabled])\"].join(\",\"),\n  Gt = t => {\n    if (!t || !t.target) return !1;\n    const e = t.target;\n    if (\"disabled\" in e && e.disabled || Rn.indexOf(e.tagName) !== -1) return !1;\n    if (e.closest(\".dropdown-menu\")) return !0;\n    const l = e.tagName === \"LABEL\" ? e : e.closest(\"label\");\n    if (l) {\n      const a = l.getAttribute(\"for\"),\n        o = a ? document.getElementById(a) : l.querySelector(\"input, select, textarea\");\n      if (o && !o.disabled) return !0;\n    }\n    return e.matches(Mn);\n  },\n  Wl = [\"top\", \"right\", \"bottom\", \"left\"],\n  rl = [\"start\", \"end\"],\n  il = /* @__PURE__ */Wl.reduce((t, e) => t.concat(e, e + \"-\" + rl[0], e + \"-\" + rl[1]), []),\n  tt = Math.min,\n  Ie = Math.max,\n  ea = Math.round,\n  Ut = Math.floor,\n  pt = t => ({\n    x: t,\n    y: t\n  }),\n  xn = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n  },\n  Dn = {\n    start: \"end\",\n    end: \"start\"\n  };\nfunction Ca(t, e, l) {\n  return Ie(t, tt(e, l));\n}\nfunction dt(t, e) {\n  return typeof t == \"function\" ? t(e) : t;\n}\nfunction Ue(t) {\n  return t.split(\"-\")[0];\n}\nfunction Qe(t) {\n  return t.split(\"-\")[1];\n}\nfunction Gl(t) {\n  return t === \"x\" ? \"y\" : \"x\";\n}\nfunction Ha(t) {\n  return t === \"y\" ? \"height\" : \"width\";\n}\nfunction Nt(t) {\n  return [\"top\", \"bottom\"].includes(Ue(t)) ? \"y\" : \"x\";\n}\nfunction Ra(t) {\n  return Gl(Nt(t));\n}\nfunction Ul(t, e, l) {\n  l === void 0 && (l = !1);\n  const a = Qe(t),\n    o = Ra(t),\n    r = Ha(o);\n  let s = o === \"x\" ? a === (l ? \"end\" : \"start\") ? \"right\" : \"left\" : a === \"start\" ? \"bottom\" : \"top\";\n  return e.reference[r] > e.floating[r] && (s = aa(s)), [s, aa(s)];\n}\nfunction jn(t) {\n  const e = aa(t);\n  return [ta(t), e, ta(e)];\n}\nfunction ta(t) {\n  return t.replace(/start|end/g, e => Dn[e]);\n}\nfunction qn(t, e, l) {\n  const a = [\"left\", \"right\"],\n    o = [\"right\", \"left\"],\n    r = [\"top\", \"bottom\"],\n    s = [\"bottom\", \"top\"];\n  switch (t) {\n    case \"top\":\n    case \"bottom\":\n      return l ? e ? o : a : e ? a : o;\n    case \"left\":\n    case \"right\":\n      return e ? r : s;\n    default:\n      return [];\n  }\n}\nfunction Wn(t, e, l, a) {\n  const o = Qe(t);\n  let r = qn(Ue(t), l === \"start\", a);\n  return o && (r = r.map(s => s + \"-\" + o), e && (r = r.concat(r.map(ta)))), r;\n}\nfunction aa(t) {\n  return t.replace(/left|right|bottom|top/g, e => xn[e]);\n}\nfunction Gn(t) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...t\n  };\n}\nfunction Ma(t) {\n  return typeof t != \"number\" ? Gn(t) : {\n    top: t,\n    right: t,\n    bottom: t,\n    left: t\n  };\n}\nfunction Vt(t) {\n  return {\n    ...t,\n    top: t.y,\n    left: t.x,\n    right: t.x + t.width,\n    bottom: t.y + t.height\n  };\n}\nfunction ul(t, e, l) {\n  let {\n    reference: a,\n    floating: o\n  } = t;\n  const r = Nt(e),\n    s = Ra(e),\n    n = Ha(s),\n    i = Ue(e),\n    u = r === \"y\",\n    d = a.x + a.width / 2 - o.width / 2,\n    p = a.y + a.height / 2 - o.height / 2,\n    f = a[n] / 2 - o[n] / 2;\n  let m;\n  switch (i) {\n    case \"top\":\n      m = {\n        x: d,\n        y: a.y - o.height\n      };\n      break;\n    case \"bottom\":\n      m = {\n        x: d,\n        y: a.y + a.height\n      };\n      break;\n    case \"right\":\n      m = {\n        x: a.x + a.width,\n        y: p\n      };\n      break;\n    case \"left\":\n      m = {\n        x: a.x - o.width,\n        y: p\n      };\n      break;\n    default:\n      m = {\n        x: a.x,\n        y: a.y\n      };\n  }\n  switch (Qe(e)) {\n    case \"start\":\n      m[s] -= f * (l && u ? -1 : 1);\n      break;\n    case \"end\":\n      m[s] += f * (l && u ? -1 : 1);\n      break;\n  }\n  return m;\n}\nconst Un = async (t, e, l) => {\n  const {\n      placement: a = \"bottom\",\n      strategy: o = \"absolute\",\n      middleware: r = [],\n      platform: s\n    } = l,\n    n = r.filter(Boolean),\n    i = await (s.isRTL == null ? void 0 : s.isRTL(e));\n  let u = await s.getElementRects({\n      reference: t,\n      floating: e,\n      strategy: o\n    }),\n    {\n      x: d,\n      y: p\n    } = ul(u, a, i),\n    f = a,\n    m = {},\n    y = 0;\n  for (let h = 0; h < n.length; h++) {\n    const {\n        name: c,\n        fn: g\n      } = n[h],\n      {\n        x: v,\n        y: $,\n        data: B,\n        reset: C\n      } = await g({\n        x: d,\n        y: p,\n        initialPlacement: a,\n        placement: f,\n        strategy: o,\n        middlewareData: m,\n        rects: u,\n        platform: s,\n        elements: {\n          reference: t,\n          floating: e\n        }\n      });\n    d = v ?? d, p = $ ?? p, m = {\n      ...m,\n      [c]: {\n        ...m[c],\n        ...B\n      }\n    }, C && y <= 50 && (y++, typeof C == \"object\" && (C.placement && (f = C.placement), C.rects && (u = C.rects === !0 ? await s.getElementRects({\n      reference: t,\n      floating: e,\n      strategy: o\n    }) : C.rects), ({\n      x: d,\n      y: p\n    } = ul(u, f, i))), h = -1);\n  }\n  return {\n    x: d,\n    y: p,\n    placement: f,\n    strategy: o,\n    middlewareData: m\n  };\n};\nasync function At(t, e) {\n  var l;\n  e === void 0 && (e = {});\n  const {\n      x: a,\n      y: o,\n      platform: r,\n      rects: s,\n      elements: n,\n      strategy: i\n    } = t,\n    {\n      boundary: u = \"clippingAncestors\",\n      rootBoundary: d = \"viewport\",\n      elementContext: p = \"floating\",\n      altBoundary: f = !1,\n      padding: m = 0\n    } = dt(e, t),\n    y = Ma(m),\n    c = n[f ? p === \"floating\" ? \"reference\" : \"floating\" : p],\n    g = Vt(await r.getClippingRect({\n      element: (l = await (r.isElement == null ? void 0 : r.isElement(c))) == null || l ? c : c.contextElement || (await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(n.floating))),\n      boundary: u,\n      rootBoundary: d,\n      strategy: i\n    })),\n    v = p === \"floating\" ? {\n      ...s.floating,\n      x: a,\n      y: o\n    } : s.reference,\n    $ = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(n.floating)),\n    B = (await (r.isElement == null ? void 0 : r.isElement($))) ? (await (r.getScale == null ? void 0 : r.getScale($))) || {\n      x: 1,\n      y: 1\n    } : {\n      x: 1,\n      y: 1\n    },\n    C = Vt(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({\n      elements: n,\n      rect: v,\n      offsetParent: $,\n      strategy: i\n    }) : v);\n  return {\n    top: (g.top - C.top + y.top) / B.y,\n    bottom: (C.bottom - g.bottom + y.bottom) / B.y,\n    left: (g.left - C.left + y.left) / B.x,\n    right: (C.right - g.right + y.right) / B.x\n  };\n}\nconst Kn = t => ({\n  name: \"arrow\",\n  options: t,\n  async fn(e) {\n    const {\n        x: l,\n        y: a,\n        placement: o,\n        rects: r,\n        platform: s,\n        elements: n,\n        middlewareData: i\n      } = e,\n      {\n        element: u,\n        padding: d = 0\n      } = dt(t, e) || {};\n    if (u == null) return {};\n    const p = Ma(d),\n      f = {\n        x: l,\n        y: a\n      },\n      m = Ra(o),\n      y = Ha(m),\n      h = await s.getDimensions(u),\n      c = m === \"y\",\n      g = c ? \"top\" : \"left\",\n      v = c ? \"bottom\" : \"right\",\n      $ = c ? \"clientHeight\" : \"clientWidth\",\n      B = r.reference[y] + r.reference[m] - f[m] - r.floating[y],\n      C = f[m] - r.reference[m],\n      V = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u));\n    let L = V ? V[$] : 0;\n    (!L || !(await (s.isElement == null ? void 0 : s.isElement(V)))) && (L = n.floating[$] || r.floating[y]);\n    const Q = B / 2 - C / 2,\n      W = L / 2 - h[y] / 2 - 1,\n      F = tt(p[g], W),\n      Z = tt(p[v], W),\n      R = F,\n      le = L - h[y] - Z,\n      N = L / 2 - h[y] / 2 + Q,\n      S = Ca(R, N, le),\n      P = !i.arrow && Qe(o) != null && N !== S && r.reference[y] / 2 - (N < R ? F : Z) - h[y] / 2 < 0,\n      M = P ? N < R ? N - R : N - le : 0;\n    return {\n      [m]: f[m] + M,\n      data: {\n        [m]: S,\n        centerOffset: N - S - M,\n        ...(P && {\n          alignmentOffset: M\n        })\n      },\n      reset: P\n    };\n  }\n});\nfunction Xn(t, e, l) {\n  return (t ? [...l.filter(o => Qe(o) === t), ...l.filter(o => Qe(o) !== t)] : l.filter(o => Ue(o) === o)).filter(o => t ? Qe(o) === t || (e ? ta(o) !== o : !1) : !0);\n}\nconst Yn = function (t) {\n    return t === void 0 && (t = {}), {\n      name: \"autoPlacement\",\n      options: t,\n      async fn(e) {\n        var l, a, o;\n        const {\n            rects: r,\n            middlewareData: s,\n            placement: n,\n            platform: i,\n            elements: u\n          } = e,\n          {\n            crossAxis: d = !1,\n            alignment: p,\n            allowedPlacements: f = il,\n            autoAlignment: m = !0,\n            ...y\n          } = dt(t, e),\n          h = p !== void 0 || f === il ? Xn(p || null, m, f) : f,\n          c = await At(e, y),\n          g = ((l = s.autoPlacement) == null ? void 0 : l.index) || 0,\n          v = h[g];\n        if (v == null) return {};\n        const $ = Ul(v, r, await (i.isRTL == null ? void 0 : i.isRTL(u.floating)));\n        if (n !== v) return {\n          reset: {\n            placement: h[0]\n          }\n        };\n        const B = [c[Ue(v)], c[$[0]], c[$[1]]],\n          C = [...(((a = s.autoPlacement) == null ? void 0 : a.overflows) || []), {\n            placement: v,\n            overflows: B\n          }],\n          V = h[g + 1];\n        if (V) return {\n          data: {\n            index: g + 1,\n            overflows: C\n          },\n          reset: {\n            placement: V\n          }\n        };\n        const L = C.map(F => {\n            const Z = Qe(F.placement);\n            return [F.placement, Z && d ?\n            // Check along the mainAxis and main crossAxis side.\n            F.overflows.slice(0, 2).reduce((R, le) => R + le, 0) :\n            // Check only the mainAxis.\n            F.overflows[0], F.overflows];\n          }).sort((F, Z) => F[1] - Z[1]),\n          W = ((o = L.filter(F => F[2].slice(0,\n          // Aligned placements should not check their opposite crossAxis\n          // side.\n          Qe(F[0]) ? 2 : 3).every(Z => Z <= 0))[0]) == null ? void 0 : o[0]) || L[0][0];\n        return W !== n ? {\n          data: {\n            index: g + 1,\n            overflows: C\n          },\n          reset: {\n            placement: W\n          }\n        } : {};\n      }\n    };\n  },\n  Zn = function (t) {\n    return t === void 0 && (t = {}), {\n      name: \"flip\",\n      options: t,\n      async fn(e) {\n        var l, a;\n        const {\n            placement: o,\n            middlewareData: r,\n            rects: s,\n            initialPlacement: n,\n            platform: i,\n            elements: u\n          } = e,\n          {\n            mainAxis: d = !0,\n            crossAxis: p = !0,\n            fallbackPlacements: f,\n            fallbackStrategy: m = \"bestFit\",\n            fallbackAxisSideDirection: y = \"none\",\n            flipAlignment: h = !0,\n            ...c\n          } = dt(t, e);\n        if ((l = r.arrow) != null && l.alignmentOffset) return {};\n        const g = Ue(o),\n          v = Ue(n) === n,\n          $ = await (i.isRTL == null ? void 0 : i.isRTL(u.floating)),\n          B = f || (v || !h ? [aa(n)] : jn(n));\n        !f && y !== \"none\" && B.push(...Wn(n, h, y, $));\n        const C = [n, ...B],\n          V = await At(e, c),\n          L = [];\n        let Q = ((a = r.flip) == null ? void 0 : a.overflows) || [];\n        if (d && L.push(V[g]), p) {\n          const R = Ul(o, s, $);\n          L.push(V[R[0]], V[R[1]]);\n        }\n        if (Q = [...Q, {\n          placement: o,\n          overflows: L\n        }], !L.every(R => R <= 0)) {\n          var W, F;\n          const R = (((W = r.flip) == null ? void 0 : W.index) || 0) + 1,\n            le = C[R];\n          if (le) return {\n            data: {\n              index: R,\n              overflows: Q\n            },\n            reset: {\n              placement: le\n            }\n          };\n          let N = (F = Q.filter(S => S.overflows[0] <= 0).sort((S, P) => S.overflows[1] - P.overflows[1])[0]) == null ? void 0 : F.placement;\n          if (!N) switch (m) {\n            case \"bestFit\":\n              {\n                var Z;\n                const S = (Z = Q.map(P => [P.placement, P.overflows.filter(M => M > 0).reduce((M, j) => M + j, 0)]).sort((P, M) => P[1] - M[1])[0]) == null ? void 0 : Z[0];\n                S && (N = S);\n                break;\n              }\n            case \"initialPlacement\":\n              N = n;\n              break;\n          }\n          if (o !== N) return {\n            reset: {\n              placement: N\n            }\n          };\n        }\n        return {};\n      }\n    };\n  };\nfunction dl(t, e) {\n  return {\n    top: t.top - e.height,\n    right: t.right - e.width,\n    bottom: t.bottom - e.height,\n    left: t.left - e.width\n  };\n}\nfunction cl(t) {\n  return Wl.some(e => t[e] >= 0);\n}\nconst Jn = function (t) {\n  return t === void 0 && (t = {}), {\n    name: \"hide\",\n    options: t,\n    async fn(e) {\n      const {\n          rects: l\n        } = e,\n        {\n          strategy: a = \"referenceHidden\",\n          ...o\n        } = dt(t, e);\n      switch (a) {\n        case \"referenceHidden\":\n          {\n            const r = await At(e, {\n                ...o,\n                elementContext: \"reference\"\n              }),\n              s = dl(r, l.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: s,\n                referenceHidden: cl(s)\n              }\n            };\n          }\n        case \"escaped\":\n          {\n            const r = await At(e, {\n                ...o,\n                altBoundary: !0\n              }),\n              s = dl(r, l.floating);\n            return {\n              data: {\n                escapedOffsets: s,\n                escaped: cl(s)\n              }\n            };\n          }\n        default:\n          return {};\n      }\n    }\n  };\n};\nfunction Kl(t) {\n  const e = tt(...t.map(r => r.left)),\n    l = tt(...t.map(r => r.top)),\n    a = Ie(...t.map(r => r.right)),\n    o = Ie(...t.map(r => r.bottom));\n  return {\n    x: e,\n    y: l,\n    width: a - e,\n    height: o - l\n  };\n}\nfunction Qn(t) {\n  const e = t.slice().sort((o, r) => o.y - r.y),\n    l = [];\n  let a = null;\n  for (let o = 0; o < e.length; o++) {\n    const r = e[o];\n    !a || r.y - a.y > a.height / 2 ? l.push([r]) : l[l.length - 1].push(r), a = r;\n  }\n  return l.map(o => Vt(Kl(o)));\n}\nconst es = function (t) {\n  return t === void 0 && (t = {}), {\n    name: \"inline\",\n    options: t,\n    async fn(e) {\n      const {\n          placement: l,\n          elements: a,\n          rects: o,\n          platform: r,\n          strategy: s\n        } = e,\n        {\n          padding: n = 2,\n          x: i,\n          y: u\n        } = dt(t, e),\n        d = Array.from((await (r.getClientRects == null ? void 0 : r.getClientRects(a.reference))) || []),\n        p = Qn(d),\n        f = Vt(Kl(d)),\n        m = Ma(n);\n      function y() {\n        if (p.length === 2 && p[0].left > p[1].right && i != null && u != null) return p.find(c => i > c.left - m.left && i < c.right + m.right && u > c.top - m.top && u < c.bottom + m.bottom) || f;\n        if (p.length >= 2) {\n          if (Nt(l) === \"y\") {\n            const F = p[0],\n              Z = p[p.length - 1],\n              R = Ue(l) === \"top\",\n              le = F.top,\n              N = Z.bottom,\n              S = R ? F.left : Z.left,\n              P = R ? F.right : Z.right,\n              M = P - S,\n              j = N - le;\n            return {\n              top: le,\n              bottom: N,\n              left: S,\n              right: P,\n              width: M,\n              height: j,\n              x: S,\n              y: le\n            };\n          }\n          const c = Ue(l) === \"left\",\n            g = Ie(...p.map(F => F.right)),\n            v = tt(...p.map(F => F.left)),\n            $ = p.filter(F => c ? F.left === v : F.right === g),\n            B = $[0].top,\n            C = $[$.length - 1].bottom,\n            V = v,\n            L = g,\n            Q = L - V,\n            W = C - B;\n          return {\n            top: B,\n            bottom: C,\n            left: V,\n            right: L,\n            width: Q,\n            height: W,\n            x: V,\n            y: B\n          };\n        }\n        return f;\n      }\n      const h = await r.getElementRects({\n        reference: {\n          getBoundingClientRect: y\n        },\n        floating: a.floating,\n        strategy: s\n      });\n      return o.reference.x !== h.reference.x || o.reference.y !== h.reference.y || o.reference.width !== h.reference.width || o.reference.height !== h.reference.height ? {\n        reset: {\n          rects: h\n        }\n      } : {};\n    }\n  };\n};\nasync function ts(t, e) {\n  const {\n      placement: l,\n      platform: a,\n      elements: o\n    } = t,\n    r = await (a.isRTL == null ? void 0 : a.isRTL(o.floating)),\n    s = Ue(l),\n    n = Qe(l),\n    i = Nt(l) === \"y\",\n    u = [\"left\", \"top\"].includes(s) ? -1 : 1,\n    d = r && i ? -1 : 1,\n    p = dt(e, t);\n  let {\n    mainAxis: f,\n    crossAxis: m,\n    alignmentAxis: y\n  } = typeof p == \"number\" ? {\n    mainAxis: p,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...p\n  };\n  return n && typeof y == \"number\" && (m = n === \"end\" ? y * -1 : y), i ? {\n    x: m * d,\n    y: f * u\n  } : {\n    x: f * u,\n    y: m * d\n  };\n}\nconst Xl = function (t) {\n    return t === void 0 && (t = 0), {\n      name: \"offset\",\n      options: t,\n      async fn(e) {\n        var l, a;\n        const {\n            x: o,\n            y: r,\n            placement: s,\n            middlewareData: n\n          } = e,\n          i = await ts(e, t);\n        return s === ((l = n.offset) == null ? void 0 : l.placement) && (a = n.arrow) != null && a.alignmentOffset ? {} : {\n          x: o + i.x,\n          y: r + i.y,\n          data: {\n            ...i,\n            placement: s\n          }\n        };\n      }\n    };\n  },\n  as = function (t) {\n    return t === void 0 && (t = {}), {\n      name: \"shift\",\n      options: t,\n      async fn(e) {\n        const {\n            x: l,\n            y: a,\n            placement: o\n          } = e,\n          {\n            mainAxis: r = !0,\n            crossAxis: s = !1,\n            limiter: n = {\n              fn: c => {\n                let {\n                  x: g,\n                  y: v\n                } = c;\n                return {\n                  x: g,\n                  y: v\n                };\n              }\n            },\n            ...i\n          } = dt(t, e),\n          u = {\n            x: l,\n            y: a\n          },\n          d = await At(e, i),\n          p = Nt(Ue(o)),\n          f = Gl(p);\n        let m = u[f],\n          y = u[p];\n        if (r) {\n          const c = f === \"y\" ? \"top\" : \"left\",\n            g = f === \"y\" ? \"bottom\" : \"right\",\n            v = m + d[c],\n            $ = m - d[g];\n          m = Ca(v, m, $);\n        }\n        if (s) {\n          const c = p === \"y\" ? \"top\" : \"left\",\n            g = p === \"y\" ? \"bottom\" : \"right\",\n            v = y + d[c],\n            $ = y - d[g];\n          y = Ca(v, y, $);\n        }\n        const h = n.fn({\n          ...e,\n          [f]: m,\n          [p]: y\n        });\n        return {\n          ...h,\n          data: {\n            x: h.x - l,\n            y: h.y - a\n          }\n        };\n      }\n    };\n  },\n  ls = function (t) {\n    return t === void 0 && (t = {}), {\n      name: \"size\",\n      options: t,\n      async fn(e) {\n        const {\n            placement: l,\n            rects: a,\n            platform: o,\n            elements: r\n          } = e,\n          {\n            apply: s = () => {},\n            ...n\n          } = dt(t, e),\n          i = await At(e, n),\n          u = Ue(l),\n          d = Qe(l),\n          p = Nt(l) === \"y\",\n          {\n            width: f,\n            height: m\n          } = a.floating;\n        let y, h;\n        u === \"top\" || u === \"bottom\" ? (y = u, h = d === ((await (o.isRTL == null ? void 0 : o.isRTL(r.floating))) ? \"start\" : \"end\") ? \"left\" : \"right\") : (h = u, y = d === \"end\" ? \"top\" : \"bottom\");\n        const c = m - i[y],\n          g = f - i[h],\n          v = !e.middlewareData.shift;\n        let $ = c,\n          B = g;\n        if (p) {\n          const V = f - i.left - i.right;\n          B = d || v ? tt(g, V) : V;\n        } else {\n          const V = m - i.top - i.bottom;\n          $ = d || v ? tt(c, V) : V;\n        }\n        if (v && !d) {\n          const V = Ie(i.left, 0),\n            L = Ie(i.right, 0),\n            Q = Ie(i.top, 0),\n            W = Ie(i.bottom, 0);\n          p ? B = f - 2 * (V !== 0 || L !== 0 ? V + L : Ie(i.left, i.right)) : $ = m - 2 * (Q !== 0 || W !== 0 ? Q + W : Ie(i.top, i.bottom));\n        }\n        await s({\n          ...e,\n          availableWidth: B,\n          availableHeight: $\n        });\n        const C = await o.getDimensions(r.floating);\n        return f !== C.width || m !== C.height ? {\n          reset: {\n            rects: !0\n          }\n        } : {};\n      }\n    };\n  };\nfunction st(t) {\n  return xa(t) ? (t.nodeName || \"\").toLowerCase() : \"#document\";\n}\nfunction xe(t) {\n  var e;\n  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;\n}\nfunction ct(t) {\n  var e;\n  return (e = (xa(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;\n}\nfunction xa(t) {\n  return t instanceof Node || t instanceof xe(t).Node;\n}\nfunction rt(t) {\n  return t instanceof Element || t instanceof xe(t).Element;\n}\nfunction lt(t) {\n  return t instanceof HTMLElement || t instanceof xe(t).HTMLElement;\n}\nfunction fl(t) {\n  return typeof ShadowRoot > \"u\" ? !1 : t instanceof ShadowRoot || t instanceof xe(t).ShadowRoot;\n}\nfunction jt(t) {\n  const {\n    overflow: e,\n    overflowX: l,\n    overflowY: a,\n    display: o\n  } = Ke(t);\n  return /auto|scroll|overlay|hidden|clip/.test(e + a + l) && ![\"inline\", \"contents\"].includes(o);\n}\nfunction os(t) {\n  return [\"table\", \"td\", \"th\"].includes(st(t));\n}\nfunction Da(t) {\n  const e = ja(),\n    l = Ke(t);\n  return l.transform !== \"none\" || l.perspective !== \"none\" || (l.containerType ? l.containerType !== \"normal\" : !1) || !e && (l.backdropFilter ? l.backdropFilter !== \"none\" : !1) || !e && (l.filter ? l.filter !== \"none\" : !1) || [\"transform\", \"perspective\", \"filter\"].some(a => (l.willChange || \"\").includes(a)) || [\"paint\", \"layout\", \"strict\", \"content\"].some(a => (l.contain || \"\").includes(a));\n}\nfunction ns(t) {\n  let e = Ot(t);\n  for (; lt(e) && !da(e);) {\n    if (Da(e)) return e;\n    e = Ot(e);\n  }\n  return null;\n}\nfunction ja() {\n  return typeof CSS > \"u\" || !CSS.supports ? !1 : CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction da(t) {\n  return [\"html\", \"body\", \"#document\"].includes(st(t));\n}\nfunction Ke(t) {\n  return xe(t).getComputedStyle(t);\n}\nfunction ca(t) {\n  return rt(t) ? {\n    scrollLeft: t.scrollLeft,\n    scrollTop: t.scrollTop\n  } : {\n    scrollLeft: t.pageXOffset,\n    scrollTop: t.pageYOffset\n  };\n}\nfunction Ot(t) {\n  if (st(t) === \"html\") return t;\n  const e =\n  // Step into the shadow DOM of the parent of a slotted node.\n  t.assignedSlot ||\n  // DOM Element detected.\n  t.parentNode ||\n  // ShadowRoot detected.\n  fl(t) && t.host ||\n  // Fallback.\n  ct(t);\n  return fl(e) ? e.host : e;\n}\nfunction Yl(t) {\n  const e = Ot(t);\n  return da(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : lt(e) && jt(e) ? e : Yl(e);\n}\nfunction Lt(t, e, l) {\n  var a;\n  e === void 0 && (e = []), l === void 0 && (l = !0);\n  const o = Yl(t),\n    r = o === ((a = t.ownerDocument) == null ? void 0 : a.body),\n    s = xe(o);\n  return r ? e.concat(s, s.visualViewport || [], jt(o) ? o : [], s.frameElement && l ? Lt(s.frameElement) : []) : e.concat(o, Lt(o, [], l));\n}\nfunction Zl(t) {\n  const e = Ke(t);\n  let l = parseFloat(e.width) || 0,\n    a = parseFloat(e.height) || 0;\n  const o = lt(t),\n    r = o ? t.offsetWidth : l,\n    s = o ? t.offsetHeight : a,\n    n = ea(l) !== r || ea(a) !== s;\n  return n && (l = r, a = s), {\n    width: l,\n    height: a,\n    $: n\n  };\n}\nfunction qa(t) {\n  return rt(t) ? t : t.contextElement;\n}\nfunction _t(t) {\n  const e = qa(t);\n  if (!lt(e)) return pt(1);\n  const l = e.getBoundingClientRect(),\n    {\n      width: a,\n      height: o,\n      $: r\n    } = Zl(e);\n  let s = (r ? ea(l.width) : l.width) / a,\n    n = (r ? ea(l.height) : l.height) / o;\n  return (!s || !Number.isFinite(s)) && (s = 1), (!n || !Number.isFinite(n)) && (n = 1), {\n    x: s,\n    y: n\n  };\n}\nconst ss = /* @__PURE__ */pt(0);\nfunction Jl(t) {\n  const e = xe(t);\n  return !ja() || !e.visualViewport ? ss : {\n    x: e.visualViewport.offsetLeft,\n    y: e.visualViewport.offsetTop\n  };\n}\nfunction rs(t, e, l) {\n  return e === void 0 && (e = !1), !l || e && l !== xe(t) ? !1 : e;\n}\nfunction yt(t, e, l, a) {\n  e === void 0 && (e = !1), l === void 0 && (l = !1);\n  const o = t.getBoundingClientRect(),\n    r = qa(t);\n  let s = pt(1);\n  e && (a ? rt(a) && (s = _t(a)) : s = _t(t));\n  const n = rs(r, l, a) ? Jl(r) : pt(0);\n  let i = (o.left + n.x) / s.x,\n    u = (o.top + n.y) / s.y,\n    d = o.width / s.x,\n    p = o.height / s.y;\n  if (r) {\n    const f = xe(r),\n      m = a && rt(a) ? xe(a) : a;\n    let y = f,\n      h = y.frameElement;\n    for (; h && a && m !== y;) {\n      const c = _t(h),\n        g = h.getBoundingClientRect(),\n        v = Ke(h),\n        $ = g.left + (h.clientLeft + parseFloat(v.paddingLeft)) * c.x,\n        B = g.top + (h.clientTop + parseFloat(v.paddingTop)) * c.y;\n      i *= c.x, u *= c.y, d *= c.x, p *= c.y, i += $, u += B, y = xe(h), h = y.frameElement;\n    }\n  }\n  return Vt({\n    width: d,\n    height: p,\n    x: i,\n    y: u\n  });\n}\nconst is = [\":popover-open\", \":modal\"];\nfunction Ql(t) {\n  return is.some(e => {\n    try {\n      return t.matches(e);\n    } catch {\n      return !1;\n    }\n  });\n}\nfunction us(t) {\n  let {\n    elements: e,\n    rect: l,\n    offsetParent: a,\n    strategy: o\n  } = t;\n  const r = o === \"fixed\",\n    s = ct(a),\n    n = e ? Ql(e.floating) : !1;\n  if (a === s || n && r) return l;\n  let i = {\n      scrollLeft: 0,\n      scrollTop: 0\n    },\n    u = pt(1);\n  const d = pt(0),\n    p = lt(a);\n  if ((p || !p && !r) && ((st(a) !== \"body\" || jt(s)) && (i = ca(a)), lt(a))) {\n    const f = yt(a);\n    u = _t(a), d.x = f.x + a.clientLeft, d.y = f.y + a.clientTop;\n  }\n  return {\n    width: l.width * u.x,\n    height: l.height * u.y,\n    x: l.x * u.x - i.scrollLeft * u.x + d.x,\n    y: l.y * u.y - i.scrollTop * u.y + d.y\n  };\n}\nfunction ds(t) {\n  return Array.from(t.getClientRects());\n}\nfunction eo(t) {\n  return yt(ct(t)).left + ca(t).scrollLeft;\n}\nfunction cs(t) {\n  const e = ct(t),\n    l = ca(t),\n    a = t.ownerDocument.body,\n    o = Ie(e.scrollWidth, e.clientWidth, a.scrollWidth, a.clientWidth),\n    r = Ie(e.scrollHeight, e.clientHeight, a.scrollHeight, a.clientHeight);\n  let s = -l.scrollLeft + eo(t);\n  const n = -l.scrollTop;\n  return Ke(a).direction === \"rtl\" && (s += Ie(e.clientWidth, a.clientWidth) - o), {\n    width: o,\n    height: r,\n    x: s,\n    y: n\n  };\n}\nfunction fs(t, e) {\n  const l = xe(t),\n    a = ct(t),\n    o = l.visualViewport;\n  let r = a.clientWidth,\n    s = a.clientHeight,\n    n = 0,\n    i = 0;\n  if (o) {\n    r = o.width, s = o.height;\n    const u = ja();\n    (!u || u && e === \"fixed\") && (n = o.offsetLeft, i = o.offsetTop);\n  }\n  return {\n    width: r,\n    height: s,\n    x: n,\n    y: i\n  };\n}\nfunction vs(t, e) {\n  const l = yt(t, !0, e === \"fixed\"),\n    a = l.top + t.clientTop,\n    o = l.left + t.clientLeft,\n    r = lt(t) ? _t(t) : pt(1),\n    s = t.clientWidth * r.x,\n    n = t.clientHeight * r.y,\n    i = o * r.x,\n    u = a * r.y;\n  return {\n    width: s,\n    height: n,\n    x: i,\n    y: u\n  };\n}\nfunction vl(t, e, l) {\n  let a;\n  if (e === \"viewport\") a = fs(t, l);else if (e === \"document\") a = cs(ct(t));else if (rt(e)) a = vs(e, l);else {\n    const o = Jl(t);\n    a = {\n      ...e,\n      x: e.x - o.x,\n      y: e.y - o.y\n    };\n  }\n  return Vt(a);\n}\nfunction to(t, e) {\n  const l = Ot(t);\n  return l === e || !rt(l) || da(l) ? !1 : Ke(l).position === \"fixed\" || to(l, e);\n}\nfunction ps(t, e) {\n  const l = e.get(t);\n  if (l) return l;\n  let a = Lt(t, [], !1).filter(n => rt(n) && st(n) !== \"body\"),\n    o = null;\n  const r = Ke(t).position === \"fixed\";\n  let s = r ? Ot(t) : t;\n  for (; rt(s) && !da(s);) {\n    const n = Ke(s),\n      i = Da(s);\n    !i && n.position === \"fixed\" && (o = null), (r ? !i && !o : !i && n.position === \"static\" && !!o && [\"absolute\", \"fixed\"].includes(o.position) || jt(s) && !i && to(t, s)) ? a = a.filter(d => d !== s) : o = n, s = Ot(s);\n  }\n  return e.set(t, a), a;\n}\nfunction ms(t) {\n  let {\n    element: e,\n    boundary: l,\n    rootBoundary: a,\n    strategy: o\n  } = t;\n  const s = [...(l === \"clippingAncestors\" ? ps(e, this._c) : [].concat(l)), a],\n    n = s[0],\n    i = s.reduce((u, d) => {\n      const p = vl(e, d, o);\n      return u.top = Ie(p.top, u.top), u.right = tt(p.right, u.right), u.bottom = tt(p.bottom, u.bottom), u.left = Ie(p.left, u.left), u;\n    }, vl(e, n, o));\n  return {\n    width: i.right - i.left,\n    height: i.bottom - i.top,\n    x: i.left,\n    y: i.top\n  };\n}\nfunction bs(t) {\n  const {\n    width: e,\n    height: l\n  } = Zl(t);\n  return {\n    width: e,\n    height: l\n  };\n}\nfunction ys(t, e, l) {\n  const a = lt(e),\n    o = ct(e),\n    r = l === \"fixed\",\n    s = yt(t, !0, r, e);\n  let n = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const i = pt(0);\n  if (a || !a && !r) if ((st(e) !== \"body\" || jt(o)) && (n = ca(e)), a) {\n    const p = yt(e, !0, r, e);\n    i.x = p.x + e.clientLeft, i.y = p.y + e.clientTop;\n  } else o && (i.x = eo(o));\n  const u = s.left + n.scrollLeft - i.x,\n    d = s.top + n.scrollTop - i.y;\n  return {\n    x: u,\n    y: d,\n    width: s.width,\n    height: s.height\n  };\n}\nfunction pl(t, e) {\n  return !lt(t) || Ke(t).position === \"fixed\" ? null : e ? e(t) : t.offsetParent;\n}\nfunction ao(t, e) {\n  const l = xe(t);\n  if (!lt(t) || Ql(t)) return l;\n  let a = pl(t, e);\n  for (; a && os(a) && Ke(a).position === \"static\";) a = pl(a, e);\n  return a && (st(a) === \"html\" || st(a) === \"body\" && Ke(a).position === \"static\" && !Da(a)) ? l : a || ns(t) || l;\n}\nconst gs = async function (t) {\n  const e = this.getOffsetParent || ao,\n    l = this.getDimensions;\n  return {\n    reference: ys(t.reference, await e(t.floating), t.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await l(t.floating))\n    }\n  };\n};\nfunction hs(t) {\n  return Ke(t).direction === \"rtl\";\n}\nconst Bs = {\n  convertOffsetParentRelativeRectToViewportRelativeRect: us,\n  getDocumentElement: ct,\n  getClippingRect: ms,\n  getOffsetParent: ao,\n  getElementRects: gs,\n  getClientRects: ds,\n  getDimensions: bs,\n  getScale: _t,\n  isElement: rt,\n  isRTL: hs\n};\nfunction ws(t, e) {\n  let l = null,\n    a;\n  const o = ct(t);\n  function r() {\n    var n;\n    clearTimeout(a), (n = l) == null || n.disconnect(), l = null;\n  }\n  function s(n, i) {\n    n === void 0 && (n = !1), i === void 0 && (i = 1), r();\n    const {\n      left: u,\n      top: d,\n      width: p,\n      height: f\n    } = t.getBoundingClientRect();\n    if (n || e(), !p || !f) return;\n    const m = Ut(d),\n      y = Ut(o.clientWidth - (u + p)),\n      h = Ut(o.clientHeight - (d + f)),\n      c = Ut(u),\n      v = {\n        rootMargin: -m + \"px \" + -y + \"px \" + -h + \"px \" + -c + \"px\",\n        threshold: Ie(0, tt(1, i)) || 1\n      };\n    let $ = !0;\n    function B(C) {\n      const V = C[0].intersectionRatio;\n      if (V !== i) {\n        if (!$) return s();\n        V ? s(!1, V) : a = setTimeout(() => {\n          s(!1, 1e-7);\n        }, 100);\n      }\n      $ = !1;\n    }\n    try {\n      l = new IntersectionObserver(B, {\n        ...v,\n        // Handle <iframe>s\n        root: o.ownerDocument\n      });\n    } catch {\n      l = new IntersectionObserver(B, v);\n    }\n    l.observe(t);\n  }\n  return s(!0), r;\n}\nfunction lo(t, e, l, a) {\n  a === void 0 && (a = {});\n  const {\n      ancestorScroll: o = !0,\n      ancestorResize: r = !0,\n      elementResize: s = typeof ResizeObserver == \"function\",\n      layoutShift: n = typeof IntersectionObserver == \"function\",\n      animationFrame: i = !1\n    } = a,\n    u = qa(t),\n    d = o || r ? [...(u ? Lt(u) : []), ...Lt(e)] : [];\n  d.forEach(g => {\n    o && g.addEventListener(\"scroll\", l, {\n      passive: !0\n    }), r && g.addEventListener(\"resize\", l);\n  });\n  const p = u && n ? ws(u, l) : null;\n  let f = -1,\n    m = null;\n  s && (m = new ResizeObserver(g => {\n    let [v] = g;\n    v && v.target === u && m && (m.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {\n      var $;\n      ($ = m) == null || $.observe(e);\n    })), l();\n  }), u && !i && m.observe(u), m.observe(e));\n  let y,\n    h = i ? yt(t) : null;\n  i && c();\n  function c() {\n    const g = yt(t);\n    h && (g.x !== h.x || g.y !== h.y || g.width !== h.width || g.height !== h.height) && l(), h = g, y = requestAnimationFrame(c);\n  }\n  return l(), () => {\n    var g;\n    d.forEach(v => {\n      o && v.removeEventListener(\"scroll\", l), r && v.removeEventListener(\"resize\", l);\n    }), p == null || p(), (g = m) == null || g.disconnect(), m = null, i && cancelAnimationFrame(y);\n  };\n}\nconst Cs = Yn,\n  oo = as,\n  no = Zn,\n  so = ls,\n  ks = Jn,\n  $s = Kn,\n  Ts = es,\n  Ss = (t, e, l) => {\n    const a = /* @__PURE__ */new Map(),\n      o = {\n        platform: Bs,\n        ...l\n      },\n      r = {\n        ...o.platform,\n        _c: a\n      };\n    return Un(t, e, {\n      ...o,\n      platform: r\n    });\n  };\nfunction _s(t) {\n  return t != null && typeof t == \"object\" && \"$el\" in t;\n}\nfunction ka(t) {\n  if (_s(t)) {\n    const e = t.$el;\n    return xa(e) && st(e) === \"#comment\" ? null : e;\n  }\n  return t;\n}\nfunction Vs(t) {\n  return {\n    name: \"arrow\",\n    options: t,\n    fn(e) {\n      const l = ka(O(t.element));\n      return l == null ? {} : $s({\n        element: l,\n        padding: t.padding\n      }).fn(e);\n    }\n  };\n}\nfunction ro(t) {\n  return typeof window > \"u\" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;\n}\nfunction ml(t, e) {\n  const l = ro(t);\n  return Math.round(e * l) / l;\n}\nfunction io(t, e, l) {\n  l === void 0 && (l = {});\n  const a = l.whileElementsMounted,\n    o = w(() => {\n      var L;\n      return (L = O(l.open)) != null ? L : !0;\n    }),\n    r = w(() => O(l.middleware)),\n    s = w(() => {\n      var L;\n      return (L = O(l.placement)) != null ? L : \"bottom\";\n    }),\n    n = w(() => {\n      var L;\n      return (L = O(l.strategy)) != null ? L : \"absolute\";\n    }),\n    i = w(() => {\n      var L;\n      return (L = O(l.transform)) != null ? L : !0;\n    }),\n    u = w(() => ka(t.value)),\n    d = w(() => ka(e.value)),\n    p = x(0),\n    f = x(0),\n    m = x(n.value),\n    y = x(s.value),\n    h = bt({}),\n    c = x(!1),\n    g = w(() => {\n      const L = {\n        position: m.value,\n        left: \"0\",\n        top: \"0\"\n      };\n      if (!d.value) return L;\n      const Q = ml(d.value, p.value),\n        W = ml(d.value, f.value);\n      return i.value ? {\n        ...L,\n        transform: \"translate(\" + Q + \"px, \" + W + \"px)\",\n        ...(ro(d.value) >= 1.5 && {\n          willChange: \"transform\"\n        })\n      } : {\n        position: m.value,\n        left: Q + \"px\",\n        top: W + \"px\"\n      };\n    });\n  let v;\n  function $() {\n    u.value == null || d.value == null || Ss(u.value, d.value, {\n      middleware: r.value,\n      placement: s.value,\n      strategy: n.value\n    }).then(L => {\n      p.value = L.x, f.value = L.y, m.value = L.strategy, y.value = L.placement, h.value = L.middlewareData, c.value = !0;\n    });\n  }\n  function B() {\n    typeof v == \"function\" && (v(), v = void 0);\n  }\n  function C() {\n    if (B(), a === void 0) {\n      $();\n      return;\n    }\n    if (u.value != null && d.value != null) {\n      v = a(u.value, d.value, $);\n      return;\n    }\n  }\n  function V() {\n    o.value || (c.value = !1);\n  }\n  return ue([r, s, n], $, {\n    flush: \"sync\"\n  }), ue([u, d], C, {\n    flush: \"sync\"\n  }), ue(o, V, {\n    flush: \"sync\"\n  }), Ml() && xl(B), {\n    x: kt(p),\n    y: kt(f),\n    strategy: kt(m),\n    placement: kt(y),\n    middlewareData: kt(h),\n    isPositioned: kt(c),\n    floatingStyles: g,\n    update: $\n  };\n}\nconst As = /* @__PURE__ */new Set([\"background\", \"cite\", \"href\", \"itemtype\", \"longdesc\", \"poster\", \"src\", \"xlink:href\"]),\n  Os = /^aria-[\\w-]*$/i,\n  Ns = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,\n  Is = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i,\n  Ps = (t, e) => {\n    const l = t.nodeName.toLowerCase();\n    return e.includes(l) ? As.has(l) ? !!(Ns.test(t.nodeValue || \"\") || Is.test(t.nodeValue || \"\")) : !0 : e.filter(a => a instanceof RegExp).some(a => a.test(l));\n  },\n  $t = {\n    // Global attributes allowed on any supplied element below.\n    \"*\": [\"class\", \"dir\", \"id\", \"lang\", \"role\", Os],\n    a: [\"target\", \"href\", \"title\", \"rel\"],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: [\"src\", \"srcset\", \"alt\", \"title\", \"width\", \"height\"],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  },\n  Tt = (t, e, l) => {\n    if (!t.length) return t;\n    if (l && typeof l == \"function\") return l(t);\n    const o = new window.DOMParser().parseFromString(t, \"text/html\"),\n      r = o.body.querySelectorAll(\"*\");\n    for (const s of r) {\n      const n = s.nodeName.toLowerCase();\n      if (!Object.keys(e).includes(n)) {\n        s.remove();\n        continue;\n      }\n      const i = s.attributes,\n        u = [...(e[\"*\"] || []), ...(e[n] || [])];\n      for (const d of i) Ps(d, u) || s.removeAttribute(d.nodeName);\n    }\n    return o.body.innerHTML;\n  };\nfunction it(t) {\n  return Ml() ? (xl(t), !0) : !1;\n}\nfunction Es(t, e) {\n  if (typeof Symbol < \"u\") {\n    const l = {\n      ...t\n    };\n    return Object.defineProperty(l, Symbol.iterator, {\n      enumerable: !1,\n      value() {\n        let a = 0;\n        return {\n          next: () => ({\n            value: e[a++],\n            done: a > e.length\n          })\n        };\n      }\n    }), l;\n  } else return Object.assign([...e], t);\n}\nfunction Fe(t) {\n  return typeof t == \"function\" ? t() : O(t);\n}\nconst la = typeof window < \"u\" && typeof document < \"u\";\ntypeof WorkerGlobalScope < \"u\" && globalThis instanceof WorkerGlobalScope;\nconst Fs = t => typeof t < \"u\",\n  uo = t => t != null,\n  Ls = Object.prototype.toString,\n  zs = t => Ls.call(t) === \"[object Object]\",\n  Ge = () => {},\n  $a = /* @__PURE__ */Hs();\nfunction Hs() {\n  var t, e;\n  return la && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\nfunction co(t, e) {\n  function l(...a) {\n    return new Promise((o, r) => {\n      Promise.resolve(t(() => e.apply(this, a), {\n        fn: e,\n        thisArg: this,\n        args: a\n      })).then(o).catch(r);\n    });\n  }\n  return l;\n}\nconst fo = t => t();\nfunction Rs(t, e = {}) {\n  let l,\n    a,\n    o = Ge;\n  const r = n => {\n    clearTimeout(n), o(), o = Ge;\n  };\n  return n => {\n    const i = Fe(t),\n      u = Fe(e.maxWait);\n    return l && r(l), i <= 0 || u !== void 0 && u <= 0 ? (a && (r(a), a = null), Promise.resolve(n())) : new Promise((d, p) => {\n      o = e.rejectOnCancel ? p : d, u && !a && (a = setTimeout(() => {\n        l && r(l), a = null, d(n());\n      }, u)), l = setTimeout(() => {\n        a && r(a), a = null, d(n());\n      }, i);\n    });\n  };\n}\nfunction Ms(t = fo) {\n  const e = x(!0);\n  function l() {\n    e.value = !1;\n  }\n  function a() {\n    e.value = !0;\n  }\n  const o = (...r) => {\n    e.value && t(...r);\n  };\n  return {\n    isActive: We(e),\n    pause: l,\n    resume: a,\n    eventFilter: o\n  };\n}\nfunction xs(t) {\n  const e = /* @__PURE__ */Object.create(null);\n  return l => e[l] || (e[l] = t(l));\n}\nconst Ds = /-(\\w)/g,\n  js = xs(t => t.replace(Ds, (e, l) => l ? l.toUpperCase() : \"\"));\nfunction qs(t) {\n  return t || gt();\n}\nfunction vo(...t) {\n  if (t.length !== 1) return k(...t);\n  const e = t[0];\n  return typeof e == \"function\" ? We(_n(() => ({\n    get: e,\n    set: Ge\n  }))) : x(e);\n}\nfunction Ws(t, e = 200, l = {}) {\n  return co(Rs(e, l), t);\n}\nfunction Gs(t, e, l = {}) {\n  const {\n    eventFilter: a = fo,\n    ...o\n  } = l;\n  return ue(t, co(a, e), o);\n}\nfunction Ta(t, e, l = {}) {\n  const {\n      eventFilter: a,\n      ...o\n    } = l,\n    {\n      eventFilter: r,\n      pause: s,\n      resume: n,\n      isActive: i\n    } = Ms(a);\n  return {\n    stop: Gs(t, e, {\n      ...o,\n      eventFilter: r\n    }),\n    pause: s,\n    resume: n,\n    isActive: i\n  };\n}\nfunction Sa(t, e, ...[l]) {\n  const {\n      flush: a = \"sync\",\n      deep: o = !1,\n      immediate: r = !0,\n      direction: s = \"both\",\n      transform: n = {}\n    } = l || {},\n    i = [],\n    u = \"ltr\" in n && n.ltr || (f => f),\n    d = \"rtl\" in n && n.rtl || (f => f);\n  return (s === \"both\" || s === \"ltr\") && i.push(Ta(t, f => {\n    i.forEach(m => m.pause()), e.value = u(f), i.forEach(m => m.resume());\n  }, {\n    flush: a,\n    deep: o,\n    immediate: r\n  })), (s === \"both\" || s === \"rtl\") && i.push(Ta(e, f => {\n    i.forEach(m => m.pause()), t.value = d(f), i.forEach(m => m.resume());\n  }, {\n    flush: a,\n    deep: o,\n    immediate: r\n  })), () => {\n    i.forEach(f => f.stop());\n  };\n}\nfunction po(t, e = !0, l) {\n  qs() ? Xe(t, l) : e ? t() : Ve(t);\n}\nfunction mo(t, e = 1e3, l = {}) {\n  const {\n    immediate: a = !0,\n    immediateCallback: o = !1\n  } = l;\n  let r = null;\n  const s = x(!1);\n  function n() {\n    r && (clearInterval(r), r = null);\n  }\n  function i() {\n    s.value = !1, n();\n  }\n  function u() {\n    const d = Fe(e);\n    d <= 0 || (s.value = !0, o && t(), n(), r = setInterval(t, d));\n  }\n  if (a && la && u(), Sn(e) || typeof e == \"function\") {\n    const d = ue(e, () => {\n      s.value && la && u();\n    });\n    it(d);\n  }\n  return it(i), {\n    isActive: s,\n    pause: i,\n    resume: u\n  };\n}\nfunction be(t, e = {}) {\n  const {\n    method: l = \"parseFloat\",\n    radix: a,\n    nanToZero: o\n  } = e;\n  return w(() => {\n    let r = Fe(t);\n    return typeof r == \"string\" && (r = Number[l](r, a)), o && Number.isNaN(r) && (r = 0), r;\n  });\n}\nfunction zt(t = {}) {\n  const {\n      inheritAttrs: e = !0\n    } = t,\n    l = bt(),\n    a = /* @__PURE__ */H({\n      setup(r, {\n        slots: s\n      }) {\n        return () => {\n          l.value = s.default;\n        };\n      }\n    }),\n    o = /* @__PURE__ */H({\n      inheritAttrs: e,\n      setup(r, {\n        attrs: s,\n        slots: n\n      }) {\n        return () => {\n          var i;\n          if (!l.value && process.env.NODE_ENV !== \"production\") throw new Error(\"[VueUse] Failed to find the definition of reusable template\");\n          const u = (i = l.value) == null ? void 0 : i.call(l, {\n            ...Us(s),\n            $slots: n\n          });\n          return e && (u == null ? void 0 : u.length) === 1 ? u[0] : u;\n        };\n      }\n    });\n  return Es({\n    define: a,\n    reuse: o\n  }, [a, o]);\n}\nfunction Us(t) {\n  const e = {};\n  for (const l in t) e[js(l)] = t[l];\n  return e;\n}\nfunction Me(t) {\n  var e;\n  const l = Fe(t);\n  return (e = l == null ? void 0 : l.$el) != null ? e : l;\n}\nconst De = la ? window : void 0;\nfunction ke(...t) {\n  let e, l, a, o;\n  if (typeof t[0] == \"string\" || Array.isArray(t[0]) ? ([l, a, o] = t, e = De) : [e, l, a, o] = t, !e) return Ge;\n  Array.isArray(l) || (l = [l]), Array.isArray(a) || (a = [a]);\n  const r = [],\n    s = () => {\n      r.forEach(d => d()), r.length = 0;\n    },\n    n = (d, p, f, m) => (d.addEventListener(p, f, m), () => d.removeEventListener(p, f, m)),\n    i = ue(() => [Me(e), Fe(o)], ([d, p]) => {\n      if (s(), !d) return;\n      const f = zs(p) ? {\n        ...p\n      } : p;\n      r.push(...l.flatMap(m => a.map(y => n(d, m, y, f))));\n    }, {\n      immediate: !0,\n      flush: \"post\"\n    }),\n    u = () => {\n      i(), s();\n    };\n  return it(u), u;\n}\nlet bl = !1;\nfunction bo(t, e, l = {}) {\n  const {\n    window: a = De,\n    ignore: o = [],\n    capture: r = !0,\n    detectIframe: s = !1\n  } = l;\n  if (!a) return Ge;\n  $a && !bl && (bl = !0, Array.from(a.document.body.children).forEach(f => f.addEventListener(\"click\", Ge)), a.document.documentElement.addEventListener(\"click\", Ge));\n  let n = !0;\n  const i = f => o.some(m => {\n      if (typeof m == \"string\") return Array.from(a.document.querySelectorAll(m)).some(y => y === f.target || f.composedPath().includes(y));\n      {\n        const y = Me(m);\n        return y && (f.target === y || f.composedPath().includes(y));\n      }\n    }),\n    d = [ke(a, \"click\", f => {\n      const m = Me(t);\n      if (!(!m || m === f.target || f.composedPath().includes(m))) {\n        if (f.detail === 0 && (n = !i(f)), !n) {\n          n = !0;\n          return;\n        }\n        e(f);\n      }\n    }, {\n      passive: !0,\n      capture: r\n    }), ke(a, \"pointerdown\", f => {\n      const m = Me(t);\n      n = !i(f) && !!(m && !f.composedPath().includes(m));\n    }, {\n      passive: !0\n    }), s && ke(a, \"blur\", f => {\n      setTimeout(() => {\n        var m;\n        const y = Me(t);\n        ((m = a.document.activeElement) == null ? void 0 : m.tagName) === \"IFRAME\" && !(y != null && y.contains(a.document.activeElement)) && e(f);\n      }, 0);\n    })].filter(Boolean);\n  return () => d.forEach(f => f());\n}\nfunction Ks(t) {\n  return typeof t == \"function\" ? t : typeof t == \"string\" ? e => e.key === t : Array.isArray(t) ? e => t.includes(e.key) : () => !0;\n}\nfunction Re(...t) {\n  let e,\n    l,\n    a = {};\n  t.length === 3 ? (e = t[0], l = t[1], a = t[2]) : t.length === 2 ? typeof t[1] == \"object\" ? (e = !0, l = t[0], a = t[1]) : (e = t[0], l = t[1]) : (e = !0, l = t[0]);\n  const {\n      target: o = De,\n      eventName: r = \"keydown\",\n      passive: s = !1,\n      dedupe: n = !1\n    } = a,\n    i = Ks(e);\n  return ke(o, r, d => {\n    d.repeat && Fe(n) || i(d) && l(d);\n  }, s);\n}\nfunction Xs() {\n  const t = x(!1),\n    e = gt();\n  return e && Xe(() => {\n    t.value = !0;\n  }, e), t;\n}\nfunction Wa(t) {\n  const e = Xs();\n  return w(() => (e.value, !!t()));\n}\nfunction Ys(t, e = {}) {\n  const {\n      window: l = De\n    } = e,\n    a = Wa(() => l && \"matchMedia\" in l && typeof l.matchMedia == \"function\");\n  let o;\n  const r = x(!1),\n    s = u => {\n      r.value = u.matches;\n    },\n    n = () => {\n      o && (\"removeEventListener\" in o ? o.removeEventListener(\"change\", s) : o.removeListener(s));\n    },\n    i = Rt(() => {\n      a.value && (n(), o = l.matchMedia(Fe(t)), \"addEventListener\" in o ? o.addEventListener(\"change\", s) : o.addListener(s), r.value = o.matches);\n    });\n  return it(() => {\n    i(), n(), o = void 0;\n  }), r;\n}\nfunction Zs(t) {\n  return JSON.parse(JSON.stringify(t));\n}\nconst Kt = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {},\n  Xt = \"__vueuse_ssr_handlers__\",\n  Js = /* @__PURE__ */Qs();\nfunction Qs() {\n  return Xt in Kt || (Kt[Xt] = Kt[Xt] || {}), Kt[Xt];\n}\nfunction Ga(t, e) {\n  return Js[t] || e;\n}\nfunction er(t) {\n  return t == null ? \"any\" : t instanceof Set ? \"set\" : t instanceof Map ? \"map\" : t instanceof Date ? \"date\" : typeof t == \"boolean\" ? \"boolean\" : typeof t == \"string\" ? \"string\" : typeof t == \"object\" ? \"object\" : Number.isNaN(t) ? \"any\" : \"number\";\n}\nconst tr = {\n    boolean: {\n      read: t => t === \"true\",\n      write: t => String(t)\n    },\n    object: {\n      read: t => JSON.parse(t),\n      write: t => JSON.stringify(t)\n    },\n    number: {\n      read: t => Number.parseFloat(t),\n      write: t => String(t)\n    },\n    any: {\n      read: t => t,\n      write: t => String(t)\n    },\n    string: {\n      read: t => t,\n      write: t => String(t)\n    },\n    map: {\n      read: t => new Map(JSON.parse(t)),\n      write: t => JSON.stringify(Array.from(t.entries()))\n    },\n    set: {\n      read: t => new Set(JSON.parse(t)),\n      write: t => JSON.stringify(Array.from(t))\n    },\n    date: {\n      read: t => new Date(t),\n      write: t => t.toISOString()\n    }\n  },\n  yl = \"vueuse-storage\";\nfunction ar(t, e, l, a = {}) {\n  var o;\n  const {\n      flush: r = \"pre\",\n      deep: s = !0,\n      listenToStorageChanges: n = !0,\n      writeDefaults: i = !0,\n      mergeDefaults: u = !1,\n      shallow: d,\n      window: p = De,\n      eventFilter: f,\n      onError: m = F => {\n        console.error(F);\n      },\n      initOnMounted: y\n    } = a,\n    h = (d ? bt : x)(typeof e == \"function\" ? e() : e);\n  if (!l) try {\n    l = Ga(\"getDefaultStorage\", () => {\n      var F;\n      return (F = De) == null ? void 0 : F.localStorage;\n    })();\n  } catch (F) {\n    m(F);\n  }\n  if (!l) return h;\n  const c = Fe(e),\n    g = er(c),\n    v = (o = a.serializer) != null ? o : tr[g],\n    {\n      pause: $,\n      resume: B\n    } = Ta(h, () => V(h.value), {\n      flush: r,\n      deep: s,\n      eventFilter: f\n    });\n  p && n && po(() => {\n    ke(p, \"storage\", Q), ke(p, yl, W), y && Q();\n  }), y || Q();\n  function C(F, Z) {\n    p && p.dispatchEvent(new CustomEvent(yl, {\n      detail: {\n        key: t,\n        oldValue: F,\n        newValue: Z,\n        storageArea: l\n      }\n    }));\n  }\n  function V(F) {\n    try {\n      const Z = l.getItem(t);\n      if (F == null) C(Z, null), l.removeItem(t);else {\n        const R = v.write(F);\n        Z !== R && (l.setItem(t, R), C(Z, R));\n      }\n    } catch (Z) {\n      m(Z);\n    }\n  }\n  function L(F) {\n    const Z = F ? F.newValue : l.getItem(t);\n    if (Z == null) return i && c != null && l.setItem(t, v.write(c)), c;\n    if (!F && u) {\n      const R = v.read(Z);\n      return typeof u == \"function\" ? u(R, c) : g === \"object\" && !Array.isArray(R) ? {\n        ...c,\n        ...R\n      } : R;\n    } else return typeof Z != \"string\" ? Z : v.read(Z);\n  }\n  function Q(F) {\n    if (!(F && F.storageArea !== l)) {\n      if (F && F.key == null) {\n        h.value = c;\n        return;\n      }\n      if (!(F && F.key !== t)) {\n        $();\n        try {\n          (F == null ? void 0 : F.newValue) !== v.write(h.value) && (h.value = L(F));\n        } catch (Z) {\n          m(Z);\n        } finally {\n          F ? Ve(B) : B();\n        }\n      }\n    }\n  }\n  function W(F) {\n    Q(F.detail);\n  }\n  return h;\n}\nfunction lr(t) {\n  return Ys(\"(prefers-color-scheme: dark)\", t);\n}\nfunction or(t = {}) {\n  const {\n      selector: e = \"html\",\n      attribute: l = \"class\",\n      initialValue: a = \"auto\",\n      window: o = De,\n      storage: r,\n      storageKey: s = \"vueuse-color-scheme\",\n      listenToStorageChanges: n = !0,\n      storageRef: i,\n      emitAuto: u,\n      disableTransition: d = !0\n    } = t,\n    p = {\n      auto: \"\",\n      light: \"light\",\n      dark: \"dark\",\n      ...(t.modes || {})\n    },\n    f = lr({\n      window: o\n    }),\n    m = w(() => f.value ? \"dark\" : \"light\"),\n    y = i || (s == null ? vo(a) : ar(s, a, r, {\n      window: o,\n      listenToStorageChanges: n\n    })),\n    h = w(() => y.value === \"auto\" ? m.value : y.value),\n    c = Ga(\"updateHTMLAttrs\", (B, C, V) => {\n      const L = typeof B == \"string\" ? o == null ? void 0 : o.document.querySelector(B) : Me(B);\n      if (!L) return;\n      let Q;\n      if (d && (Q = o.document.createElement(\"style\"), Q.appendChild(document.createTextNode(\"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\")), o.document.head.appendChild(Q)), C === \"class\") {\n        const W = V.split(/\\s/g);\n        Object.values(p).flatMap(F => (F || \"\").split(/\\s/g)).filter(Boolean).forEach(F => {\n          W.includes(F) ? L.classList.add(F) : L.classList.remove(F);\n        });\n      } else L.setAttribute(C, V);\n      d && (o.getComputedStyle(Q).opacity, document.head.removeChild(Q));\n    });\n  function g(B) {\n    var C;\n    c(e, l, (C = p[B]) != null ? C : B);\n  }\n  function v(B) {\n    t.onChanged ? t.onChanged(B, g) : g(B);\n  }\n  ue(h, v, {\n    flush: \"post\",\n    immediate: !0\n  }), po(() => v(h.value));\n  const $ = w({\n    get() {\n      return u ? y.value : h.value;\n    },\n    set(B) {\n      y.value = B;\n    }\n  });\n  try {\n    return Object.assign($, {\n      store: y,\n      system: m,\n      state: h\n    });\n  } catch {\n    return $;\n  }\n}\nfunction nr(t, e, l = {}) {\n  const {\n    window: a = De,\n    ...o\n  } = l;\n  let r;\n  const s = Wa(() => a && \"MutationObserver\" in a),\n    n = () => {\n      r && (r.disconnect(), r = void 0);\n    },\n    i = w(() => {\n      const f = Fe(t),\n        m = (Array.isArray(f) ? f : [f]).map(Me).filter(uo);\n      return new Set(m);\n    }),\n    u = ue(() => i.value, f => {\n      n(), s.value && a && f.size && (r = new MutationObserver(e), f.forEach(m => r.observe(m, o)));\n    }, {\n      immediate: !0,\n      flush: \"post\"\n    }),\n    d = () => r == null ? void 0 : r.takeRecords(),\n    p = () => {\n      n(), u();\n    };\n  return it(p), {\n    isSupported: s,\n    stop: p,\n    takeRecords: d\n  };\n}\nfunction Ua(t, e = {}) {\n  const {\n      delayEnter: l = 0,\n      delayLeave: a = 0,\n      window: o = De\n    } = e,\n    r = x(!1);\n  let s;\n  const n = i => {\n    const u = i ? l : a;\n    s && (clearTimeout(s), s = void 0), u ? s = setTimeout(() => r.value = i, u) : r.value = i;\n  };\n  return o && (ke(t, \"mouseenter\", () => n(!0), {\n    passive: !0\n  }), ke(t, \"mouseleave\", () => n(!1), {\n    passive: !0\n  })), r;\n}\nfunction sr(t, e, l = {}) {\n  const {\n      root: a,\n      rootMargin: o = \"0px\",\n      threshold: r = 0.1,\n      window: s = De,\n      immediate: n = !0\n    } = l,\n    i = Wa(() => s && \"IntersectionObserver\" in s),\n    u = w(() => {\n      const y = Fe(t);\n      return (Array.isArray(y) ? y : [y]).map(Me).filter(uo);\n    });\n  let d = Ge;\n  const p = x(n),\n    f = i.value ? ue(() => [u.value, Me(a), p.value], ([y, h]) => {\n      if (d(), !p.value || !y.length) return;\n      const c = new IntersectionObserver(e, {\n        root: Me(h),\n        rootMargin: o,\n        threshold: r\n      });\n      y.forEach(g => g && c.observe(g)), d = () => {\n        c.disconnect(), d = Ge;\n      };\n    }, {\n      immediate: n,\n      flush: \"post\"\n    }) : Ge,\n    m = () => {\n      d(), f(), p.value = !1;\n    };\n  return it(m), {\n    isSupported: i,\n    isActive: p,\n    pause() {\n      d(), p.value = !1;\n    },\n    resume() {\n      p.value = !0;\n    },\n    stop: m\n  };\n}\nfunction Pe(t, e = {}) {\n  const {\n      initialValue: l = !1,\n      focusVisible: a = !1\n    } = e,\n    o = x(!1),\n    r = w(() => Me(t));\n  ke(r, \"focus\", n => {\n    var i, u;\n    (!a || (u = (i = n.target).matches) != null && u.call(i, \":focus-visible\")) && (o.value = !0);\n  }), ke(r, \"blur\", () => o.value = !1);\n  const s = w({\n    get: () => o.value,\n    set(n) {\n      var i, u;\n      !n && o.value ? (i = r.value) == null || i.blur() : n && !o.value && ((u = r.value) == null || u.focus());\n    }\n  });\n  return ue(r, () => {\n    s.value = l;\n  }, {\n    immediate: !0,\n    flush: \"post\"\n  }), {\n    focused: s\n  };\n}\nfunction ba(t) {\n  return typeof Window < \"u\" && t instanceof Window ? t.document.documentElement : typeof Document < \"u\" && t instanceof Document ? t.documentElement : t;\n}\nconst rr = {\n  page: t => [t.pageX, t.pageY],\n  client: t => [t.clientX, t.clientY],\n  screen: t => [t.screenX, t.screenY],\n  movement: t => t instanceof Touch ? null : [t.movementX, t.movementY]\n};\nfunction ir(t = {}) {\n  const {\n    type: e = \"page\",\n    touch: l = !0,\n    resetOnTouchEnds: a = !1,\n    initialValue: o = {\n      x: 0,\n      y: 0\n    },\n    window: r = De,\n    target: s = r,\n    scroll: n = !0,\n    eventFilter: i\n  } = t;\n  let u = null;\n  const d = x(o.x),\n    p = x(o.y),\n    f = x(null),\n    m = typeof e == \"function\" ? e : rr[e],\n    y = C => {\n      const V = m(C);\n      u = C, V && ([d.value, p.value] = V, f.value = \"mouse\");\n    },\n    h = C => {\n      if (C.touches.length > 0) {\n        const V = m(C.touches[0]);\n        V && ([d.value, p.value] = V, f.value = \"touch\");\n      }\n    },\n    c = () => {\n      if (!u || !r) return;\n      const C = m(u);\n      u instanceof MouseEvent && C && (d.value = C[0] + r.scrollX, p.value = C[1] + r.scrollY);\n    },\n    g = () => {\n      d.value = o.x, p.value = o.y;\n    },\n    v = i ? C => i(() => y(C), {}) : C => y(C),\n    $ = i ? C => i(() => h(C), {}) : C => h(C),\n    B = i ? () => i(() => c(), {}) : () => c();\n  if (s) {\n    const C = {\n      passive: !0\n    };\n    ke(s, [\"mousemove\", \"dragover\"], v, C), l && e !== \"movement\" && (ke(s, [\"touchstart\", \"touchmove\"], $, C), a && ke(s, \"touchend\", g, C)), n && e === \"page\" && ke(r, \"scroll\", B, {\n      passive: !0\n    });\n  }\n  return {\n    x: d,\n    y: p,\n    sourceType: f\n  };\n}\nfunction gl(t, e = {}) {\n  const {\n      handleOutside: l = !0,\n      window: a = De\n    } = e,\n    o = e.type || \"page\",\n    {\n      x: r,\n      y: s,\n      sourceType: n\n    } = ir(e),\n    i = x(t ?? (a == null ? void 0 : a.document.body)),\n    u = x(0),\n    d = x(0),\n    p = x(0),\n    f = x(0),\n    m = x(0),\n    y = x(0),\n    h = x(!0);\n  let c = () => {};\n  return a && (c = ue([i, r, s], () => {\n    const g = Me(i);\n    if (!g) return;\n    const {\n      left: v,\n      top: $,\n      width: B,\n      height: C\n    } = g.getBoundingClientRect();\n    p.value = v + (o === \"page\" ? a.pageXOffset : 0), f.value = $ + (o === \"page\" ? a.pageYOffset : 0), m.value = C, y.value = B;\n    const V = r.value - p.value,\n      L = s.value - f.value;\n    h.value = B === 0 || C === 0 || V < 0 || L < 0 || V > B || L > C, (l || !h.value) && (u.value = V, d.value = L);\n  }, {\n    immediate: !0\n  }), ke(document, \"mouseleave\", () => {\n    h.value = !0;\n  })), {\n    x: r,\n    y: s,\n    sourceType: n,\n    elementX: u,\n    elementY: d,\n    elementPositionX: p,\n    elementPositionY: f,\n    elementHeight: m,\n    elementWidth: y,\n    isOutside: h,\n    stop: c\n  };\n}\nfunction yo(t) {\n  const e = window.getComputedStyle(t);\n  if (e.overflowX === \"scroll\" || e.overflowY === \"scroll\" || e.overflowX === \"auto\" && t.clientWidth < t.scrollWidth || e.overflowY === \"auto\" && t.clientHeight < t.scrollHeight) return !0;\n  {\n    const l = t.parentNode;\n    return !l || l.tagName === \"BODY\" ? !1 : yo(l);\n  }\n}\nfunction ur(t) {\n  const e = t || window.event,\n    l = e.target;\n  return yo(l) ? !1 : e.touches.length > 1 ? !0 : (e.preventDefault && e.preventDefault(), !1);\n}\nconst Yt = /* @__PURE__ */new WeakMap();\nfunction dr(t, e = !1) {\n  const l = x(e);\n  let a = null;\n  ue(vo(t), s => {\n    const n = ba(Fe(s));\n    if (n) {\n      const i = n;\n      Yt.get(i) || Yt.set(i, i.style.overflow), l.value && (i.style.overflow = \"hidden\");\n    }\n  }, {\n    immediate: !0\n  });\n  const o = () => {\n      const s = ba(Fe(t));\n      !s || l.value || ($a && (a = ke(s, \"touchmove\", n => {\n        ur(n);\n      }, {\n        passive: !1\n      })), s.style.overflow = \"hidden\", l.value = !0);\n    },\n    r = () => {\n      var s;\n      const n = ba(Fe(t));\n      !n || !l.value || ($a && (a == null || a()), n.style.overflow = (s = Yt.get(n)) != null ? s : \"\", Yt.delete(n), l.value = !1);\n    };\n  return it(r), w({\n    get() {\n      return l.value;\n    },\n    set(s) {\n      s ? o() : r();\n    }\n  });\n}\nfunction cr(t, e = {}) {\n  const {\n      threshold: l = 50,\n      onSwipe: a,\n      onSwipeEnd: o,\n      onSwipeStart: r,\n      passive: s = !0,\n      window: n = De\n    } = e,\n    i = nl({\n      x: 0,\n      y: 0\n    }),\n    u = nl({\n      x: 0,\n      y: 0\n    }),\n    d = w(() => i.x - u.x),\n    p = w(() => i.y - u.y),\n    {\n      max: f,\n      abs: m\n    } = Math,\n    y = w(() => f(m(d.value), m(p.value)) >= l),\n    h = x(!1),\n    c = w(() => y.value ? m(d.value) > m(p.value) ? d.value > 0 ? \"left\" : \"right\" : p.value > 0 ? \"up\" : \"down\" : \"none\"),\n    g = W => [W.touches[0].clientX, W.touches[0].clientY],\n    v = (W, F) => {\n      i.x = W, i.y = F;\n    },\n    $ = (W, F) => {\n      u.x = W, u.y = F;\n    };\n  let B;\n  const C = fr(n == null ? void 0 : n.document);\n  s ? B = C ? {\n    passive: !0\n  } : {\n    capture: !1\n  } : B = C ? {\n    passive: !1,\n    capture: !0\n  } : {\n    capture: !0\n  };\n  const V = W => {\n      h.value && (o == null || o(W, c.value)), h.value = !1;\n    },\n    L = [ke(t, \"touchstart\", W => {\n      if (W.touches.length !== 1) return;\n      B.capture && !B.passive && W.preventDefault();\n      const [F, Z] = g(W);\n      v(F, Z), $(F, Z), r == null || r(W);\n    }, B), ke(t, \"touchmove\", W => {\n      if (W.touches.length !== 1) return;\n      const [F, Z] = g(W);\n      $(F, Z), !h.value && y.value && (h.value = !0), h.value && (a == null || a(W));\n    }, B), ke(t, [\"touchend\", \"touchcancel\"], V, B)];\n  return {\n    isPassiveEventSupported: C,\n    isSwiping: h,\n    direction: c,\n    coordsStart: i,\n    coordsEnd: u,\n    lengthX: d,\n    lengthY: p,\n    stop: () => L.forEach(W => W())\n  };\n}\nfunction fr(t) {\n  if (!t) return !1;\n  let e = !1;\n  const l = {\n    get passive() {\n      return e = !0, !1;\n    }\n  };\n  return t.addEventListener(\"x\", Ge, l), t.removeEventListener(\"x\", Ge), e;\n}\nfunction vr(t, e, l, a = {}) {\n  var o, r, s;\n  const {\n      clone: n = !1,\n      passive: i = !1,\n      eventName: u,\n      deep: d = !1,\n      defaultValue: p,\n      shouldEmit: f\n    } = a,\n    m = gt(),\n    y = l || (m == null ? void 0 : m.emit) || ((o = m == null ? void 0 : m.$emit) == null ? void 0 : o.bind(m)) || ((s = (r = m == null ? void 0 : m.proxy) == null ? void 0 : r.$emit) == null ? void 0 : s.bind(m == null ? void 0 : m.proxy));\n  let h = u;\n  e || (e = \"modelValue\"), h = h || `update:${e.toString()}`;\n  const c = $ => n ? typeof n == \"function\" ? n($) : Zs($) : $,\n    g = () => Fs(t[e]) ? c(t[e]) : p,\n    v = $ => {\n      f ? f($) && y(h, $) : y(h, $);\n    };\n  if (i) {\n    const $ = g(),\n      B = x($);\n    let C = !1;\n    return ue(() => t[e], V => {\n      C || (C = !0, B.value = c(V), Ve(() => C = !1));\n    }), ue(B, V => {\n      !C && (V !== t[e] || d) && v(V);\n    }, {\n      deep: d\n    }), B;\n  } else return w({\n    get() {\n      return g();\n    },\n    set($) {\n      v($);\n    }\n  });\n}\nconst pr = [\"id\"],\n  mr = [\"id\"],\n  br = [\"innerHTML\"],\n  yr = [\"innerHTML\"],\n  Ka = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BPopover\",\n    props: /* @__PURE__ */pe({\n      boundary: {\n        default: \"clippingAncestors\"\n      },\n      boundaryPadding: {\n        default: void 0\n      },\n      click: {\n        type: Boolean,\n        default: !1\n      },\n      content: {\n        default: void 0\n      },\n      customClass: {\n        default: \"\"\n      },\n      delay: {\n        default: () => ({\n          show: 100,\n          hide: 300\n        })\n      },\n      floatingMiddleware: {\n        default: void 0\n      },\n      hide: {\n        type: Boolean,\n        default: void 0\n      },\n      html: {\n        type: Boolean,\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      inline: {\n        type: Boolean,\n        default: !1\n      },\n      manual: {\n        type: Boolean,\n        default: !1\n      },\n      modelValue: {\n        type: Boolean\n      },\n      noAutoClose: {\n        type: Boolean,\n        default: !1\n      },\n      noFade: {\n        type: Boolean,\n        default: !1\n      },\n      noFlip: {\n        type: Boolean,\n        default: !1\n      },\n      noHide: {\n        type: Boolean,\n        default: !1\n      },\n      noShift: {\n        type: Boolean,\n        default: !1\n      },\n      noSize: {\n        type: Boolean,\n        default: !1\n      },\n      noninteractive: {\n        type: Boolean,\n        default: !1\n      },\n      offset: {\n        default: null\n      },\n      placement: {\n        default: \"top\"\n      },\n      persistent: {\n        type: Boolean,\n        default: !1\n      },\n      realtime: {\n        type: Boolean,\n        default: !1\n      },\n      reference: {\n        default: null\n      },\n      strategy: {\n        default: \"absolute\"\n      },\n      target: {\n        default: null\n      },\n      title: {\n        default: void 0\n      },\n      tooltip: {\n        type: Boolean,\n        default: !1\n      },\n      variant: {\n        default: null\n      },\n      teleportDisabled: {\n        default: !1\n      },\n      teleportTo: {\n        default: void 0\n      }\n    }, {\n      modelValue: {\n        type: Boolean,\n        default: !1\n      },\n      modelModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"hidden\", \"hide\", \"hide-prevented\", \"show\", \"show-prevented\", \"shown\"], [\"update:modelValue\"]),\n    setup(t, {\n      expose: e,\n      emit: l\n    }) {\n      const a = t,\n        o = l,\n        r = he(t, \"modelValue\"),\n        s = x(r.value),\n        n = x(r.value);\n      Rt(() => {\n        r.value = s.value;\n      }), ue(r, q => {\n        q !== s.value && (q ? A() : X(new Event(\"update:modelValue\")));\n      });\n      const i = Be(() => a.id, \"popover\"),\n        u = x(!1),\n        d = x(null),\n        p = x(null),\n        f = x(null),\n        m = x(null),\n        y = x(null),\n        h = w(() => a.title ? Tt(a.title, $t) : \"\"),\n        c = w(() => a.content ? Tt(a.content, $t) : \"\"),\n        g = k(() => a.placement.startsWith(\"auto\")),\n        v = be(() => a.offset ?? NaN),\n        $ = w(() => a.boundary === \"document\" || a.boundary === \"viewport\" ? void 0 : a.boundary),\n        B = w(() => a.boundary === \"document\" || a.boundary === \"viewport\" ? a.boundary : void 0),\n        C = x({}),\n        V = w(() => {\n          if (a.floatingMiddleware !== void 0) return a.floatingMiddleware;\n          const q = a.offset !== null ? v.value : a.tooltip ? 6 : 8,\n            se = [Xl(q)];\n          return a.noFlip === !1 && !g.value && se.push(no({\n            boundary: $.value,\n            rootBoundary: B.value,\n            padding: a.boundaryPadding\n          })), g.value && se.push(Cs({\n            alignment: a.placement.split(\"-\")[1] || void 0,\n            boundary: $.value,\n            rootBoundary: B.value,\n            padding: a.boundaryPadding\n          })), a.noShift === !1 && se.push(oo({\n            boundary: $.value,\n            rootBoundary: B.value,\n            padding: a.boundaryPadding\n          })), a.noHide === !1 && se.push(ks({\n            boundary: $.value,\n            rootBoundary: B.value,\n            padding: a.boundaryPadding\n          })), a.inline === !0 && se.push(Ts()), se.push(Vs({\n            element: f,\n            padding: 10\n          })), a.noSize === !1 && se.push(so({\n            boundary: $.value,\n            rootBoundary: B.value,\n            padding: a.boundaryPadding,\n            apply({\n              availableWidth: me,\n              availableHeight: te\n            }) {\n              C.value = {\n                maxHeight: te ? `${te}px` : void 0,\n                maxWidth: me ? `${me}px` : void 0\n              };\n            }\n          })), se;\n        }),\n        L = k(() => g.value ? void 0 : a.placement),\n        {\n          floatingStyles: Q,\n          middlewareData: W,\n          placement: F,\n          update: Z\n        } = io(p, d, {\n          placement: L,\n          middleware: V,\n          strategy: k(() => a.strategy),\n          whileElementsMounted: (...q) => lo(...q, {\n            animationFrame: a.realtime\n          })\n        }),\n        R = x({\n          position: \"absolute\"\n        });\n      ue(W, () => {\n        var q;\n        if (a.noHide === !1 && ((q = W.value.hide) != null && q.referenceHidden ? u.value = !0 : u.value = !1), W.value.arrow) {\n          const {\n            x: se,\n            y: me\n          } = W.value.arrow;\n          R.value = {\n            position: \"absolute\",\n            top: me ? `${me}px` : \"\",\n            left: se ? `${se}px` : \"\"\n          };\n        }\n      });\n      const le = w(() => {\n          const q = a.tooltip ? \"tooltip\" : \"popover\";\n          return [q, `b-${q}`, {\n            [`b-${q}-${a.variant}`]: a.variant !== null,\n            show: s.value && !u.value,\n            \"pe-none\": !s.value,\n            fade: !a.noFade,\n            \"d-none\": !s.value && a.noFade,\n            [`${a.customClass}`]: a.customClass !== void 0,\n            [`bs-${q}-${hr(F.value)}`]: F.value !== void 0\n          }];\n        }),\n        {\n          isOutside: N\n        } = gl(d),\n        {\n          isOutside: S\n        } = gl(m),\n        P = q => {\n          const se = q ?? new Event(\"click\");\n          s.value ? X(se) : A();\n        },\n        M = (q, se = {}) => new Bt(q, {\n          cancelable: !1,\n          target: d.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...se,\n          componentId: i.value\n        });\n      let j;\n      const A = () => {\n          const q = M(\"show\", {\n            cancelable: !0\n          });\n          if (o(\"show\", q), q.defaultPrevented) {\n            o(\"show-prevented\");\n            return;\n          }\n          n.value = !0, Ve(() => {\n            var se;\n            Z(), j = setTimeout(() => {\n              Z(), s.value = !0, Ve(() => {\n                o(\"shown\", M(\"shown\"));\n              });\n            }, typeof a.delay == \"number\" ? a.delay : ((se = a.delay) == null ? void 0 : se.show) || 0);\n          });\n        },\n        X = q => {\n          var te;\n          const se = M(\"hide\", {\n            cancelable: !0\n          });\n          if (o(\"hide\", se), se.defaultPrevented) {\n            o(\"hide-prevented\");\n            return;\n          }\n          j && (clearTimeout(j), j = void 0);\n          const me = typeof a.delay == \"number\" ? a.delay : ((te = a.delay) == null ? void 0 : te.hide) || 0;\n          setTimeout(() => {\n            var ye, ee;\n            (q == null ? void 0 : q.type) === \"click\" || (q == null ? void 0 : q.type) === \"forceHide\" || (q == null ? void 0 : q.type) === \"update:modelValue\" && a.manual || !a.noninteractive && N.value && S.value && !((ye = d.value) != null && ye.contains(document == null ? void 0 : document.activeElement)) && !((ee = m.value) != null && ee.contains(document == null ? void 0 : document.activeElement)) || a.noninteractive && S.value ? (s.value = !1, Ve(() => {\n              setTimeout(() => {\n                n.value = !1;\n              }, d.value ? wa(d.value) : 150), o(\"hidden\", M(\"hidden\"));\n            })) : setTimeout(() => {\n              X(q);\n            }, me < 50 ? 50 : me);\n          }, me);\n        };\n      e({\n        hide: X,\n        show: A,\n        toggle: P\n      });\n      const G = () => {\n          var q;\n          if (a.target) {\n            const se = mt(a.target);\n            se ? m.value = se : console.warn(\"Target element not found\", a.target);\n          } else m.value = (q = y.value) == null ? void 0 : q.nextElementSibling;\n          if (a.reference) {\n            const se = mt(a.reference);\n            se ? p.value = se : console.warn(\"Reference element not found\", a.reference);\n          } else p.value = m.value;\n          if (!(!m.value || a.manual) && za) {\n            if (m.value.addEventListener(\"forceHide\", X), a.click) {\n              m.value.addEventListener(\"click\", P);\n              return;\n            }\n            m.value.addEventListener(\"pointerenter\", A), m.value.addEventListener(\"pointerleave\", X), m.value.addEventListener(\"focus\", A), m.value.addEventListener(\"blur\", X);\n          }\n        },\n        ie = () => {\n          m.value && (m.value.removeEventListener(\"forceHide\", X), m.value.removeEventListener(\"click\", P), m.value.removeEventListener(\"pointerenter\", A), m.value.removeEventListener(\"pointerleave\", X), m.value.removeEventListener(\"focus\", A), m.value.removeEventListener(\"blur\", X));\n        };\n      return bo(d, () => {\n        s.value && a.click && !a.noAutoClose && !a.manual && X(new Event(\"clickOutside\"));\n      }, {\n        ignore: [m]\n      }), ue([() => a.click, () => a.target, () => a.reference], () => {\n        ie(), G();\n      }), Xe(G), Fa(ie), (q, se) => (b(), _(de, null, [J(\"span\", {\n        id: O(i) + \"_placeholder\",\n        ref_key: \"placeholder\",\n        ref: y\n      }, null, 8, pr), T(q.$slots, \"target\", {\n        show: A,\n        hide: X,\n        toggle: P,\n        showState: s.value\n      }), (b(), I(ht, {\n        to: q.teleportTo,\n        disabled: !q.teleportTo || q.teleportDisabled\n      }, [n.value || a.persistent ? (b(), _(\"div\", K({\n        key: 0,\n        id: O(i)\n      }, q.$attrs, {\n        ref_key: \"element\",\n        ref: d,\n        class: le.value,\n        role: \"tooltip\",\n        tabindex: \"-1\",\n        style: O(Q)\n      }), [J(\"div\", {\n        ref_key: \"arrow\",\n        ref: f,\n        class: D(`${a.tooltip ? \"tooltip\" : \"popover\"}-arrow`),\n        style: Ee(R.value),\n        \"data-popper-arrow\": \"\"\n      }, null, 6), J(\"div\", {\n        class: \"overflow-auto\",\n        style: Ee(C.value)\n      }, [q.title || q.$slots.title ? (b(), _(de, {\n        key: 0\n      }, [a.html ? (b(), _(\"div\", {\n        key: 1,\n        class: D([\"position-sticky top-0\", a.tooltip ? \"tooltip-inner\" : \"popover-header\"]),\n        innerHTML: h.value\n      }, null, 10, br)) : (b(), _(\"div\", {\n        key: 0,\n        class: D([\"position-sticky top-0\", a.tooltip ? \"tooltip-inner\" : \"popover-header\"])\n      }, [T(q.$slots, \"title\", {}, () => [ne(Y(q.title), 1)])], 2))], 64)) : ae(\"\", !0), a.tooltip && !q.$slots.title && !q.title || !a.tooltip ? (b(), _(de, {\n        key: 1\n      }, [a.html ? (b(), _(\"div\", {\n        key: 1,\n        class: D(a.tooltip ? \"tooltip-inner\" : \"popover-body\"),\n        innerHTML: c.value\n      }, null, 10, yr)) : (b(), _(\"div\", {\n        key: 0,\n        class: D(a.tooltip ? \"tooltip-inner\" : \"popover-body\")\n      }, [T(q.$slots, \"default\", {}, () => [ne(Y(q.content), 1)])], 2))], 64)) : ae(\"\", !0)], 4)], 16, mr)) : ae(\"\", !0)], 8, [\"to\", \"disabled\"]))], 64));\n    }\n  }),\n  gr = ({\n    top: t,\n    end: e,\n    start: l,\n    alignCenter: a,\n    alignEnd: o\n  }) => {\n    const r = t ? \"top\" : l ? \"left\" : e ? \"right\" : \"bottom\",\n      s = o ? \"end\" : a ? null : \"start\";\n    return `${r}${s ? `-${s}` : \"\"}`;\n  },\n  hr = t => {\n    const [e] = t.split(\"-\");\n    switch (e) {\n      case \"left\":\n        return \"start\";\n      case \"right\":\n        return \"end\";\n      default:\n        return e;\n    }\n  },\n  Ht = t => typeof t != \"object\" || t.active !== !1,\n  oa = (t, e) => {\n    if (!Ht(t)) return {};\n    const a = typeof t > \"u\" || typeof t == \"object\" && !t.title && !t.content,\n      o = e.getAttribute(\"title\") || e.getAttribute(\"data-original-title\");\n    return a ? o ? (e.removeAttribute(\"title\"), e.setAttribute(\"data-original-title\", o), {\n      content: Tt(o, $t)\n    }) : {} : typeof t == \"string\" ? {\n      content: Tt(t, $t)\n    } : {\n      title: t != null && t.title ? Tt(t == null ? void 0 : t.title, $t) : void 0,\n      content: t != null && t.content ? Tt(t == null ? void 0 : t.content, $t) : void 0\n    };\n  },\n  na = (t, e) => ({\n    target: e,\n    modelValue: t.modifiers.show,\n    inline: t.modifiers.inline,\n    click: t.modifiers.click,\n    realtime: t.modifiers.realtime,\n    persistent: t.modifiers.persistent,\n    placement: t.modifiers.left ? \"left\" : t.modifiers.right ? \"right\" : t.modifiers.bottom ? \"bottom\" : t.modifiers.top ? \"top\" : void 0,\n    html: !0,\n    ...(typeof t.value == \"object\" ? t.value : {}),\n    ...(t.modifiers.interactive ? {\n      noninteractive: !1\n    } : {}),\n    title: null,\n    content: null\n  }),\n  sa = (t, e, l) => {\n    var o;\n    const a = document.createElement(\"span\");\n    e.modifiers.body ? document.body.appendChild(a) : e.modifiers.child ? t.appendChild(a) : (o = t.parentNode) == null || o.insertBefore(a, t.nextSibling), Dl(Ne(Ka, l), a), t.$__element = a;\n  },\n  ra = t => {\n    const e = t.$__element;\n    e && Dl(null, e), setTimeout(() => {\n      e == null || e.remove();\n    }, 0), delete t.$__element;\n  },\n  go = (t, e, l) => {\n    const a = qe(t, e);\n    return l && typeof l == \"function\" ? l(a, e, t) : a;\n  },\n  fa = (t, e, l) => e.concat([\"sm\", \"md\", \"lg\", \"xl\", \"xxl\"]).reduce((a, o) => (a[t ? `${t}${o.charAt(0).toUpperCase() + o.slice(1)}` : o] = l, a), {}),\n  ho = (t, e, l, a = l) => Object.keys(e).reduce((o, r) => (t[r] && o.push([a, r.replace(l, \"\"), t[r]].filter(s => s && typeof s != \"boolean\").join(\"-\").toLowerCase()), o), []),\n  mt = t => {\n    if (t) return typeof t == \"string\" ? typeof document > \"u\" ? void 0 : document.getElementById(t) ?? document.querySelector(t) ?? void 0 : t.$el ?? t;\n  },\n  Br = (t, e) => ((t == null ? void 0 : t()) ?? []).reduce((l, a) => (typeof a.type == \"symbol\" ? l = l.concat(a.children) : l.push(a), l), []).filter(l => {\n    var a;\n    return ((a = l.type) == null ? void 0 : a.__name) === e;\n  }),\n  Bo = /_/g,\n  wo = /([a-z])([A-Z])/g,\n  wr = /^[0-9]*\\.?[0-9]+$/,\n  Cr = /(\\s|^)(\\w)/g,\n  kr = /(\\s|^)(\\w)/,\n  Zt = /\\s+/,\n  $r = /^#/,\n  Tr = /^#[A-Za-z]+[\\w\\-:.]*$/,\n  Sr = /[-/\\\\^$*+?.()|[\\]{}]/g,\n  _r = /[\\s\\uFEFF\\xA0]+/g,\n  ya = t => t.replace(Bo, \" \").replace(wo, (e, l, a) => `${l} ${a}`).replace(kr, (e, l, a) => l + a.toUpperCase()),\n  hl = t => t.replace(Bo, \" \").replace(wo, (e, l, a) => `${l} ${a}`).replace(Cr, (e, l, a) => l + a.toUpperCase()),\n  Vr = t => {\n    const e = t.trim();\n    return e.charAt(0).toUpperCase() + e.slice(1);\n  },\n  Ar = t => t.replace(Sr, \"\\\\$&\"),\n  Or = t => Ar(t).replace(_r, \"\\\\s\"),\n  Jt = t => typeof t == \"string\" ? hl(t) : t.label !== void 0 ? t.label : typeof t.key == \"string\" ? hl(t.key) : t.key,\n  Nr = t => !!(t.href || t.to),\n  Co = Symbol(\"carousel\"),\n  ko = Symbol(\"tabs\"),\n  $o = Symbol(\"progress\"),\n  To = Symbol(\"listGroup\"),\n  So = Symbol(\"avatarGroup\"),\n  _o = Symbol(\"accordion\"),\n  Vo = Symbol(\"checkboxGroup\"),\n  Ao = Symbol(\"radioGroup\"),\n  Xa = Symbol(\"collapse\"),\n  Oo = Symbol(\"collapse\"),\n  Ya = Symbol(\"navbar\"),\n  No = Symbol(\"toastPlugin\"),\n  Io = Symbol(\"rtlPlugin\"),\n  Po = Symbol(\"breadcrumbPlugin\"),\n  Eo = Symbol(\"modalControllerPlugin\"),\n  Fo = Symbol(\"modalManagerPlugin\"),\n  Lo = Symbol(\"idPluginKey\"),\n  Et = (t, e = {}, l = {}) => {\n    const a = [t];\n    let o;\n    for (let r = 0; r < a.length && !o; r++) {\n      const s = a[r];\n      o = l[s];\n    }\n    return o && typeof o == \"function\" ? o(e) : o;\n  },\n  va = (t, e) => Object.keys(t).filter(l => !e.map(a => a.toString()).includes(l)).reduce((l, a) => ({\n    ...l,\n    [a]: t[a]\n  }), {}),\n  Za = (t, e) => [...e].reduce((l, a) => (l[a] = t[a], l), {}),\n  qe = (t, e, l) => {\n    const a = e.split(/[.[\\]]/g);\n    let o = t;\n    for (const r of a) {\n      if (o === null || o === void 0) return l;\n      r.trim() !== \"\" && (o = o[r]);\n    }\n    return o === void 0 ? l : o;\n  },\n  Ir = (t, e, l) => {\n    const a = i => {\n        if ((p => p == null || typeof p != \"object\" && typeof p != \"function\")(i)) return i;\n        if (typeof i == \"function\") return i.bind({});\n        const d = new i.constructor();\n        return Object.getOwnPropertyNames(i).forEach(p => {\n          d[p] = i[p];\n        }), d;\n      },\n      o = (i, u) => {\n        const d = u === void 0 ? 0 : u;\n        if (i == null) return d;\n        const p = Number.parseInt(i);\n        return Number.isNaN(p) ? d : p;\n      };\n    if (!t) return {};\n    if (!e || l === void 0) return t;\n    const r = e.split(/[.[\\]]/g).filter(i => !!i.trim()),\n      s = i => {\n        if (r.length > 1) {\n          const u = r.shift(),\n            d = o(r[0], null) !== null;\n          i[u] = i[u] === void 0 ? d ? [] : {} : i[u], s(i[u]);\n        } else i[r[0]] = l;\n      },\n      n = a(t);\n    return s(n), n;\n  },\n  Bl = (t, e) => {\n    const {\n        all: l,\n        ...a\n      } = t,\n      o = {};\n    l && e.forEach(s => {\n      o[s] = l;\n    });\n    const r = {\n      ...o,\n      ...a\n    };\n    return Object.entries(r).filter(([s, n]) => !!n && e.includes(s)).map(([s]) => s);\n  },\n  wl = (t, e) => e + (t ? Vr(t) : \"\"),\n  wt = (t, e) => {\n    const l = k(e),\n      a = k(t),\n      o = k(() => Nr(a.value)),\n      r = w(() => o.value ? Za(a.value, l.value ?? [\"active\", \"activeClass\", \"append\", \"href\", \"rel\", \"replace\", \"routerComponentName\", \"target\", \"to\", \"variant\", \"opacity\", \"opacityHover\", \"underlineVariant\", \"underlineOffset\", \"underlineOffsetHover\", \"underlineOpacity\", \"underlineOpacityHover\"]) : {});\n    return {\n      computedLink: o,\n      computedLinkProps: r\n    };\n  },\n  zo = () => ({\n    ..._e(Po)\n  }),\n  Pr = (t = {}) => {\n    const e = t.persist ?? !1,\n      l = \"data-bs-theme\",\n      a = \"body\";\n    return or({\n      attribute: l,\n      selector: a,\n      storageKey: e === !0 ? `bv-color-${t.attribute ?? l}-${t.selector ?? a}` : null,\n      ...t\n    });\n  },\n  et = t => w(() => {\n    let e = Se(t);\n    return e = {\n      ...e,\n      variant: e.variant ?? null,\n      bgVariant: e.bgVariant ?? null,\n      textVariant: e.textVariant ?? null\n    }, {\n      [`text-bg-${e.variant}`]: e.variant !== null,\n      [`text-${e.textVariant}`]: e.textVariant !== null && e.variant === null,\n      [`bg-${e.bgVariant}`]: e.bgVariant !== null && e.variant === null\n    };\n  }),\n  Er = t => w(() => {\n    const e = Se(t);\n    return {\n      container: e === !0,\n      [`container-${e}`]: typeof e == \"string\"\n    };\n  }),\n  Ho = (t, e = x(1e3), l = {}) => {\n    const a = We(k(t)),\n      o = We(k(e)),\n      r = x(!1),\n      s = x(0),\n      n = k(() => Math.ceil(a.value / o.value)),\n      i = k(() => p.value || r.value ? Math.round(a.value - s.value * o.value) : 0),\n      {\n        pause: u,\n        resume: d,\n        isActive: p\n      } = mo(() => {\n        s.value = s.value + 1;\n      }, e, l),\n      f = () => {\n        r.value = !1, s.value = 0, d();\n      },\n      m = () => {\n        r.value = !1, s.value = n.value;\n      };\n    Rt(() => {\n      s.value > n.value && (s.value = n.value), s.value === n.value && u();\n    }), ue([o, a], () => {\n      m(), f();\n    });\n    const y = () => {\n        p.value !== !1 && (r.value = !0, u());\n      },\n      h = () => {\n        s.value !== n.value && (r.value = !1, d());\n      };\n    return {\n      isActive: We(p),\n      isPaused: We(r),\n      restart: f,\n      stop: m,\n      pause: y,\n      resume: h,\n      value: i\n    };\n  },\n  Ct = t => w(() => {\n    const e = Se(t);\n    return e === !0 ? \"is-valid\" : e === !1 ? \"is-invalid\" : null;\n  }),\n  Ro = t => w(() => {\n    const e = Se(t);\n    return {\n      \"form-check\": e.plain === !1 && e.button === !1 && e.hasDefaultSlot,\n      \"form-check-reverse\": e.reverse === !0,\n      \"form-check-inline\": e.inline === !0,\n      \"form-switch\": e.switch === !0,\n      [`form-control-${e.size}`]: e.size !== void 0 && e.size !== \"md\" && e.button === !1\n    };\n  }),\n  Mo = t => {\n    const e = k(t),\n      l = Ct(() => e.value.state ?? null);\n    return w(() => [l.value, {\n      \"form-check-input\": e.value.plain === !1 && e.value.button === !1,\n      \"btn-check\": e.value.button === !0\n    }]);\n  },\n  xo = t => w(() => {\n    const e = Se(t);\n    return {\n      \"form-check-label\": e.plain === !1 && e.button === !1,\n      btn: e.button === !0,\n      [`btn-${e.buttonVariant}`]: e.button === !0 && e.buttonVariant !== void 0 && e.buttonVariant !== null,\n      [`btn-${e.size}`]: e.button && e.size && e.size !== \"md\"\n    };\n  }),\n  Do = t => {\n    const e = k(t),\n      l = ua(() => e.value.ariaInvalid, () => e.value.state);\n    return w(() => ({\n      \"aria-invalid\": l.value,\n      \"aria-required\": e.value.required === !0 ? !0 : void 0\n    }));\n  },\n  jo = t => w(() => {\n    const e = Se(t);\n    return {\n      \"was-validated\": e.validated === !0,\n      \"btn-group\": e.buttons === !0 && e.stacked === !1,\n      \"btn-group-vertical\": e.stacked === !0 && e.buttons === !0,\n      [`btn-group-${e.size}`]: e.size !== void 0\n    };\n  }),\n  Be = (t, e) => w(() => Se(t) || Fr(e)),\n  Fr = (t = \"\") => `__BVID__${_e(Lo, () => Math.random().toString().slice(2, 8))()}___BV_${t}__`,\n  qo = (t, e) => {\n    const l = x(null),\n      a = vr(t, \"modelValue\", e, {\n        passive: !0\n      }),\n      o = Be(() => t.id, \"input\"),\n      r = be(() => t.debounce ?? 0),\n      s = be(() => t.debounceMaxWait ?? NaN),\n      n = Ws(v => {\n        a.value = v;\n      }, () => t.lazy === !0 ? 0 : r.value, {\n        maxWait: () => t.lazy === !0 ? NaN : s.value\n      }),\n      i = (v, $ = !1) => {\n        t.lazy === !0 && $ === !1 || n(v);\n      },\n      {\n        focused: u\n      } = Pe(l, {\n        initialValue: t.autofocus\n      }),\n      d = (v, $, B = !1) => t.formatter !== void 0 && (!t.lazyFormatter || B) ? t.formatter(v, $) : v,\n      p = v => t.trim ? v.trim() : t.number ? Number.parseFloat(v) : v;\n    Xe(() => {\n      var v;\n      l.value && (l.value.value = ((v = a.value) == null ? void 0 : v.toString()) ?? \"\");\n    }), Vn(() => {\n      Ve(() => {\n        t.autofocus && (u.value = !0);\n      });\n    });\n    const f = ua(() => t.ariaInvalid, () => t.state);\n    return {\n      input: l,\n      computedId: o,\n      computedAriaInvalid: f,\n      onInput: v => {\n        const {\n            value: $\n          } = v.target,\n          B = d($, v);\n        if (v.defaultPrevented) {\n          v.preventDefault();\n          return;\n        }\n        const C = p(B);\n        i(C);\n      },\n      onChange: v => {\n        const {\n            value: $\n          } = v.target,\n          B = d($, v);\n        if (v.defaultPrevented) {\n          v.preventDefault();\n          return;\n        }\n        const C = p(B);\n        a.value !== C && i(B, !0);\n      },\n      onBlur: v => {\n        if (!t.lazy && !t.lazyFormatter) return;\n        const {\n            value: $\n          } = v.target,\n          B = d($, v, !0),\n          C = p(B);\n        a.value !== C && i(B, !0);\n      },\n      focus: () => {\n        t.disabled || (u.value = !0);\n      },\n      blur: () => {\n        t.disabled || (u.value = !1);\n      }\n    };\n  },\n  Wo = (t, e) => {\n    const l = s => typeof s == \"object\" && s !== null && \"label\" in s,\n      a = s => {\n        if (typeof s == \"string\") return {\n          value: s,\n          text: s\n        };\n        if (typeof s == \"number\") return {\n          value: s,\n          text: `${s}`\n        };\n        if (s instanceof Date) return {\n          value: s,\n          text: s.toLocaleString()\n        };\n        const n = qe(s, e.valueField),\n          i = qe(s, e.textField),\n          u = qe(s, e.htmlField),\n          d = qe(s, e.disabledField),\n          p = e.optionsField ? qe(s, e.optionsField) : void 0;\n        return p !== void 0 ? {\n          label: qe(s, e.labelField) || i,\n          options: p\n        } : {\n          value: n,\n          text: i,\n          html: u,\n          disabled: d\n        };\n      },\n      o = s => s.map(n => a(n));\n    return {\n      normalizedOptions: w(() => o(Se(t))),\n      isComplex: l\n    };\n  },\n  ga = \"modal-open\",\n  Ja = () => {\n    const t = _e(Fo),\n      e = a => {\n        t == null || t.removeStack(a), t == null || t.removeRegistry(a);\n      },\n      l = Ga(\"updateHTMLAttrs\", (a, o, r) => {\n        const s = typeof a == \"string\" ? window == null ? void 0 : window.document.querySelector(a) : Me(a);\n        s && (o === \"class\" ? s.classList.toggle(ga, r === ga) : s.setAttribute(o, r));\n      });\n    return it(() => {\n      l(\"body\", \"class\", \"\");\n    }), ue(() => t == null ? void 0 : t.countStack.value, a => {\n      a !== void 0 && l(\"body\", \"class\", a > 0 ? ga : \"\");\n    }), {\n      ...t,\n      dispose: e\n    };\n  },\n  Lr = t => {\n    const {\n        pushRegistry: e,\n        pushStack: l,\n        removeStack: a,\n        stack: o,\n        dispose: r,\n        countStack: s\n      } = Ja(),\n      n = gt();\n    if (!n || n.type.__name !== \"BModal\") throw new Error(\"useModalManager must only use in BModal component\");\n    return e == null || e(n), it(() => {\n      r(n);\n    }), ue(t, (i, u) => {\n      i ? l == null || l(n) : u && !i && (a == null || a(n));\n    }, {\n      immediate: !0\n    }), {\n      activePosition: w(() => o == null ? void 0 : o.value.findIndex(i => {\n        var u, d;\n        return ((u = i.exposed) == null ? void 0 : u.id) === ((d = n.exposed) == null ? void 0 : d.id);\n      })),\n      activeModalCount: s\n    };\n  },\n  zr = (t = void 0) => {\n    const {\n        registry: e\n      } = Ja(),\n      l = gt(),\n      a = s => s.parent ? s.parent.type.__name === \"BModal\" ? s.parent : a(s.parent) : null,\n      o = w(() => {\n        const s = Se(t);\n        return s ? (e == null ? void 0 : e.value.find(n => {\n          var i;\n          return ((i = n.exposed) == null ? void 0 : i.id.value) === s;\n        })) || null : l ? a(l) : null;\n      }),\n      r = k(() => {\n        var s;\n        return (s = o.value) == null ? void 0 : s.proxy;\n      });\n    return {\n      show() {\n        var s, n;\n        (n = (s = o.value) == null ? void 0 : s.exposed) == null || n.show();\n      },\n      hide(s = \"\") {\n        var n, i;\n        (i = (n = o.value) == null ? void 0 : n.exposed) == null || i.hide(s);\n      },\n      modal: r\n    };\n  },\n  Go = () => {\n    const {\n      lastStack: t,\n      stack: e\n    } = Ja();\n    return {\n      ..._e(Eo),\n      hide: (r = \"\") => {\n        var s;\n        t != null && t.value && ((s = t == null ? void 0 : t.value.exposed) == null || s.hide(r));\n      },\n      hideAll: (r = \"\") => {\n        e == null || e.value.forEach(s => {\n          var n;\n          (n = s.exposed) == null || n.hide(r);\n        });\n      }\n      // Todo: Supports listening events globally in the future\n    };\n  },\n  ia = (t, e = \"px\") => w(() => {\n    const l = Se(t),\n      a = Se(e);\n    return wr.test(String(l)) ? `${Number(l)}${a}` : l;\n  }),\n  Qa = t => {\n    const e = (l, a) => {\n      const o = a === null ? \"\" : `${a}-`;\n      return l === \"circle\" ? `${o}rounded-circle` : l === \"pill\" ? `${o}rounded-pill` : typeof l == \"number\" || l === \"0\" || l === \"1\" || l === \"2\" || l === \"3\" || l === \"4\" || l === \"5\" ? `${o}rounded-${l}` : l === \"none\" ? `${o}rounded-0` : l === \"sm\" ? `${o}rounded-1` : l === \"lg\" ? `${o}rounded-5` : `${o}rounded`;\n    };\n    return w(() => {\n      const l = Se(t);\n      return {\n        [`${e(l.rounded, null)}`]: !!l.rounded,\n        [`${e(l.roundedTop, \"top\")}`]: !!l.roundedTop,\n        [`${e(l.roundedBottom, \"bottom\")}`]: !!l.roundedBottom,\n        [`${e(l.roundedStart, \"start\")}`]: !!l.roundedStart,\n        [`${e(l.roundedEnd, \"end\")}`]: !!l.roundedEnd\n      };\n    });\n  },\n  Hr = () => {\n    const t = _e(Io);\n    return Xe(() => {\n      ue([() => t == null ? void 0 : t.isRtl.value, () => t == null ? void 0 : t.locale.value], ([e, l]) => {\n        const a = document.documentElement;\n        a.setAttribute(\"dir\", e ?? !1 ? \"rtl\" : \"ltr\"), a.setAttribute(\"lang\", l ?? \"\");\n      }, {\n        immediate: !0\n      });\n    }), {\n      ...t\n    };\n  },\n  Uo = (t, e) => {\n    const l = We(k(t)),\n      a = We(k(e)),\n      o = k(() => !a.value);\n    Xe(() => {\n      const r = dr(document.body, l.value && o.value);\n      ue([l, o], ([s, n]) => {\n        r.value = s && n;\n      });\n    });\n  },\n  Ko = (t, e, l = {}) => {\n    const a = k(t),\n      o = k(e),\n      r = x(mt(a.value)),\n      s = x(mt(o.value));\n    ue([a, o], () => {\n      v();\n    });\n    const {\n        contentQuery: n = \":scope > [id]\",\n        targetQuery: i = \"[href]\",\n        manual: u = !1,\n        root: d,\n        rootMargin: p = \"0px 0px -25%\",\n        threshold: f = [0.1, 0.5, 1],\n        watchChanges: m = !0\n      } = l,\n      y = x(null),\n      h = x([]),\n      c = x([]);\n    gt() ? Xe(() => {\n      Sa(a, r, {\n        transform: {\n          ltr: F => mt(F)\n        },\n        direction: \"ltr\",\n        immediate: !0\n      }), Sa(o, s, {\n        transform: {\n          ltr: F => mt(F)\n        },\n        direction: \"ltr\",\n        immediate: !0\n      }), v();\n    }) : Ve(() => {\n      v();\n    });\n    const v = () => {\n      c.value = r.value ? Array.from(r.value.querySelectorAll(n)) : [], h.value = c.value.map(F => ({\n        id: F.id,\n        el: F,\n        visible: !1,\n        text: F.textContent\n      }));\n    };\n    let $ = !0,\n      B = 0;\n    const C = w(() => r.value && getComputedStyle(r.value).overflowY === \"visible\" ? null : r.value),\n      V = sr(c, F => {\n        var le, N, S, P;\n        const Z = (le = C.value || (document == null ? void 0 : document.documentElement)) == null ? void 0 : le.scrollTop;\n        $ = Z > B, B = Z, F.forEach(M => {\n          if (M.isIntersecting) {\n            h.value.forEach(j => {\n              j.el === M.target && (j.visible = !0);\n            });\n            return;\n          }\n          h.value.forEach(j => {\n            j.el === M.target && (j.visible = !1);\n          });\n        });\n        let R = null;\n        $ ? R = ((N = [...h.value].reverse().find(M => M.visible)) == null ? void 0 : N.id) || null : R = ((S = h.value.find(M => M.visible)) == null ? void 0 : S.id) || null, R !== null && (y.value = R), y.value || (y.value = ((P = h.value[0]) == null ? void 0 : P.id) || null);\n      }, {\n        root: d ? mt(d) : C,\n        rootMargin: p,\n        threshold: f\n      });\n    ue(y, F => {\n      var N;\n      if (u) return;\n      const Z = (N = s.value) == null ? void 0 : N.querySelectorAll(i);\n      if (Z === void 0) return;\n      let R = !1,\n        le = null;\n      Z.forEach(S => {\n        var M, j, A, X, G, ie, q, se, me, te, ye;\n        const P = S.closest(\".dropdown\");\n        if ((M = S.getAttribute(\"href\")) != null && M.includes(`#${F}`)) {\n          le = S, S.classList.add(\"active\"), P && ((j = P == null ? void 0 : P.querySelector(\".dropdown-toggle\")) == null || j.classList.add(\"active\"), R = !0);\n          let ee = (A = S.closest(\".nav\")) == null ? void 0 : A.previousSibling;\n          for (; (X = ee == null ? void 0 : ee.classList) != null && X.contains(\"nav-item\");) R = !0, (G = ee.querySelector(\".nav-link\")) == null || G.classList.add(\"active\"), ee = (ie = ee.closest(\".nav\")) == null ? void 0 : ie.previousSibling;\n        } else if (S.classList.remove(\"active\"), P && !R && ((q = P == null ? void 0 : P.querySelector(\".dropdown-toggle\")) == null || q.classList.remove(\"active\")), !R) {\n          let ee = (se = S.closest(\".nav\")) == null ? void 0 : se.previousSibling;\n          for (; (me = ee == null ? void 0 : ee.classList) != null && me.contains(\"nav-item\");) R = !0, ee.querySelector(\".nav-link\") !== le && ((te = ee.querySelector(\".nav-link\")) == null || te.classList.remove(\"active\")), ee = (ye = ee.closest(\".nav\")) == null ? void 0 : ye.previousSibling;\n        }\n      });\n    });\n    const L = m ? nr(r, () => {\n        v();\n      }, {\n        childList: !0\n      }) : {\n        stop: () => {}\n      },\n      Q = (F, Z = !1) => {\n        var N, S;\n        F.preventDefault();\n        const R = (S = (N = F.target) == null ? void 0 : N.getAttribute) == null ? void 0 : S.call(N, \"href\"),\n          le = R ? document == null ? void 0 : document.querySelector(R) : null;\n        le && r.value && (r.value.scrollTo ? r.value.scrollTo({\n          top: le.offsetTop,\n          behavior: Z ? \"smooth\" : \"auto\"\n        }) : r.value.scrollTop = le.offsetTop);\n      },\n      W = () => {\n        V.stop(), L.stop();\n      };\n    return {\n      current: We(y),\n      list: h,\n      content: r,\n      target: s,\n      scrollIntoView: Q,\n      updateList: v,\n      cleanup: W\n    };\n  },\n  Xo = () => ({\n    ..._e(No)\n  }),\n  It = /* @__PURE__ */H({\n    __name: \"BTransition\",\n    props: {\n      appear: {\n        type: Boolean,\n        default: !1\n      },\n      mode: {\n        default: void 0\n      },\n      noFade: {\n        type: Boolean,\n        default: !1\n      },\n      transProps: {\n        default: void 0\n      }\n    },\n    emits: [\"after-appear\", \"after-enter\", \"after-leave\", \"appear\", \"before-appear\", \"before-enter\", \"before-leave\", \"enter\", \"appear-cancelled\", \"enter-cancelled\", \"leave\", \"leave-cancelled\"],\n    setup(t, {\n      emit: e\n    }) {\n      const l = t,\n        a = e,\n        o = w(() => {\n          const s = {\n              name: \"\",\n              enterActiveClass: \"\",\n              enterToClass: \"\",\n              leaveActiveClass: \"\",\n              leaveToClass: \"showing\",\n              enterFromClass: \"showing\",\n              leaveFromClass: \"\"\n            },\n            n = {\n              ...s,\n              enterActiveClass: \"fade showing\",\n              leaveActiveClass: \"fade showing\"\n            };\n          return l.noFade ? s : n;\n        }),\n        r = w(() => ({\n          mode: l.mode,\n          css: !0,\n          ...o.value\n        }));\n      return (s, n) => (b(), I(An, K({\n        ...r.value,\n        ...s.transProps\n      }, {\n        appear: l.appear,\n        onAfterAppear: n[0] || (n[0] = i => a(\"after-appear\", i)),\n        onAfterEnter: n[1] || (n[1] = i => a(\"after-enter\", i)),\n        onAfterLeave: n[2] || (n[2] = i => a(\"after-leave\", i)),\n        onAppear: n[3] || (n[3] = i => a(\"appear\", i)),\n        onBeforeAppear: n[4] || (n[4] = i => a(\"before-appear\", i)),\n        onBeforeEnter: n[5] || (n[5] = i => a(\"before-enter\", i)),\n        onBeforeLeave: n[6] || (n[6] = i => a(\"before-leave\", i)),\n        onEnter: n[7] || (n[7] = i => a(\"enter\", i)),\n        onAppearCancelled: n[8] || (n[8] = i => a(\"appear-cancelled\", i)),\n        onEnterCancelled: n[9] || (n[9] = i => a(\"enter-cancelled\", i)),\n        onLeave: n[10] || (n[10] = i => a(\"leave\", i)),\n        onLeaveCancelled: n[11] || (n[11] = i => a(\"leave-cancelled\", i))\n      }), {\n        default: E(() => [T(s.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"appear\"]));\n    }\n  }),\n  Rr = [\"type\", \"disabled\", \"aria-label\"],\n  Pt = /* @__PURE__ */H({\n    __name: \"BCloseButton\",\n    props: {\n      ariaLabel: {\n        default: \"Close\"\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      type: {\n        default: \"button\"\n      }\n    },\n    emits: [\"click\"],\n    setup(t, {\n      emit: e\n    }) {\n      const l = t,\n        a = e;\n      return (o, r) => (b(), _(\"button\", {\n        type: o.type,\n        class: \"btn-close\",\n        disabled: l.disabled,\n        \"aria-label\": o.ariaLabel,\n        onClick: r[0] || (r[0] = s => a(\"click\", s))\n      }, null, 8, Rr));\n    }\n  }),\n  Cl = \"active\",\n  ot = /* @__PURE__ */H({\n    __name: \"BLink\",\n    props: {\n      active: {\n        type: Boolean,\n        default: void 0\n      },\n      activeClass: {\n        default: \"router-link-active\"\n      },\n      append: {\n        type: Boolean,\n        default: !1\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      exactActiveClass: {\n        default: \"router-link-exact-active\"\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: Boolean,\n        default: !1\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: Boolean,\n        default: !1\n      },\n      routerComponentName: {\n        default: \"router-link\"\n      },\n      routerTag: {\n        default: \"a\"\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: null\n      },\n      variant: {\n        default: null\n      }\n    },\n    emits: [\"click\"],\n    setup(t, {\n      emit: e\n    }) {\n      const l = t,\n        a = e,\n        o = Mt(),\n        r = _e(Xa, null),\n        s = _e(Ya, null),\n        n = gt(),\n        i = w(() => {\n          const y = l.routerComponentName.split(\"-\").map(c => c.charAt(0).toUpperCase() + c.slice(1)).join(\"\");\n          return !((n == null ? void 0 : n.appContext.app.component(y)) !== void 0) || l.disabled || !l.to ? \"a\" : l.routerComponentName;\n        }),\n        u = w(() => {\n          const y = \"#\";\n          if (l.href) return l.href;\n          if (typeof l.to == \"string\") return l.to || y;\n          const {\n            to: h\n          } = l;\n          if (h !== void 0 && \"path\" in h) {\n            const c = h.path || \"\",\n              g = h.query ? `?${Object.keys(h.query).map($ => {\n                var B;\n                return `${$}=${(B = h.query) == null ? void 0 : B[$]}`;\n              }).join(\"=\")}` : \"\",\n              v = !h.hash || h.hash.charAt(0) === \"#\" ? h.hash || \"\" : `#${h.hash}`;\n            return `${c}${g}${v}` || y;\n          }\n          return y;\n        }),\n        d = w(() => ({\n          [`link-${l.variant}`]: l.variant !== null,\n          [`link-opacity-${l.opacity}`]: l.opacity !== void 0,\n          [`link-opacity-${l.opacityHover}-hover`]: l.opacityHover !== void 0,\n          [`link-underline-${l.underlineVariant}`]: l.underlineVariant !== null,\n          [`link-offset-${l.underlineOffset}`]: l.underlineOffset !== void 0,\n          [`link-offset-${l.underlineOffsetHover}-hover`]: l.underlineOffsetHover !== void 0,\n          [`link-underline-opacity-${l.underlineOpacity}`]: l.underlineOpacity !== void 0,\n          [`link-underline-opacity-${l.underlineOpacityHover}-hover`]: l.underlineOpacityHover !== void 0,\n          \"icon-link\": l.icon === !0\n        })),\n        p = w(() => ({\n          class: d.value,\n          to: l.to,\n          href: u.value,\n          target: l.target,\n          rel: l.target === \"_blank\" ? l.rel ?? \"noopener\" : void 0,\n          tabindex: l.disabled ? \"-1\" : typeof o.tabindex > \"u\" ? null : o.tabindex,\n          \"aria-disabled\": l.disabled ? !0 : null\n        })),\n        f = w(() => ({\n          [Cl]: l.active,\n          disabled: l.disabled\n        })),\n        m = y => {\n          var h, c, g;\n          if (l.disabled) {\n            y.preventDefault(), y.stopImmediatePropagation();\n            return;\n          }\n          (((h = r == null ? void 0 : r.isNav) == null ? void 0 : h.value) === !0 && s === null || s !== null && ((c = s.autoClose) == null ? void 0 : c.value) === !0) && ((g = r == null ? void 0 : r.hide) == null || g.call(r)), a(\"click\", y);\n        };\n      return (y, h) => i.value === \"router-link\" ? (b(), I(re(i.value), K({\n        key: 0\n      }, p.value, {\n        custom: \"\"\n      }), {\n        default: E(({\n          href: c,\n          navigate: g,\n          isActive: v,\n          isExactActive: $\n        }) => [(b(), I(re(y.routerTag), K({\n          href: c,\n          class: {\n            [Cl]: l.active,\n            [y.activeClass]: v,\n            [y.exactActiveClass]: $\n          }\n        }, y.$attrs, {\n          onClick: B => {\n            g(B), m(B);\n          }\n        }), {\n          default: E(() => [T(y.$slots, \"default\")]),\n          _: 2\n        }, 1040, [\"href\", \"class\", \"onClick\"]))]),\n        _: 3\n      }, 16)) : (b(), I(re(i.value), K({\n        key: 1,\n        class: f.value\n      }, p.value, {\n        onClick: m\n      }), {\n        default: E(() => [T(y.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\"]));\n    }\n  }),\n  Mr = [\"aria-valuenow\", \"aria-valuemax\"],\n  Yo = /* @__PURE__ */H({\n    __name: \"BProgressBar\",\n    props: {\n      animated: {\n        type: Boolean,\n        default: !1\n      },\n      label: {\n        default: void 0\n      },\n      labelHtml: {\n        default: void 0\n      },\n      max: {\n        default: void 0\n      },\n      precision: {\n        default: 0\n      },\n      showProgress: {\n        type: Boolean,\n        default: !1\n      },\n      showValue: {\n        type: Boolean,\n        default: !1\n      },\n      striped: {\n        type: Boolean,\n        default: !1\n      },\n      value: {\n        default: 0\n      },\n      variant: {\n        default: null\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = _e($o, null),\n        a = et(e),\n        o = w(() => [a.value, {\n          \"progress-bar-animated\": e.animated || (l == null ? void 0 : l.animated.value),\n          \"progress-bar-striped\": e.striped || (l == null ? void 0 : l.striped.value) || e.animated || (l == null ? void 0 : l.animated.value)\n        }]),\n        r = be(() => e.precision),\n        s = be(() => e.value),\n        n = be(() => e.max ?? NaN),\n        i = be(() => (l == null ? void 0 : l.max.value) ?? NaN),\n        u = w(() => e.labelHtml !== void 0 ? e.labelHtml : e.showValue || l != null && l.showValue.value ? s.value.toFixed(r.value) : e.showProgress || l != null && l.showProgress.value ? (s.value * 100 / (n.value || 100)).toFixed(r.value) : e.label !== void 0 ? e.label : \"\"),\n        d = w(() => i.value ? `${s.value * 100 / i.value}%` : n.value ? `${s.value * 100 / n.value}%` : typeof e.value == \"string\" ? e.value : `${e.value}%`);\n      return (p, f) => (b(), _(\"div\", {\n        class: D([\"progress-bar\", o.value]),\n        role: \"progressbar\",\n        \"aria-valuenow\": p.value,\n        \"aria-valuemin\": \"0\",\n        \"aria-valuemax\": p.max,\n        style: Ee({\n          width: d.value\n        })\n      }, [T(p.$slots, \"default\", {}, () => [ne(Y(u.value), 1)])], 14, Mr));\n    }\n  }),\n  Zo = /* @__PURE__ */H({\n    __name: \"BProgress\",\n    props: {\n      height: {\n        default: void 0\n      },\n      animated: {\n        type: Boolean,\n        default: void 0\n      },\n      max: {\n        default: 100\n      },\n      precision: {\n        default: void 0\n      },\n      showProgress: {\n        type: Boolean,\n        default: void 0\n      },\n      showValue: {\n        type: Boolean,\n        default: void 0\n      },\n      striped: {\n        type: Boolean,\n        default: void 0\n      },\n      value: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      },\n      bgVariant: {\n        default: void 0\n      },\n      textVariant: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      const e = t;\n      return at($o, {\n        animated: k(() => e.animated),\n        max: k(() => e.max),\n        showProgress: k(() => e.showProgress),\n        showValue: k(() => e.showValue),\n        striped: k(() => e.striped)\n      }), (l, a) => (b(), _(\"div\", {\n        class: \"progress\",\n        style: Ee({\n          height: l.height\n        })\n      }, [T(l.$slots, \"default\", {}, () => [ve(Yo, {\n        animated: l.animated,\n        max: l.max,\n        precision: l.precision,\n        \"show-progress\": l.showProgress,\n        \"show-value\": l.showValue,\n        striped: l.striped,\n        value: l.value,\n        variant: l.variant,\n        \"text-variant\": l.textVariant,\n        \"bg-variant\": l.bgVariant\n      }, null, 8, [\"animated\", \"max\", \"precision\", \"show-progress\", \"show-value\", \"striped\", \"value\", \"variant\", \"text-variant\", \"bg-variant\"])])], 4));\n    }\n  }),\n  xr = [\"id\", \"role\", \"aria-live\", \"aria-atomic\"],\n  Dr = {\n    class: \"me-auto\"\n  },\n  Jo = /* @__PURE__ */H({\n    __name: \"BToast\",\n    props: /* @__PURE__ */pe({\n      body: {\n        default: void 0\n      },\n      bodyClass: {\n        default: void 0\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerTag: {\n        default: \"div\"\n      },\n      id: {\n        default: void 0\n      },\n      interval: {\n        default: 1e3\n      },\n      isStatus: {\n        type: Boolean,\n        default: !1\n      },\n      modelValue: {\n        type: [Boolean, Number]\n      },\n      noCloseButton: {\n        type: Boolean,\n        default: !1\n      },\n      noFade: {\n        type: Boolean,\n        default: !1\n      },\n      noHoverPause: {\n        type: Boolean,\n        default: !1\n      },\n      progressProps: {\n        default: void 0\n      },\n      showOnPause: {\n        type: Boolean,\n        default: !0\n      },\n      solid: {\n        type: Boolean,\n        default: !1\n      },\n      title: {\n        default: void 0\n      },\n      toastClass: {\n        default: void 0\n      },\n      transProps: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      },\n      active: {\n        type: Boolean,\n        default: void 0\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: Boolean,\n        default: void 0\n      },\n      disabled: {\n        type: Boolean,\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: Boolean,\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: Boolean,\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      }\n    }, {\n      modelValue: {\n        type: [Boolean, Number],\n        default: !1\n      },\n      modelModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"close\", \"close-countdown\", \"hide\", \"hidden\", \"show\", \"shown\", \"show-prevented\", \"hide-prevented\"], [\"update:modelValue\"]),\n    setup(t, {\n      expose: e,\n      emit: l\n    }) {\n      const a = t,\n        o = l,\n        r = x(null),\n        s = Ua(r),\n        n = he(t, \"modelValue\"),\n        {\n          computedLink: i,\n          computedLinkProps: u\n        } = wt(a),\n        d = be(() => a.interval),\n        p = et(a),\n        f = k(() => typeof n.value == \"boolean\" ? 0 : n.value),\n        {\n          isActive: m,\n          pause: y,\n          restart: h,\n          resume: c,\n          stop: g,\n          isPaused: v,\n          value: $\n        } = Ho(f, d, {\n          immediate: typeof n.value == \"number\"\n        });\n      Rt(() => {\n        o(\"close-countdown\", $.value);\n      });\n      const B = k(() => i.value ? ot : \"div\"),\n        C = k(() => typeof n.value == \"boolean\" ? n.value : m.value || a.showOnPause && v.value),\n        V = w(() => [p.value, {\n          show: C.value\n        }]),\n        L = () => {\n          a.noHoverPause || y();\n        };\n      ue(s, N => {\n        if (N) {\n          L();\n          return;\n        }\n        c();\n      });\n      const Q = (N, S = {}) => new Bt(N, {\n          cancelable: !1,\n          target: r.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...S,\n          componentId: a.id\n        }),\n        W = () => {\n          const N = Q(\"show\", {\n            cancelable: !0\n          });\n          if (o(\"show\", N), N.defaultPrevented) {\n            n.value && (n.value = !1), o(\"show-prevented\");\n            return;\n          }\n          n.value || (n.value = !0);\n        },\n        F = (N = \"\") => {\n          const S = Q(\"hide\", {\n            cancelable: N !== \"\",\n            trigger: N\n          });\n          if (o(\"hide\", S), N === \"close\" && o(\"close\", S), S.defaultPrevented) {\n            o(\"hide-prevented\"), n.value || (n.value = !0);\n            return;\n          }\n          typeof n.value == \"boolean\" ? n.value = !1 : (n.value = 0, g());\n        },\n        Z = () => {\n          W();\n        },\n        R = () => {\n          o(\"shown\", Q(\"shown\"));\n        },\n        le = () => {\n          o(\"hidden\", Q(\"hidden\"));\n        };\n      return ue(m, N => {\n        N === !1 && v.value === !1 && n.value && F();\n      }), Fa(g), e({\n        pause: y,\n        restart: h,\n        resume: c,\n        stop: g\n      }), (N, S) => (b(), I(It, K({\n        \"no-fade\": a.noFade\n      }, N.transProps, {\n        onBeforeEnter: Z,\n        onAfterEnter: R,\n        onAfterLeave: le\n      }), {\n        default: E(() => [C.value ? (b(), _(\"div\", {\n          key: 0,\n          id: N.id,\n          ref_key: \"element\",\n          ref: r,\n          class: D([\"toast\", [N.toastClass, V.value]]),\n          tabindex: \"0\",\n          role: C.value ? a.isStatus ? \"status\" : \"alert\" : void 0,\n          \"aria-live\": C.value ? a.isStatus ? \"polite\" : \"assertive\" : void 0,\n          \"aria-atomic\": C.value ? !0 : void 0\n        }, [N.$slots.title || N.title ? (b(), I(re(N.headerTag), {\n          key: 0,\n          class: \"toast-header\"\n        }, {\n          default: E(() => [T(N.$slots, \"title\", {\n            hide: F\n          }, () => [J(\"strong\", Dr, Y(N.title), 1)]), a.noCloseButton ? ae(\"\", !0) : (b(), I(Pt, {\n            key: 0,\n            onClick: S[0] || (S[0] = P => F(\"close\"))\n          }))]),\n          _: 3\n        })) : ae(\"\", !0), N.$slots.default || N.body ? (b(), I(re(B.value), K({\n          key: 1,\n          class: [\"toast-body\", N.bodyClass],\n          style: {\n            display: \"block\"\n          }\n        }, O(u), {\n          onClick: S[1] || (S[1] = P => O(i) ? F() : () => {})\n        }), {\n          default: E(() => [T(N.$slots, \"default\", {\n            hide: F\n          }, () => [ne(Y(N.body), 1)])]),\n          _: 3\n        }, 16, [\"class\"])) : ae(\"\", !0), typeof n.value == \"number\" && N.progressProps !== void 0 ? (b(), I(Zo, {\n          key: 2,\n          animated: N.progressProps.animated,\n          precision: N.progressProps.precision,\n          \"show-progress\": N.progressProps.showProgress,\n          \"show-value\": N.progressProps.showValue,\n          striped: N.progressProps.striped,\n          variant: N.progressProps.variant,\n          max: n.value,\n          value: O($),\n          height: \"4px\"\n        }, null, 8, [\"animated\", \"precision\", \"show-progress\", \"show-value\", \"striped\", \"variant\", \"max\", \"value\"])) : ae(\"\", !0)], 10, xr)) : ae(\"\", !0)]),\n        _: 3\n      }, 16, [\"no-fade\"]));\n    }\n  }),\n  jr = \"top-right\",\n  qr = {\n    install(t) {\n      const e = bt([]),\n        l = x(!1),\n        a = s => {\n          l.value = s;\n        },\n        o = s => {\n          const n = Symbol(),\n            i = w(() => {\n              const u = Se(s.props);\n              return {\n                component: Se(s.component) ?? Jo,\n                props: {\n                  ...u,\n                  pos: (u == null ? void 0 : u.pos) || jr,\n                  _modelValue: (u == null ? void 0 : u.value) || 5e3,\n                  _self: n\n                }\n              };\n            });\n          return (i.value.props.appendToast !== void 0 ? i.value.props.appendToast : l.value) ? e.value = [...e.value, i] : e.value = [i, ...e.value], n;\n        },\n        r = s => {\n          e.value = e.value.filter(n => n.value.props._self !== s);\n        };\n      t.provide(No, {\n        _setIsAppend: a,\n        toasts: e,\n        show: o,\n        remove: r\n      });\n    }\n  },\n  Wr = {\n    install(t) {\n      const e = x([]),\n        l = () => {\n          e.value.splice(0, e.value.length);\n        };\n      t.provide(Po, {\n        items: e,\n        reset: l\n      });\n    }\n  },\n  Gr = {\n    install(t, e) {\n      (e == null ? void 0 : e.id) instanceof Object && typeof e.id.getId == \"function\" && t.provide(Lo, e.id.getId);\n    }\n  },\n  Ur = {\n    key: 0,\n    class: \"visually-hidden\"\n  },\n  pa = /* @__PURE__ */H({\n    __name: \"BSpinner\",\n    props: {\n      label: {\n        default: void 0\n      },\n      role: {\n        default: \"status\"\n      },\n      small: {\n        type: Boolean,\n        default: !1\n      },\n      tag: {\n        default: \"span\"\n      },\n      type: {\n        default: \"border\"\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = Le(),\n        a = w(() => [`spinner-${e.type}`, {\n          [`spinner-${e.type}-sm`]: e.small,\n          [`text-${e.variant}`]: e.variant !== null\n        }]),\n        o = k(() => !Ae(l.label));\n      return (r, s) => (b(), I(re(r.tag), {\n        class: D(a.value),\n        role: r.label || o.value ? r.role : null,\n        \"aria-hidden\": r.label || o.value ? null : !0\n      }, {\n        default: E(() => [r.label || o.value ? (b(), _(\"span\", Ur, [T(r.$slots, \"label\", {}, () => [ne(Y(r.label), 1)])])) : ae(\"\", !0)]),\n        _: 3\n      }, 8, [\"class\", \"role\", \"aria-hidden\"]));\n    }\n  }),\n  vt = /* @__PURE__ */H({\n    __name: \"BButton\",\n    props: /* @__PURE__ */pe({\n      loading: {\n        type: Boolean,\n        default: !1\n      },\n      loadingFill: {\n        type: Boolean,\n        default: !1\n      },\n      loadingText: {\n        default: \"Loading...\"\n      },\n      pill: {\n        type: Boolean,\n        default: !1\n      },\n      pressed: {\n        type: Boolean\n      },\n      size: {\n        default: \"md\"\n      },\n      squared: {\n        type: Boolean,\n        default: !1\n      },\n      tag: {\n        default: \"button\"\n      },\n      type: {\n        default: \"button\"\n      },\n      variant: {\n        default: \"secondary\"\n      },\n      active: {\n        type: Boolean,\n        default: !1\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: Boolean,\n        default: void 0\n      },\n      disabled: {\n        type: Boolean,\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: Boolean,\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: Boolean,\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      routerTag: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      }\n    }, {\n      pressed: {\n        type: Boolean,\n        default: void 0\n      },\n      pressedModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"click\"], [\"update:pressed\"]),\n    setup(t, {\n      emit: e\n    }) {\n      const l = t,\n        a = e,\n        o = he(t, \"pressed\"),\n        {\n          computedLink: r,\n          computedLinkProps: s\n        } = wt(l, [\"active-class\", \"exact-active-class\", \"replace\", \"routerComponentName\", \"routerTag\"]),\n        n = k(() => typeof l.pressed == \"boolean\"),\n        i = k(() => l.tag === \"button\" && l.href === void 0 && l.to === void 0),\n        u = k(() => l.to !== void 0),\n        d = k(() => l.href !== void 0 ? !1 : !i.value),\n        p = w(() => u.value ? s.value : []),\n        f = w(() => [[`btn-${l.size}`], {\n          [`btn-${l.variant}`]: l.variant !== null,\n          active: l.active || l.pressed,\n          \"rounded-pill\": l.pill,\n          \"rounded-0\": l.squared,\n          disabled: l.disabled\n        }]),\n        m = k(() => u.value ? ot : l.href ? \"a\" : l.tag),\n        y = h => {\n          if (l.disabled) {\n            h.preventDefault(), h.stopPropagation();\n            return;\n          }\n          a(\"click\", h), n.value && (o.value = !l.pressed);\n        };\n      return (h, c) => (b(), I(re(m.value), K({\n        class: \"btn\"\n      }, p.value, {\n        class: f.value,\n        \"aria-disabled\": d.value ? l.disabled : null,\n        \"aria-pressed\": n.value ? l.pressed : null,\n        autocomplete: n.value ? \"off\" : null,\n        disabled: i.value ? l.disabled : null,\n        href: h.href,\n        rel: O(r) ? h.rel : null,\n        role: d.value || O(r) ? \"button\" : null,\n        target: O(r) ? h.target : null,\n        type: i.value ? h.type : null,\n        to: i.value ? null : h.to,\n        append: O(r) ? h.append : null,\n        onClick: y\n      }), {\n        default: E(() => [l.loading ? T(h.$slots, \"loading\", {\n          key: 0\n        }, () => [l.loadingFill ? ae(\"\", !0) : (b(), _(de, {\n          key: 0\n        }, [ne(Y(h.loadingText), 1)], 64)), T(h.$slots, \"loading-spinner\", {}, () => [ve(pa, {\n          small: h.size !== \"lg\",\n          label: l.loadingFill ? h.loadingText : void 0\n        }, null, 8, [\"small\", \"label\"])])]) : T(h.$slots, \"default\", {\n          key: 1\n        })]),\n        _: 3\n      }, 16, [\"class\", \"aria-disabled\", \"aria-pressed\", \"autocomplete\", \"disabled\", \"href\", \"rel\", \"role\", \"target\", \"type\", \"to\", \"append\"]));\n    }\n  }),\n  ma = /* @__PURE__ */H({\n    __name: \"BOverlay\",\n    props: {\n      bgColor: {\n        default: void 0\n      },\n      blur: {\n        default: \"2px\"\n      },\n      fixed: {\n        type: Boolean,\n        default: !1\n      },\n      noCenter: {\n        type: Boolean,\n        default: !1\n      },\n      noFade: {\n        type: Boolean,\n        default: !1\n      },\n      noSpinner: {\n        type: Boolean,\n        default: !1\n      },\n      noWrap: {\n        type: Boolean,\n        default: !1\n      },\n      opacity: {\n        default: 0.85\n      },\n      overlayTag: {\n        default: \"div\"\n      },\n      show: {\n        type: Boolean,\n        default: !1\n      },\n      spinnerSmall: {\n        type: Boolean,\n        default: !1\n      },\n      spinnerType: {\n        default: \"border\"\n      },\n      spinnerVariant: {\n        default: void 0\n      },\n      variant: {\n        default: \"light\"\n      },\n      wrapTag: {\n        default: \"div\"\n      },\n      zIndex: {\n        default: 10\n      },\n      rounded: {\n        type: [Boolean, String, Number],\n        default: !1\n      },\n      roundedTop: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedBottom: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedStart: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedEnd: {\n        type: [Boolean, String, Number],\n        default: void 0\n      }\n    },\n    emits: [\"click\", \"hidden\", \"shown\"],\n    setup(t, {\n      emit: e\n    }) {\n      const l = t,\n        a = e,\n        o = {\n          top: 0,\n          left: 0,\n          bottom: 0,\n          right: 0\n        },\n        r = Qa(() => ({\n          rounded: l.rounded,\n          roundedTop: l.roundedTop,\n          roundedBottom: l.roundedBottom,\n          roundedStart: l.roundedStart,\n          roundedEnd: l.roundedEnd\n        })),\n        s = k(() => l.variant !== null && !l.bgColor ? `bg-${l.variant}` : \"\"),\n        n = k(() => l.show ? !0 : null),\n        i = w(() => ({\n          type: l.spinnerType,\n          variant: l.spinnerVariant,\n          small: l.spinnerSmall\n        })),\n        u = w(() => ({\n          ...o,\n          zIndex: l.zIndex || 10\n        })),\n        d = w(() => ({\n          \"position-absolute\": !l.noWrap || !l.fixed,\n          \"position-fixed\": l.noWrap && l.fixed\n        })),\n        p = w(() => [s.value, r.value]),\n        f = w(() => ({\n          ...o,\n          opacity: l.opacity,\n          backgroundColor: l.bgColor || void 0,\n          backdropFilter: l.blur ? `blur(${l.blur})` : void 0\n        })),\n        m = w(() => l.noCenter ? o : {\n          top: \"50%\",\n          left: \"50%\",\n          transform: \"translateX(-50%) translateY(-50%)\"\n        });\n      return (y, h) => (b(), I(re(y.wrapTag), {\n        class: \"b-overlay-wrap position-relative\",\n        \"aria-busy\": n.value\n      }, {\n        default: E(() => [T(y.$slots, \"default\"), ve(It, {\n          \"no-fade\": y.noFade,\n          \"trans-props\": {\n            enterToClass: \"show\"\n          },\n          name: \"fade\",\n          onAfterEnter: h[1] || (h[1] = c => a(\"shown\")),\n          onAfterLeave: h[2] || (h[2] = c => a(\"hidden\"))\n        }, {\n          default: E(() => [l.show ? (b(), I(re(y.overlayTag), {\n            key: 0,\n            class: D([\"b-overlay\", d.value]),\n            style: Ee(u.value),\n            onClick: h[0] || (h[0] = c => a(\"click\", c))\n          }, {\n            default: E(() => [J(\"div\", {\n              class: D([\"position-absolute\", p.value]),\n              style: Ee(f.value)\n            }, null, 6), J(\"div\", {\n              class: \"position-absolute\",\n              style: Ee(m.value)\n            }, [T(y.$slots, \"overlay\", ge(we(i.value)), () => [l.noSpinner ? ae(\"\", !0) : (b(), I(pa, ge(K({\n              key: 0\n            }, i.value)), null, 16))])], 4)]),\n            _: 3\n          }, 8, [\"class\", \"style\"])) : ae(\"\", !0)]),\n          _: 3\n        }, 8, [\"no-fade\"])]),\n        _: 3\n      }, 8, [\"aria-busy\"]));\n    }\n  }),\n  Kr = [\"id\", \"aria-labelledby\", \"aria-describedby\"],\n  Xr = [\"id\"],\n  kl = 1056,\n  Yr = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BModal\",\n    props: /* @__PURE__ */pe({\n      autoFocus: {\n        type: Boolean,\n        default: !0\n      },\n      autoFocusButton: {\n        default: void 0\n      },\n      body: {\n        default: void 0\n      },\n      backdropVariant: {\n        default: void 0\n      },\n      bodyAttrs: {\n        default: void 0\n      },\n      bodyBgVariant: {\n        default: null\n      },\n      bodyClass: {\n        default: null\n      },\n      bodyScrolling: {\n        type: Boolean,\n        default: !1\n      },\n      bodyTextVariant: {\n        default: null\n      },\n      bodyVariant: {\n        default: null\n      },\n      busy: {\n        type: Boolean,\n        default: !1\n      },\n      buttonSize: {\n        default: \"md\"\n      },\n      cancelDisabled: {\n        type: Boolean,\n        default: !1\n      },\n      cancelTitle: {\n        default: \"Cancel\"\n      },\n      cancelVariant: {\n        default: \"secondary\"\n      },\n      centered: {\n        type: Boolean,\n        default: !1\n      },\n      contentClass: {\n        default: void 0\n      },\n      dialogClass: {\n        default: void 0\n      },\n      footerBgVariant: {\n        default: null\n      },\n      footerBorderVariant: {\n        default: null\n      },\n      footerClass: {\n        default: void 0\n      },\n      footerTextVariant: {\n        default: null\n      },\n      footerVariant: {\n        default: null\n      },\n      fullscreen: {\n        type: [Boolean, String],\n        default: !1\n      },\n      headerBgVariant: {\n        default: null\n      },\n      headerBorderVariant: {\n        default: null\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerCloseClass: {\n        default: void 0\n      },\n      headerCloseLabel: {\n        default: \"Close\"\n      },\n      headerCloseVariant: {\n        default: \"secondary\"\n      },\n      headerTextVariant: {\n        default: null\n      },\n      headerVariant: {\n        default: null\n      },\n      hideBackdrop: {\n        type: Boolean,\n        default: !1\n      },\n      hideFooter: {\n        type: Boolean,\n        default: !1\n      },\n      hideHeader: {\n        type: Boolean,\n        default: !1\n      },\n      hideHeaderClose: {\n        type: Boolean,\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      lazy: {\n        type: Boolean,\n        default: !1\n      },\n      modalClass: {\n        default: void 0\n      },\n      modelValue: {\n        type: Boolean\n      },\n      noCloseOnBackdrop: {\n        type: Boolean,\n        default: !1\n      },\n      noCloseOnEsc: {\n        type: Boolean,\n        default: !1\n      },\n      noFade: {\n        type: Boolean,\n        default: !1\n      },\n      okDisabled: {\n        type: Boolean,\n        default: !1\n      },\n      okOnly: {\n        type: Boolean,\n        default: !1\n      },\n      okTitle: {\n        default: \"Ok\"\n      },\n      okVariant: {\n        default: \"primary\"\n      },\n      scrollable: {\n        type: Boolean,\n        default: !1\n      },\n      size: {\n        default: \"md\"\n      },\n      title: {\n        default: void 0\n      },\n      titleClass: {\n        default: void 0\n      },\n      titleSrOnly: {\n        type: Boolean,\n        default: !1\n      },\n      titleTag: {\n        default: \"h5\"\n      },\n      transProps: {\n        default: void 0\n      },\n      teleportDisabled: {\n        default: !1\n      },\n      teleportTo: {\n        default: \"body\"\n      }\n    }, {\n      modelValue: {\n        type: Boolean,\n        default: !1\n      },\n      modelModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"cancel\", \"close\", \"hidden\", \"hide\", \"hide-prevented\", \"ok\", \"show\", \"show-prevented\", \"shown\"], [\"update:modelValue\"]),\n    setup(t, {\n      expose: e,\n      emit: l\n    }) {\n      const a = t,\n        o = l,\n        r = Le(),\n        s = Be(() => a.id, \"modal\"),\n        n = he(t, \"modelValue\"),\n        i = x(null),\n        u = x(null),\n        d = x(null),\n        p = x(null),\n        f = x(n.value),\n        m = x(!1);\n      Re(\"Escape\", () => {\n        j(\"esc\");\n      }, {\n        target: i\n      }), Uo(n, () => a.bodyScrolling);\n      const {\n          focused: y\n        } = Pe(i, {\n          initialValue: n.value && a.autoFocusButton === void 0\n        }),\n        {\n          focused: h\n        } = Pe(u, {\n          initialValue: n.value && a.autoFocusButton === \"ok\"\n        }),\n        {\n          focused: c\n        } = Pe(d, {\n          initialValue: n.value && a.autoFocusButton === \"cancel\"\n        }),\n        {\n          focused: g\n        } = Pe(p, {\n          initialValue: n.value && a.autoFocusButton === \"close\"\n        }),\n        v = w(() => [a.modalClass, {\n          fade: !a.noFade,\n          show: f.value\n        }]),\n        $ = k(() => a.lazy === !1 || a.lazy === !0 && m.value === !0 || a.lazy === !0 && n.value === !0),\n        B = k(() => a.backdropVariant !== void 0 ? a.backdropVariant : a.hideBackdrop ? \"transparent\" : \"dark\"),\n        C = k(() => !Ae(r[\"header-close\"])),\n        V = w(() => [a.dialogClass, {\n          \"modal-fullscreen\": a.fullscreen === !0,\n          [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == \"string\",\n          [`modal-${a.size}`]: a.size !== \"md\",\n          \"modal-dialog-centered\": a.centered,\n          \"modal-dialog-scrollable\": a.scrollable\n        }]),\n        L = et(() => ({\n          bgVariant: a.bodyBgVariant,\n          textVariant: a.bodyTextVariant,\n          variant: a.bodyVariant\n        })),\n        Q = w(() => [a.bodyClass, L.value]),\n        W = et(() => ({\n          bgVariant: a.headerBgVariant,\n          textVariant: a.headerTextVariant,\n          variant: a.headerVariant\n        })),\n        F = w(() => [a.headerClass, W.value, {\n          [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== null\n        }]),\n        Z = w(() => ({\n          variant: C.value ? a.headerCloseVariant : void 0,\n          class: a.headerCloseClass\n        })),\n        R = et(() => ({\n          bgVariant: a.footerBgVariant,\n          textVariant: a.footerTextVariant,\n          variant: a.footerVariant\n        })),\n        le = w(() => [a.footerClass, R.value, {\n          [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== null\n        }]),\n        N = w(() => [a.titleClass, {\n          \"visually-hidden\": a.titleSrOnly\n        }]),\n        S = k(() => a.cancelDisabled || a.busy),\n        P = k(() => a.okDisabled || a.busy),\n        M = (U, z = {}) => new Bt(U, {\n          cancelable: !1,\n          target: i.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...z,\n          componentId: s.value\n        });\n      ue(n, (U, z) => {\n        U !== z && (U === !0 ? A() : j());\n      });\n      const j = (U = \"\") => {\n          if (U === \"backdrop\" && a.noCloseOnBackdrop || U === \"esc\" && a.noCloseOnEsc) {\n            o(\"hide-prevented\");\n            return;\n          }\n          const z = M(\"hide\", {\n            cancelable: U !== \"\",\n            trigger: U\n          });\n          if (U === \"ok\" && o(U, z), U === \"cancel\" && o(U, z), U === \"close\" && o(U, z), o(\"hide\", z), z.defaultPrevented) {\n            o(\"hide-prevented\"), n.value || (n.value = !0);\n            return;\n          }\n          n.value && (n.value = !1);\n        },\n        A = () => {\n          if (f.value) return;\n          const U = M(\"show\", {\n            cancelable: !0\n          });\n          if (o(\"show\", U), U.defaultPrevented) {\n            n.value && (n.value = !1), o(\"show-prevented\");\n            return;\n          }\n          n.value || (n.value = !0);\n        },\n        X = () => {\n          a.autoFocus !== !1 && (a.autoFocusButton === \"ok\" ? h.value = !0 : a.autoFocusButton === \"close\" ? g.value = !0 : a.autoFocusButton === \"cancel\" ? c.value = !0 : y.value = !0);\n        },\n        G = () => {\n          A();\n        },\n        ie = () => {\n          f.value = !0, X(), o(\"shown\", M(\"shown\")), a.lazy === !0 && (m.value = !0);\n        },\n        q = () => {\n          f.value = !1;\n        },\n        se = () => {\n          o(\"hidden\", M(\"hidden\")), a.lazy === !0 && (m.value = !1);\n        },\n        {\n          activePosition: me,\n          activeModalCount: te\n        } = Lr(f),\n        ye = w(() => ({\n          // Make sure that newly opened modals have a higher z-index than currently active ones.\n          // All active modals have a z-index of ('defaultZIndex' - 'stackSize' - 'positionInStack').\n          //\n          // This means inactive modals will already be higher than active ones when opened.\n          \"z-index\": f.value ? kl - (((te == null ? void 0 : te.value) ?? 0) - ((me == null ? void 0 : me.value) ?? 0)) : kl\n        }));\n      ke(i, \"bv-toggle\", () => {\n        n.value ? j() : A();\n      });\n      const ee = w(() => ({\n        cancel: () => {\n          j(\"cancel\");\n        },\n        close: () => {\n          j(\"close\");\n        },\n        hide: j,\n        ok: () => {\n          j(\"ok\");\n        },\n        visible: n.value\n      }));\n      return e({\n        hide: j,\n        id: s,\n        show: A\n      }), (U, z) => {\n        var oe;\n        return b(), I(ht, {\n          to: U.teleportTo,\n          disabled: a.teleportDisabled\n        }, [ve(It, K({\n          \"no-fade\": !0\n        }, U.transProps, {\n          \"trans-props\": {\n            enterToClass: \"show\",\n            ...((oe = U.transProps) == null ? void 0 : oe.transProps)\n          },\n          onBeforeEnter: G,\n          onAfterEnter: ie,\n          onLeave: q,\n          onAfterLeave: se\n        }), {\n          default: E(() => [ut(J(\"div\", K({\n            id: O(s),\n            ref_key: \"element\",\n            ref: i,\n            class: [\"modal\", v.value],\n            role: \"dialog\",\n            \"aria-labelledby\": a.hideHeader ? void 0 : `${O(s)}-label`,\n            \"aria-describedby\": `${O(s)}-body`,\n            tabindex: \"-1\"\n          }, U.$attrs, {\n            style: ye.value\n          }), [J(\"div\", {\n            class: D([\"modal-dialog\", V.value])\n          }, [$.value ? (b(), _(\"div\", {\n            key: 0,\n            class: D([\"modal-content\", U.contentClass])\n          }, [a.hideHeader ? ae(\"\", !0) : (b(), _(\"div\", {\n            key: 0,\n            class: D([\"modal-header\", F.value])\n          }, [T(U.$slots, \"header\", ge(we(ee.value)), () => [(b(), I(re(U.titleTag), {\n            id: `${O(s)}-label`,\n            class: D([\"modal-title\", N.value])\n          }, {\n            default: E(() => [T(U.$slots, \"title\", ge(we(ee.value)), () => [ne(Y(U.title), 1)], !0)]),\n            _: 3\n          }, 8, [\"id\", \"class\"])), a.hideHeaderClose ? ae(\"\", !0) : (b(), _(de, {\n            key: 0\n          }, [C.value ? (b(), I(vt, K({\n            key: 0\n          }, Z.value, {\n            onClick: z[0] || (z[0] = fe => j(\"close\"))\n          }), {\n            default: E(() => [T(U.$slots, \"header-close\", {}, void 0, !0)]),\n            _: 3\n          }, 16)) : (b(), I(Pt, K({\n            key: 1,\n            \"aria-label\": U.headerCloseLabel\n          }, Z.value, {\n            onClick: z[1] || (z[1] = fe => j(\"close\"))\n          }), null, 16, [\"aria-label\"]))], 64))], !0)], 2)), J(\"div\", K({\n            id: `${O(s)}-body`,\n            class: [\"modal-body\", Q.value]\n          }, U.bodyAttrs), [T(U.$slots, \"default\", ge(we(ee.value)), () => [ne(Y(U.body), 1)], !0)], 16, Xr), a.hideFooter ? ae(\"\", !0) : (b(), _(\"div\", {\n            key: 1,\n            class: D([\"modal-footer\", le.value])\n          }, [T(U.$slots, \"footer\", ge(we(ee.value)), () => [T(U.$slots, \"cancel\", ge(we(ee.value)), () => [a.okOnly ? ae(\"\", !0) : (b(), I(vt, {\n            key: 0,\n            ref_key: \"cancelButton\",\n            ref: d,\n            disabled: S.value,\n            size: U.buttonSize,\n            variant: U.cancelVariant,\n            onClick: z[2] || (z[2] = fe => j(\"cancel\"))\n          }, {\n            default: E(() => [ne(Y(U.cancelTitle), 1)]),\n            _: 1\n          }, 8, [\"disabled\", \"size\", \"variant\"]))], !0), T(U.$slots, \"ok\", ge(we(ee.value)), () => [ve(vt, {\n            ref_key: \"okButton\",\n            ref: u,\n            disabled: P.value,\n            size: U.buttonSize,\n            variant: U.okVariant,\n            onClick: z[3] || (z[3] = fe => j(\"ok\"))\n          }, {\n            default: E(() => [ne(Y(U.okTitle), 1)]),\n            _: 1\n          }, 8, [\"disabled\", \"size\", \"variant\"])], !0)], !0)], 2))], 2)) : ae(\"\", !0)], 2), T(U.$slots, \"backdrop\", {}, () => [ve(ma, {\n            variant: B.value,\n            show: n.value,\n            \"no-spinner\": \"\",\n            fixed: \"\",\n            \"no-wrap\": \"\",\n            blur: null,\n            onClick: z[4] || (z[4] = fe => j(\"backdrop\"))\n          }, null, 8, [\"variant\", \"show\"])], !0)], 16, Kr), [[xt, n.value]])]),\n          _: 3\n        }, 16, [\"trans-props\"])], 8, [\"to\", \"disabled\"]);\n      };\n    }\n  }),\n  qt = (t, e) => {\n    const l = t.__vccOpts || t;\n    for (const [a, o] of e) l[a] = o;\n    return l;\n  },\n  _a = /* @__PURE__ */qt(Yr, [[\"__scopeId\", \"data-v-8a2b2b28\"]]),\n  Zr = {\n    install(t) {\n      const e = bt([]),\n        l = () => {\n          let s = () => {};\n          return {\n            value: new Promise(i => {\n              s = i;\n            }),\n            resolve: s\n          };\n        },\n        a = s => {\n          const n = l(),\n            i = Symbol();\n          return e.value = [...e.value, w(() => ({\n            component: Se(s.component) ?? _a,\n            props: {\n              ...Se(s.props),\n              _isConfirm: !1,\n              _promise: n,\n              _self: i,\n              _modelValue: !0\n            }\n          }))], n.value;\n        },\n        o = s => {\n          const n = l(),\n            i = Symbol();\n          return e.value = [...e.value, w(() => ({\n            component: Se(s.component) ?? _a,\n            props: {\n              ...Se(s.props),\n              _isConfirm: !0,\n              _promise: n,\n              _self: i,\n              _modelValue: !0\n            }\n          }))], n.value;\n        },\n        r = s => {\n          e.value = e.value.filter(n => n.value.props._self !== s);\n        };\n      t.provide(Eo, {\n        modals: e,\n        remove: r,\n        show: a,\n        confirm: o\n      });\n    }\n  },\n  Jr = {\n    install(t) {\n      const e = bt([]),\n        l = k(() => e.value.length),\n        a = k(() => e.value[e.value.length - 1]),\n        o = u => {\n          e.value = [...e.value, u];\n        },\n        r = u => {\n          e.value = e.value.filter(d => d.uid !== u.uid);\n        },\n        s = bt([]),\n        n = u => {\n          s.value = [...s.value, u];\n        },\n        i = u => {\n          s.value = s.value.filter(d => d.uid !== u.uid);\n        };\n      t.provide(Fo, {\n        stack: e,\n        countStack: l,\n        lastStack: a,\n        registry: s,\n        pushStack: o,\n        removeStack: r,\n        pushRegistry: n,\n        removeRegistry: i\n      });\n    }\n  },\n  Qr = {\n    install(t, e) {\n      var i, u;\n      const o = typeof (e == null ? void 0 : e.rtl) == \"boolean\" ? !1 : ((i = e == null ? void 0 : e.rtl) == null ? void 0 : i.rtlInitial) ?? !1,\n        r = typeof (e == null ? void 0 : e.rtl) == \"boolean\" ? void 0 : ((u = e == null ? void 0 : e.rtl) == null ? void 0 : u.localeInitial) ?? void 0,\n        s = x(o),\n        n = x(r);\n      t.provide(Io, {\n        isRtl: s,\n        locale: n\n      });\n    }\n  },\n  ei = [\"id\"],\n  ti = /* @__PURE__ */H({\n    __name: \"BAccordion\",\n    props: /* @__PURE__ */pe({\n      flush: {\n        type: Boolean,\n        default: !1\n      },\n      free: {\n        type: Boolean,\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      modelValue: {}\n    }, {\n      modelValue: {\n        default: void 0\n      },\n      modelModifiers: {}\n    }),\n    emits: [\"update:modelValue\"],\n    setup(t) {\n      const e = t,\n        l = he(t, \"modelValue\"),\n        a = Be(() => e.id, \"accordion\"),\n        o = w(() => ({\n          \"accordion-flush\": e.flush\n        }));\n      return at(_o, {\n        openItem: We(l),\n        free: k(() => e.free),\n        setOpenItem: r => {\n          l.value = r;\n        }\n      }), (r, s) => (b(), _(\"div\", {\n        id: O(a),\n        class: D([\"accordion\", o.value])\n      }, [T(r.$slots, \"default\")], 10, ei));\n    }\n  }),\n  Qo = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BCollapse\",\n    props: /* @__PURE__ */pe({\n      horizontal: {\n        type: Boolean,\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      isNav: {\n        type: Boolean,\n        default: !1\n      },\n      modelValue: {\n        type: Boolean\n      },\n      skipAnimation: {\n        type: Boolean,\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      toggle: {\n        type: Boolean,\n        default: !1\n      },\n      visible: {\n        type: Boolean,\n        default: !1\n      }\n    }, {\n      modelValue: {\n        type: Boolean,\n        default: !1\n      },\n      modelModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"hidden\", \"hide\", \"hide-prevented\", \"show\", \"show-prevented\", \"shown\"], [\"update:modelValue\"]),\n    setup(t, {\n      expose: e,\n      emit: l\n    }) {\n      const a = t,\n        o = l,\n        r = (C, V = {}) => new Bt(C, {\n          cancelable: !1,\n          target: i.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...V,\n          componentId: n.value\n        }),\n        s = he(t, \"modelValue\"),\n        n = Be(() => a.id, \"collapse\"),\n        i = x(null),\n        u = x(!1),\n        d = x(s.value),\n        p = w(() => ({\n          show: d.value,\n          \"navbar-collapse\": a.isNav,\n          collapsing: u.value,\n          closing: d.value && !s.value,\n          \"collapse-horizontal\": a.horizontal\n        })),\n        f = () => {\n          s.value = !1;\n        },\n        m = () => {\n          s.value = !0;\n        },\n        y = () => {\n          s.value = !s.value;\n        },\n        h = w(() => ({\n          toggle: y,\n          show: m,\n          hide: f,\n          id: n.value,\n          visible: s.value\n        }));\n      let c,\n        g,\n        v = a.skipAnimation;\n      const $ = () => {\n          const C = r(\"show\", {\n            cancelable: !0\n          });\n          if (o(\"show\", C), C.defaultPrevented) {\n            o(\"show-prevented\");\n            return;\n          }\n          clearTimeout(g), clearTimeout(c), d.value = !0, !v && (u.value = !0, Ve(() => {\n            i.value !== null && (a.horizontal ? i.value.style.width = `${i.value.scrollWidth}px` : i.value.style.height = `${i.value.scrollHeight}px`, c = setTimeout(() => {\n              u.value = !1, o(\"shown\"), i.value !== null && (i.value.style.height = \"\", i.value.style.width = \"\");\n            }, wa(i.value)));\n          }));\n        },\n        B = () => {\n          const C = r(\"hide\", {\n            cancelable: !0\n          });\n          if (o(\"hide\", C), C.defaultPrevented) {\n            o(\"hide-prevented\");\n            return;\n          }\n          if (clearTimeout(c), clearTimeout(g), i.value !== null) {\n            if (v) {\n              d.value = !1;\n              return;\n            }\n            u.value ? (i.value.style.height = \"\", i.value.style.width = \"\") : a.horizontal ? i.value.style.width = `${i.value.scrollWidth}px` : i.value.style.height = `${i.value.scrollHeight}px`, i.value.offsetHeight, u.value = !0, Ve(() => {\n              i.value !== null && (i.value.style.height = \"\", i.value.style.width = \"\", g = setTimeout(() => {\n                d.value = !1, u.value = !1, o(\"hidden\");\n              }, wa(i.value)));\n            });\n          }\n        };\n      return ue(s, () => {\n        s.value ? $() : B();\n      }), Xe(() => {\n        i.value !== null && !s.value && a.toggle && Ve(() => {\n          s.value = !0;\n        });\n      }), ue(() => a.skipAnimation, C => {\n        v = C;\n      }), a.visible && (v = !0, s.value = !0, Ve(() => {\n        v = a.skipAnimation;\n      })), ue(() => a.visible, C => {\n        v = !0, C ? m() : f(), Ve(() => {\n          v = a.skipAnimation;\n        });\n      }), ke(i, \"bv-toggle\", () => {\n        s.value = !s.value;\n      }), e({\n        hide: f,\n        isNav: a.isNav,\n        show: m,\n        toggle: y,\n        visible: We(d)\n      }), at(Xa, {\n        id: n,\n        hide: f,\n        show: m,\n        toggle: y,\n        visible: We(d),\n        isNav: k(() => a.isNav)\n      }), (C, V) => (b(), _(de, null, [T(C.$slots, \"header\", ge(we(h.value))), (b(), I(re(C.tag), K({\n        id: O(n),\n        ref_key: \"element\",\n        ref: i,\n        class: [\"collapse\", p.value],\n        \"is-nav\": a.isNav\n      }, C.$attrs), {\n        default: E(() => [T(C.$slots, \"default\", ge(we(h.value)))]),\n        _: 3\n      }, 16, [\"id\", \"class\", \"is-nav\"])), T(C.$slots, \"footer\", ge(we(h.value)))], 64));\n    }\n  }),\n  ai = [\"aria-expanded\", \"aria-controls\", \"onClick\"],\n  li = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BAccordionItem\",\n    props: /* @__PURE__ */pe({\n      bodyAttrs: {\n        default: void 0\n      },\n      bodyClass: {\n        default: void 0\n      },\n      buttonAttrs: {\n        default: void 0\n      },\n      buttonClass: {\n        default: void 0\n      },\n      collapseClass: {\n        default: void 0\n      },\n      headerAttrs: {\n        default: void 0\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerTag: {\n        default: \"h2\"\n      },\n      horizontal: {\n        type: Boolean,\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      isNav: {\n        type: Boolean,\n        default: void 0\n      },\n      modelValue: {\n        type: Boolean\n      },\n      tag: {\n        default: void 0\n      },\n      title: {\n        default: void 0\n      },\n      toggle: {\n        type: Boolean,\n        default: void 0\n      },\n      visible: {\n        type: Boolean,\n        default: !1\n      },\n      wrapperAttrs: {\n        default: void 0\n      }\n    }, {\n      modelValue: {\n        type: Boolean,\n        default: !1\n      },\n      modelModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"hidden\", \"hide\", \"hide-prevented\", \"show\", \"show-prevented\", \"shown\"], [\"update:modelValue\"]),\n    setup(t, {\n      emit: e\n    }) {\n      const {\n          class: l,\n          ...a\n        } = Mt(),\n        o = t,\n        r = e,\n        s = he(t, \"modelValue\"),\n        n = _e(_o, null),\n        i = Be(() => o.id, \"accordion_item\");\n      return Xe(() => {\n        s.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(i.value)), !s.value && (n == null ? void 0 : n.openItem.value) === i.value && (s.value = !0);\n      }), ue(() => n == null ? void 0 : n.openItem.value, () => s.value = (n == null ? void 0 : n.openItem.value) === i.value && !(n != null && n.free.value)), ue(s, () => {\n        s.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(i.value));\n      }), (u, d) => (b(), _(\"div\", K({\n        class: \"accordion-item\"\n      }, u.wrapperAttrs, {\n        class: O(l)\n      }), [ve(Qo, K({\n        id: O(i),\n        modelValue: s.value,\n        \"onUpdate:modelValue\": d[0] || (d[0] = p => s.value = p),\n        class: [\"accordion-collapse\", u.collapseClass],\n        \"aria-labelledby\": `${O(i)}-heading`\n      }, a, {\n        tag: u.tag,\n        toggle: u.toggle,\n        horizontal: u.horizontal,\n        visible: u.visible,\n        \"is-nav\": u.isNav,\n        onShow: d[1] || (d[1] = p => r(\"show\", p)),\n        onShown: d[2] || (d[2] = p => r(\"shown\")),\n        onHide: d[3] || (d[3] = p => r(\"hide\", p)),\n        onHidden: d[4] || (d[4] = p => r(\"hidden\")),\n        onHidePrevented: d[5] || (d[5] = p => r(\"hide-prevented\")),\n        onShowPrevented: d[6] || (d[6] = p => r(\"show-prevented\"))\n      }), {\n        header: E(({\n          visible: p,\n          toggle: f\n        }) => [(b(), I(re(u.headerTag), K({\n          id: `${O(i)}-heading`,\n          class: [\"accordion-header\", u.headerClass]\n        }, u.headerAttrs), {\n          default: E(() => [J(\"button\", K({\n            class: \"accordion-button\"\n          }, u.buttonAttrs, {\n            class: [{\n              collapsed: !p\n            }, u.buttonClass],\n            type: \"button\",\n            \"aria-expanded\": p ? \"true\" : \"false\",\n            \"aria-controls\": O(i),\n            onClick: f\n          }), [T(u.$slots, \"title\", {}, () => [ne(Y(u.title), 1)])], 16, ai)]),\n          _: 2\n        }, 1040, [\"id\", \"class\"]))]),\n        default: E(() => [J(\"div\", K({\n          class: \"accordion-body\"\n        }, u.bodyAttrs, {\n          class: u.bodyClass\n        }), [T(u.$slots, \"default\")], 16)]),\n        _: 3\n      }, 16, [\"id\", \"modelValue\", \"class\", \"aria-labelledby\", \"tag\", \"toggle\", \"horizontal\", \"visible\", \"is-nav\"])], 16));\n    }\n  }),\n  oi = /* @__PURE__ */H({\n    __name: \"BAlert\",\n    props: /* @__PURE__ */pe({\n      closeClass: {\n        default: void 0\n      },\n      closeContent: {\n        default: void 0\n      },\n      closeLabel: {\n        default: \"Close\"\n      },\n      closeVariant: {\n        default: \"secondary\"\n      },\n      dismissible: {\n        type: Boolean,\n        default: !1\n      },\n      fade: {\n        type: Boolean,\n        default: !1\n      },\n      immediate: {\n        type: Boolean,\n        default: !0\n      },\n      interval: {\n        default: 1e3\n      },\n      modelValue: {\n        type: [Boolean, Number]\n      },\n      noHoverPause: {\n        type: Boolean,\n        default: !1\n      },\n      showOnPause: {\n        type: Boolean,\n        default: !0\n      },\n      variant: {\n        default: \"info\"\n      }\n    }, {\n      modelValue: {\n        type: [Boolean, Number],\n        default: !1\n      },\n      modelModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"close\", \"close-countdown\", \"closed\"], [\"update:modelValue\"]),\n    setup(t, {\n      expose: e,\n      emit: l\n    }) {\n      const a = t,\n        o = l,\n        r = Le(),\n        s = x(null),\n        n = he(t, \"modelValue\"),\n        i = Ua(s),\n        u = be(() => a.interval),\n        d = k(() => !Ae(r.close)),\n        p = k(() => typeof n.value == \"boolean\" ? 0 : n.value),\n        f = w(() => ({\n          [`alert-${a.variant}`]: a.variant !== null,\n          \"alert-dismissible\": a.dismissible\n        })),\n        m = w(() => [a.closeClass, {\n          \"btn-close-custom\": d.value\n        }]),\n        {\n          isActive: y,\n          pause: h,\n          restart: c,\n          resume: g,\n          stop: v,\n          isPaused: $,\n          value: B\n        } = Ho(p, u, {\n          immediate: typeof n.value == \"number\" && a.immediate\n        }),\n        C = k(() => typeof n.value == \"boolean\" ? n.value : y.value || a.showOnPause && $.value),\n        V = w(() => ({\n          variant: d.value ? a.closeVariant : void 0,\n          class: m.value\n        }));\n      Rt(() => {\n        o(\"close-countdown\", B.value);\n      });\n      const L = () => {\n          o(\"close\"), typeof n.value == \"boolean\" ? n.value = !1 : (n.value = 0, v()), o(\"closed\");\n        },\n        Q = () => {\n          a.noHoverPause || h();\n        };\n      return ue(i, W => {\n        if (W) {\n          Q();\n          return;\n        }\n        g();\n      }), Fa(v), e({\n        pause: h,\n        restart: c,\n        resume: g,\n        stop: v\n      }), (W, F) => (b(), I(It, {\n        \"no-fade\": !a.fade,\n        \"trans-props\": {\n          enterToClass: \"show\"\n        }\n      }, {\n        default: E(() => [C.value ? (b(), _(\"div\", {\n          key: 0,\n          ref_key: \"element\",\n          ref: s,\n          class: D([\"alert\", f.value]),\n          role: \"alert\",\n          \"aria-live\": \"polite\",\n          \"aria-atomic\": \"true\"\n        }, [T(W.$slots, \"default\", {}, void 0, !0), a.dismissible ? (b(), _(de, {\n          key: 0\n        }, [d.value || W.closeContent ? (b(), I(vt, K({\n          key: 0\n        }, V.value, {\n          onClick: L\n        }), {\n          default: E(() => [T(W.$slots, \"close\", {}, () => [ne(Y(W.closeContent), 1)], !0)]),\n          _: 3\n        }, 16)) : (b(), I(Pt, K({\n          key: 1,\n          \"aria-label\": W.closeLabel\n        }, V.value, {\n          onClick: L\n        }), null, 16, [\"aria-label\"]))], 64)) : ae(\"\", !0)], 2)) : ae(\"\", !0)]),\n        _: 3\n      }, 8, [\"no-fade\"]));\n    }\n  }),\n  ni = /* @__PURE__ */qt(oi, [[\"__scopeId\", \"data-v-30d91aa1\"]]),\n  si = {\n    key: 0,\n    class: \"b-avatar-custom\"\n  },\n  ri = {\n    key: 1,\n    class: \"b-avatar-img\"\n  },\n  ii = [\"src\", \"alt\"],\n  $l = 0.4,\n  ui = /* @__PURE__ */H({\n    __name: \"BAvatar\",\n    props: {\n      alt: {\n        default: \"avatar\"\n      },\n      badge: {\n        type: [Boolean, String],\n        default: !1\n      },\n      badgeBgVariant: {\n        default: null\n      },\n      badgeOffset: {\n        default: void 0\n      },\n      badgeStart: {\n        type: Boolean,\n        default: !1\n      },\n      badgeTextVariant: {\n        default: null\n      },\n      badgeTop: {\n        type: Boolean,\n        default: !1\n      },\n      badgeVariant: {\n        default: \"primary\"\n      },\n      button: {\n        type: Boolean,\n        default: !1\n      },\n      buttonType: {\n        default: \"button\"\n      },\n      icon: {\n        default: void 0\n      },\n      size: {\n        default: void 0\n      },\n      square: {\n        type: Boolean,\n        default: !1\n      },\n      src: {\n        default: void 0\n      },\n      text: {\n        default: void 0\n      },\n      active: {\n        type: Boolean,\n        default: void 0\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: Boolean,\n        default: void 0\n      },\n      disabled: {\n        type: Boolean,\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: Boolean,\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      },\n      variant: {\n        default: \"secondary\"\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      },\n      rounded: {\n        type: [Boolean, String, Number],\n        default: !1\n      },\n      roundedTop: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedBottom: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedStart: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedEnd: {\n        type: [Boolean, String, Number],\n        default: void 0\n      }\n    },\n    emits: [\"click\", \"img-error\"],\n    setup(t, {\n      emit: e\n    }) {\n      const l = t,\n        a = e,\n        o = Le(),\n        {\n          computedLink: r,\n          computedLinkProps: s\n        } = wt(l),\n        n = _e(So, null),\n        i = [\"sm\", null, \"lg\"],\n        u = $l * 0.7,\n        d = k(() => !Ae(o.default)),\n        p = k(() => !Ae(o.badge)),\n        f = k(() => !!l.badge || l.badge === \"\" || p.value),\n        m = k(() => (n == null ? void 0 : n.size.value) ?? l.square),\n        y = ia(() => l.size),\n        h = ia(() => n == null ? void 0 : n.size.value),\n        c = w(() => h.value ?? y.value),\n        g = k(() => (n == null ? void 0 : n.variant.value) ?? l.variant),\n        v = k(() => (n == null ? void 0 : n.rounded.value) ?? l.rounded),\n        $ = k(() => (n == null ? void 0 : n.roundedTop.value) ?? l.roundedTop),\n        B = k(() => (n == null ? void 0 : n.roundedBottom.value) ?? l.roundedBottom),\n        C = k(() => (n == null ? void 0 : n.roundedStart.value) ?? l.roundedStart),\n        V = k(() => (n == null ? void 0 : n.roundedEnd.value) ?? l.roundedEnd),\n        L = Qa(() => ({\n          rounded: v.value,\n          roundedTop: $.value,\n          roundedBottom: B.value,\n          roundedStart: C.value,\n          roundedEnd: V.value\n        })),\n        Q = et(() => ({\n          variant: l.badgeVariant,\n          bgVariant: l.badgeBgVariant,\n          textVariant: l.badgeTextVariant\n        })),\n        W = k(() => l.badge === !0 ? \"\" : l.badge),\n        F = k(() => (n == null ? void 0 : n.textVariant.value) ?? l.textVariant),\n        Z = k(() => (n == null ? void 0 : n.bgVariant.value) ?? l.bgVariant),\n        R = et(() => ({\n          bgVariant: Z.value,\n          textVariant: F.value,\n          variant: g.value\n        })),\n        le = w(() => [R.value,\n        // Square overwrites all else\n        m.value === !0 ? void 0 : L.value, {\n          [`b-avatar-${l.size}`]: !!l.size && i.indexOf(y.value) !== -1,\n          [`btn-${g.value}`]: l.button ? g.value !== null : !1,\n          badge: !l.button && g.value !== null && d.value,\n          btn: l.button,\n          // Square is the same as rounded-0 class\n          \"rounded-0\": m.value === !0\n        }]),\n        N = w(() => {\n          const G = l.badgeOffset || \"0px\";\n          return {\n            fontSize: (i.indexOf(c.value || null) === -1 ? `calc(${c.value} * ${u})` : \"\") || \"\",\n            top: l.badgeTop ? G : \"\",\n            bottom: l.badgeTop ? \"\" : G,\n            left: l.badgeStart ? G : \"\",\n            right: l.badgeStart ? \"\" : G\n          };\n        }),\n        S = w(() => {\n          const G = i.indexOf(c.value || null) === -1 ? `calc(${c.value} * ${$l})` : null;\n          return G ? {\n            fontSize: G\n          } : {};\n        }),\n        P = w(() => {\n          var q;\n          const G = ((q = n == null ? void 0 : n.overlapScale) == null ? void 0 : q.value) || 0,\n            ie = c.value && G ? `calc(${c.value} * -${G})` : null;\n          return ie ? {\n            marginLeft: ie,\n            marginRight: ie\n          } : {};\n        }),\n        M = k(() => r.value ? ot : l.button ? \"button\" : \"span\"),\n        j = w(() => ({\n          ...P.value,\n          width: c.value ?? void 0,\n          height: c.value ?? void 0\n        })),\n        A = G => {\n          !l.disabled && (r.value || l.button) && a(\"click\", G);\n        },\n        X = G => {\n          a(\"img-error\", G);\n        };\n      return (G, ie) => (b(), I(re(M.value), K({\n        class: [\"b-avatar\", le.value],\n        style: j.value\n      }, O(s), {\n        type: l.button && !O(r) ? l.buttonType : void 0,\n        disabled: l.disabled || null,\n        onClick: A\n      }), {\n        default: E(() => [d.value ? (b(), _(\"span\", si, [T(G.$slots, \"default\")])) : G.src ? (b(), _(\"span\", ri, [J(\"img\", {\n          src: G.src,\n          alt: G.alt,\n          onError: X\n        }, null, 40, ii)])) : G.text ? (b(), _(\"span\", {\n          key: 2,\n          class: \"b-avatar-text\",\n          style: Ee(S.value)\n        }, Y(G.text), 5)) : ae(\"\", !0), f.value ? (b(), _(\"span\", {\n          key: 3,\n          class: D([\"b-avatar-badge\", O(Q)]),\n          style: Ee(N.value)\n        }, [T(G.$slots, \"badge\", {}, () => [ne(Y(W.value), 1)])], 6)) : ae(\"\", !0)]),\n        _: 3\n      }, 16, [\"class\", \"style\", \"type\", \"disabled\"]));\n    }\n  }),\n  di = /* @__PURE__ */H({\n    __name: \"BAvatarGroup\",\n    props: {\n      overlap: {\n        default: 0.3\n      },\n      size: {\n        default: void 0\n      },\n      square: {\n        type: Boolean,\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      variant: {\n        default: null\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      },\n      rounded: {\n        type: [Boolean, String, Number],\n        default: !1\n      },\n      roundedTop: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedBottom: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedStart: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedEnd: {\n        type: [Boolean, String, Number],\n        default: void 0\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = be(() => e.overlap),\n        a = ia(() => e.size),\n        o = k(() => Math.min(Math.max(l.value, 0), 1) / 2),\n        r = w(() => {\n          const s = a.value ? `calc(${a.value} * ${o.value})` : null;\n          return s ? {\n            paddingLeft: s,\n            paddingRight: s\n          } : {};\n        });\n      return at(So, {\n        overlapScale: o,\n        size: k(() => e.size),\n        square: k(() => e.square),\n        rounded: k(() => e.rounded),\n        roundedTop: k(() => e.roundedTop),\n        roundedBottom: k(() => e.roundedBottom),\n        roundedStart: k(() => e.roundedStart),\n        roundedEnd: k(() => e.roundedEnd),\n        variant: k(() => e.variant),\n        bgVariant: k(() => e.bgVariant),\n        textVariant: k(() => e.textVariant)\n      }), (s, n) => (b(), I(re(s.tag), {\n        class: \"b-avatar-group\",\n        role: \"group\"\n      }, {\n        default: E(() => [J(\"div\", {\n          class: \"b-avatar-group-inner\",\n          style: Ee(r.value)\n        }, [T(s.$slots, \"default\")], 4)]),\n        _: 3\n      }));\n    }\n  }),\n  ci = /* @__PURE__ */H({\n    __name: \"BBadge\",\n    props: {\n      dotIndicator: {\n        type: Boolean,\n        default: !1\n      },\n      pill: {\n        type: Boolean,\n        default: !1\n      },\n      tag: {\n        default: \"span\"\n      },\n      textIndicator: {\n        type: Boolean,\n        default: !1\n      },\n      active: {\n        type: Boolean,\n        default: void 0\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: Boolean,\n        default: void 0\n      },\n      disabled: {\n        type: Boolean,\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: Boolean,\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: Boolean,\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      },\n      variant: {\n        default: \"secondary\"\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = et(e),\n        {\n          computedLink: a,\n          computedLinkProps: o\n        } = wt(e, [\"active\", \"activeClass\", \"append\", \"disabled\", \"href\", \"rel\", \"replace\", \"routerComponentName\", \"target\", \"to\", \"opacity\", \"opacityHover\", \"underlineVariant\", \"underlineOffset\", \"underlineOffsetHover\", \"underlineOpacity\", \"underlineOpacityHover\", \"icon\"]),\n        r = k(() => a.value ? ot : e.tag),\n        s = w(() => [l.value, {\n          active: e.active,\n          disabled: e.disabled,\n          \"rounded-pill\": e.pill,\n          \"position-absolute top-0 start-100 translate-middle\": e.textIndicator || e.dotIndicator,\n          \"p-2 border border-light rounded-circle\": e.dotIndicator,\n          \"text-decoration-none\": a.value\n        }]);\n      return (n, i) => (b(), I(re(r.value), K({\n        class: [\"badge\", s.value]\n      }, O(o)), {\n        default: E(() => [T(n.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\"]));\n    }\n  }),\n  en = /* @__PURE__ */H({\n    __name: \"BBreadcrumbItem\",\n    props: {\n      ariaCurrent: {\n        default: \"location\"\n      },\n      text: {\n        default: void 0\n      },\n      active: {\n        type: Boolean,\n        default: !1\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: Boolean,\n        default: void 0\n      },\n      disabled: {\n        type: Boolean,\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: Boolean,\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: Boolean,\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    emits: [\"click\"],\n    setup(t, {\n      emit: e\n    }) {\n      const l = t,\n        a = e,\n        o = w(() => ({\n          active: l.active\n        })),\n        r = k(() => l.active ? \"span\" : ot),\n        s = k(() => l.active ? l.ariaCurrent : void 0),\n        n = w(() => r.value !== \"span\" ? Za(l, [\"active\", \"activeClass\", \"append\", \"disabled\", \"href\", \"rel\", \"replace\", \"routerComponentName\", \"target\", \"to\", \"variant\", \"opacity\", \"opacityHover\", \"underlineVariant\", \"underlineOffset\", \"underlineOffsetHover\", \"underlineOpacity\", \"underlineOpacityHover\", \"icon\"]) : {}),\n        i = u => {\n          if (l.disabled || l.active) {\n            u.preventDefault(), u.stopImmediatePropagation();\n            return;\n          }\n          l.disabled || a(\"click\", u);\n        };\n      return (u, d) => (b(), _(\"li\", {\n        class: D([\"breadcrumb-item\", o.value])\n      }, [(b(), I(re(r.value), K({\n        \"aria-current\": s.value\n      }, n.value, {\n        onClick: i\n      }), {\n        default: E(() => [T(u.$slots, \"default\", {}, () => [ne(Y(u.text), 1)])]),\n        _: 3\n      }, 16, [\"aria-current\"]))], 2));\n    }\n  }),\n  fi = {\n    \"aria-label\": \"breadcrumb\"\n  },\n  vi = {\n    class: \"breadcrumb\"\n  },\n  pi = /* @__PURE__ */H({\n    __name: \"BBreadcrumb\",\n    props: {\n      items: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = zo(),\n        a = w(() => {\n          var n;\n          const o = e.items || ((n = l.items) == null ? void 0 : n.value) || [];\n          let r = !1;\n          return o.map((i, u) => (typeof i == \"string\" && (i = {\n            text: i\n          }, u < o.length - 1 && (i.href = \"#\")), i.active && (r = !0), !i.active && !r && (i.active = u + 1 === o.length), i));\n        });\n      return (o, r) => (b(), _(\"nav\", fi, [J(\"ol\", vi, [T(o.$slots, \"prepend\"), (b(!0), _(de, null, Ce(a.value, (s, n) => (b(), I(en, K({\n        key: n,\n        ref_for: !0\n      }, s), {\n        default: E(() => [ne(Y(s.text), 1)]),\n        _: 2\n      }, 1040))), 128)), T(o.$slots, \"default\"), T(o.$slots, \"append\")])]));\n    }\n  }),\n  mi = /* @__PURE__ */H({\n    __name: \"BButtonGroup\",\n    props: {\n      ariaLabel: {\n        default: \"Group\"\n      },\n      size: {\n        default: \"md\"\n      },\n      tag: {\n        default: \"div\"\n      },\n      vertical: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => ({\n          \"btn-group\": !e.vertical,\n          [`btn-group-${e.size}`]: e.size !== \"md\",\n          \"btn-group-vertical\": e.vertical\n        }));\n      return (a, o) => (b(), I(re(a.tag), {\n        class: D(l.value),\n        role: \"group\",\n        \"aria-label\": a.ariaLabel\n      }, {\n        default: E(() => [T(a.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\", \"aria-label\"]));\n    }\n  }),\n  bi = [\"role\", \"aria-label\"],\n  yi = /* @__PURE__ */H({\n    __name: \"BButtonToolbar\",\n    props: {\n      ariaLabel: {\n        default: \"Group\"\n      },\n      justify: {\n        type: Boolean,\n        default: !1\n      },\n      role: {\n        default: \"toolbar\"\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => ({\n          \"justify-content-between\": e.justify\n        }));\n      return (a, o) => (b(), _(\"div\", {\n        class: D([l.value, \"btn-toolbar\"]),\n        role: a.role,\n        \"aria-label\": a.ariaLabel\n      }, [T(a.$slots, \"default\")], 10, bi));\n    }\n  }),\n  gi = [\"src\", \"width\", \"height\", \"srcset\", \"sizes\", \"loading\"],\n  el = /* @__PURE__ */H({\n    __name: \"BImg\",\n    props: {\n      blank: {\n        type: Boolean,\n        default: !1\n      },\n      blankColor: {\n        default: \"transparent\"\n      },\n      block: {\n        type: Boolean,\n        default: !1\n      },\n      center: {\n        type: Boolean,\n        default: !1\n      },\n      end: {\n        type: Boolean,\n        default: !1\n      },\n      fluid: {\n        type: Boolean,\n        default: !1\n      },\n      fluidGrow: {\n        type: Boolean,\n        default: !1\n      },\n      height: {\n        default: void 0\n      },\n      lazy: {\n        type: Boolean,\n        default: !1\n      },\n      sizes: {\n        default: void 0\n      },\n      src: {\n        default: void 0\n      },\n      srcset: {\n        default: void 0\n      },\n      start: {\n        type: Boolean,\n        default: !1\n      },\n      thumbnail: {\n        type: Boolean,\n        default: !1\n      },\n      width: {\n        default: void 0\n      },\n      rounded: {\n        type: [Boolean, String, Number],\n        default: !1\n      },\n      roundedTop: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedBottom: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedStart: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedEnd: {\n        type: [Boolean, String, Number],\n        default: void 0\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = be(() => e.height ?? NaN),\n        a = be(() => e.width ?? NaN),\n        o = Qa(() => ({\n          rounded: e.rounded,\n          roundedTop: e.roundedTop,\n          roundedBottom: e.roundedBottom,\n          roundedStart: e.roundedStart,\n          roundedEnd: e.roundedEnd\n        })),\n        r = w(() => typeof e.srcset == \"string\" ? e.srcset.split(\",\").filter(f => f).join(\",\") : Array.isArray(e.srcset) ? e.srcset.filter(f => f).join(\",\") : void 0),\n        s = w(() => typeof e.sizes == \"string\" ? e.sizes.split(\",\").filter(f => f).join(\",\") : Array.isArray(e.sizes) ? e.sizes.filter(f => f).join(\",\") : void 0),\n        n = w(() => {\n          const f = Number.isNaN(a.value) ? void 0 : a.value,\n            m = Number.isNaN(l.value) ? void 0 : l.value;\n          return e.blank ? f !== void 0 && m === void 0 ? {\n            height: f,\n            width: f\n          } : f === void 0 && m !== void 0 ? {\n            height: m,\n            width: m\n          } : {\n            height: 1,\n            width: 1\n          } : {\n            width: f,\n            height: m\n          };\n        }),\n        i = k(() => p(n.value.width, n.value.height, e.blankColor)),\n        u = k(() => e.start ? \"float-start\" : e.end ? \"float-end\" : e.center ? \"mx-auto\" : void 0),\n        d = w(() => [o.value, {\n          \"img-thumbnail\": e.thumbnail,\n          \"img-fluid\": e.fluid || e.fluidGrow,\n          \"w-100\": e.fluidGrow,\n          [`${u.value}`]: u.value !== void 0,\n          \"d-block\": e.block || e.center\n        }]),\n        p = (f, m, y) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`<svg width=\"${f}\" height=\"${m}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${f} ${m}\" preserveAspectRatio=\"none\">\n    <rect width=\"100%\" height=\"100%\" style=\"fill:${y};\"></rect>\n    </svg>`)}`;\n      return (f, m) => (b(), _(\"img\", {\n        class: D(d.value),\n        src: e.blank ? i.value : f.src,\n        width: n.value.width || void 0,\n        height: n.value.height || void 0,\n        srcset: e.blank ? void 0 : r.value,\n        sizes: e.blank ? void 0 : s.value,\n        loading: e.lazy ? \"lazy\" : \"eager\"\n      }, null, 10, gi));\n    }\n  }),\n  tl = /* @__PURE__ */H({\n    __name: \"BCardImg\",\n    props: {\n      bottom: {\n        type: Boolean,\n        default: !1\n      },\n      top: {\n        type: Boolean,\n        default: !1\n      },\n      blank: {\n        type: Boolean,\n        default: void 0\n      },\n      blankColor: {\n        default: void 0\n      },\n      block: {\n        type: Boolean,\n        default: void 0\n      },\n      center: {\n        type: Boolean,\n        default: void 0\n      },\n      end: {\n        type: Boolean,\n        default: void 0\n      },\n      fluid: {\n        type: Boolean,\n        default: void 0\n      },\n      fluidGrow: {\n        type: Boolean,\n        default: void 0\n      },\n      height: {\n        default: void 0\n      },\n      lazy: {\n        type: Boolean,\n        default: void 0\n      },\n      sizes: {\n        default: void 0\n      },\n      src: {\n        default: void 0\n      },\n      srcset: {\n        default: void 0\n      },\n      start: {\n        type: Boolean,\n        default: void 0\n      },\n      thumbnail: {\n        type: Boolean,\n        default: void 0\n      },\n      width: {\n        default: void 0\n      },\n      rounded: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedTop: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedBottom: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedStart: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      roundedEnd: {\n        type: [Boolean, String, Number],\n        default: void 0\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = k(() => e.top ? \"card-img-top\" : e.end ? \"card-img-right\" : e.bottom ? \"card-img-bottom\" : e.start ? \"card-img-left\" : \"card-img\"),\n        a = w(() => va(e, [\"bottom\", \"top\", \"end\", \"start\"]));\n      return (o, r) => (b(), I(el, K(a.value, {\n        class: l.value\n      }), null, 16, [\"class\"]));\n    }\n  }),\n  hi = [\"innerHTML\"],\n  tn = /* @__PURE__ */H({\n    __name: \"BCardHeadFoot\",\n    props: {\n      borderVariant: {\n        default: null\n      },\n      html: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      },\n      variant: {\n        default: null\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = et(e),\n        a = w(() => [l.value, {\n          [`border-${e.borderVariant}`]: e.borderVariant !== null\n        }]);\n      return (o, r) => (b(), I(re(o.tag), {\n        class: D(a.value)\n      }, {\n        default: E(() => [o.html ? (b(), _(\"div\", {\n          key: 0,\n          innerHTML: o.html\n        }, null, 8, hi)) : T(o.$slots, \"default\", {\n          key: 1\n        }, () => [ne(Y(o.text), 1)])]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  an = /* @__PURE__ */H({\n    __name: \"BCardHeader\",\n    props: {\n      borderVariant: {\n        default: void 0\n      },\n      html: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      },\n      bgVariant: {\n        default: void 0\n      },\n      textVariant: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      const e = t;\n      return (l, a) => (b(), I(tn, K({\n        class: \"card-header\"\n      }, e), {\n        default: E(() => [T(l.$slots, \"default\")]),\n        _: 3\n      }, 16));\n    }\n  }),\n  ln = /* @__PURE__ */H({\n    __name: \"BCardTitle\",\n    props: {\n      tag: {\n        default: \"h4\"\n      },\n      text: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      return (e, l) => (b(), I(re(e.tag), {\n        class: \"card-title\"\n      }, {\n        default: E(() => [T(e.$slots, \"default\", {}, () => [ne(Y(e.text), 1)])]),\n        _: 3\n      }));\n    }\n  }),\n  on = /* @__PURE__ */H({\n    __name: \"BCardSubtitle\",\n    props: {\n      text: {\n        default: void 0\n      },\n      tag: {\n        default: \"h6\"\n      },\n      textVariant: {\n        default: \"body-secondary\"\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => ({\n          [`text-${e.textVariant}`]: e.textVariant !== null\n        }));\n      return (a, o) => (b(), I(re(a.tag), {\n        class: D([\"card-subtitle mb-2\", l.value])\n      }, {\n        default: E(() => [T(a.$slots, \"default\", {}, () => [ne(Y(a.text), 1)])]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  nn = /* @__PURE__ */H({\n    __name: \"BCardBody\",\n    props: {\n      overlay: {\n        type: Boolean,\n        default: !1\n      },\n      subtitle: {\n        default: void 0\n      },\n      subtitleTag: {\n        default: \"h4\"\n      },\n      subtitleTextVariant: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      },\n      title: {\n        default: void 0\n      },\n      titleTag: {\n        default: \"h4\"\n      },\n      variant: {\n        default: null\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = Le(),\n        a = et(e),\n        o = k(() => !Ae(l.title)),\n        r = k(() => !Ae(l.subtitle)),\n        s = w(() => [a.value, {\n          \"card-img-overlay\": e.overlay\n        }]);\n      return (n, i) => (b(), I(re(n.tag), {\n        class: D([\"card-body\", s.value])\n      }, {\n        default: E(() => [n.title || o.value ? (b(), I(ln, {\n          key: 0,\n          tag: n.titleTag\n        }, {\n          default: E(() => [T(n.$slots, \"title\", {}, () => [ne(Y(n.title), 1)])]),\n          _: 3\n        }, 8, [\"tag\"])) : ae(\"\", !0), n.subtitle || r.value ? (b(), I(on, {\n          key: 1,\n          tag: n.subtitleTag,\n          \"text-variant\": n.subtitleTextVariant\n        }, {\n          default: E(() => [T(n.$slots, \"subtitle\", {}, () => [ne(Y(n.subtitle), 1)])]),\n          _: 3\n        }, 8, [\"tag\", \"text-variant\"])) : ae(\"\", !0), T(n.$slots, \"default\", {}, () => [ne(Y(n.text), 1)])]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  sn = /* @__PURE__ */H({\n    __name: \"BCardFooter\",\n    props: {\n      borderVariant: {\n        default: void 0\n      },\n      html: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      },\n      bgVariant: {\n        default: void 0\n      },\n      textVariant: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      const e = t;\n      return (l, a) => (b(), I(tn, K({\n        class: \"card-footer\"\n      }, e), {\n        default: E(() => [T(l.$slots, \"default\", {}, () => [ne(Y(l.text), 1)])]),\n        _: 3\n      }, 16));\n    }\n  }),\n  rn = /* @__PURE__ */H({\n    __name: \"BCard\",\n    props: {\n      align: {\n        default: void 0\n      },\n      bodyBgVariant: {\n        default: void 0\n      },\n      bodyClass: {\n        default: void 0\n      },\n      bodyTag: {\n        default: \"div\"\n      },\n      bodyText: {\n        default: \"\"\n      },\n      bodyTextVariant: {\n        default: void 0\n      },\n      borderVariant: {\n        default: null\n      },\n      footer: {\n        default: void 0\n      },\n      footerBgVariant: {\n        default: void 0\n      },\n      footerBorderVariant: {\n        default: void 0\n      },\n      footerClass: {\n        default: void 0\n      },\n      footerHtml: {\n        default: \"\"\n      },\n      footerTag: {\n        default: \"div\"\n      },\n      footerTextVariant: {\n        default: void 0\n      },\n      footerVariant: {\n        default: null\n      },\n      header: {\n        default: void 0\n      },\n      headerBgVariant: {\n        default: void 0\n      },\n      headerBorderVariant: {\n        default: void 0\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerHtml: {\n        default: \"\"\n      },\n      headerTag: {\n        default: \"div\"\n      },\n      headerTextVariant: {\n        default: void 0\n      },\n      headerVariant: {\n        default: null\n      },\n      imgAlt: {\n        default: void 0\n      },\n      imgBottom: {\n        type: Boolean,\n        default: !1\n      },\n      imgEnd: {\n        type: Boolean,\n        default: !1\n      },\n      imgHeight: {\n        default: void 0\n      },\n      imgSrc: {\n        default: void 0\n      },\n      imgStart: {\n        type: Boolean,\n        default: !1\n      },\n      imgTop: {\n        type: Boolean,\n        default: !1\n      },\n      imgWidth: {\n        default: void 0\n      },\n      noBody: {\n        type: Boolean,\n        default: !1\n      },\n      overlay: {\n        type: Boolean,\n        default: !1\n      },\n      subtitle: {\n        default: void 0\n      },\n      subtitleTag: {\n        default: \"h6\"\n      },\n      subtitleTextVariant: {\n        default: \"body-secondary\"\n      },\n      tag: {\n        default: \"div\"\n      },\n      title: {\n        default: void 0\n      },\n      titleTag: {\n        default: \"h4\"\n      },\n      variant: {\n        default: null\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = Le(),\n        a = k(() => !Ae(l.header)),\n        o = k(() => !Ae(l.footer)),\n        r = et(e),\n        s = w(() => [r.value, {\n          [`text-${e.align}`]: e.align !== void 0,\n          [`border-${e.borderVariant}`]: e.borderVariant !== null,\n          \"flex-row\": e.imgStart,\n          \"flex-row-reverse\": e.imgEnd\n        }]),\n        n = w(() => ({\n          src: e.imgSrc,\n          alt: e.imgAlt,\n          height: e.imgHeight,\n          width: e.imgWidth,\n          bottom: e.imgBottom,\n          end: e.imgEnd,\n          start: e.imgStart,\n          top: e.imgTop\n        })),\n        i = zt();\n      return (u, d) => (b(), I(re(u.tag), {\n        class: D([\"card\", s.value])\n      }, {\n        default: E(() => [ve(O(i).define, null, {\n          default: E(() => [T(u.$slots, \"img\", {}, () => [u.imgSrc ? (b(), I(tl, ge(K({\n            key: 0\n          }, n.value)), null, 16)) : ae(\"\", !0)])]),\n          _: 3\n        }), e.imgBottom ? ae(\"\", !0) : (b(), I(O(i).reuse, {\n          key: 0\n        })), u.header || a.value || u.headerHtml ? (b(), I(an, {\n          key: 1,\n          \"bg-variant\": u.headerBgVariant,\n          variant: u.headerVariant,\n          \"border-variant\": u.headerBorderVariant,\n          html: u.headerHtml,\n          tag: u.headerTag,\n          \"text-variant\": u.headerTextVariant,\n          class: D(u.headerClass)\n        }, {\n          default: E(() => [T(u.$slots, \"header\", {}, () => [ne(Y(u.header), 1)])]),\n          _: 3\n        }, 8, [\"bg-variant\", \"variant\", \"border-variant\", \"html\", \"tag\", \"text-variant\", \"class\"])) : ae(\"\", !0), e.noBody ? T(u.$slots, \"default\", {\n          key: 3\n        }, () => [ne(Y(u.bodyText), 1)]) : (b(), I(nn, {\n          key: 2,\n          overlay: u.overlay,\n          \"bg-variant\": u.bodyBgVariant,\n          tag: u.bodyTag,\n          \"text-variant\": u.bodyTextVariant,\n          subtitle: u.subtitle,\n          \"subtitle-tag\": u.subtitleTag,\n          \"subtitle-text-variant\": u.subtitleTextVariant,\n          title: u.title,\n          \"title-tag\": u.titleTag,\n          class: D(u.bodyClass)\n        }, {\n          default: E(() => [T(u.$slots, \"default\", {}, () => [ne(Y(u.bodyText), 1)])]),\n          _: 3\n        }, 8, [\"overlay\", \"bg-variant\", \"tag\", \"text-variant\", \"subtitle\", \"subtitle-tag\", \"subtitle-text-variant\", \"title\", \"title-tag\", \"class\"])), u.footer || o.value || u.footerHtml ? (b(), I(sn, {\n          key: 4,\n          \"bg-variant\": u.footerBgVariant,\n          \"border-variant\": u.footerBorderVariant,\n          variant: u.footerVariant,\n          html: u.footerHtml,\n          tag: u.footerTag,\n          \"text-variant\": u.footerTextVariant,\n          class: D(u.footerClass)\n        }, {\n          default: E(() => [T(u.$slots, \"footer\", {}, () => [ne(Y(u.footer), 1)])]),\n          _: 3\n        }, 8, [\"bg-variant\", \"border-variant\", \"variant\", \"html\", \"tag\", \"text-variant\", \"class\"])) : ae(\"\", !0), e.imgBottom ? (b(), I(O(i).reuse, {\n          key: 5\n        })) : ae(\"\", !0)]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  Bi = /* @__PURE__ */H({\n    __name: \"BCardGroup\",\n    props: {\n      columns: {\n        type: Boolean,\n        default: !1\n      },\n      deck: {\n        type: Boolean,\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = k(() => e.deck ? \"card-deck\" : e.columns ? \"card-columns\" : \"card-group\");\n      return (a, o) => (b(), I(re(a.tag), {\n        class: D(l.value)\n      }, {\n        default: E(() => [T(a.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  wi = /* @__PURE__ */H({\n    __name: \"BCardText\",\n    props: {\n      tag: {\n        default: \"p\"\n      },\n      text: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      return (e, l) => (b(), I(re(e.tag), {\n        class: \"card-text\"\n      }, {\n        default: E(() => [T(e.$slots, \"default\", {}, () => [ne(Y(e.text), 1)])]),\n        _: 3\n      }));\n    }\n  }),\n  Ci = [\"id\"],\n  ki = {\n    key: 0,\n    class: \"carousel-indicators\"\n  },\n  $i = [\"aria-current\", \"aria-label\", \"onClick\"],\n  Ti = /* @__PURE__ */J(\"span\", {\n    class: \"carousel-control-prev-icon\",\n    \"aria-hidden\": \"true\"\n  }, null, -1),\n  Si = {\n    class: \"visually-hidden\"\n  },\n  _i = /* @__PURE__ */J(\"span\", {\n    class: \"carousel-control-next-icon\",\n    \"aria-hidden\": \"true\"\n  }, null, -1),\n  Vi = {\n    class: \"visually-hidden\"\n  },\n  Ai = /* @__PURE__ */H({\n    __name: \"BCarousel\",\n    props: /* @__PURE__ */pe({\n      background: {\n        default: void 0\n      },\n      controls: {\n        type: Boolean,\n        default: !1\n      },\n      controlsNextText: {\n        default: \"Next\"\n      },\n      controlsPrevText: {\n        default: \"Previous\"\n      },\n      fade: {\n        type: Boolean,\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      imgHeight: {\n        default: void 0\n      },\n      imgWidth: {\n        default: void 0\n      },\n      indicators: {\n        type: Boolean,\n        default: !1\n      },\n      indicatorsButtonLabel: {\n        default: \"Slide\"\n      },\n      interval: {\n        default: 5e3\n      },\n      keyboard: {\n        type: Boolean,\n        default: !0\n      },\n      modelValue: {},\n      noHoverPause: {\n        type: Boolean,\n        default: !1\n      },\n      noTouch: {\n        type: Boolean,\n        default: !1\n      },\n      noWrap: {\n        type: Boolean,\n        default: !1\n      },\n      ride: {\n        type: [Boolean, String],\n        default: !1\n      },\n      rideReverse: {\n        type: Boolean,\n        default: !1\n      },\n      touchThreshold: {\n        default: 50\n      }\n    }, {\n      modelValue: {\n        default: 0\n      },\n      modelModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"slide\", \"slid\"], [\"update:modelValue\"]),\n    setup(t, {\n      expose: e,\n      emit: l\n    }) {\n      const a = t,\n        o = l,\n        r = Le(),\n        s = Be(() => a.id, \"carousel\"),\n        n = he(t, \"modelValue\"),\n        i = be(() => a.touchThreshold),\n        u = be(() => a.interval),\n        d = x(!1),\n        p = x(!1),\n        f = x(!0),\n        m = x(null),\n        y = x(null),\n        h = x(n.value),\n        c = Ua(y),\n        g = k(() => `carousel-item carousel-item-${f.value ? \"prev\" : \"next\"} carousel-item-${f.value ? \"end\" : \"start\"}`),\n        v = k(() => `carousel-item active carousel-item-${f.value ? \"start\" : \"end\"}`),\n        {\n          pause: $,\n          resume: B\n        } = mo(() => {\n          a.rideReverse ? F() : Z();\n        }, u, {\n          immediate: a.ride === \"carousel\"\n        }),\n        C = k(() => a.ride === !0 && p.value === !0 || a.ride === \"carousel\"),\n        V = w(() => Br(r.default, \"BCarouselSlide\")),\n        L = w(() => ({\n          \"carousel-fade\": a.fade\n        })),\n        Q = A => {\n          var X;\n          return new ql(A, {\n            componentId: s.value,\n            cancelable: !1,\n            target: y.value,\n            direction: f.value ? \"right\" : \"left\",\n            from: h.value,\n            to: n.value,\n            relatedTarget: ((X = m.value) == null ? void 0 : X.children[n.value]) ?? null\n          });\n        },\n        W = A => {\n          if (d.value !== !0) {\n            if (a.ride === !0 && (p.value = !0), C.value === !0 && B(), f.value = !(A < n.value), A >= V.value.length) {\n              if (a.noWrap) return;\n              n.value = 0;\n              return;\n            }\n            if (A < 0) {\n              if (a.noWrap) return;\n              n.value = V.value.length - 1;\n              return;\n            }\n            h.value = n.value, n.value = A;\n          }\n        },\n        F = () => {\n          W(n.value - 1);\n        },\n        Z = () => {\n          W(n.value + 1);\n        },\n        R = A => {\n          a.keyboard !== !1 && A();\n        },\n        le = () => {\n          a.noHoverPause || $();\n        },\n        N = () => {\n          C.value && B();\n        },\n        {\n          lengthX: S\n        } = cr(y, {\n          passive: !0,\n          onSwipeStart() {\n            a.noTouch !== !0 && $();\n          },\n          onSwipeEnd() {\n            if (a.noTouch === !0) return;\n            const A = () => {\n              C.value !== !1 && B();\n            };\n            if (S.value >= i.value) {\n              Z(), A();\n              return;\n            }\n            S.value <= -i.value && (F(), A());\n          }\n        }),\n        P = () => {\n          o(\"slide\", Q(\"slide\")), d.value = !0;\n        },\n        M = () => {\n          o(\"slid\", Q(\"slid\")), d.value = !1;\n        },\n        j = A => {\n          n.value !== 0 && A.classList.add(\"carousel-item\");\n        };\n      return Re(\"ArrowLeft\", () => {\n        R(F);\n      }, {\n        target: y\n      }), Re(\"ArrowRight\", () => {\n        R(Z);\n      }, {\n        target: y\n      }), ue(() => a.ride, () => {\n        p.value = !1;\n      }), ue(c, A => {\n        if (A) {\n          le();\n          return;\n        }\n        N();\n      }), e({\n        next: Z,\n        pause: $,\n        prev: F,\n        resume: B\n      }), at(Co, {\n        background: k(() => a.background),\n        width: k(() => a.imgWidth),\n        height: k(() => a.imgHeight)\n      }), (A, X) => (b(), _(\"div\", {\n        id: O(s),\n        ref_key: \"element\",\n        ref: y,\n        class: D([\"carousel slide pointer-event\", L.value])\n      }, [a.indicators ? (b(), _(\"div\", ki, [(b(!0), _(de, null, Ce(V.value.length, (G, ie) => (b(), _(\"button\", {\n        key: ie,\n        type: \"button\",\n        \"data-bs-target\": \"\",\n        class: D(ie === n.value ? \"active\" : \"\"),\n        \"aria-current\": ie === n.value ? !0 : void 0,\n        \"aria-label\": `${A.indicatorsButtonLabel} ${ie}`,\n        onClick: q => W(ie)\n      }, null, 10, $i))), 128))])) : ae(\"\", !0), J(\"div\", {\n        ref_key: \"relatedTarget\",\n        ref: m,\n        class: \"carousel-inner\"\n      }, [ve(jl, {\n        \"enter-from-class\": g.value,\n        \"enter-active-class\": g.value,\n        \"enter-to-class\": g.value,\n        \"leave-from-class\": v.value,\n        \"leave-active-class\": v.value,\n        \"leave-to-class\": v.value,\n        onBeforeLeave: P,\n        onAfterLeave: M,\n        onAfterEnter: j\n      }, {\n        default: E(() => [(b(!0), _(de, null, Ce(V.value, (G, ie) => ut((b(), I(re(G), {\n          key: ie,\n          class: D({\n            active: ie === n.value && d.value === !1\n          })\n        }, null, 8, [\"class\"])), [[xt, ie === n.value]])), 128))]),\n        _: 1\n      }, 8, [\"enter-from-class\", \"enter-active-class\", \"enter-to-class\", \"leave-from-class\", \"leave-active-class\", \"leave-to-class\"])], 512), a.controls ? (b(), _(de, {\n        key: 1\n      }, [J(\"button\", {\n        class: \"carousel-control-prev\",\n        type: \"button\",\n        onClick: F\n      }, [Ti, J(\"span\", Si, Y(A.controlsPrevText), 1)]), J(\"button\", {\n        class: \"carousel-control-next\",\n        type: \"button\",\n        onClick: Z\n      }, [_i, J(\"span\", Vi, Y(A.controlsNextText), 1)])], 64)) : ae(\"\", !0)], 10, Ci));\n    }\n  }),\n  Oi = [\"innerHTML\"],\n  Ni = {\n    key: 1\n  },\n  Ii = [\"innerHTML\"],\n  Pi = {\n    key: 1\n  },\n  Ei = /* @__PURE__ */H({\n    __name: \"BCarouselSlide\",\n    props: {\n      background: {\n        default: void 0\n      },\n      caption: {\n        default: void 0\n      },\n      captionHtml: {\n        default: void 0\n      },\n      captionTag: {\n        default: \"h3\"\n      },\n      contentTag: {\n        default: \"div\"\n      },\n      contentVisibleUp: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      imgAlt: {\n        default: void 0\n      },\n      imgBlank: {\n        type: Boolean,\n        default: !1\n      },\n      imgBlankColor: {\n        default: \"transparent\"\n      },\n      imgHeight: {\n        default: void 0\n      },\n      imgSrc: {\n        default: void 0\n      },\n      imgSrcset: {\n        default: void 0\n      },\n      imgWidth: {\n        default: void 0\n      },\n      interval: {\n        default: void 0\n      },\n      text: {\n        default: void 0\n      },\n      textHtml: {\n        default: void 0\n      },\n      textTag: {\n        default: \"p\"\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = Le(),\n        a = _e(Co, null),\n        o = k(() => e.text || e.textHtml || !Ae(l.text)),\n        r = k(() => e.caption || e.captionHtml || !Ae(l.caption)),\n        s = k(() => o.value || r.value || !Ae(l.default)),\n        n = w(() => ({\n          background: `${e.background || (a == null ? void 0 : a.background.value) || \"rgb(171, 171, 171)\"} none repeat scroll 0% 0%`\n        })),\n        i = w(() => ({\n          \"d-none\": e.contentVisibleUp !== void 0,\n          [`d-${e.contentVisibleUp}-block`]: e.contentVisibleUp !== void 0\n        }));\n      return (u, d) => (b(), _(\"div\", {\n        class: \"carousel-item\",\n        style: Ee(n.value)\n      }, [T(u.$slots, \"img\", {}, () => {\n        var p, f;\n        return [ve(el, {\n          class: \"d-block w-100\",\n          alt: u.imgAlt,\n          srcset: u.imgSrcset,\n          src: u.imgSrc,\n          width: u.imgWidth || ((p = O(a)) == null ? void 0 : p.width.value),\n          height: u.imgHeight || ((f = O(a)) == null ? void 0 : f.height.value),\n          blank: u.imgBlank,\n          \"blank-color\": u.imgBlankColor\n        }, null, 8, [\"alt\", \"srcset\", \"src\", \"width\", \"height\", \"blank\", \"blank-color\"])];\n      }), s.value ? (b(), I(re(u.contentTag), {\n        key: 0,\n        class: D([\"carousel-caption\", i.value])\n      }, {\n        default: E(() => [r.value ? (b(), I(re(u.captionTag), {\n          key: 0\n        }, {\n          default: E(() => [T(u.$slots, \"caption\", {}, () => [u.captionHtml ? (b(), _(\"span\", {\n            key: 0,\n            innerHTML: u.captionHtml\n          }, null, 8, Oi)) : (b(), _(\"span\", Ni, Y(u.caption), 1))])]),\n          _: 3\n        })) : ae(\"\", !0), o.value ? (b(), I(re(u.textTag), {\n          key: 1\n        }, {\n          default: E(() => [T(u.$slots, \"text\", {}, () => [u.textHtml ? (b(), _(\"span\", {\n            key: 0,\n            innerHTML: u.textHtml\n          }, null, 8, Ii)) : (b(), _(\"span\", Pi, Y(u.text), 1))])]),\n          _: 3\n        })) : ae(\"\", !0), T(u.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"])) : ae(\"\", !0)], 4));\n    }\n  }),\n  Tl = fa(\"\", [], {\n    type: [Boolean, String, Number],\n    default: !1\n  }),\n  Sl = fa(\"offset\", [\"\"], {\n    type: [String, Number],\n    default: null\n  }),\n  _l = fa(\"order\", [\"\"], {\n    type: [String, Number],\n    default: null\n  }),\n  Fi = H({\n    name: \"BCol\",\n    slots: Object,\n    props: {\n      col: {\n        type: Boolean,\n        default: !1\n      },\n      // Generic flexbox .col (xs)\n      cols: {\n        type: [String, Number],\n        default: null\n      },\n      // .col-[1-12]|auto (xs)\n      ...Tl,\n      offset: {\n        type: [String, Number],\n        default: null\n      },\n      ...Sl,\n      order: {\n        type: [String, Number],\n        default: null\n      },\n      ..._l,\n      alignSelf: {\n        type: String,\n        default: null\n      },\n      tag: {\n        type: String,\n        default: \"div\"\n      }\n    },\n    setup(t) {\n      const e = [{\n          content: Tl,\n          propPrefix: \"cols\",\n          classPrefix: \"col\"\n        }, {\n          content: Sl,\n          propPrefix: \"offset\"\n        }, {\n          content: _l,\n          propPrefix: \"order\"\n        }],\n        l = w(() => e.flatMap(o => ho(t, o.content, o.propPrefix, o.classPrefix)));\n      return {\n        computedClasses: w(() => [l.value, {\n          col: t.col || !l.value.some(o => /^col-/.test(o)) && !t.cols,\n          [`col-${t.cols}`]: !!t.cols,\n          [`offset-${t.offset}`]: !!t.offset,\n          [`order-${t.order}`]: !!t.order,\n          [`align-self-${t.alignSelf}`]: !!t.alignSelf\n        }])\n      };\n    }\n  });\nfunction Li(t, e, l, a, o, r) {\n  return b(), I(re(t.tag), {\n    class: D(t.computedClasses)\n  }, {\n    default: E(() => [T(t.$slots, \"default\")]),\n    _: 3\n  }, 8, [\"class\"]);\n}\nconst Ft = /* @__PURE__ */qt(Fi, [[\"render\", Li]]),\n  zi = /* @__PURE__ */H({\n    __name: \"BContainer\",\n    props: {\n      fluid: {\n        type: [Boolean, String],\n        default: !1\n      },\n      gutterX: {\n        default: void 0\n      },\n      gutterY: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = be(() => e.gutterX ?? NaN, {\n          method: \"parseInt\"\n        }),\n        a = be(() => e.gutterY ?? NaN, {\n          method: \"parseInt\"\n        }),\n        o = w(() => ({\n          container: e.fluid === !1,\n          \"container-fluid\": e.fluid === !0,\n          [`container-${e.fluid}`]: typeof e.fluid == \"string\",\n          [`gx-${l.value}`]: !Number.isNaN(l.value),\n          [`gy-${a.value}`]: !Number.isNaN(a.value)\n        }));\n      return (r, s) => (b(), I(re(r.tag), {\n        class: D(o.value)\n      }, {\n        default: E(() => [T(r.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  Hi = {\n    class: \"visually-hidden\"\n  },\n  Ri = [\"aria-labelledby\", \"role\"],\n  un = /* @__PURE__ */H({\n    __name: \"BDropdown\",\n    props: /* @__PURE__ */pe({\n      ariaLabel: {\n        default: void 0\n      },\n      autoClose: {\n        type: [Boolean, String],\n        default: !0\n      },\n      boundary: {\n        default: \"clippingAncestors\"\n      },\n      boundaryPadding: {\n        default: void 0\n      },\n      center: {\n        type: Boolean,\n        default: !1\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      dropend: {\n        type: Boolean,\n        default: !1\n      },\n      dropstart: {\n        type: Boolean,\n        default: !1\n      },\n      dropup: {\n        type: Boolean,\n        default: !1\n      },\n      end: {\n        type: Boolean,\n        default: !1\n      },\n      floatingMiddleware: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      isNav: {\n        type: Boolean,\n        default: !1\n      },\n      lazy: {\n        type: Boolean,\n        default: !1\n      },\n      menuClass: {\n        default: void 0\n      },\n      modelValue: {\n        type: Boolean\n      },\n      noCaret: {\n        type: Boolean,\n        default: !1\n      },\n      noFlip: {\n        type: Boolean,\n        default: !1\n      },\n      noShift: {\n        type: Boolean,\n        default: !1\n      },\n      noSize: {\n        type: Boolean,\n        default: !1\n      },\n      offset: {\n        default: 0\n      },\n      role: {\n        default: \"menu\"\n      },\n      size: {\n        default: \"md\"\n      },\n      split: {\n        type: Boolean,\n        default: !1\n      },\n      splitButtonType: {\n        default: \"button\"\n      },\n      splitClass: {\n        default: void 0\n      },\n      splitDisabled: {\n        type: Boolean,\n        default: void 0\n      },\n      splitHref: {\n        default: void 0\n      },\n      splitTo: {\n        default: void 0\n      },\n      splitVariant: {\n        default: void 0\n      },\n      strategy: {\n        default: \"absolute\"\n      },\n      text: {\n        default: void 0\n      },\n      toggleClass: {\n        default: void 0\n      },\n      toggleText: {\n        default: \"Toggle dropdown\"\n      },\n      variant: {\n        default: \"secondary\"\n      },\n      teleportDisabled: {\n        default: !1\n      },\n      teleportTo: {\n        default: void 0\n      }\n    }, {\n      modelValue: {\n        type: Boolean,\n        default: !1\n      },\n      modelModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"click\", \"hidden\", \"hide\", \"hide-prevented\", \"show\", \"show-prevented\", \"shown\", \"toggle\"], [\"update:modelValue\"]),\n    setup(t, {\n      expose: e,\n      emit: l\n    }) {\n      const a = t,\n        o = l,\n        r = Be(() => a.id, \"dropdown\"),\n        s = he(t, \"modelValue\"),\n        n = k(() => typeof a.offset == \"string\" || typeof a.offset == \"number\" ? a.offset : NaN),\n        i = be(n),\n        u = x(null),\n        d = x(null),\n        p = x(null),\n        f = x(null),\n        m = w(() => a.boundary === \"document\" || a.boundary === \"viewport\" ? void 0 : a.boundary),\n        y = w(() => a.boundary === \"document\" || a.boundary === \"viewport\" ? a.boundary : void 0),\n        h = k(() => a.split ? d.value : p.value);\n      Re(\"Escape\", () => {\n        s.value = !s.value;\n      }, {\n        target: h\n      }), Re(\"Escape\", () => {\n        s.value = !s.value;\n      }, {\n        target: u\n      });\n      const c = (N, S) => {\n        var M, j, A, X, G, ie, q;\n        if ((j = u.value) != null && j.contains((M = N.target) == null ? void 0 : M.closest(\"form\")) || /input|select|option|textarea|form/i.test((A = N.target) == null ? void 0 : A.tagName)) return;\n        if (N.preventDefault(), !s.value) {\n          open(), Ve(() => c(N, S));\n          return;\n        }\n        const P = (X = u.value) == null ? void 0 : X.querySelectorAll(\".dropdown-item:not(.disabled):not(:disabled)\");\n        if (P) if ((G = u.value) != null && G.contains(document.activeElement)) {\n          const se = u.value.querySelector(\".dropdown-item:focus\"),\n            me = Array.prototype.indexOf.call(P, se) + S;\n          me >= 0 && me < (P == null ? void 0 : P.length) && ((ie = P[me]) == null || ie.focus());\n        } else (q = P[S === -1 ? P.length - 1 : 0]) == null || q.focus();\n      };\n      Re(\"ArrowUp\", N => c(N, -1), {\n        target: h\n      }), Re(\"ArrowDown\", N => c(N, 1), {\n        target: h\n      }), Re(\"ArrowUp\", N => c(N, -1), {\n        target: u\n      }), Re(\"ArrowDown\", N => c(N, 1), {\n        target: u\n      });\n      const g = w(() => gr({\n          top: a.dropup,\n          start: a.dropstart,\n          end: a.dropend,\n          alignCenter: a.center,\n          alignEnd: a.end\n        })),\n        v = x({}),\n        $ = w(() => {\n          if (a.floatingMiddleware !== void 0) return a.floatingMiddleware;\n          const N = typeof a.offset == \"string\" || typeof a.offset == \"number\" ? i.value : a.offset,\n            S = [Xl(N)];\n          return a.noFlip === !1 && S.push(no({\n            boundary: m.value,\n            rootBoundary: y.value,\n            padding: a.boundaryPadding\n          })), a.noShift === !1 && S.push(oo({\n            boundary: m.value,\n            rootBoundary: y.value,\n            padding: a.boundaryPadding\n          })), a.noSize === !1 && S.push(so({\n            boundary: m.value,\n            rootBoundary: y.value,\n            padding: a.boundaryPadding,\n            apply({\n              availableWidth: P,\n              availableHeight: M\n            }) {\n              v.value = {\n                maxHeight: M && s.value ? `${M}px` : void 0,\n                maxWidth: P && s.value ? `${P}px` : void 0\n              };\n            }\n          })), S;\n        }),\n        {\n          update: B,\n          floatingStyles: C\n        } = io(h, u, {\n          placement: g,\n          middleware: $,\n          strategy: k(() => a.strategy),\n          whileElementsMounted: lo\n        }),\n        V = w(() => ({\n          dropup: a.dropup,\n          dropend: a.dropend,\n          dropstart: a.dropstart,\n          \"position-static\": a.boundary !== \"clippingAncestors\" && !a.isNav\n        })),\n        L = w(() => [a.split ? a.splitClass : a.toggleClass, {\n          \"nav-link\": a.isNav,\n          \"dropdown-toggle\": !a.split,\n          \"dropdown-toggle-no-caret\": a.noCaret && !a.split,\n          show: a.split ? void 0 : s.value\n        }]),\n        Q = () => {\n          le();\n        },\n        W = N => {\n          a.split ? o(\"click\", N) : Q();\n        };\n      bo(u, () => {\n        s.value && (a.autoClose === !0 || a.autoClose === \"outside\") && le();\n      }, {\n        ignore: [d, p]\n      });\n      const F = () => {\n          s.value && (a.autoClose === !0 || a.autoClose === \"inside\") && le();\n        },\n        Z = () => {\n          s.value && le();\n        },\n        R = () => {\n          s.value || le();\n        },\n        le = () => {\n          var P;\n          o(\"toggle\");\n          const N = s.value,\n            S = new Bt(N ? \"hide\" : \"show\");\n          if (o(N ? \"hide\" : \"show\", S), S.defaultPrevented) {\n            o(N ? \"hide-prevented\" : \"show-prevented\");\n            return;\n          }\n          s.value = !N, o(N ? \"hidden\" : \"shown\"), (P = f.value) == null || P.dispatchEvent(new Event(\"forceHide\"));\n        };\n      return ue(s, () => {\n        B();\n      }), e({\n        hide: Z,\n        show: R,\n        toggle: le\n      }), at(Oo, {\n        id: r,\n        show: R,\n        hide: Z,\n        toggle: le,\n        visible: k(() => s.value),\n        isNav: k(() => a.isNav)\n      }), (N, S) => (b(), _(\"div\", {\n        ref_key: \"wrapper\",\n        ref: f,\n        class: D([V.value, \"btn-group\"])\n      }, [ve(vt, {\n        id: O(r),\n        ref_key: \"splitButton\",\n        ref: p,\n        variant: N.splitVariant || N.variant,\n        size: N.size,\n        class: D(L.value),\n        disabled: a.splitDisabled || N.disabled,\n        type: N.splitButtonType,\n        \"aria-label\": N.ariaLabel,\n        \"aria-expanded\": a.split ? void 0 : s.value,\n        \"aria-haspopup\": a.split ? void 0 : \"menu\",\n        href: a.split ? N.splitHref : void 0,\n        to: a.split && N.splitTo ? N.splitTo : void 0,\n        onClick: W\n      }, {\n        default: E(() => [T(N.$slots, \"button-content\", {}, () => [ne(Y(N.text), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"variant\", \"size\", \"class\", \"disabled\", \"type\", \"aria-label\", \"aria-expanded\", \"aria-haspopup\", \"href\", \"to\"]), a.split ? (b(), I(vt, {\n        key: 0,\n        ref_key: \"button\",\n        ref: d,\n        variant: N.variant,\n        size: N.size,\n        disabled: N.disabled,\n        class: D([[N.toggleClass, {\n          show: s.value\n        }], \"dropdown-toggle-split dropdown-toggle\"]),\n        \"aria-expanded\": s.value,\n        \"aria-haspopup\": \"menu\",\n        onClick: Q\n      }, {\n        default: E(() => [J(\"span\", Hi, [T(N.$slots, \"toggle-text\", {}, () => [ne(Y(N.toggleText), 1)])])]),\n        _: 3\n      }, 8, [\"variant\", \"size\", \"disabled\", \"class\", \"aria-expanded\"])) : ae(\"\", !0), (b(), I(ht, {\n        to: N.teleportTo,\n        disabled: !N.teleportTo || N.teleportDisabled\n      }, [!a.lazy || s.value ? ut((b(), _(\"ul\", {\n        key: 0,\n        ref_key: \"floating\",\n        ref: u,\n        style: Ee([O(C), v.value]),\n        class: D([\"dropdown-menu overflow-auto\", [N.menuClass, {\n          show: s.value\n        }]]),\n        \"aria-labelledby\": O(r),\n        role: N.role,\n        onClick: F\n      }, [T(N.$slots, \"default\", {\n        hide: Z,\n        show: R\n      })], 14, Ri)), [[xt, a.lazy || s.value]]) : ae(\"\", !0)], 8, [\"to\", \"disabled\"]))], 2));\n    }\n  }),\n  Mi = {\n    role: \"presentation\"\n  },\n  xi = /* @__PURE__ */H({\n    __name: \"BDropdownDivider\",\n    props: {\n      tag: {\n        default: \"hr\"\n      }\n    },\n    setup(t) {\n      return (e, l) => (b(), _(\"li\", Mi, [(b(), I(re(e.tag), {\n        class: \"dropdown-divider\",\n        role: \"separator\",\n        \"aria-orientation\": \"horizontal\"\n      }))]));\n    }\n  }),\n  Di = {\n    role: \"presentation\"\n  },\n  ji = /* @__PURE__ */H({\n    __name: \"BDropdownForm\",\n    setup(t) {\n      return (e, l) => (b(), _(\"li\", Di, [J(\"form\", K({\n        class: \"dropdown-item-text\"\n      }, e.$attrs), [T(e.$slots, \"default\")], 16)]));\n    }\n  }),\n  qi = {\n    role: \"presentation\"\n  },\n  Wi = [\"id\", \"aria-describedby\"],\n  Gi = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BDropdownGroup\",\n    props: {\n      ariaDescribedby: {\n        default: void 0\n      },\n      header: {\n        default: void 0\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerTag: {\n        default: \"header\"\n      },\n      headerVariant: {\n        default: null\n      },\n      id: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = k(() => e.id ? `${e.id}_group_dd_header` : void 0),\n        a = k(() => e.headerTag === \"header\" ? void 0 : \"heading\"),\n        o = w(() => [e.headerClass, {\n          [`text-${e.headerVariant}`]: e.headerVariant !== null\n        }]);\n      return (r, s) => (b(), _(\"li\", qi, [(b(), I(re(r.headerTag), {\n        id: l.value,\n        class: D([\"dropdown-header\", o.value]),\n        role: a.value\n      }, {\n        default: E(() => [T(r.$slots, \"header\", {}, () => [ne(Y(r.header), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"class\", \"role\"])), J(\"ul\", K({\n        id: r.id,\n        role: \"group\",\n        class: \"list-unstyled\"\n      }, r.$attrs, {\n        \"aria-describedby\": r.ariaDescribedby || l.value\n      }), [T(r.$slots, \"default\")], 16, Wi)]));\n    }\n  }),\n  Ui = {\n    class: \"dropdown-header\"\n  },\n  Ki = /* @__PURE__ */H({\n    __name: \"BDropdownHeader\",\n    setup(t) {\n      return (e, l) => (b(), _(\"li\", null, [J(\"h6\", Ui, [T(e.$slots, \"default\")])]));\n    }\n  }),\n  Xi = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BDropdownItem\",\n    props: {\n      linkClass: {\n        default: void 0\n      },\n      wrapperAttrs: {\n        default: void 0\n      },\n      active: {\n        type: Boolean,\n        default: void 0\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: Boolean,\n        default: void 0\n      },\n      disabled: {\n        type: Boolean,\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: Boolean,\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: Boolean,\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      },\n      variant: {\n        default: null\n      }\n    },\n    emits: [\"click\"],\n    setup(t, {\n      emit: e\n    }) {\n      const l = t,\n        a = e,\n        {\n          class: o,\n          ...r\n        } = Mt(),\n        {\n          computedLink: s,\n          computedLinkProps: n\n        } = wt(l),\n        i = w(() => [l.linkClass, {\n          active: l.active,\n          disabled: l.disabled,\n          [`text-${l.variant}`]: l.variant !== null\n        }]),\n        u = k(() => s.value ? ot : l.href ? \"a\" : \"button\"),\n        d = _e(Xa, null),\n        p = _e(Oo, null),\n        f = _e(Ya, null),\n        m = y => {\n          var h, c, g;\n          a(\"click\", y), f !== null && ((h = f == null ? void 0 : f.autoClose) == null ? void 0 : h.value) === !0 && ((c = d == null ? void 0 : d.hide) == null || c.call(d)), (g = p == null ? void 0 : p.hide) == null || g.call(p);\n        };\n      return (y, h) => (b(), _(\"li\", K({\n        role: \"presentation\",\n        class: O(o)\n      }, y.wrapperAttrs), [(b(), I(re(u.value), K({\n        class: [\"dropdown-item\", i.value],\n        disabled: l.disabled,\n        \"aria-disabled\": l.disabled ? !0 : null,\n        \"aria-current\": l.active ? !0 : null,\n        href: u.value === \"a\" ? y.href : null,\n        rel: y.rel,\n        role: \"menuitem\",\n        type: u.value === \"button\" ? \"button\" : null,\n        target: y.target\n      }, {\n        ...O(n),\n        ...r\n      }, {\n        onClick: m\n      }), {\n        default: E(() => [T(y.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\", \"disabled\", \"aria-disabled\", \"aria-current\", \"href\", \"rel\", \"type\", \"target\"]))], 16));\n    }\n  }),\n  Yi = {\n    role: \"presentation\"\n  },\n  Zi = [\"disabled\"],\n  Ji = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BDropdownItemButton\",\n    props: {\n      active: {\n        type: Boolean,\n        default: !1\n      },\n      activeClass: {\n        default: \"active\"\n      },\n      buttonClass: {\n        default: void 0\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      variant: {\n        default: null\n      }\n    },\n    emits: [\"click\"],\n    setup(t, {\n      emit: e\n    }) {\n      const l = t,\n        a = e,\n        o = w(() => [l.buttonClass, {\n          [l.activeClass]: l.active,\n          disabled: l.disabled,\n          [`text-${l.variant}`]: l.variant !== null\n        }]),\n        r = s => {\n          a(\"click\", s);\n        };\n      return (s, n) => (b(), _(\"li\", Yi, [J(\"button\", {\n        role: \"menu\",\n        type: \"button\",\n        class: D([\"dropdown-item\", o.value]),\n        disabled: l.disabled,\n        onClick: r\n      }, [T(s.$slots, \"default\")], 10, Zi)]));\n    }\n  }),\n  Qi = {\n    role: \"presentation\"\n  },\n  eu = /* @__PURE__ */H({\n    __name: \"BDropdownText\",\n    props: {\n      text: {\n        default: \"\"\n      }\n    },\n    setup(t) {\n      return (e, l) => (b(), _(\"li\", Qi, [J(\"span\", K({\n        class: \"dropdown-item-text\"\n      }, e.$attrs), [T(e.$slots, \"default\", {}, () => [ne(Y(e.text), 1)])], 16)]));\n    }\n  }),\n  tu = [\"id\", \"novalidate\"],\n  dn = /* @__PURE__ */H({\n    __name: \"BForm\",\n    props: {\n      floating: {\n        type: Boolean,\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      novalidate: {\n        type: Boolean,\n        default: !1\n      },\n      validated: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    emits: [\"submit\"],\n    setup(t, {\n      expose: e,\n      emit: l\n    }) {\n      const a = t,\n        o = l,\n        r = x(null),\n        s = w(() => ({\n          \"form-floating\": a.floating,\n          \"was-validated\": a.validated\n        })),\n        n = i => {\n          o(\"submit\", i);\n        };\n      return e({\n        element: r\n      }), (i, u) => (b(), _(\"form\", {\n        id: i.id,\n        ref_key: \"element\",\n        ref: r,\n        novalidate: a.novalidate,\n        class: D(s.value),\n        onSubmit: ft(n, [\"prevent\"])\n      }, [T(i.$slots, \"default\")], 42, tu));\n    }\n  }),\n  au = {\n    class: \"form-floating\"\n  },\n  lu = [\"for\"],\n  ou = /* @__PURE__ */H({\n    __name: \"BFormFloatingLabel\",\n    props: {\n      label: {\n        default: void 0\n      },\n      labelFor: {\n        default: void 0\n      },\n      text: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      return (e, l) => (b(), _(\"div\", au, [T(e.$slots, \"default\", {}, () => [ne(Y(e.text), 1)]), J(\"label\", {\n        for: e.labelFor\n      }, [T(e.$slots, \"label\", {}, () => [ne(Y(e.label), 1)])], 8, lu)]));\n    }\n  }),\n  Va = /* @__PURE__ */H({\n    __name: \"BFormInvalidFeedback\",\n    props: {\n      ariaLive: {\n        default: void 0\n      },\n      forceShow: {\n        type: Boolean,\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      role: {\n        default: void 0\n      },\n      state: {\n        type: [Boolean, null],\n        default: null\n      },\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      },\n      tooltip: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = k(() => e.forceShow === !0 || e.state === !1),\n        a = w(() => ({\n          \"d-block\": l.value,\n          \"invalid-feedback\": !e.tooltip,\n          \"invalid-tooltip\": e.tooltip\n        }));\n      return (o, r) => (b(), I(re(o.tag), {\n        id: o.id,\n        role: o.role,\n        \"aria-live\": o.ariaLive,\n        \"aria-atomic\": o.ariaLive ? !0 : void 0,\n        class: D(a.value)\n      }, {\n        default: E(() => [T(o.$slots, \"default\", {}, () => [ne(Y(o.text), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"role\", \"aria-live\", \"aria-atomic\", \"class\"]));\n    }\n  }),\n  Qt = /* @__PURE__ */H({\n    __name: \"BFormRow\",\n    props: {\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(t) {\n      return (e, l) => (b(), I(re(e.tag), {\n        class: \"row d-flex flex-wrap\"\n      }, {\n        default: E(() => [T(e.$slots, \"default\")]),\n        _: 3\n      }));\n    }\n  }),\n  Aa = /* @__PURE__ */H({\n    __name: \"BFormText\",\n    props: {\n      id: {\n        default: void 0\n      },\n      inline: {\n        type: Boolean,\n        default: !1\n      },\n      tag: {\n        default: \"small\"\n      },\n      text: {\n        default: void 0\n      },\n      textVariant: {\n        default: \"body-secondary\"\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => ({\n          [`text-${e.textVariant}`]: e.textVariant !== null,\n          \"form-text\": !e.inline\n        }));\n      return (a, o) => (b(), I(re(a.tag), {\n        id: a.id,\n        class: D(l.value)\n      }, {\n        default: E(() => [T(a.$slots, \"default\", {}, () => [ne(Y(a.text), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"class\"]));\n    }\n  }),\n  Oa = /* @__PURE__ */H({\n    __name: \"BFormValidFeedback\",\n    props: {\n      ariaLive: {\n        default: void 0\n      },\n      forceShow: {\n        type: Boolean,\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      role: {\n        default: void 0\n      },\n      state: {\n        type: [Boolean, null],\n        default: null\n      },\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      },\n      tooltip: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = k(() => e.forceShow === !0 || e.state === !0),\n        a = w(() => ({\n          \"d-block\": l.value,\n          \"valid-feedback\": !e.tooltip,\n          \"valid-tooltip\": e.tooltip\n        }));\n      return (o, r) => (b(), I(re(o.tag), {\n        id: o.id,\n        role: o.role,\n        \"aria-live\": o.ariaLive,\n        \"aria-atomic\": o.ariaLive ? !0 : void 0,\n        class: D(a.value)\n      }, {\n        default: E(() => [T(o.$slots, \"default\", {}, () => [ne(Y(o.text), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"role\", \"aria-live\", \"aria-atomic\", \"class\"]));\n    }\n  }),\n  cn = H({\n    name: \"ComponentOrEmpty\",\n    slots: Object,\n    props: {\n      tag: {\n        type: String,\n        default: \"div\"\n      },\n      to: {\n        type: [String, Object],\n        default: null\n      },\n      skip: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    setup(t, {\n      slots: e,\n      attrs: l\n    }) {\n      return () => {\n        var a, o, r;\n        return t.skip ? (a = e.default) == null ? void 0 : a.call(e) : t.tag === \"Teleport\" ? Ne(ht, {\n          to: t.to\n        }, [(o = e.default) == null ? void 0 : o.call(e)]) : Ne(t.tag, {\n          ...l\n        }, [(r = e.default) == null ? void 0 : r.call(e)]);\n      };\n    }\n  }),\n  nu = [\"id\", \"disabled\", \"required\", \"name\", \"form\", \"aria-label\", \"aria-labelledby\", \"aria-required\", \"value\", \"true-value\", \"false-value\", \"indeterminate\"],\n  su = [\"for\"],\n  fn = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BFormCheckbox\",\n    props: /* @__PURE__ */pe({\n      ariaLabel: {\n        default: void 0\n      },\n      ariaLabelledby: {\n        default: void 0\n      },\n      autofocus: {\n        type: Boolean,\n        default: !1\n      },\n      button: {\n        type: Boolean,\n        default: !1\n      },\n      buttonGroup: {\n        type: Boolean,\n        default: !1\n      },\n      buttonVariant: {\n        default: null\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      indeterminate: {\n        type: Boolean\n      },\n      inline: {\n        type: Boolean,\n        default: !1\n      },\n      modelValue: {\n        type: [Array, Set, String, Boolean, Object, Number, null]\n      },\n      name: {\n        default: void 0\n      },\n      plain: {\n        type: Boolean,\n        default: !1\n      },\n      required: {\n        type: Boolean,\n        default: void 0\n      },\n      reverse: {\n        type: Boolean,\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [Boolean, null],\n        default: null\n      },\n      switch: {\n        type: Boolean,\n        default: !1\n      },\n      uncheckedValue: {\n        type: [Array, Set, String, Boolean, Object, Number, null],\n        default: !1\n      },\n      value: {\n        type: [String, Boolean, Array, Set, Object, Number, null],\n        default: !0\n      }\n    }, {\n      modelValue: {\n        type: [Array, Set, String, Boolean, Object, Number, null],\n        default: void 0\n      },\n      modelModifiers: {},\n      indeterminate: {\n        type: Boolean,\n        default: !1\n      },\n      indeterminateModifiers: {}\n    }),\n    emits: [\"update:modelValue\", \"update:indeterminate\"],\n    setup(t, {\n      expose: e\n    }) {\n      const l = t,\n        a = Le(),\n        o = he(t, \"modelValue\"),\n        r = he(t, \"indeterminate\"),\n        s = Be(() => l.id, \"form-check\"),\n        n = _e(Vo, null),\n        i = x(null),\n        {\n          focused: u\n        } = Pe(i, {\n          initialValue: l.autofocus\n        }),\n        d = k(() => !Ae(a.default)),\n        p = w({\n          get: () => (n == null ? void 0 : n.modelValue.value) ?? o.value,\n          set: v => {\n            if (v !== void 0) {\n              if (r.value = !1, n !== null && Array.isArray(v)) {\n                n.modelValue.value = v;\n                return;\n              }\n              o.value = v;\n            }\n          }\n        }),\n        f = k(() => !!(l.name ?? (n == null ? void 0 : n.name.value)) && (l.required || (n == null ? void 0 : n.required.value))),\n        m = k(() => l.buttonGroup || ((n == null ? void 0 : n.buttons.value) ?? !1)),\n        y = w(() => ({\n          plain: l.plain || ((n == null ? void 0 : n.plain.value) ?? !1),\n          button: l.button || ((n == null ? void 0 : n.buttons.value) ?? !1),\n          inline: l.inline || ((n == null ? void 0 : n.inline.value) ?? !1),\n          reverse: l.reverse || ((n == null ? void 0 : n.reverse.value) ?? !1),\n          switch: l.switch || ((n == null ? void 0 : n.switch.value) ?? !1),\n          state: l.state || (n == null ? void 0 : n.state.value),\n          size: l.size ?? (n == null ? void 0 : n.size.value) ?? \"md\",\n          // This is where the true default is made\n          buttonVariant: l.buttonVariant ?? (n == null ? void 0 : n.buttonVariant.value) ?? \"secondary\",\n          // This is where the true default is made\n          hasDefaultSlot: d.value\n        })),\n        h = Ro(y),\n        c = Mo(y),\n        g = xo(y);\n      return e({\n        blur: () => {\n          u.value = !1;\n        },\n        element: i,\n        focus: () => {\n          u.value = !0;\n        }\n      }), (v, $) => (b(), I(cn, {\n        skip: m.value,\n        class: D(O(h))\n      }, {\n        default: E(() => {\n          var B, C, V;\n          return [ut(J(\"input\", K({\n            id: O(s)\n          }, v.$attrs, {\n            ref_key: \"input\",\n            ref: i,\n            \"onUpdate:modelValue\": $[0] || ($[0] = L => p.value = L),\n            class: O(c),\n            type: \"checkbox\",\n            disabled: l.disabled || ((B = O(n)) == null ? void 0 : B.disabled.value),\n            required: f.value || void 0,\n            name: v.name || ((C = O(n)) == null ? void 0 : C.name.value),\n            form: v.form || ((V = O(n)) == null ? void 0 : V.form.value),\n            \"aria-label\": v.ariaLabel,\n            \"aria-labelledby\": v.ariaLabelledby,\n            \"aria-required\": f.value || void 0,\n            value: v.value,\n            \"true-value\": v.value,\n            \"false-value\": v.uncheckedValue,\n            indeterminate: l.indeterminate\n          }), null, 16, nu), [[On, p.value]]), d.value || l.plain === !1 ? (b(), _(\"label\", {\n            key: 0,\n            for: O(s),\n            class: D(O(g))\n          }, [T(v.$slots, \"default\")], 10, su)) : ae(\"\", !0)];\n        }),\n        _: 3\n      }, 8, [\"skip\", \"class\"]));\n    }\n  }),\n  ru = [\"id\"],\n  iu = [\"innerHTML\"],\n  uu = /* @__PURE__ */H({\n    __name: \"BFormCheckboxGroup\",\n    props: /* @__PURE__ */pe({\n      ariaInvalid: {\n        type: [Boolean, String],\n        default: void 0\n      },\n      autofocus: {\n        type: Boolean,\n        default: !1\n      },\n      buttonVariant: {\n        default: \"secondary\"\n      },\n      buttons: {\n        type: Boolean,\n        default: !1\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      disabledField: {\n        default: \"disabled\"\n      },\n      form: {\n        default: void 0\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      id: {\n        default: void 0\n      },\n      modelValue: {},\n      name: {\n        default: void 0\n      },\n      options: {\n        default: () => []\n      },\n      plain: {\n        type: Boolean,\n        default: !1\n      },\n      required: {\n        type: Boolean,\n        default: !1\n      },\n      reverse: {\n        type: Boolean,\n        default: !1\n      },\n      size: {\n        default: \"md\"\n      },\n      stacked: {\n        type: Boolean,\n        default: !1\n      },\n      state: {\n        type: [Boolean, null],\n        default: null\n      },\n      switches: {\n        type: Boolean,\n        default: !1\n      },\n      textField: {\n        default: \"text\"\n      },\n      validated: {\n        type: Boolean,\n        default: !1\n      },\n      valueField: {\n        default: \"value\"\n      }\n    }, {\n      modelValue: {\n        default: () => []\n      },\n      modelModifiers: {}\n    }),\n    emits: [\"update:modelValue\"],\n    setup(t, {\n      expose: e\n    }) {\n      const l = t,\n        a = he(t, \"modelValue\"),\n        o = Be(() => l.id, \"checkbox\"),\n        r = Be(() => l.name, \"checkbox\"),\n        s = x(null),\n        {\n          focused: n\n        } = Pe(s, {\n          initialValue: l.autofocus\n        });\n      at(Vo, {\n        modelValue: a,\n        switch: k(() => l.switches),\n        buttonVariant: k(() => l.buttonVariant),\n        form: k(() => l.form),\n        name: r,\n        state: k(() => l.state),\n        plain: k(() => l.plain),\n        size: k(() => l.size),\n        inline: k(() => !l.stacked),\n        reverse: k(() => l.reverse),\n        required: k(() => l.required),\n        buttons: k(() => l.buttons),\n        disabled: k(() => l.disabled)\n      });\n      const i = w(() => l.options.map((f, m) => typeof f == \"string\" || typeof f == \"number\" ? {\n          props: {\n            value: f,\n            disabled: l.disabled\n          },\n          text: f.toString(),\n          html: void 0,\n          self: Symbol(`checkboxGroupOptionItem${m}`)\n        } : {\n          props: {\n            value: f[l.valueField],\n            disabled: f[l.disabledField],\n            ...(f.props ? f.props : {})\n          },\n          text: f[l.textField],\n          html: f[l.htmlField],\n          self: Symbol(`checkboxGroupOptionItem${m}`)\n        })),\n        u = w(() => ({\n          required: l.required,\n          ariaInvalid: l.ariaInvalid,\n          state: l.state,\n          validated: l.validated,\n          buttons: l.buttons,\n          stacked: l.stacked,\n          size: l.size\n        })),\n        d = Do(u),\n        p = jo(u);\n      return e({\n        blur: () => {\n          n.value = !1;\n        },\n        focus: () => {\n          n.value = !0;\n        }\n      }), (f, m) => (b(), _(\"div\", K(O(d), {\n        id: O(o),\n        ref_key: \"element\",\n        ref: s,\n        role: \"group\",\n        class: [O(p), \"bv-no-focus-ring\"],\n        tabindex: \"-1\"\n      }), [T(f.$slots, \"first\"), (b(!0), _(de, null, Ce(i.value, y => (b(), I(fn, K({\n        key: y.self,\n        ref_for: !0\n      }, y.props), {\n        default: E(() => [y.html ? (b(), _(\"span\", {\n          key: 0,\n          innerHTML: y.html\n        }, null, 8, iu)) : (b(), _(de, {\n          key: 1\n        }, [ne(Y(y.text), 1)], 64))]),\n        _: 2\n      }, 1040))), 128)), T(f.$slots, \"default\")], 16, ru));\n    }\n  }),\n  du = [\"for\"],\n  cu = [\"for\"],\n  fu = {\n    class: \"input-group form-input-file\"\n  },\n  vu = [\"id\", \"form\", \"name\", \"multiple\", \"disabled\", \"capture\", \"accept\", \"required\", \"aria-label\", \"aria-labelledby\", \"aria-required\", \"directory\", \"webkitdirectory\"],\n  pu = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BFormFile\",\n    props: /* @__PURE__ */pe({\n      ariaLabel: {\n        default: void 0\n      },\n      ariaLabelledby: {\n        default: void 0\n      },\n      accept: {\n        default: \"\"\n      },\n      autofocus: {\n        type: Boolean,\n        default: !1\n      },\n      browserText: {\n        default: \"Choose\"\n      },\n      capture: {\n        type: [Boolean, String],\n        default: !1\n      },\n      directory: {\n        type: Boolean,\n        default: !1\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      label: {\n        default: \"\"\n      },\n      labelClass: {\n        default: void 0\n      },\n      modelValue: {},\n      multiple: {\n        type: Boolean,\n        default: !1\n      },\n      name: {\n        default: void 0\n      },\n      noDrop: {\n        type: Boolean,\n        default: !1\n      },\n      noTraverse: {\n        type: Boolean,\n        default: !1\n      },\n      placement: {\n        default: \"start\"\n      },\n      required: {\n        type: Boolean,\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [Boolean, null],\n        default: null\n      }\n    }, {\n      modelValue: {\n        default: null\n      },\n      modelModifiers: {}\n    }),\n    emits: [\"update:modelValue\"],\n    setup(t, {\n      expose: e\n    }) {\n      const l = Le(),\n        a = t,\n        o = he(t, \"modelValue\"),\n        r = Be(() => a.id),\n        s = Ct(() => a.state),\n        n = x(null),\n        {\n          focused: i\n        } = Pe(n, {\n          initialValue: a.autofocus\n        }),\n        u = k(() => !Ae(l.label)),\n        d = k(() => typeof a.accept == \"string\" ? a.accept : a.accept.join(\",\")),\n        p = w(() => [s.value, {\n          [`form-control-${a.size}`]: a.size !== void 0\n        }]),\n        f = () => {\n          var v, $;\n          const g = ((v = n.value) == null ? void 0 : v.files) === null || (($ = n.value) == null ? void 0 : $.files) === void 0 ? null : [...n.value.files];\n          o.value = g === null ? null : a.multiple === !0 ? g : g[0];\n        },\n        m = g => {\n          a.noDrop === !0 && g.preventDefault();\n        },\n        y = () => {\n          o.value = null;\n        };\n      ue(o, g => {\n        g === null && n.value !== null && (n.value.value = \"\");\n      }), e({\n        blur: () => {\n          i.value = !1;\n        },\n        element: n,\n        focus: () => {\n          i.value = !0;\n        },\n        reset: y\n      });\n      const [h, c] = zt();\n      return (g, v) => (b(), _(de, null, [ve(O(h), null, {\n        default: E(() => [J(\"label\", {\n          class: \"input-group-text\",\n          for: O(r)\n        }, Y(g.browserText), 9, du)]),\n        _: 1\n      }), u.value || g.label ? (b(), _(\"label\", {\n        key: 0,\n        class: D([\"form-label\", g.labelClass]),\n        for: O(r)\n      }, [T(g.$slots, \"label\", {}, () => [ne(Y(g.label), 1)], !0)], 10, cu)) : ae(\"\", !0), J(\"div\", fu, [g.placement === \"start\" ? (b(), I(O(c), {\n        key: 0\n      })) : ae(\"\", !0), J(\"input\", K({\n        id: O(r)\n      }, g.$attrs, {\n        ref_key: \"input\",\n        ref: n,\n        type: \"file\",\n        class: [\"form-control\", p.value],\n        form: g.form,\n        name: g.name,\n        multiple: a.multiple,\n        disabled: a.disabled,\n        capture: a.capture,\n        accept: d.value || void 0,\n        required: a.required || void 0,\n        \"aria-label\": g.ariaLabel,\n        \"aria-labelledby\": g.ariaLabelledby,\n        \"aria-required\": a.required || void 0,\n        directory: a.directory,\n        webkitdirectory: a.directory,\n        onChange: f,\n        onDrop: m\n      }), null, 16, vu), g.placement === \"end\" ? (b(), I(O(c), {\n        key: 1\n      })) : ae(\"\", !0)])], 64));\n    }\n  }),\n  mu = /* @__PURE__ */qt(pu, [[\"__scopeId\", \"data-v-1eb930f5\"]]),\n  vn = [\"input\", \"select\", \"textarea\"],\n  bu = vn.map(t => `${t}:not([disabled])`).join(),\n  yu = [...vn, \"a\", \"button\", \"label\"],\n  gu = \"label\",\n  hu = \"invalid-feedback\",\n  Bu = \"valid-feedback\",\n  wu = \"description\",\n  Cu = \"default\",\n  ku = H({\n    components: {\n      BCol: Ft,\n      BFormInvalidFeedback: Va,\n      BFormRow: Qt,\n      BFormText: Aa,\n      BFormValidFeedback: Oa\n    },\n    props: {\n      ariaInvalid: {\n        type: [Boolean, String],\n        default: void 0\n      },\n      contentCols: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      contentColsLg: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      contentColsMd: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      contentColsSm: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      contentColsXl: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      description: {\n        type: [String],\n        default: void 0\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      feedbackAriaLive: {\n        type: String,\n        default: \"assertive\"\n      },\n      id: {\n        type: String,\n        default: void 0\n      },\n      invalidFeedback: {\n        type: String,\n        default: void 0\n      },\n      label: {\n        type: String,\n        default: void 0\n      },\n      labelAlign: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelAlignLg: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelAlignMd: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelAlignSm: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelAlignXl: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelClass: {\n        type: [Array, Object, String],\n        default: void 0\n      },\n      labelCols: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelColsLg: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelColsMd: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelColsSm: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelColsXl: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelFor: {\n        type: String,\n        default: void 0\n      },\n      labelSize: {\n        type: String,\n        default: void 0\n      },\n      labelSrOnly: {\n        type: Boolean,\n        default: !1\n      },\n      state: {\n        type: Boolean,\n        default: null\n      },\n      tooltip: {\n        type: Boolean,\n        default: !1\n      },\n      validFeedback: {\n        type: String,\n        default: void 0\n      },\n      validated: {\n        type: Boolean,\n        default: !1\n      },\n      floating: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    setup(t) {\n      const l = [\"xs\", \"sm\", \"md\", \"lg\", \"xl\"],\n        a = (y, h) => l.reduce((c, g) => {\n          const v = wl(g === \"xs\" ? \"\" : g, `${h}Align`),\n            $ = y[v] || null;\n          return $ && (g === \"xs\" ? c.push(`text-${$}`) : c.push(`text-${g}-${$}`)), c;\n        }, []),\n        o = (y, h) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        l.reduce((c, g) => {\n          const v = wl(g === \"xs\" ? \"\" : g, `${h}Cols`);\n          let $ = y[v];\n          if ($ = $ === \"\" ? !0 : $ || !1, typeof $ != \"boolean\" && $ !== \"auto\") {\n            const B = Number.parseInt($);\n            $ = Number.isNaN(B) ? 0 : B, $ = $ > 0 ? $ : !1;\n          }\n          return $ && (g === \"xs\" ? c[typeof $ == \"boolean\" ? \"col\" : \"cols\"] = $ : c[g || (typeof $ == \"boolean\" ? \"col\" : \"cols\")] = $), c;\n        }, {}),\n        r = x(null),\n        s = (y, h = null) => {\n          if (za && t.labelFor && r.value !== null) {\n            const c = r.value.querySelector(`#${CSS.escape(t.labelFor)}`);\n            if (c) {\n              const g = \"aria-describedby\",\n                v = (y || \"\").split(Zt),\n                $ = (h || \"\").split(Zt),\n                B = (c.getAttribute(g) || \"\").split(Zt).filter(C => !$.includes(C)).concat(v).filter((C, V, L) => L.indexOf(C) === V).filter(C => C).join(\" \").trim();\n              B ? c.setAttribute(g, B) : c.removeAttribute(g);\n            }\n          }\n        },\n        n = w(() => o(t, \"content\")),\n        i = w(() => a(t, \"label\")),\n        u = w(() => o(t, \"label\")),\n        d = w(() =>\n        // Determine if the form group will be rendered horizontal\n        // based on the existence of 'content-col' or 'label-col' props\n        Object.keys(n.value).length > 0 || Object.keys(u.value).length > 0),\n        p = Ct(() => t.state),\n        f = ua(() => t.ariaInvalid, () => t.state);\n      return ue(() => null, (y, h) => {\n        y !== h && s(y, h);\n      }), Xe(() => {\n        Ve(() => {\n          s(null);\n        });\n      }), {\n        ariaDescribedby: null,\n        computedAriaInvalid: f,\n        contentColProps: n,\n        isHorizontal: d,\n        labelAlignClasses: i,\n        labelColProps: u,\n        onLegendClick: y => {\n          if (t.labelFor || r.value === null) return;\n          const {\n              target: h\n            } = y,\n            c = h ? h.tagName : \"\";\n          if (yu.indexOf(c) !== -1) return;\n          const g = [...r.value.querySelectorAll(bu)].filter(Fn),\n            [v] = g;\n          g.length === 1 && v instanceof HTMLElement && En(v);\n        },\n        stateClass: p\n      };\n    },\n    render() {\n      const t = this.$props,\n        e = this.$slots,\n        l = Be(),\n        a = !t.labelFor;\n      let o = null;\n      const r = Et(gu, {}, e) || t.label,\n        s = r ? Be(void 0, \"_BV_label_\").value : null;\n      if (r || this.isHorizontal) {\n        const B = a ? \"legend\" : \"label\";\n        if (t.labelSrOnly) r && (o = Ne(B, {\n          class: \"visually-hidden\",\n          id: s,\n          for: t.labelFor || null\n        }, r)), this.isHorizontal ? o = Ne(Ft, this.labelColProps, {\n          default: () => o\n        }) : o = Ne(\"div\", {}, [o]);else {\n          const C = {\n            onClick: a ? this.onLegendClick : null,\n            ...(this.isHorizontal ? this.labelColProps : {}),\n            tag: this.isHorizontal ? B : null,\n            id: s,\n            for: t.labelFor || null,\n            tabIndex: a ? \"-1\" : null,\n            class: [this.isHorizontal ? \"col-form-label\" : \"form-label\", {\n              \"bv-no-focus-ring\": a,\n              \"col-form-label\": this.isHorizontal || a,\n              \"pt-0\": !this.isHorizontal && a,\n              \"d-block\": !this.isHorizontal && !a,\n              [`col-form-label-${t.labelSize}`]: !!t.labelSize\n            }, this.labelAlignClasses, t.labelClass]\n          };\n          this.isHorizontal ? o = Ne(Ft, C, {\n            default: () => r\n          }) : o = Ne(B, C, r);\n        }\n      }\n      let n = null;\n      const i = Et(hu, {}, e) || this.invalidFeedback,\n        u = i ? Be(void 0, \"_BV_feedback_invalid_\").value : void 0;\n      i && (n = Ne(Va, {\n        ariaLive: t.feedbackAriaLive,\n        id: u,\n        state: t.state,\n        tooltip: t.tooltip\n      }, {\n        default: () => i\n      }));\n      let d = null;\n      const p = Et(Bu, {}, e) || this.validFeedback,\n        f = p ? Be(void 0, \"_BV_feedback_valid_\").value : void 0;\n      p && (d = Ne(Oa, {\n        ariaLive: t.feedbackAriaLive,\n        id: f,\n        state: t.state,\n        tooltip: t.tooltip\n      }, {\n        default: () => p\n      }\n      // validFeedbackContent\n      ));\n      let m = null;\n      const y = Et(wu, {}, e) || this.description,\n        h = y ? Be(void 0, \"_BV_description_\").value : void 0;\n      y && (m = Ne(Aa, {\n        id: h\n      }, {\n        default: () => y\n      }));\n      const c = this.ariaDescribedby = [h, t.state === !1 ? u : null, t.state === !0 ? f : null].filter(B => B).join(\" \") || null,\n        g = [Et(Cu, {\n          ariaDescribedby: c,\n          descriptionId: h,\n          id: l,\n          labelId: s\n        }, e) || \"\", n, d, m];\n      !this.isHorizontal && t.floating && g.push(o);\n      let v = Ne(\"div\", {\n        ref: \"content\",\n        class: [{\n          \"form-floating\": !this.isHorizontal && t.floating\n        }]\n      }, g);\n      this.isHorizontal && (v = Ne(Ft, {\n        ref: \"content\",\n        ...this.contentColProps\n      }, {\n        default: () => g\n      }));\n      const $ = {\n        class: [this.stateClass, {\n          \"was-validated\": t.validated\n        }],\n        id: Be(() => t.id).value,\n        disabled: a ? t.disabled : null,\n        role: a ? null : \"group\",\n        \"aria-invalid\": this.computedAriaInvalid,\n        // Only apply `aria-labelledby` if we are a horizontal fieldset\n        // as the legend is no longer a direct child of fieldset\n        \"aria-labelledby\": a && this.isHorizontal ? s : null\n      };\n      return this.isHorizontal && !a ? Ne(Qt, $, {\n        default: () => [o, v]\n      }) : Ne(a ? \"fieldset\" : \"div\", $, this.isHorizontal && a ? [Ne(Qt, null, {\n        default: () => [o, v]\n      })] : this.isHorizontal || !t.floating ? [o, v] : [v]);\n    }\n  }),\n  $u = [\"id\", \"value\", \"name\", \"form\", \"type\", \"disabled\", \"placeholder\", \"required\", \"autocomplete\", \"readonly\", \"min\", \"max\", \"step\", \"list\", \"aria-required\", \"aria-invalid\"],\n  Tu = /* @__PURE__ */H({\n    __name: \"BFormInput\",\n    props: {\n      max: {\n        default: void 0\n      },\n      min: {\n        default: void 0\n      },\n      step: {\n        default: void 0\n      },\n      type: {\n        default: \"text\"\n      },\n      ariaInvalid: {\n        type: [Boolean, String],\n        default: void 0\n      },\n      autocomplete: {\n        default: void 0\n      },\n      autofocus: {\n        type: Boolean,\n        default: !1\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      formatter: {\n        type: Function,\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      lazy: {\n        type: Boolean,\n        default: !1\n      },\n      lazyFormatter: {\n        type: Boolean,\n        default: !1\n      },\n      list: {\n        default: void 0\n      },\n      modelValue: {\n        default: \"\"\n      },\n      name: {\n        default: void 0\n      },\n      number: {\n        type: Boolean,\n        default: !1\n      },\n      placeholder: {\n        default: void 0\n      },\n      plaintext: {\n        type: Boolean,\n        default: !1\n      },\n      readonly: {\n        type: Boolean,\n        default: !1\n      },\n      required: {\n        type: Boolean,\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [Boolean, null],\n        default: null\n      },\n      trim: {\n        type: Boolean,\n        default: !1\n      },\n      debounce: {\n        default: 0\n      },\n      debounceMaxWait: {\n        default: NaN\n      }\n    },\n    emits: [\"update:modelValue\"],\n    setup(t, {\n      expose: e,\n      emit: l\n    }) {\n      const a = t,\n        o = l,\n        {\n          input: r,\n          computedId: s,\n          computedAriaInvalid: n,\n          onInput: i,\n          onChange: u,\n          onBlur: d,\n          focus: p,\n          blur: f\n        } = qo(a, o),\n        m = Ct(() => a.state),\n        y = x(!1),\n        h = w(() => {\n          const c = a.type === \"range\",\n            g = a.type === \"color\";\n          return [m.value, {\n            \"form-control-highlighted\": y.value,\n            \"form-range\": c,\n            \"form-control\": g || !a.plaintext && !c,\n            \"form-control-color\": g,\n            \"form-control-plaintext\": a.plaintext && !c && !g,\n            [`form-control-${a.size}`]: !!a.size\n          }];\n        });\n      return e({\n        blur: f,\n        element: r,\n        focus: p\n      }), (c, g) => (b(), _(\"input\", {\n        id: O(s),\n        ref_key: \"input\",\n        ref: r,\n        value: c.modelValue,\n        class: D(h.value),\n        name: c.name || void 0,\n        form: c.form || void 0,\n        type: c.type,\n        disabled: a.disabled,\n        placeholder: c.placeholder,\n        required: a.required || void 0,\n        autocomplete: c.autocomplete || void 0,\n        readonly: a.readonly || a.plaintext,\n        min: c.min,\n        max: c.max,\n        step: c.step,\n        list: c.type !== \"password\" ? c.list : void 0,\n        \"aria-required\": a.required || void 0,\n        \"aria-invalid\": O(n),\n        onInput: g[0] || (g[0] = v => O(i)(v)),\n        onChange: g[1] || (g[1] = v => O(u)(v)),\n        onBlur: g[2] || (g[2] = v => O(d)(v))\n      }, null, 42, $u));\n    }\n  }),\n  Su = [\"id\", \"disabled\", \"required\", \"name\", \"form\", \"aria-label\", \"aria-labelledby\", \"value\", \"aria-required\"],\n  _u = [\"for\"],\n  pn = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BFormRadio\",\n    props: /* @__PURE__ */pe({\n      ariaLabel: {\n        default: void 0\n      },\n      ariaLabelledby: {\n        default: void 0\n      },\n      autofocus: {\n        type: Boolean,\n        default: !1\n      },\n      button: {\n        type: Boolean,\n        default: !1\n      },\n      buttonGroup: {\n        type: Boolean,\n        default: !1\n      },\n      buttonVariant: {\n        default: null\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      inline: {\n        type: Boolean,\n        default: !1\n      },\n      modelValue: {\n        type: [Boolean, String, Array, Object, Number, null]\n      },\n      name: {\n        default: void 0\n      },\n      plain: {\n        type: Boolean,\n        default: !1\n      },\n      required: {\n        type: Boolean,\n        default: !1\n      },\n      reverse: {\n        type: Boolean,\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [Boolean, null],\n        default: null\n      },\n      value: {\n        type: [Boolean, String, Array, Object, Number, null],\n        default: !0\n      }\n    }, {\n      modelValue: {\n        type: [Boolean, String, Array, Object, Number, null],\n        default: void 0\n      },\n      modelModifiers: {}\n    }),\n    emits: [\"update:modelValue\"],\n    setup(t, {\n      expose: e\n    }) {\n      const l = t,\n        a = Le(),\n        o = he(t, \"modelValue\"),\n        r = Be(() => l.id, \"form-check\"),\n        s = _e(Ao, null),\n        n = x(null),\n        {\n          focused: i\n        } = Pe(n, {\n          initialValue: l.autofocus\n        }),\n        u = k(() => !Ae(a.default)),\n        d = w({\n          get: () => (s == null ? void 0 : s.modelValue.value) ?? o.value,\n          set: g => {\n            if (g !== void 0) {\n              if (s !== null) {\n                s.modelValue.value = g;\n                return;\n              }\n              o.value = g;\n            }\n          }\n        }),\n        p = k(() => !!(l.name ?? (s == null ? void 0 : s.name.value)) && (l.required || (s == null ? void 0 : s.required.value))),\n        f = k(() => l.buttonGroup || ((s == null ? void 0 : s.buttons.value) ?? !1)),\n        m = w(() => ({\n          plain: l.plain || ((s == null ? void 0 : s.plain.value) ?? !1),\n          button: l.button || ((s == null ? void 0 : s.buttons.value) ?? !1),\n          inline: l.inline || ((s == null ? void 0 : s.inline.value) ?? !1),\n          state: l.state || (s == null ? void 0 : s.state.value),\n          reverse: l.reverse || ((s == null ? void 0 : s.reverse.value) ?? !1),\n          size: l.size ?? (s == null ? void 0 : s.size.value) ?? \"md\",\n          // This is where the true default is made\n          buttonVariant: l.buttonVariant ?? (s == null ? void 0 : s.buttonVariant.value) ?? \"secondary\",\n          // This is where the true default is made\n          hasDefaultSlot: u.value\n        })),\n        y = Ro(m),\n        h = Mo(m),\n        c = xo(m);\n      return e({\n        blur: () => {\n          i.value = !1;\n        },\n        element: n,\n        focus: () => {\n          i.value = !0;\n        }\n      }), (g, v) => (b(), I(cn, {\n        skip: f.value,\n        class: D(O(y))\n      }, {\n        default: E(() => {\n          var $, B, C;\n          return [ut(J(\"input\", K({\n            id: O(r)\n          }, g.$attrs, {\n            ref_key: \"input\",\n            ref: n,\n            \"onUpdate:modelValue\": v[0] || (v[0] = V => d.value = V),\n            class: O(h),\n            type: \"radio\",\n            disabled: l.disabled || (($ = O(s)) == null ? void 0 : $.disabled.value),\n            required: p.value || void 0,\n            name: g.name || ((B = O(s)) == null ? void 0 : B.name.value),\n            form: g.form || ((C = O(s)) == null ? void 0 : C.form.value),\n            \"aria-label\": g.ariaLabel,\n            \"aria-labelledby\": g.ariaLabelledby,\n            value: g.value,\n            \"aria-required\": p.value || void 0\n          }), null, 16, Su), [[Nn, d.value]]), u.value || l.plain === !1 ? (b(), _(\"label\", {\n            key: 0,\n            for: O(r),\n            class: D(O(c))\n          }, [T(g.$slots, \"default\")], 10, _u)) : ae(\"\", !0)];\n        }),\n        _: 3\n      }, 8, [\"skip\", \"class\"]));\n    }\n  }),\n  Vu = [\"id\"],\n  Au = [\"innerHTML\"],\n  Ou = /* @__PURE__ */H({\n    __name: \"BFormRadioGroup\",\n    props: /* @__PURE__ */pe({\n      ariaInvalid: {\n        type: [Boolean, String],\n        default: void 0\n      },\n      autofocus: {\n        type: Boolean,\n        default: !1\n      },\n      buttonVariant: {\n        default: \"secondary\"\n      },\n      buttons: {\n        type: Boolean,\n        default: !1\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      disabledField: {\n        default: \"disabled\"\n      },\n      form: {\n        default: void 0\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      id: {\n        default: void 0\n      },\n      modelValue: {\n        type: [Boolean, String, Array, Object, Number, null]\n      },\n      name: {\n        default: void 0\n      },\n      options: {\n        default: () => []\n      },\n      plain: {\n        type: Boolean,\n        default: !1\n      },\n      required: {\n        type: Boolean,\n        default: !1\n      },\n      reverse: {\n        type: Boolean,\n        default: !1\n      },\n      size: {\n        default: \"md\"\n      },\n      stacked: {\n        type: Boolean,\n        default: !1\n      },\n      state: {\n        type: [Boolean, null],\n        default: null\n      },\n      textField: {\n        default: \"text\"\n      },\n      validated: {\n        type: Boolean,\n        default: !1\n      },\n      valueField: {\n        default: \"value\"\n      }\n    }, {\n      modelValue: {\n        type: [Boolean, String, Array, Object, Number, null],\n        default: null\n      },\n      modelModifiers: {}\n    }),\n    emits: [\"update:modelValue\"],\n    setup(t, {\n      expose: e\n    }) {\n      const l = t,\n        a = he(t, \"modelValue\"),\n        o = Be(() => l.id, \"radio\"),\n        r = Be(() => l.name, \"checkbox\"),\n        s = x(null),\n        {\n          focused: n\n        } = Pe(s, {\n          initialValue: l.autofocus\n        });\n      at(Ao, {\n        modelValue: a,\n        buttonVariant: k(() => l.buttonVariant),\n        form: k(() => l.form),\n        name: r,\n        buttons: k(() => l.buttons),\n        state: k(() => l.state),\n        plain: k(() => l.plain),\n        size: k(() => l.size),\n        inline: k(() => !l.stacked),\n        reverse: k(() => l.reverse),\n        required: k(() => l.required),\n        disabled: k(() => l.disabled)\n      });\n      const i = w(() => l.options.map((f, m) => typeof f == \"string\" || typeof f == \"number\" ? {\n          value: f,\n          disabled: l.disabled,\n          text: f.toString(),\n          html: void 0,\n          self: Symbol(`radioGroupOptionItem${m}`)\n        } : {\n          value: f[l.valueField],\n          disabled: f[l.disabledField],\n          ...(f.props ? f.props : {}),\n          text: f[l.textField],\n          html: f[l.htmlField],\n          self: Symbol(`radioGroupOptionItem${m}`)\n        })),\n        u = w(() => ({\n          required: l.required,\n          ariaInvalid: l.ariaInvalid,\n          state: l.state,\n          validated: l.validated,\n          buttons: l.buttons,\n          stacked: l.stacked,\n          size: l.size\n        })),\n        d = Do(u),\n        p = jo(u);\n      return e({\n        blur: () => {\n          n.value = !1;\n        },\n        focus: () => {\n          n.value = !0;\n        }\n      }), (f, m) => (b(), _(\"div\", K(O(d), {\n        id: O(o),\n        ref_key: \"element\",\n        ref: s,\n        role: \"radiogroup\",\n        class: [O(p), \"bv-no-focus-ring\"],\n        tabindex: \"-1\"\n      }), [T(f.$slots, \"first\"), (b(!0), _(de, null, Ce(i.value, y => (b(), I(pn, {\n        key: y.self,\n        disabled: y.disabled,\n        value: y.value\n      }, {\n        default: E(() => [y.html ? (b(), _(\"span\", {\n          key: 0,\n          innerHTML: y.html\n        }, null, 8, Au)) : (b(), _(de, {\n          key: 1\n        }, [ne(Y(y.text), 1)], 64))]),\n        _: 2\n      }, 1032, [\"disabled\", \"value\"]))), 128)), T(f.$slots, \"default\")], 16, Vu));\n    }\n  }),\n  Nu = [\"value\", \"disabled\"],\n  al = /* @__PURE__ */H({\n    __name: \"BFormSelectOption\",\n    props: {\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      value: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      const e = t;\n      return (l, a) => (b(), _(\"option\", {\n        value: l.value,\n        disabled: e.disabled\n      }, [T(l.$slots, \"default\")], 8, Nu));\n    }\n  }),\n  Iu = [\"label\"],\n  Pu = [\"innerHTML\"],\n  mn = /* @__PURE__ */H({\n    __name: \"BFormSelectOptionGroup\",\n    props: {\n      disabledField: {\n        default: \"disabled\"\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      label: {\n        default: void 0\n      },\n      options: {\n        default: () => []\n      },\n      textField: {\n        default: \"text\"\n      },\n      valueField: {\n        default: \"value\"\n      }\n    },\n    setup(t) {\n      const e = t,\n        {\n          normalizedOptions: l\n        } = Wo(() => e.options, e),\n        a = w(() => l.value);\n      return (o, r) => (b(), _(\"optgroup\", {\n        label: o.label\n      }, [T(o.$slots, \"first\"), (b(!0), _(de, null, Ce(a.value, (s, n) => (b(), I(al, K({\n        key: n,\n        disabled: s.disabled,\n        value: s.value,\n        ref_for: !0\n      }, o.$attrs), {\n        default: E(() => [s.html ? (b(), _(\"span\", {\n          key: 0,\n          innerHTML: s.html\n        }, null, 8, Pu)) : (b(), _(de, {\n          key: 1\n        }, [ne(Y(s.text), 1)], 64))]),\n        _: 2\n      }, 1040, [\"disabled\", \"value\"]))), 128)), T(o.$slots, \"default\")], 8, Iu));\n    }\n  }),\n  Eu = [\"id\", \"name\", \"form\", \"multiple\", \"size\", \"disabled\", \"required\", \"aria-required\", \"aria-invalid\"],\n  Fu = [\"innerHTML\"],\n  Lu = /* @__PURE__ */H({\n    __name: \"BFormSelect\",\n    props: /* @__PURE__ */pe({\n      ariaInvalid: {\n        type: [Boolean, String],\n        default: void 0\n      },\n      autofocus: {\n        type: Boolean,\n        default: !1\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      disabledField: {\n        default: \"disabled\"\n      },\n      form: {\n        default: void 0\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      id: {\n        default: void 0\n      },\n      labelField: {\n        default: \"label\"\n      },\n      modelValue: {\n        type: [Boolean, String, Array, Object, Number, null]\n      },\n      multiple: {\n        type: Boolean,\n        default: !1\n      },\n      name: {\n        default: void 0\n      },\n      options: {\n        default: () => []\n      },\n      optionsField: {\n        default: \"options\"\n      },\n      plain: {\n        type: Boolean,\n        default: !1\n      },\n      required: {\n        type: Boolean,\n        default: !1\n      },\n      selectSize: {\n        default: 0\n      },\n      size: {\n        default: \"md\"\n      },\n      state: {\n        type: [Boolean, null],\n        default: null\n      },\n      textField: {\n        default: \"text\"\n      },\n      valueField: {\n        default: \"value\"\n      }\n    }, {\n      modelValue: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        default: \"\"\n      },\n      modelModifiers: {}\n    }),\n    emits: [\"update:modelValue\"],\n    setup(t, {\n      expose: e\n    }) {\n      const l = t,\n        a = he(t, \"modelValue\"),\n        o = Be(() => l.id, \"input\"),\n        r = be(() => l.selectSize),\n        s = Ct(() => l.state),\n        n = x(null),\n        {\n          focused: i\n        } = Pe(n, {\n          initialValue: l.autofocus\n        }),\n        u = w(() => [s.value, {\n          \"form-control\": l.plain,\n          [`form-control-${l.size}`]: l.size !== \"md\" && l.plain,\n          \"form-select\": !l.plain,\n          [`form-select-${l.size}`]: l.size !== \"md\" && !l.plain\n        }]),\n        d = k(() => r.value || l.plain ? r.value : void 0),\n        p = ua(() => l.ariaInvalid, () => l.state),\n        {\n          normalizedOptions: f,\n          isComplex: m\n        } = Wo(() => l.options, l),\n        y = w(() => f.value),\n        h = w({\n          get: () => a.value,\n          set: c => {\n            a.value = c;\n          }\n        });\n      return e({\n        blur: () => {\n          i.value = !1;\n        },\n        element: n,\n        focus: () => {\n          i.value = !0;\n        }\n      }), (c, g) => ut((b(), _(\"select\", {\n        id: O(o),\n        ref_key: \"input\",\n        ref: n,\n        \"onUpdate:modelValue\": g[0] || (g[0] = v => h.value = v),\n        class: D(u.value),\n        name: c.name,\n        form: c.form || void 0,\n        multiple: l.multiple || void 0,\n        size: d.value,\n        disabled: l.disabled,\n        required: l.required || void 0,\n        \"aria-required\": l.required || void 0,\n        \"aria-invalid\": O(p)\n      }, [T(c.$slots, \"first\"), (b(!0), _(de, null, Ce(y.value, (v, $) => (b(), _(de, {\n        key: $\n      }, [O(m)(v) ? (b(), I(mn, {\n        key: 0,\n        label: v.label,\n        options: v.options,\n        \"value-field\": c.valueField,\n        \"text-field\": c.textField,\n        \"html-field\": c.htmlField,\n        \"disabled-field\": c.disabledField\n      }, null, 8, [\"label\", \"options\", \"value-field\", \"text-field\", \"html-field\", \"disabled-field\"])) : (b(), I(al, {\n        key: 1,\n        value: v.value,\n        disabled: v.disabled\n      }, {\n        default: E(() => [v.html ? (b(), _(\"span\", {\n          key: 0,\n          innerHTML: v.html\n        }, null, 8, Fu)) : (b(), _(de, {\n          key: 1\n        }, [ne(Y(v.text), 1)], 64))]),\n        _: 2\n      }, 1032, [\"value\", \"disabled\"]))], 64))), 128)), T(c.$slots, \"default\")], 10, Eu)), [[In, h.value]]);\n    }\n  }),\n  ha = \"ArrowDown\",\n  Vl = \"End\",\n  Al = \"Home\",\n  Ol = \"PageDown\",\n  Nl = \"PageUp\",\n  Ba = \"ArrowUp\",\n  zu = [\"lang\", \"tabindex\", \"title\"],\n  Hu = [\"name\", \"form\", \"value\"],\n  Ru = [\"id\", \"dir\", \"tabindex\", \"aria-label\", \"aria-invalid\", \"aria-required\", \"aria-valuemin\", \"aria-valuemax\", \"aria-valuenow\", \"aria-valuetext\"],\n  He = {\n    min: 1,\n    max: 100,\n    step: 1,\n    repeatDelay: 500,\n    repeatInterval: 100,\n    repeatThreshold: 10,\n    repeatMultiplier: 4\n  },\n  Mu = /* @__PURE__ */H({\n    __name: \"BFormSpinbutton\",\n    props: /* @__PURE__ */pe({\n      ariaControls: {\n        default: void 0\n      },\n      ariaLabel: {\n        default: void 0\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      formatterFn: {\n        type: Function,\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      inline: {\n        type: Boolean,\n        default: !1\n      },\n      labelDecrement: {\n        default: \"Decrement\"\n      },\n      labelIncrement: {\n        default: \"Increment\"\n      },\n      locale: {\n        default: void 0\n      },\n      max: {\n        default: He.max\n      },\n      min: {\n        default: He.min\n      },\n      modelValue: {},\n      name: {\n        default: void 0\n      },\n      placeholder: {\n        default: void 0\n      },\n      readonly: {\n        type: Boolean,\n        default: !1\n      },\n      repeatDelay: {\n        default: He.repeatDelay\n      },\n      repeatInterval: {\n        default: He.repeatInterval\n      },\n      repeatStepMultiplier: {\n        default: He.repeatMultiplier\n      },\n      repeatThreshold: {\n        default: He.repeatThreshold\n      },\n      required: {\n        type: Boolean,\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [Boolean, null],\n        default: null\n      },\n      step: {\n        default: He.step\n      },\n      vertical: {\n        type: Boolean,\n        default: !1\n      },\n      wrap: {\n        type: Boolean,\n        default: !1\n      }\n    }, {\n      modelValue: {\n        default: null\n      },\n      modelModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"change\"], [\"update:modelValue\"]),\n    setup(t, {\n      emit: e\n    }) {\n      const l = [Ba, ha, Al, Vl, Nl, Ol],\n        a = t,\n        o = e,\n        r = he(t, \"modelValue\"),\n        s = x(null),\n        {\n          focused: n\n        } = Pe(s),\n        i = Be(() => a.id, \"spinbutton\"),\n        u = w(() => ({\n          disabled: a.disabled,\n          readonly: a.readonly,\n          focus: n.value,\n          \"d-inline-flex\": a.inline || a.vertical,\n          \"d-flex\": !a.inline && !a.vertical,\n          \"align-items-stretch\": !a.vertical,\n          \"flex-column\": a.vertical,\n          [`form-control-${a.size}`]: a.size !== void 0\n        })),\n        d = w(() => ({\n          \"d-flex\": a.vertical,\n          \"align-self-center\": !a.vertical,\n          \"align-items-center\": a.vertical,\n          \"border-top\": a.vertical,\n          \"border-bottom\": a.vertical,\n          \"border-start\": !a.vertical,\n          \"border-end\": !a.vertical\n        }));\n      let p,\n        f,\n        m = !1;\n      const y = be(() => a.step),\n        h = k(() => Number.isNaN(y.value) ? He.step : y.value),\n        c = be(() => a.min),\n        g = k(() => Number.isNaN(c.value) ? He.min : c.value),\n        v = be(() => a.max),\n        $ = k(() => {\n          const z = h.value,\n            oe = g.value;\n          return Math.floor((v.value - oe) / z) * z + oe;\n        }),\n        B = be(() => a.repeatDelay, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        C = k(() => B.value > 0 ? B.value : He.repeatDelay),\n        V = be(() => a.repeatInterval, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        L = k(() => V.value > 0 ? V.value : He.repeatInterval),\n        Q = be(() => a.repeatThreshold, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        W = k(() => Math.max(Number.isNaN(Q.value) ? He.repeatThreshold : Q.value, 1)),\n        F = be(() => a.repeatStepMultiplier, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        Z = k(() => Math.max(Number.isNaN(F.value) ? He.repeatMultiplier : F.value, 1)),\n        R = k(() => {\n          const z = h.value;\n          return Math.floor(z) === z ? 0 : (z.toString().split(\".\")[1] || \"\").length;\n        }),\n        le = k(() => Math.pow(10, R.value || 0)),\n        N = k(() => r.value === null ? \"\" : r.value.toFixed(R.value)),\n        {\n          isRtl: S,\n          locale: P\n        } = Hr(),\n        M = w(() => {\n          const oe = [(a.locale ?? (P == null ? void 0 : P.value)) || \"locale\"];\n          return new Intl.NumberFormat(oe).resolvedOptions().locale;\n        }),\n        j = () => new Intl.NumberFormat(M.value, {\n          style: \"decimal\",\n          useGrouping: !1,\n          minimumIntegerDigits: 1,\n          minimumFractionDigits: R.value,\n          maximumFractionDigits: R.value,\n          notation: \"standard\"\n        }).format,\n        A = k(() => a.formatterFn ?? j()),\n        X = z => {\n          let {\n            value: oe\n          } = r;\n          if (!a.disabled && oe !== null) {\n            const fe = h.value * z,\n              ce = g.value,\n              Oe = $.value,\n              $e = le.value,\n              {\n                wrap: Te\n              } = a;\n            oe = Math.round((oe - ce) / fe) * fe + ce + fe, oe = Math.round(oe * $e) / $e, r.value = oe > Oe ? Te ? ce : Oe : oe < ce ? Te ? Oe : ce : oe;\n          }\n        },\n        G = (z = 1) => {\n          if (r.value === null) {\n            r.value = g.value;\n            return;\n          }\n          X(1 * z);\n        },\n        ie = (z = 1) => {\n          if (r.value === null) {\n            r.value = a.wrap ? $.value : g.value;\n            return;\n          }\n          X(-1 * z);\n        },\n        q = z => {\n          z.preventDefault(), z.stopImmediatePropagation();\n        };\n      Re(l, z => {\n        const {\n          code: oe,\n          altKey: fe,\n          ctrlKey: ce,\n          metaKey: Oe\n        } = z;\n        if (!(a.disabled || a.readonly || fe || ce || Oe) && (q(z), !m)) {\n          if (ee(), [Ba, ha].includes(oe)) {\n            if (m = !0, oe === Ba) {\n              se(z, G);\n              return;\n            }\n            oe === ha && se(z, ie);\n            return;\n          }\n          if (oe === Nl) {\n            G(Z.value);\n            return;\n          }\n          if (oe === Ol) {\n            ie(Z.value);\n            return;\n          }\n          if (oe === Al) {\n            r.value = g.value;\n            return;\n          }\n          oe === Vl && (r.value = $.value);\n        }\n      }, {\n        target: s,\n        eventName: \"keydown\"\n      }), Re(l, z => {\n        const {\n          altKey: oe,\n          ctrlKey: fe,\n          metaKey: ce\n        } = z;\n        a.disabled || a.readonly || oe || fe || ce || (q(z), ee(), m = !1, o(\"change\", r.value));\n      }, {\n        target: s,\n        eventName: \"keyup\"\n      });\n      const se = (z, oe) => {\n          const {\n            type: fe\n          } = z || {};\n          if (!a.disabled && !a.readonly) {\n            if (me(z) && fe === \"mousedown\" && z.button) return;\n            ee(), oe(1);\n            const ce = W.value,\n              Oe = Z.value,\n              $e = C.value,\n              Te = L.value;\n            p = setTimeout(() => {\n              let Ye = 0;\n              f = setInterval(() => {\n                oe(Ye < ce ? 1 : Oe), Ye++;\n              }, Te);\n            }, $e);\n          }\n        },\n        me = z => z.type === \"mouseup\" || z.type === \"mousedown\",\n        te = z => {\n          me(z) && z.type === \"mouseup\" && z.button || (q(z), ee(), ye(!1), o(\"change\", r.value));\n        },\n        ye = z => {\n          try {\n            sl(z, [document.body, \"mouseup\", te, !1]), sl(z, [document.body, \"touchend\", te, !1]);\n          } catch {}\n        },\n        ee = () => {\n          clearTimeout(p), clearInterval(f), p = void 0, f = void 0;\n        },\n        U = w(() => {\n          const z = {\n              svg: {\n                xmlns: \"http://www.w3.org/2000/svg\",\n                width: \"16\",\n                height: \"16\",\n                fill: \"currentColor\",\n                class: \"bi bi-plus\",\n                viewBox: \"0 0 16 16\"\n              },\n              path: {\n                d: \"M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z\"\n              }\n            },\n            oe = {\n              svg: {\n                xmlns: \"http://www.w3.org/2000/svg\",\n                width: \"16\",\n                height: \"16\",\n                fill: \"currentColor\",\n                class: \"bi bi-dash\",\n                viewBox: \"0 0 16 16\"\n              },\n              path: {\n                d: \"M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z\"\n              }\n            },\n            fe = {\n              class: [{\n                \"py-0\": !a.vertical\n              }, \"btn\", \"btn-sm\", \"border-0\", \"rounded-0\"],\n              tabindex: \"-1\",\n              type: \"button\",\n              disabled: a.disabled || a.readonly,\n              \"aria-disabled\": a.disabled || a.readonly ? !0 : void 0,\n              \"aria-controls\": i.value\n            },\n            ce = {\n              \"aria-hidden\": !0,\n              scale: n.value ? 1.5 : 1.25\n            },\n            Oe = (Ye, kn) => {\n              !a.disabled && !a.readonly && (q(Ye), ye(!0), n.value = !0, se(Ye, kn));\n            },\n            $e = {\n              button: {\n                ...fe,\n                \"aria-label\": a.labelIncrement || void 0,\n                \"aria-keyshortcuts\": \"ArrowUp\"\n              },\n              svg: {\n                ...ce,\n                ...z.svg\n              },\n              path: {\n                ...z.path\n              },\n              slot: {\n                name: \"increment\"\n              },\n              handler: Ye => Oe(Ye, G)\n            },\n            Te = {\n              button: {\n                ...fe,\n                \"aria-label\": a.labelDecrement || void 0,\n                \"aria-keyshortcuts\": \"ArrowDown\"\n              },\n              svg: {\n                ...ce,\n                ...oe.svg\n              },\n              path: {\n                ...oe.path\n              },\n              slot: {\n                name: \"decrement\"\n              },\n              handler: Ye => Oe(Ye, ie)\n            };\n          return {\n            top: {\n              ...(a.vertical ? $e : Te)\n            },\n            bottom: {\n              ...(a.vertical ? Te : $e)\n            }\n          };\n        });\n      return (z, oe) => (b(), _(\"div\", {\n        ref_key: \"element\",\n        ref: s,\n        class: D([\"b-form-spinbutton form-control\", u.value]),\n        role: \"group\",\n        lang: M.value,\n        tabindex: a.disabled ? void 0 : \"-1\",\n        title: z.ariaLabel,\n        onClick: oe[4] || (oe[4] = fe => n.value = !0)\n      }, [T(z.$slots, U.value.top.slot.name, {\n        hasFocus: O(n)\n      }, () => [J(\"button\", K(U.value.top.button, {\n        onMousedown: oe[0] || (oe[0] =\n        //@ts-ignore\n        (...fe) => U.value.top.handler && U.value.top.handler(...fe)),\n        onTouchstart: oe[1] || (oe[1] =\n        //@ts-ignore\n        (...fe) => U.value.top.handler && U.value.top.handler(...fe))\n      }), [(b(), _(\"svg\", ge(we(U.value.top.svg)), [J(\"path\", ge(we(U.value.top.path)), null, 16)], 16))], 16)]), z.name && !a.disabled ? (b(), _(\"input\", {\n        key: \"hidden\",\n        type: \"hidden\",\n        name: z.name,\n        form: z.form,\n        value: N.value\n      }, null, 8, Hu)) : ae(\"\", !0), J(\"output\", {\n        id: O(i),\n        key: \"output\",\n        class: D([\"flex-grow-1\", d.value]),\n        dir: O(S) ?? !1 ? \"rtl\" : \"ltr\",\n        tabindex: a.disabled ? void 0 : \"0\",\n        role: \"spinbutton\",\n        \"aria-live\": \"off\",\n        \"aria-label\": z.ariaLabel || void 0,\n        \"aria-invalid\": a.state === !1 || !r.value !== null && a.required ? !0 : void 0,\n        \"aria-required\": a.required ? !0 : void 0,\n        \"aria-valuemin\": g.value,\n        \"aria-valuemax\": $.value,\n        \"aria-valuenow\": r.value !== null ? r.value : void 0,\n        \"aria-valuetext\": r.value !== null ? A.value(r.value) : void 0\n      }, [J(\"bdi\", null, Y((r.value !== null ? A.value(r.value) : z.placeholder) || \"\"), 1)], 10, Ru), T(z.$slots, U.value.bottom.slot.name, {\n        hasFocus: O(n)\n      }, () => [J(\"button\", K(U.value.bottom.button, {\n        onMousedown: oe[2] || (oe[2] =\n        //@ts-ignore\n        (...fe) => U.value.bottom.handler && U.value.bottom.handler(...fe)),\n        onTouchstart: oe[3] || (oe[3] =\n        //@ts-ignore\n        (...fe) => U.value.bottom.handler && U.value.bottom.handler(...fe))\n      }), [(b(), _(\"svg\", ge(we(U.value.bottom.svg)), [J(\"path\", ge(we(U.value.bottom.path)), null, 16)], 16))], 16)])], 10, zu));\n    }\n  }),\n  xu = [\"id\"],\n  bn = /* @__PURE__ */H({\n    __name: \"BFormTag\",\n    props: {\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      noRemove: {\n        type: Boolean,\n        default: !1\n      },\n      pill: {\n        type: Boolean,\n        default: !1\n      },\n      removeLabel: {\n        default: \"Remove tag\"\n      },\n      tag: {\n        default: \"span\"\n      },\n      title: {\n        default: void 0\n      },\n      variant: {\n        default: \"secondary\"\n      }\n    },\n    emits: [\"remove\"],\n    setup(t, {\n      emit: e\n    }) {\n      const l = t,\n        a = e,\n        o = Le(),\n        r = Be(() => l.id),\n        s = w(() => {\n          var u;\n          return ((((u = o.default) == null ? void 0 : u.call(o, {})[0].children) ?? \"\").toString() || l.title) ?? \"\";\n        }),\n        n = k(() => `${r.value}taglabel__`),\n        i = w(() => ({\n          [`text-bg-${l.variant}`]: l.variant !== null,\n          \"rounded-pill\": l.pill,\n          disabled: l.disabled\n        }));\n      return (u, d) => (b(), I(re(u.tag), {\n        id: O(r),\n        title: s.value,\n        class: D([\"badge b-form-tag d-inline-flex align-items-center mw-100\", i.value]),\n        \"aria-labelledby\": n.value\n      }, {\n        default: E(() => [J(\"span\", {\n          id: n.value,\n          class: \"b-form-tag-content flex-grow-1 text-truncate\"\n        }, [T(u.$slots, \"default\", {}, () => [ne(Y(s.value), 1)])], 8, xu), !l.disabled && !l.noRemove ? (b(), I(Pt, {\n          key: 0,\n          \"aria-keyshortcuts\": \"Delete\",\n          \"aria-label\": u.removeLabel,\n          class: \"b-form-tag-remove\",\n          \"aria-describedby\": n.value,\n          \"aria-controls\": u.id,\n          onClick: d[0] || (d[0] = p => a(\"remove\", s.value))\n        }, null, 8, [\"aria-label\", \"aria-describedby\", \"aria-controls\"])) : ae(\"\", !0)]),\n        _: 3\n      }, 8, [\"id\", \"title\", \"class\", \"aria-labelledby\"]));\n    }\n  }),\n  Du = [\"id\"],\n  ju = [\"id\", \"for\", \"aria-live\"],\n  qu = [\"id\", \"aria-live\"],\n  Wu = [\"id\"],\n  Gu = [\"aria-controls\"],\n  Uu = {\n    role: \"group\",\n    class: \"d-flex\"\n  },\n  Ku = [\"id\", \"disabled\", \"value\", \"type\", \"placeholder\", \"form\", \"required\", \"aria-required\"],\n  Xu = [\"disabled\"],\n  Yu = {\n    \"aria-live\": \"polite\",\n    \"aria-atomic\": \"true\"\n  },\n  Zu = {\n    key: 0,\n    class: \"d-block invalid-feedback\"\n  },\n  Ju = {\n    key: 1,\n    class: \"form-text text-body-secondary\"\n  },\n  Qu = {\n    key: 2,\n    class: \"form-text text-body-secondary\"\n  },\n  ed = [\"name\", \"value\"],\n  td = /* @__PURE__ */H({\n    __name: \"BFormTags\",\n    props: /* @__PURE__ */pe({\n      addButtonText: {\n        default: \"Add\"\n      },\n      addButtonVariant: {\n        default: \"outline-secondary\"\n      },\n      addOnChange: {\n        type: Boolean,\n        default: !1\n      },\n      autofocus: {\n        type: Boolean,\n        default: !1\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      duplicateTagText: {\n        default: \"Duplicate tag(s)\"\n      },\n      form: {\n        default: void 0\n      },\n      inputAttrs: {\n        default: void 0\n      },\n      inputClass: {\n        default: void 0\n      },\n      inputId: {\n        default: void 0\n      },\n      inputType: {\n        default: \"text\"\n      },\n      invalidTagText: {\n        default: \"Invalid tag(s)\"\n      },\n      limit: {\n        default: void 0\n      },\n      limitTagsText: {\n        default: \"Tag limit reached\"\n      },\n      modelValue: {},\n      name: {\n        default: void 0\n      },\n      noAddOnEnter: {\n        type: Boolean,\n        default: !1\n      },\n      noOuterFocus: {\n        type: Boolean,\n        default: !1\n      },\n      noTagRemove: {\n        type: Boolean,\n        default: !1\n      },\n      placeholder: {\n        default: \"Add tag...\"\n      },\n      removeOnDelete: {\n        type: Boolean,\n        default: !1\n      },\n      required: {\n        type: Boolean,\n        default: !1\n      },\n      separator: {\n        default: void 0\n      },\n      size: {\n        default: \"md\"\n      },\n      state: {\n        type: [Boolean, null],\n        default: null\n      },\n      tagClass: {\n        default: void 0\n      },\n      tagPills: {\n        type: Boolean,\n        default: !1\n      },\n      tagRemoveLabel: {\n        default: void 0\n      },\n      tagRemovedLabel: {\n        default: \"Tag removed\"\n      },\n      tagValidator: {\n        type: Function,\n        default: () => !0\n      },\n      tagVariant: {\n        default: \"secondary\"\n      }\n    }, {\n      modelValue: {\n        default: () => []\n      },\n      modelModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"blur\", \"focus\", \"focusin\", \"focusout\", \"tag-state\"], [\"update:modelValue\"]),\n    setup(t, {\n      expose: e,\n      emit: l\n    }) {\n      const a = t,\n        o = l,\n        r = he(t, \"modelValue\"),\n        s = Be(),\n        n = be(() => a.limit ?? NaN),\n        i = Ct(() => a.state),\n        u = x(null),\n        {\n          focused: d\n        } = Pe(u, {\n          initialValue: a.autofocus\n        }),\n        p = k(() => a.inputId || `${s.value}input__`),\n        f = x([...r.value]),\n        m = x(\"\"),\n        y = x(r.value.length > 0),\n        h = x(\"\"),\n        c = x([]),\n        g = x([]),\n        v = x([]);\n      Sa(r, f, {\n        direction: \"ltr\",\n        transform: {\n          ltr: A => [...A]\n        }\n      });\n      const $ = w(() => [i.value, {\n          [`form-control-${a.size}`]: a.size !== \"md\",\n          disabled: a.disabled,\n          focus: d.value\n        }]),\n        B = w(() => f.value.includes(m.value)),\n        C = w(() => m.value === \"\" ? !1 : !a.tagValidator(m.value)),\n        V = k(() => f.value.length === n.value),\n        L = k(() => !C.value && !B.value),\n        Q = w(() => ({\n          addButtonText: a.addButtonText,\n          addButtonVariant: a.addButtonVariant,\n          addTag: M,\n          disableAddButton: L.value,\n          disabled: a.disabled,\n          duplicateTagText: a.duplicateTagText,\n          duplicateTags: v.value,\n          form: a.form,\n          inputAttrs: {\n            ...a.inputAttrs,\n            disabled: a.disabled,\n            form: a.form,\n            id: p,\n            value: m\n          },\n          inputHandlers: {\n            input: R,\n            keydown: N,\n            change: le\n          },\n          inputId: p,\n          inputType: a.inputType,\n          invalidTagText: a.invalidTagText,\n          invalidTags: g.value,\n          isDuplicate: B.value,\n          isInvalid: C.value,\n          isLimitReached: V.value,\n          limitTagsText: a.limitTagsText,\n          limit: n.value,\n          noTagRemove: a.noTagRemove,\n          placeholder: a.placeholder,\n          removeTag: j,\n          required: a.required,\n          separator: a.separator,\n          size: a.size,\n          state: a.state,\n          tagClass: a.tagClass,\n          tagPills: a.tagPills,\n          tagRemoveLabel: a.tagRemoveLabel,\n          tagVariant: a.tagVariant,\n          tags: f.value\n        })),\n        W = A => {\n          if (a.disabled) {\n            A.target.blur();\n            return;\n          }\n          o(\"focusin\", A);\n        },\n        F = A => {\n          a.disabled || a.noOuterFocus || (d.value = !0, o(\"focus\", A));\n        },\n        Z = A => {\n          d.value = !1, o(\"blur\", A);\n        },\n        R = A => {\n          var G, ie;\n          const X = typeof A == \"string\" ? A : A.target.value;\n          if (y.value = !1, (G = a.separator) != null && G.includes(X.charAt(0)) && X.length > 0) {\n            u.value && (u.value.value = \"\");\n            return;\n          }\n          if (m.value = X, (ie = a.separator) != null && ie.includes(X.charAt(X.length - 1))) {\n            M(X.slice(0, X.length - 1));\n            return;\n          }\n          c.value = a.tagValidator(X) && !B.value ? [X] : [], g.value = a.tagValidator(X) ? [] : [X], v.value = B.value ? [X] : [], o(\"tag-state\", c.value, g.value, v.value);\n        },\n        le = A => {\n          a.addOnChange && (R(A), B.value || M(m.value));\n        },\n        N = A => {\n          if (A.key === \"Enter\" && !a.noAddOnEnter) {\n            M(m.value);\n            return;\n          }\n          (A.key === \"Backspace\" || A.key === \"Delete\") && a.removeOnDelete && m.value === \"\" && y.value && f.value.length > 0 ? j(f.value[f.value.length - 1]) : y.value = !0;\n        };\n      Re(N, {\n        target: u\n      });\n      const S = w(() => {\n          if (a.separator) return typeof a.separator == \"string\" ? a.separator : a.separator.join(\"\");\n        }),\n        P = w(() => {\n          if (S.value) return new RegExp(`[${Or(S.value)}]+`);\n        }),\n        M = A => {\n          A = (A ?? m.value).trim();\n          const X = P.value ? A.split(P.value).map(q => q.trim()) : [A],\n            G = [];\n          for (const q of X) if (!(q === \"\" || B.value || !a.tagValidator(q))) {\n            if (n.value && V.value) break;\n            G.push(q);\n          }\n          const ie = [...r.value, ...G];\n          m.value = \"\", y.value = !0, r.value = ie, d.value = !0;\n        },\n        j = A => {\n          const X = f.value.indexOf((A == null ? void 0 : A.toString()) ?? \"\");\n          X !== -1 && (h.value = f.value.splice(X, 1).toString(), r.value = f.value);\n        };\n      return e({\n        blur: () => {\n          d.value = !1;\n        },\n        element: u,\n        focus: () => {\n          d.value = !0;\n        }\n      }), (A, X) => (b(), _(\"div\", {\n        id: O(s),\n        class: D([\"b-form-tags form-control h-auto\", $.value]),\n        role: \"group\",\n        tabindex: \"-1\",\n        onFocusin: W,\n        onFocusout: X[1] || (X[1] = G => o(\"focusout\", G))\n      }, [J(\"output\", {\n        id: `${O(s)}selected_tags__`,\n        class: \"visually-hidden\",\n        for: p.value,\n        \"aria-live\": O(d) ? \"polite\" : \"off\",\n        \"aria-atomic\": \"true\",\n        \"aria-relevant\": \"additions text\"\n      }, Y(f.value.join(\", \")), 9, ju), J(\"div\", {\n        id: `${O(s)}removed_tags__`,\n        role: \"status\",\n        \"aria-live\": O(d) ? \"assertive\" : \"off\",\n        \"aria-atomic\": \"true\",\n        class: \"visually-hidden\"\n      }, \" (\" + Y(A.tagRemovedLabel) + \") \" + Y(h.value), 9, qu), T(A.$slots, \"default\", ge(we(Q.value)), () => [J(\"ul\", {\n        id: `${O(s)}tag_list__`,\n        class: \"b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center\"\n      }, [(b(!0), _(de, null, Ce(f.value, (G, ie) => T(A.$slots, \"tag\", {\n        key: ie,\n        tag: G,\n        tagClass: A.tagClass,\n        tagVariant: A.tagVariant,\n        tagPills: a.tagPills,\n        removeTag: j\n      }, () => [(b(), I(bn, {\n        key: G,\n        class: D(A.tagClass),\n        tag: \"li\",\n        variant: A.tagVariant,\n        pill: A.tagPills,\n        onRemove: j\n      }, {\n        default: E(() => [ne(Y(G), 1)]),\n        _: 2\n      }, 1032, [\"class\", \"variant\", \"pill\"]))])), 128)), J(\"li\", {\n        role: \"none\",\n        \"aria-live\": \"off\",\n        class: \"b-from-tags-field flex-grow-1\",\n        \"aria-controls\": `${O(s)}tag_list__`\n      }, [J(\"div\", Uu, [J(\"input\", K({\n        id: p.value,\n        ref_key: \"input\",\n        ref: u,\n        disabled: a.disabled,\n        value: m.value,\n        type: A.inputType,\n        placeholder: A.placeholder,\n        class: \"b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0\",\n        style: {\n          outline: \"currentcolor none 0px\",\n          \"min-width\": \"5rem\"\n        }\n      }, A.inputAttrs, {\n        form: A.form,\n        required: a.required || void 0,\n        \"aria-required\": a.required || void 0,\n        onInput: R,\n        onChange: le,\n        onFocus: F,\n        onBlur: Z\n      }), null, 16, Ku), L.value ? (b(), _(\"button\", {\n        key: 0,\n        type: \"button\",\n        class: D([\"btn b-form-tags-button py-0\", [A.inputClass, {\n          [`btn-${A.addButtonVariant}`]: A.addButtonVariant !== null,\n          \"disabled invisible\": m.value.length === 0\n        }]]),\n        style: {\n          \"font-size\": \"90%\"\n        },\n        disabled: a.disabled || m.value.length === 0 || V.value,\n        onClick: X[0] || (X[0] = G => M(m.value))\n      }, [T(A.$slots, \"add-button-text\", {}, () => [ne(Y(A.addButtonText), 1)])], 10, Xu)) : ae(\"\", !0)])], 8, Gu)], 8, Wu), J(\"div\", Yu, [C.value ? (b(), _(\"div\", Zu, Y(A.invalidTagText) + \": \" + Y(m.value), 1)) : ae(\"\", !0), B.value ? (b(), _(\"small\", Ju, Y(A.duplicateTagText) + \": \" + Y(m.value), 1)) : ae(\"\", !0), f.value.length === A.limit ? (b(), _(\"small\", Qu, Y(A.limitTagsText), 1)) : ae(\"\", !0)])]), A.name ? (b(!0), _(de, {\n        key: 0\n      }, Ce(f.value, (G, ie) => (b(), _(\"input\", {\n        key: ie,\n        type: \"hidden\",\n        name: A.name,\n        value: G\n      }, null, 8, ed))), 128)) : ae(\"\", !0)], 42, Du));\n    }\n  }),\n  ad = [\"id\", \"name\", \"form\", \"value\", \"disabled\", \"placeholder\", \"required\", \"autocomplete\", \"readonly\", \"aria-required\", \"aria-invalid\", \"rows\", \"wrap\"],\n  ld = /* @__PURE__ */H({\n    __name: \"BFormTextarea\",\n    props: {\n      noResize: {\n        type: Boolean,\n        default: !1\n      },\n      rows: {\n        default: 2\n      },\n      wrap: {\n        default: \"soft\"\n      },\n      ariaInvalid: {\n        type: [Boolean, String],\n        default: void 0\n      },\n      autocomplete: {\n        default: void 0\n      },\n      autofocus: {\n        type: Boolean,\n        default: !1\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      formatter: {\n        type: Function,\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      lazy: {\n        type: Boolean,\n        default: !1\n      },\n      lazyFormatter: {\n        type: Boolean,\n        default: !1\n      },\n      list: {\n        default: void 0\n      },\n      modelValue: {\n        default: \"\"\n      },\n      name: {\n        default: void 0\n      },\n      number: {\n        type: Boolean,\n        default: !1\n      },\n      placeholder: {\n        default: void 0\n      },\n      plaintext: {\n        type: Boolean,\n        default: !1\n      },\n      readonly: {\n        type: Boolean,\n        default: !1\n      },\n      required: {\n        type: Boolean,\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [Boolean, null],\n        default: null\n      },\n      trim: {\n        type: Boolean,\n        default: !1\n      },\n      debounce: {\n        default: 0\n      },\n      debounceMaxWait: {\n        default: NaN\n      }\n    },\n    emits: [\"update:modelValue\"],\n    setup(t, {\n      expose: e,\n      emit: l\n    }) {\n      const a = t,\n        o = l,\n        {\n          input: r,\n          computedId: s,\n          computedAriaInvalid: n,\n          onInput: i,\n          onChange: u,\n          onBlur: d,\n          focus: p,\n          blur: f\n        } = qo(a, o),\n        m = Ct(() => a.state),\n        y = w(() => [m.value, a.plaintext ? \"form-control-plaintext\" : \"form-control\", {\n          [`form-control-${a.size}`]: !!a.size\n        }]),\n        h = w(() => ({\n          resize: a.noResize ? \"none\" : void 0\n        }));\n      return e({\n        blur: f,\n        element: r,\n        focus: p\n      }), (c, g) => (b(), _(\"textarea\", {\n        id: O(s),\n        ref_key: \"input\",\n        ref: r,\n        class: D(y.value),\n        name: c.name || void 0,\n        form: c.form || void 0,\n        value: c.modelValue ?? void 0,\n        disabled: a.disabled,\n        placeholder: c.placeholder,\n        required: a.required || void 0,\n        autocomplete: c.autocomplete || void 0,\n        readonly: a.readonly || a.plaintext,\n        \"aria-required\": c.required || void 0,\n        \"aria-invalid\": O(n),\n        rows: c.rows,\n        style: Ee(h.value),\n        wrap: c.wrap || void 0,\n        onInput: g[0] || (g[0] = v => O(i)(v)),\n        onChange: g[1] || (g[1] = v => O(u)(v)),\n        onBlur: g[2] || (g[2] = v => O(d)(v))\n      }, null, 46, ad));\n    }\n  }),\n  od = {\n    key: 0,\n    class: \"input-group-text\"\n  },\n  nd = [\"innerHTML\"],\n  sd = {\n    key: 1\n  },\n  rd = {\n    key: 0,\n    class: \"input-group-text\"\n  },\n  id = [\"innerHTML\"],\n  ud = {\n    key: 1\n  },\n  dd = /* @__PURE__ */H({\n    __name: \"BInputGroup\",\n    props: {\n      append: {\n        default: void 0\n      },\n      appendHtml: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      prepend: {\n        default: void 0\n      },\n      prependHtml: {\n        default: void 0\n      },\n      size: {\n        default: \"md\"\n      },\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => ({\n          [`input-group-${e.size}`]: e.size !== \"md\"\n        })),\n        a = k(() => !!e.append || !!e.appendHtml),\n        o = k(() => !!e.prepend || !!e.prependHtml);\n      return (r, s) => (b(), I(re(r.tag), {\n        id: r.id,\n        class: D([\"input-group\", l.value]),\n        role: \"group\"\n      }, {\n        default: E(() => [T(r.$slots, \"prepend\", {}, () => [o.value ? (b(), _(\"span\", od, [r.prependHtml ? (b(), _(\"span\", {\n          key: 0,\n          innerHTML: r.prependHtml\n        }, null, 8, nd)) : (b(), _(\"span\", sd, Y(r.prepend), 1))])) : ae(\"\", !0)]), T(r.$slots, \"default\"), T(r.$slots, \"append\", {}, () => [a.value ? (b(), _(\"span\", rd, [r.appendHtml ? (b(), _(\"span\", {\n          key: 0,\n          innerHTML: r.appendHtml\n        }, null, 8, id)) : (b(), _(\"span\", ud, Y(r.append), 1))])) : ae(\"\", !0)])]),\n        _: 3\n      }, 8, [\"id\", \"class\"]));\n    }\n  }),\n  yn = /* @__PURE__ */H({\n    __name: \"BInputGroupText\",\n    props: {\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      return (e, l) => (b(), I(re(e.tag), {\n        class: \"input-group-text\"\n      }, {\n        default: E(() => [T(e.$slots, \"default\", {}, () => [ne(Y(e.text), 1)])]),\n        _: 3\n      }));\n    }\n  }),\n  ll = /* @__PURE__ */H({\n    __name: \"BInputGroupAddon\",\n    props: {\n      isText: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    setup(t) {\n      const e = t;\n      return (l, a) => e.isText ? (b(), I(yn, {\n        key: 0\n      }, {\n        default: E(() => [T(l.$slots, \"default\")]),\n        _: 3\n      })) : T(l.$slots, \"default\", {\n        key: 1\n      });\n    }\n  }),\n  cd = /* @__PURE__ */H({\n    __name: \"BInputGroupAppend\",\n    props: {\n      isText: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    setup(t) {\n      return (e, l) => (b(), I(ll, ge(we(e.$props)), {\n        default: E(() => [T(e.$slots, \"default\")]),\n        _: 3\n      }, 16));\n    }\n  }),\n  fd = /* @__PURE__ */H({\n    __name: \"BInputGroupPrepend\",\n    props: {\n      isText: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    setup(t) {\n      return (e, l) => (b(), I(ll, ge(we(e.$props)), {\n        default: E(() => [T(e.$slots, \"default\")]),\n        _: 3\n      }, 16));\n    }\n  }),\n  vd = /* @__PURE__ */H({\n    __name: \"BListGroup\",\n    props: {\n      flush: {\n        type: Boolean,\n        default: !1\n      },\n      horizontal: {\n        type: [Boolean, String],\n        default: !1\n      },\n      numbered: {\n        type: Boolean,\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => {\n          const o = e.flush ? !1 : e.horizontal;\n          return {\n            \"list-group-flush\": e.flush,\n            \"list-group-horizontal\": o === !0,\n            [`list-group-horizontal-${o}`]: typeof o == \"string\",\n            \"list-group-numbered\": e.numbered\n          };\n        }),\n        a = k(() => e.numbered === !0 ? \"ol\" : e.tag);\n      return at(To, {\n        numbered: k(() => e.numbered)\n      }), (o, r) => (b(), I(re(a.value), {\n        class: D([\"list-group\", l.value])\n      }, {\n        default: E(() => [T(o.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  pd = /* @__PURE__ */H({\n    __name: \"BListGroupItem\",\n    props: {\n      action: {\n        type: Boolean,\n        default: !1\n      },\n      button: {\n        type: Boolean,\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      active: {\n        type: Boolean,\n        default: !1\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: Boolean,\n        default: void 0\n      },\n      disabled: {\n        type: Boolean,\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: Boolean,\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: Boolean,\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = Mt(),\n        a = _e(To, null),\n        {\n          computedLink: o\n        } = wt(e),\n        r = k(() => !e.button && o.value),\n        s = k(() => a != null && a.numbered.value ? \"li\" : e.button ? \"button\" : r.value ? ot : e.tag),\n        n = w(() => e.action || r.value || e.button || [\"a\", \"router-link\", \"button\", \"b-link\"].includes(e.tag)),\n        i = w(() => ({\n          [`list-group-item-${e.variant}`]: e.variant !== null && e.variant !== void 0,\n          \"list-group-item-action\": n.value,\n          active: e.active,\n          disabled: e.disabled\n        })),\n        u = w(() => {\n          const d = {};\n          return e.button && ((!l || !l.type) && (d.type = \"button\"), e.disabled && (d.disabled = !0)), d;\n        });\n      return (d, p) => (b(), I(re(s.value), K({\n        class: [\"list-group-item\", i.value],\n        \"aria-current\": e.active ? !0 : void 0,\n        \"aria-disabled\": e.disabled ? !0 : void 0,\n        target: r.value ? d.target : void 0,\n        href: e.button ? void 0 : d.href,\n        to: e.button ? void 0 : d.to\n      }, u.value), {\n        default: E(() => [T(d.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\", \"aria-current\", \"aria-disabled\", \"target\", \"href\", \"to\"]));\n    }\n  }),\n  md = {\n    id: \"__BVID__modal-container\"\n  },\n  bd = /* @__PURE__ */H({\n    __name: \"BModalOrchestrator\",\n    props: {\n      teleportDisabled: {\n        default: !1\n      },\n      teleportTo: {\n        default: \"body\"\n      }\n    },\n    setup(t, {\n      expose: e\n    }) {\n      const l = t,\n        {\n          modals: a,\n          remove: o,\n          show: r,\n          confirm: s\n        } = Go(),\n        n = i => va(i, [\"_promise\", \"_self\", \"_isConfirm\", \"_modelValue\"]);\n      return e({\n        modals: a,\n        show: r,\n        confirm: s\n      }), (i, u) => (b(), I(ht, {\n        to: i.teleportTo,\n        disabled: l.teleportDisabled\n      }, [J(\"div\", md, [(b(!0), _(de, null, Ce(O(a), (d, p) => (b(), I(re(d.value.component), K({\n        key: p,\n        modelValue: d.value.props._modelValue,\n        \"onUpdate:modelValue\": f => d.value.props._modelValue = f,\n        ref_for: !0\n      }, n(d.value.props), {\n        \"teleport-disabled\": !0,\n        onHide: f => {\n          if (d.value.props._isConfirm === !0) {\n            if (f.trigger === \"ok\") {\n              d.value.props._promise.resolve(!0);\n              return;\n            }\n            if (f.trigger === \"cancel\") {\n              d.value.props._promise.resolve(!1);\n              return;\n            }\n            d.value.props._promise.resolve(null);\n          }\n          d.value.props._promise.resolve(!0);\n        },\n        onHidden: f => {\n          var m;\n          return (m = O(o)) == null ? void 0 : m(d.value.props._self);\n        }\n      }), null, 16, [\"modelValue\", \"onUpdate:modelValue\", \"onHide\", \"onHidden\"]))), 128))])], 8, [\"to\", \"disabled\"]));\n    }\n  }),\n  yd = /* @__PURE__ */H({\n    __name: \"BNav\",\n    props: {\n      align: {\n        default: void 0\n      },\n      cardHeader: {\n        type: Boolean,\n        default: !1\n      },\n      fill: {\n        type: Boolean,\n        default: !1\n      },\n      justified: {\n        type: Boolean,\n        default: !1\n      },\n      pills: {\n        type: Boolean,\n        default: !1\n      },\n      small: {\n        type: Boolean,\n        default: !1\n      },\n      tabs: {\n        type: Boolean,\n        default: !1\n      },\n      tag: {\n        default: \"ul\"\n      },\n      underline: {\n        type: Boolean,\n        default: !1\n      },\n      vertical: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = Dt(() => e.align),\n        a = w(() => ({\n          \"nav-tabs\": e.tabs,\n          \"nav-pills\": e.pills && !e.tabs,\n          \"card-header-tabs\": !e.vertical && e.cardHeader && e.tabs,\n          \"card-header-pills\": !e.vertical && e.cardHeader && e.pills && !e.tabs,\n          \"flex-column\": e.vertical,\n          \"nav-fill\": !e.vertical && e.fill,\n          \"nav-justified\": !e.vertical && e.justified,\n          [l.value]: !e.vertical && e.align !== void 0,\n          small: e.small,\n          \"nav-underline\": e.underline\n        }));\n      return (o, r) => (b(), I(re(o.tag), {\n        class: D([\"nav\", a.value])\n      }, {\n        default: E(() => [T(o.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  gd = {\n    class: \"d-flex flex-row align-items-center flex-wrap\"\n  },\n  hd = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BNavForm\",\n    props: {\n      role: {\n        default: void 0\n      },\n      floating: {\n        type: Boolean,\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      novalidate: {\n        type: Boolean,\n        default: void 0\n      },\n      validated: {\n        type: Boolean,\n        default: void 0\n      }\n    },\n    emits: [\"submit\"],\n    setup(t, {\n      emit: e\n    }) {\n      const l = e,\n        a = o => {\n          l(\"submit\", o);\n        };\n      return (o, r) => (b(), _(\"li\", gd, [ve(dn, K(o.$attrs, {\n        id: o.id,\n        floating: o.floating,\n        role: o.role,\n        novalidate: o.novalidate,\n        validated: o.validated,\n        class: \"d-flex\",\n        onSubmit: ft(a, [\"prevent\"])\n      }), {\n        default: E(() => [T(o.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"id\", \"floating\", \"role\", \"novalidate\", \"validated\"])]));\n    }\n  }),\n  Bd = {\n    class: \"nav-item\"\n  },\n  wd = /* @__PURE__ */H({\n    __name: \"BNavItem\",\n    props: {\n      linkAttrs: {\n        default: void 0\n      },\n      linkClass: {\n        default: void 0\n      },\n      active: {\n        type: Boolean,\n        default: void 0\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: Boolean,\n        default: void 0\n      },\n      disabled: {\n        type: Boolean,\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: Boolean,\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: Boolean,\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    emits: [\"click\"],\n    setup(t, {\n      emit: e\n    }) {\n      const l = t,\n        a = e,\n        o = w(() => Za(l, [\"active\", \"activeClass\", \"append\", \"disabled\", \"href\", \"icon\", \"opacity\", \"opacityHover\", \"rel\", \"replace\", \"routerComponentName\", \"target\", \"to\", \"underlineOffset\", \"underlineOffsetHover\", \"underlineOpacity\", \"underlineOpacityHover\", \"underlineVariant\", \"variant\"]));\n      return o.value.activeClass, (r, s) => (b(), _(\"li\", Bd, [ve(ot, K({\n        class: [\"nav-link\", r.linkClass],\n        tabindex: l.disabled ? -1 : void 0,\n        \"aria-disabled\": l.disabled ? !0 : void 0\n      }, {\n        ...o.value,\n        ...r.linkAttrs\n      }, {\n        onClick: s[0] || (s[0] = n => a(\"click\", n))\n      }), {\n        default: E(() => [T(r.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\", \"tabindex\", \"aria-disabled\"])]));\n    }\n  }),\n  Cd = {\n    class: \"nav-item dropdown\"\n  },\n  kd = /* @__PURE__ */H({\n    __name: \"BNavItemDropdown\",\n    props: /* @__PURE__ */pe({\n      ariaLabel: {\n        default: void 0\n      },\n      autoClose: {\n        type: [Boolean, String],\n        default: !0\n      },\n      boundary: {\n        default: \"clippingAncestors\"\n      },\n      boundaryPadding: {\n        default: void 0\n      },\n      center: {\n        type: Boolean,\n        default: !1\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      dropend: {\n        type: Boolean,\n        default: !1\n      },\n      dropstart: {\n        type: Boolean,\n        default: !1\n      },\n      dropup: {\n        type: Boolean,\n        default: !1\n      },\n      end: {\n        type: Boolean,\n        default: !1\n      },\n      floatingMiddleware: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      isNav: {\n        type: Boolean,\n        default: !0\n      },\n      lazy: {\n        type: Boolean,\n        default: !1\n      },\n      menuClass: {\n        default: void 0\n      },\n      modelValue: {\n        type: Boolean\n      },\n      noCaret: {\n        type: Boolean,\n        default: !1\n      },\n      noFlip: {\n        type: Boolean,\n        default: !1\n      },\n      noShift: {\n        type: Boolean,\n        default: !1\n      },\n      noSize: {\n        type: Boolean,\n        default: !1\n      },\n      offset: {\n        default: 0\n      },\n      role: {\n        default: \"menu\"\n      },\n      size: {\n        default: \"md\"\n      },\n      split: {\n        type: Boolean,\n        default: !1\n      },\n      splitButtonType: {\n        default: \"button\"\n      },\n      splitClass: {\n        default: void 0\n      },\n      splitDisabled: {\n        type: Boolean,\n        default: void 0\n      },\n      splitHref: {\n        default: void 0\n      },\n      splitTo: {\n        default: void 0\n      },\n      splitVariant: {\n        default: void 0\n      },\n      strategy: {\n        default: \"absolute\"\n      },\n      text: {\n        default: void 0\n      },\n      toggleClass: {\n        default: void 0\n      },\n      toggleText: {\n        default: \"Toggle dropdown\"\n      },\n      variant: {\n        default: \"link\"\n      },\n      teleportDisabled: {\n        default: !1\n      },\n      teleportTo: {\n        default: void 0\n      }\n    }, {\n      modelValue: {\n        type: Boolean,\n        default: !1\n      },\n      modelModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"click\", \"hidden\", \"hide\", \"hide-prevented\", \"show\", \"show-prevented\", \"shown\", \"toggle\"], [\"update:modelValue\"]),\n    setup(t, {\n      expose: e,\n      emit: l\n    }) {\n      const a = t,\n        o = l,\n        r = he(t, \"modelValue\"),\n        s = x(null),\n        n = () => {\n          var d;\n          (d = s.value) == null || d.hide();\n        },\n        i = () => {\n          var d;\n          (d = s.value) == null || d.show();\n        };\n      return e({\n        hide: n,\n        show: i,\n        toggle: () => {\n          var d;\n          (d = s.value) == null || d.toggle();\n        }\n      }), (d, p) => (b(), _(\"li\", Cd, [ve(un, K({\n        ref_key: \"dropdown\",\n        ref: s\n      }, a, {\n        modelValue: r.value,\n        \"onUpdate:modelValue\": p[0] || (p[0] = f => r.value = f),\n        \"is-nav\": \"\",\n        onShow: p[1] || (p[1] = f => o(\"show\", f)),\n        onShown: p[2] || (p[2] = f => o(\"shown\")),\n        onHide: p[3] || (p[3] = f => o(\"hide\", f)),\n        onHidden: p[4] || (p[4] = f => o(\"hidden\")),\n        onHidePrevented: p[5] || (p[5] = f => o(\"hide-prevented\")),\n        onShowPrevented: p[6] || (p[6] = f => o(\"show-prevented\")),\n        onClick: p[7] || (p[7] = f => o(\"click\", f)),\n        onToggle: p[8] || (p[8] = f => o(\"toggle\"))\n      }), {\n        \"button-content\": E(() => [T(d.$slots, \"button-content\")]),\n        \"toggle-text\": E(() => [T(d.$slots, \"toggle-text\")]),\n        default: E(() => [T(d.$slots, \"default\", {\n          hide: n,\n          show: i\n        })]),\n        _: 3\n      }, 16, [\"modelValue\"])]));\n    }\n  }),\n  $d = {\n    class: \"navbar-text\"\n  },\n  Td = /* @__PURE__ */H({\n    __name: \"BNavText\",\n    props: {\n      text: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      return (e, l) => (b(), _(\"li\", $d, [T(e.$slots, \"default\", {}, () => [ne(Y(e.text), 1)])]));\n    }\n  }),\n  Sd = /* @__PURE__ */H({\n    __name: \"BNavbar\",\n    props: {\n      autoClose: {\n        type: Boolean,\n        default: !0\n      },\n      container: {\n        type: [Boolean, String],\n        default: \"fluid\"\n      },\n      fixed: {\n        default: void 0\n      },\n      print: {\n        type: Boolean,\n        default: !1\n      },\n      sticky: {\n        default: void 0\n      },\n      tag: {\n        default: \"nav\"\n      },\n      toggleable: {\n        type: [Boolean, String],\n        default: !1\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = k(() => e.tag === \"nav\" ? void 0 : \"navigation\"),\n        a = Er(() => e.container),\n        o = w(() => ({\n          \"d-print\": e.print,\n          [`sticky-${e.sticky}`]: e.sticky !== void 0,\n          [`bg-${e.variant}`]: e.variant !== null,\n          [`fixed-${e.fixed}`]: e.fixed !== void 0,\n          \"navbar-expand\": e.toggleable === !1,\n          [`navbar-expand-${e.toggleable}`]: typeof e.toggleable == \"string\"\n        }));\n      return at(Ya, {\n        tag: k(() => e.tag),\n        autoClose: k(() => e.autoClose)\n      }), (r, s) => (b(), I(re(r.tag), {\n        class: D([\"navbar\", o.value]),\n        role: l.value\n      }, {\n        default: E(() => [r.container !== !1 ? (b(), _(\"div\", {\n          key: 0,\n          class: D(O(a))\n        }, [T(r.$slots, \"default\")], 2)) : T(r.$slots, \"default\", {\n          key: 1\n        })]),\n        _: 3\n      }, 8, [\"class\", \"role\"]));\n    }\n  }),\n  _d = /* @__PURE__ */H({\n    __name: \"BNavbarBrand\",\n    props: {\n      tag: {\n        default: \"div\"\n      },\n      active: {\n        type: Boolean,\n        default: void 0\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: Boolean,\n        default: void 0\n      },\n      disabled: {\n        type: Boolean,\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: Boolean,\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: Boolean,\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      const e = t,\n        {\n          computedLink: l,\n          computedLinkProps: a\n        } = wt(e, [\"active\", \"activeClass\", \"append\", \"disabled\", \"href\", \"rel\", \"replace\", \"routerComponentName\", \"target\", \"to\", \"variant\", \"opacity\", \"opacityHover\", \"underlineVariant\", \"underlineOffset\", \"underlineOffsetHover\", \"underlineOpacity\", \"underlineOpacityHover\", \"icon\"]),\n        o = k(() => l.value ? ot : e.tag);\n      return (r, s) => (b(), I(re(o.value), K({\n        class: \"navbar-brand\"\n      }, O(a)), {\n        default: E(() => [T(r.$slots, \"default\")]),\n        _: 3\n      }, 16));\n    }\n  }),\n  Vd = /* @__PURE__ */H({\n    __name: \"BNavbarNav\",\n    props: {\n      align: {\n        default: void 0\n      },\n      fill: {\n        type: Boolean,\n        default: !1\n      },\n      justified: {\n        type: Boolean,\n        default: !1\n      },\n      small: {\n        type: Boolean,\n        default: !1\n      },\n      tag: {\n        default: \"ul\"\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = Dt(() => e.align),\n        a = w(() => ({\n          \"nav-fill\": e.fill,\n          \"nav-justified\": e.justified,\n          [l.value]: e.align !== void 0,\n          small: e.small\n        }));\n      return (o, r) => (b(), _(\"ul\", {\n        class: D([\"navbar-nav\", a.value])\n      }, [T(o.$slots, \"default\")], 2));\n    }\n  }),\n  Il = (t, e) => t.setAttribute(\"data-bs-theme\", e),\n  Ad = {\n    mounted(t, e) {\n      Il(t, e.value);\n    },\n    updated(t, e) {\n      Il(t, e.value);\n    }\n  },\n  Od = (t, e) => {\n    const {\n        modifiers: l,\n        arg: a,\n        value: o\n      } = t,\n      r = Object.keys(l || {}),\n      s = typeof o == \"string\" ? o.split(Zt) : o;\n    if (e.tagName.toLowerCase() === \"a\") {\n      const n = e.getAttribute(\"href\") || \"\";\n      Tr.test(n) && r.push(n.replace($r, \"\"));\n    }\n    return Array.prototype.concat.apply([], [a, s]).forEach(n => typeof n == \"string\" && r.push(n)), r.filter((n, i, u) => n && u.indexOf(n) === i);\n  },\n  Nd = (t, e) => {\n    t.forEach(l => {\n      const a = document.getElementById(l);\n      a !== null && a.dispatchEvent(new Event(\"bv-toggle\"));\n    }), setTimeout(() => gn(t, e), 50);\n  },\n  gn = (t, e) => {\n    let l = !1;\n    t.forEach(a => {\n      const o = document.getElementById(a);\n      o != null && o.classList.contains(\"show\") && (l = !0), o != null && o.classList.contains(\"closing\") && (l = !1);\n    }), e.setAttribute(\"aria-expanded\", l ? \"true\" : \"false\"), e.classList.remove(l ? \"collapsed\" : \"not-collapsed\"), e.classList.add(l ? \"not-collapsed\" : \"collapsed\");\n  },\n  Pl = (t, e) => {\n    const l = Od(e, t);\n    l.length !== 0 && (t.__toggle && t.removeEventListener(\"click\", t.__toggle), t.__toggle = () => Nd(l, t), t.addEventListener(\"click\", t.__toggle), t.setAttribute(\"aria-controls\", l.join(\" \")), gn(l, t));\n  },\n  Na = {\n    mounted: Pl,\n    updated: Pl,\n    unmounted(t) {\n      t.removeEventListener(\"click\", t.__toggle), t.removeAttribute(\"aria-controls\"), t.removeAttribute(\"aria-expanded\");\n    }\n  },\n  Id = {\n    mounted(t, e) {\n      if (!Ht(e.value)) return;\n      const a = oa(e.value, t);\n      !a.content && !a.title || sa(t, e, {\n        ...na(e, t),\n        ...a\n      });\n    },\n    updated(t, e) {\n      if (!Ht(e.value)) return;\n      const a = oa(e.value, t);\n      !a.content && !a.title || (ra(t), sa(t, e, {\n        ...na(e, t),\n        ...a\n      }));\n    },\n    beforeUnmount(t) {\n      ra(t);\n    }\n  },\n  El = (t, e) => {\n    t.$__scrollspy && t.$__scrollspy.cleanup();\n    const {\n        arg: l,\n        value: a\n      } = e,\n      o = typeof a == \"object\" && a !== null,\n      r = l || (typeof a == \"string\" ? a : o ? a.content || a.element : null);\n    t.$__scrollspy = Ko(r, t, o ? va(a, [\"content\", \"element\"]) : {});\n  },\n  Pd = {\n    mounted: El,\n    updated: El,\n    beforeUnmount(t) {\n      t.$__scrollspy && t.$__scrollspy.cleanup();\n    }\n  },\n  Ed = {\n    mounted(t, e) {\n      const l = Ht(e.value);\n      if (!l) return;\n      const a = oa(e.value, t);\n      !a.content && !a.title || sa(t, e, {\n        noninteractive: !0,\n        ...na(e, t),\n        title: a.title ?? a.content ?? \"\",\n        tooltip: l\n      });\n    },\n    updated(t, e) {\n      const l = Ht(e.value);\n      if (!l) return;\n      const a = oa(e.value, t);\n      !a.content && !a.title || (ra(t), sa(t, e, {\n        noninteractive: !0,\n        ...na(e, t),\n        title: a.title ?? a.content ?? \"\",\n        tooltip: l\n      }));\n    },\n    beforeUnmount(t) {\n      ra(t);\n    }\n  },\n  Fl = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    vBColorMode: Ad,\n    vBModal: Na,\n    vBPopover: Id,\n    vBScrollspy: Pd,\n    vBToggle: Na,\n    vBTooltip: Ed\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Fd = [\"disabled\", \"aria-label\"],\n  Ld = /* @__PURE__ */J(\"span\", {\n    class: \"navbar-toggler-icon\"\n  }, null, -1),\n  zd = /* @__PURE__ */H({\n    __name: \"BNavbarToggle\",\n    props: {\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      label: {\n        default: \"Toggle navigation\"\n      },\n      target: {\n        default: void 0\n      }\n    },\n    emits: [\"click\"],\n    setup(t, {\n      emit: e\n    }) {\n      const l = t,\n        a = e,\n        o = w(() => ({\n          disabled: l.disabled\n        })),\n        r = s => {\n          l.disabled || a(\"click\", s);\n        };\n      return (s, n) => ut((b(), _(\"button\", {\n        class: D([\"navbar-toggler\", o.value]),\n        type: \"button\",\n        disabled: l.disabled,\n        \"aria-label\": s.label,\n        onClick: r\n      }, [T(s.$slots, \"default\", {}, () => [Ld])], 10, Fd)), [[O(Na), l.disabled ? void 0 : s.target]]);\n    }\n  }),\n  Hd = [\"id\", \"aria-labelledby\"],\n  Rd = [\"id\"],\n  Md = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BOffcanvas\",\n    props: /* @__PURE__ */pe({\n      backdrop: {\n        type: Boolean,\n        default: !0\n      },\n      backdropBlur: {\n        default: void 0\n      },\n      backdropVariant: {\n        default: \"dark\"\n      },\n      bodyAttrs: {\n        default: void 0\n      },\n      bodyClass: {\n        default: void 0\n      },\n      bodyScrolling: {\n        type: Boolean,\n        default: !1\n      },\n      footerClass: {\n        default: void 0\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerCloseClass: {\n        default: void 0\n      },\n      headerCloseLabel: {\n        default: \"Close\"\n      },\n      headerCloseVariant: {\n        default: \"secondary\"\n      },\n      id: {\n        default: void 0\n      },\n      lazy: {\n        type: Boolean,\n        default: !1\n      },\n      modelValue: {\n        type: Boolean\n      },\n      noCloseOnBackdrop: {\n        type: Boolean,\n        default: !1\n      },\n      noCloseOnEsc: {\n        type: Boolean,\n        default: !1\n      },\n      noFocus: {\n        type: Boolean,\n        default: !1\n      },\n      noHeader: {\n        type: Boolean,\n        default: !1\n      },\n      noHeaderClose: {\n        type: Boolean,\n        default: !1\n      },\n      placement: {\n        default: \"start\"\n      },\n      shadow: {\n        type: [Object, Boolean],\n        default: !1\n      },\n      title: {\n        default: void 0\n      },\n      teleportDisabled: {\n        default: !1\n      },\n      teleportTo: {\n        default: \"body\"\n      }\n    }, {\n      modelValue: {\n        type: Boolean,\n        default: !1\n      },\n      modelModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"close\", \"esc\", \"hidden\", \"hide\", \"hide-prevented\", \"show\", \"show-prevented\", \"shown\"], [\"update:modelValue\"]),\n    setup(t, {\n      expose: e,\n      emit: l\n    }) {\n      const a = t,\n        o = l,\n        r = Le(),\n        s = he(t, \"modelValue\"),\n        n = Be(() => a.id, \"offcanvas\");\n      Uo(s, () => a.bodyScrolling);\n      const i = x(null);\n      Re(\"Escape\", () => {\n        C(\"esc\");\n      }, {\n        target: i\n      });\n      const {\n          focused: u\n        } = Pe(i, {\n          initialValue: s.value && a.noFocus === !1\n        }),\n        d = x(s.value),\n        p = x(!1),\n        f = k(() => a.backdrop === !0 && s.value === !0),\n        m = k(() => a.lazy === !1 || a.lazy === !0 && p.value === !0 || a.lazy === !0 && s.value === !0),\n        y = k(() => !Ae(r[\"header-close\"])),\n        h = w(() => [{\n          \"text-reset\": !y.value\n        }, a.headerCloseClass]),\n        c = w(() => ({\n          variant: y.value ? a.headerCloseVariant : void 0,\n          class: h.value\n        })),\n        g = k(() => !Ae(r.footer)),\n        v = w(() => [\n        // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,\n        \"offcanvas\",\n        // Remove when above check is fixed\n        `offcanvas-${a.placement}`, {\n          show: s.value && d.value === !0,\n          [`shadow-${a.shadow}`]: !!a.shadow\n        }]),\n        $ = w(() => ({\n          visible: s.value,\n          placement: a.placement,\n          hide: C\n        })),\n        B = (R, le = {}) => new Bt(R, {\n          cancelable: !1,\n          target: i.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...le,\n          componentId: n.value\n        }),\n        C = (R = \"\") => {\n          if (R === \"backdrop\" && a.noCloseOnBackdrop || R === \"esc\" && a.noCloseOnEsc) {\n            o(\"hide-prevented\");\n            return;\n          }\n          const le = B(\"hide\", {\n            cancelable: R !== \"\",\n            trigger: R\n          });\n          if (R === \"close\" && o(R, le), R === \"esc\" && o(R, le), o(\"hide\", le), le.defaultPrevented) {\n            o(\"hide-prevented\");\n            return;\n          }\n          s.value = !1;\n        },\n        V = () => {\n          const R = B(\"show\", {\n            cancelable: !0\n          });\n          if (o(\"show\", R), R.defaultPrevented) {\n            s.value = !1, o(\"show-prevented\");\n            return;\n          }\n          s.value = !0;\n        },\n        L = () => {\n          Ve(() => {\n            a.noFocus === !1 && (u.value = !0);\n          });\n        },\n        Q = () => V(),\n        W = () => {\n          d.value = !0, L(), o(\"shown\", B(\"shown\")), a.lazy === !0 && (p.value = !0);\n        },\n        F = () => {\n          d.value = !1;\n        },\n        Z = () => {\n          o(\"hidden\", B(\"hidden\")), a.lazy === !0 && (p.value = !1);\n        };\n      return ke(i, \"bv-toggle\", () => {\n        s.value ? C() : V();\n      }), e({\n        hide: C,\n        show: V\n      }), (R, le) => (b(), I(ht, {\n        to: R.teleportTo,\n        disabled: a.teleportDisabled\n      }, [ve(It, {\n        \"no-fade\": !0,\n        \"trans-props\": {\n          enterToClass: \"showing\",\n          enterFromClass: \"\",\n          leaveToClass: \"hiding show\",\n          leaveFromClass: \"show\"\n        },\n        onBeforeEnter: Q,\n        onAfterEnter: W,\n        onLeave: F,\n        onAfterLeave: Z\n      }, {\n        default: E(() => [ut(J(\"div\", K({\n          id: O(n),\n          ref_key: \"element\",\n          ref: i,\n          \"aria-modal\": \"true\",\n          role: \"dialog\",\n          class: v.value,\n          tabindex: \"-1\",\n          \"aria-labelledby\": `${O(n)}-offcanvas-label`,\n          \"data-bs-backdrop\": \"false\"\n        }, R.$attrs), [m.value ? (b(), _(de, {\n          key: 0\n        }, [a.noHeader ? ae(\"\", !0) : (b(), _(\"div\", {\n          key: 0,\n          class: D([\"offcanvas-header\", R.headerClass])\n        }, [T(R.$slots, \"header\", ge(we($.value)), () => [J(\"h5\", {\n          id: `${O(n)}-offcanvas-label`,\n          class: \"offcanvas-title\"\n        }, [T(R.$slots, \"title\", ge(we($.value)), () => [ne(Y(R.title), 1)])], 8, Rd), a.noHeaderClose ? ae(\"\", !0) : (b(), _(de, {\n          key: 0\n        }, [y.value ? (b(), I(vt, K({\n          key: 0\n        }, c.value, {\n          onClick: le[0] || (le[0] = N => C(\"close\"))\n        }), {\n          default: E(() => [T(R.$slots, \"header-close\")]),\n          _: 3\n        }, 16)) : (b(), I(Pt, K({\n          key: 1,\n          \"aria-label\": R.headerCloseLabel\n        }, c.value, {\n          onClick: le[1] || (le[1] = N => C(\"close\"))\n        }), null, 16, [\"aria-label\"]))], 64))])], 2)), J(\"div\", K({\n          class: [\"offcanvas-body\", R.bodyClass]\n        }, R.bodyAttrs), [T(R.$slots, \"default\", ge(we($.value)))], 16), g.value ? (b(), _(\"div\", {\n          key: 1,\n          class: D(R.footerClass)\n        }, [T(R.$slots, \"footer\", ge(we($.value)))], 2)) : ae(\"\", !0)], 64)) : ae(\"\", !0)], 16, Hd), [[xt, s.value]])]),\n        _: 3\n      }), T(R.$slots, \"backdrop\", {}, () => [ve(ma, {\n        blur: R.backdropBlur,\n        variant: R.backdropVariant,\n        show: f.value,\n        fixed: \"\",\n        \"no-wrap\": \"\",\n        \"no-spinner\": \"\",\n        onClick: le[2] || (le[2] = N => C(\"backdrop\"))\n      }, null, 8, [\"blur\", \"variant\", \"show\"])])], 8, [\"to\", \"disabled\"]));\n    }\n  }),\n  xd = [\"aria-disabled\", \"aria-label\"],\n  Ll = 20,\n  zl = 0,\n  Dd = /* @__PURE__ */H({\n    __name: \"BPagination\",\n    props: /* @__PURE__ */pe({\n      align: {\n        default: \"start\"\n      },\n      ariaControls: {\n        default: void 0\n      },\n      ariaLabel: {\n        default: \"Pagination\"\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      ellipsisClass: {\n        default: void 0\n      },\n      ellipsisText: {\n        default: \"…\"\n      },\n      firstClass: {\n        default: void 0\n      },\n      firstNumber: {\n        type: Boolean,\n        default: !1\n      },\n      firstText: {\n        default: \"«\"\n      },\n      hideEllipsis: {\n        type: Boolean,\n        default: !1\n      },\n      hideGotoEndButtons: {\n        type: Boolean,\n        default: !1\n      },\n      labelFirstPage: {\n        default: \"Go to first page\"\n      },\n      labelLastPage: {\n        default: \"Go to last page\"\n      },\n      labelNextPage: {\n        default: \"Go to next page\"\n      },\n      labelPage: {\n        default: \"Go to page\"\n      },\n      labelPrevPage: {\n        default: \"Go to previous page\"\n      },\n      lastClass: {\n        default: void 0\n      },\n      lastNumber: {\n        type: Boolean,\n        default: !1\n      },\n      lastText: {\n        default: \"»\"\n      },\n      limit: {\n        default: 5\n      },\n      modelValue: {},\n      nextClass: {\n        default: void 0\n      },\n      nextText: {\n        default: \"›\"\n      },\n      pageClass: {\n        default: void 0\n      },\n      perPage: {\n        default: Ll\n      },\n      pills: {\n        type: Boolean,\n        default: !1\n      },\n      prevClass: {\n        default: void 0\n      },\n      prevText: {\n        default: \"‹\"\n      },\n      size: {\n        default: void 0\n      },\n      totalRows: {\n        default: zl\n      }\n    }, {\n      modelValue: {\n        default: 1\n      },\n      modelModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"page-click\"], [\"update:modelValue\"]),\n    setup(t, {\n      emit: e\n    }) {\n      const i = t,\n        u = e,\n        d = he(t, \"modelValue\"),\n        p = be(() => i.limit, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        f = be(() => i.perPage, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        m = be(() => i.totalRows, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        y = be(d, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        h = k(() => Math.max(f.value || Ll, 1)),\n        c = k(() => Math.max(m.value || zl, 0)),\n        g = k(() => Math.ceil(c.value / h.value)),\n        v = k(() => i.align === \"fill\"),\n        $ = k(() => i.align === \"fill\" ? \"start\" : i.align),\n        B = Dt($),\n        C = te => te === y.value,\n        V = te => i.disabled ? null : C(te) ? \"0\" : \"-1\",\n        L = te => i.disabled || C(te) || y.value < 1 ||\n        // Check if the number is out of bounds\n        te < 1 || te > g.value,\n        Q = w(() => L(1)),\n        W = w(() => L(y.value - 1)),\n        F = w(() => L(g.value)),\n        Z = w(() => L(y.value + 1)),\n        R = ({\n          page: te,\n          classVal: ye,\n          dis: ee,\n          slotName: U,\n          textValue: z,\n          tabIndex: oe,\n          label: fe,\n          position: ce,\n          isActive: Oe,\n          role: $e,\n          hidden: Te\n        }) => ({\n          li: {\n            class: [\"page-item\", {\n              active: Oe,\n              disabled: ee,\n              \"flex-fill\": v.value,\n              \"d-flex\": v.value && !ee\n            }, ye],\n            role: $e,\n            \"aria-hidden\": Te\n          },\n          button: {\n            is: ee ? \"span\" : \"button\",\n            class: [\"page-link\", {\n              \"flex-grow-1\": !ee && v.value\n            }],\n            \"aria-label\": fe,\n            \"aria-controls\": i.ariaControls || void 0,\n            \"aria-disabled\": ee ? !0 : void 0,\n            \"aria-posinset\": ce,\n            \"aria-setsize\": ce ? g.value : void 0,\n            role: \"menuitem\",\n            type: ee ? void 0 : \"button\",\n            tabindex: ee ? void 0 : oe\n          },\n          text: {\n            name: U,\n            active: Oe,\n            value: z ?? te,\n            page: te,\n            disabled: ee,\n            index: te - 1,\n            content: z ? void 0 : te\n          },\n          clickHandler: Ye => se(Ye, te)\n        }),\n        le = ({\n          page: te,\n          classVal: ye,\n          dis: ee,\n          slotName: U,\n          textValue: z,\n          label: oe\n        }) => R({\n          page: te,\n          classVal: ye,\n          dis: ee,\n          slotName: U,\n          textValue: z,\n          label: oe,\n          tabIndex: \"-1\"\n        }),\n        N = te => R({\n          page: te,\n          dis: i.disabled,\n          classVal: i.pageClass,\n          slotName: \"page\",\n          label: i.labelPage ? `${i.labelPage} ${te}` : void 0,\n          tabIndex: V(te) ?? void 0,\n          position: te,\n          isActive: C(te)\n        }),\n        S = w(() => le({\n          page: 1,\n          dis: Q.value,\n          classVal: i.firstClass,\n          slotName: \"first-text\",\n          textValue: i.firstText,\n          label: i.labelFirstPage\n        })),\n        P = w(() => le({\n          page: Math.max(y.value - 1, 1),\n          dis: W.value,\n          classVal: i.prevClass,\n          slotName: \"prev-text\",\n          textValue: i.prevText,\n          label: i.labelPrevPage\n        })),\n        M = w(() => le({\n          page: Math.min(y.value + 1, g.value),\n          dis: Z.value,\n          classVal: i.nextClass,\n          slotName: \"next-text\",\n          textValue: i.nextText,\n          label: i.labelNextPage\n        })),\n        j = w(() => le({\n          page: g.value,\n          dis: F.value,\n          classVal: i.lastClass,\n          slotName: \"last-text\",\n          textValue: i.lastText,\n          label: i.labelLastPage\n        })),\n        A = zt(),\n        X = zt(),\n        G = w(() => ({\n          li: {\n            class: [\"page-item\", \"disabled\", \"bv-d-xs-down-none\", v.value ? \"flex-fill\" : \"\", i.ellipsisClass],\n            role: \"separator\"\n          },\n          span: {\n            class: [\"page-link\"]\n          }\n        })),\n        ie = w(() => [B.value, {\n          [`pagination-${i.size}`]: i.size !== void 0,\n          \"b-pagination-pills\": i.pills\n        }]),\n        q = w(() => ({\n          pageSize: h.value,\n          totalRows: m.value,\n          numberOfPages: g.value\n        })),\n        se = (te, ye) => {\n          if (ye === y.value) return;\n          const ee = new nt(\"page-click\", {\n            cancelable: !0,\n            target: te.target\n          });\n          u(\"page-click\", ee, ye), !ee.defaultPrevented && (d.value = ye);\n        };\n      ue(y, te => {\n        const ee = ((U, z) => {\n          const oe = U || 1;\n          return oe > z ? z : oe < 1 ? 1 : oe;\n        })(te, g.value);\n        ee !== d.value && (d.value = ee);\n      }), ue(q, (te, ye) => {\n        (ye.pageSize !== te.pageSize && ye.totalRows === te.totalRows || ye.numberOfPages !== te.numberOfPages && y.value > ye.numberOfPages) && (d.value = 1);\n      });\n      const me = w(() => {\n        const te = g.value,\n          {\n            value: ye\n          } = y,\n          ee = p.value,\n          U = i.firstNumber ? 1 : 0,\n          z = i.lastNumber ? 1 : 0,\n          oe = i.hideEllipsis || ee <= 3,\n          fe = i.hideGotoEndButtons ? 1 : 0;\n        if (te < ee + U + z) return [!U && !fe ? -1 : null, -2, ...Array.from({\n          length: te\n        }, ($e, Te) => Te + 1), -3, !z && !fe ? -4 : null].filter($e => $e !== null);\n        const ce = Array.from({\n          length: ee + 4 - fe * 2\n        });\n        fe ? (ce[0] = -2, ce[ce.length - 1] = -3) : (U ? (ce[0] = -2, ce[1] = 1) : (ce[0] = -1, ce[1] = -2), z ? (ce[ce.length - 1] = -3, ce[ce.length - 2] = te) : (ce[ce.length - 1] = -4, ce[ce.length - 2] = -3));\n        const Oe = Math.floor(ee / 2);\n        if (ye <= Oe + U) {\n          for (let $e = 1; $e <= ee; $e++) ce[$e + 1 - fe] = $e + U;\n          oe || (ce[ce.length - 3] = -5);\n        }\n        if (ye > te - Oe - z) {\n          const $e = te - (ee - 1) - z;\n          for (let Te = 0; Te < ee; Te++) ce[Te + 2 - fe] = $e + Te;\n          oe || (ce[2] = -5);\n        }\n        if (!ce[2]) {\n          const $e = ye - Math.floor(ee / 2);\n          for (let Te = 0; Te < ee; Te++) ce[Te + 2 - fe] = $e + Te;\n          oe || (ce[2] = -5, ce[ce.length - 3] = -5);\n        }\n        return ce;\n      });\n      return (te, ye) => (b(), _(\"ul\", {\n        class: D([\"pagination\", ie.value]),\n        role: \"menubar\",\n        \"aria-disabled\": i.disabled,\n        \"aria-label\": te.ariaLabel || void 0\n      }, [ve(O(A).define, null, {\n        default: E(({\n          button: ee,\n          li: U,\n          text: z,\n          clickHandler: oe\n        }) => [J(\"li\", ge(we(U)), [(b(), I(re(ee.is), K(ee, {\n          onClick: oe\n        }), {\n          default: E(() => [T(te.$slots, z.name, {\n            disabled: z.disabled,\n            page: z.page,\n            index: z.index,\n            active: z.active,\n            content: z.value\n          }, () => [ne(Y(z.value), 1)])]),\n          _: 2\n        }, 1040, [\"onClick\"]))], 16)]),\n        _: 3\n      }), ve(O(X).define, null, {\n        default: E(() => [J(\"li\", ge(we(G.value.li)), [J(\"span\", ge(we(G.value.span)), [T(te.$slots, \"ellipsis-text\", {}, () => [ne(Y(te.ellipsisText || \"...\"), 1)])], 16)], 16)]),\n        _: 3\n      }), (b(!0), _(de, null, Ce(me.value, ee => (b(), _(de, {\n        key: `page-${ee.number}`\n      }, [ee === -1 ? (b(), I(O(A).reuse, K({\n        key: 0,\n        ref_for: !0\n      }, S.value), null, 16)) : ee === -2 ? (b(), I(O(A).reuse, K({\n        key: 1,\n        ref_for: !0\n      }, P.value), null, 16)) : ee === -3 ? (b(), I(O(A).reuse, K({\n        key: 2,\n        ref_for: !0\n      }, M.value), null, 16)) : ee === -4 ? (b(), I(O(A).reuse, K({\n        key: 3,\n        ref_for: !0\n      }, j.value), null, 16)) : ee === -5 ? (b(), I(O(X).reuse, {\n        key: 4\n      })) : (b(), I(O(A).reuse, K({\n        key: 5,\n        ref_for: !0\n      }, N(ee)), null, 16))], 64))), 128))], 10, xd));\n    }\n  }),\n  je = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BPlaceholder\",\n    props: {\n      animation: {\n        default: void 0\n      },\n      cols: {\n        default: 12\n      },\n      size: {\n        default: \"md\"\n      },\n      tag: {\n        default: \"span\"\n      },\n      variant: {\n        default: null\n      },\n      width: {\n        default: void 0\n      },\n      wrapperTag: {\n        default: \"span\"\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = k(() => e.width === void 0 ? void 0 : typeof e.width == \"number\" ? e.width.toString() : e.width.replace(\"%\", \"\")),\n        a = k(() => e.cols === void 0 ? void 0 : typeof e.cols == \"number\" ? e.cols.toString() : e.cols),\n        o = w(() => ({\n          [`col-${a.value}`]: a.value !== void 0 && l.value === void 0,\n          [`bg-${e.variant}`]: e.variant !== null,\n          [`placeholder-${e.size}`]: e.size !== \"md\"\n        })),\n        r = w(() => ({\n          [`placeholder-${e.animation}`]: e.animation !== void 0\n        })),\n        s = w(() => ({\n          width: l.value === void 0 ? void 0 : `${l.value}%`\n        }));\n      return (n, i) => (b(), I(re(n.wrapperTag), {\n        class: D(r.value)\n      }, {\n        default: E(() => [(b(), I(re(n.tag), K(n.$attrs, {\n          class: [\"placeholder\", o.value],\n          style: s.value\n        }), null, 16, [\"class\", \"style\"]))]),\n        _: 1\n      }, 8, [\"class\"]));\n    }\n  }),\n  hn = /* @__PURE__ */H({\n    __name: \"BPlaceholderButton\",\n    props: {\n      animation: {\n        default: void 0\n      },\n      cols: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      variant: {\n        default: \"primary\"\n      },\n      width: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => ({\n          [`btn-${e.variant}`]: e.variant !== null\n        }));\n      return (a, o) => (b(), I(je, {\n        class: D([\"btn disabled\", l.value]),\n        animation: a.animation,\n        width: a.width,\n        cols: a.cols,\n        tag: a.tag,\n        style: {\n          cursor: \"wait\",\n          \"pointer-events\": \"auto\"\n        }\n      }, null, 8, [\"class\", \"animation\", \"width\", \"cols\", \"tag\"]));\n    }\n  }),\n  jd = /* @__PURE__ */H({\n    __name: \"BPlaceholderCard\",\n    props: {\n      animation: {\n        default: void 0\n      },\n      footerAnimation: {\n        default: void 0\n      },\n      footerSize: {\n        default: \"md\"\n      },\n      footerVariant: {\n        default: void 0\n      },\n      footerWidth: {\n        default: 100\n      },\n      headerAnimation: {\n        default: void 0\n      },\n      headerSize: {\n        default: \"md\"\n      },\n      headerVariant: {\n        default: void 0\n      },\n      headerWidth: {\n        default: 100\n      },\n      imgBlankColor: {\n        default: \"#868e96\"\n      },\n      imgBottom: {\n        type: Boolean,\n        default: !1\n      },\n      imgHeight: {\n        default: 100\n      },\n      imgSrc: {\n        default: void 0\n      },\n      noButton: {\n        type: Boolean,\n        default: !1\n      },\n      noFooter: {\n        type: Boolean,\n        default: !1\n      },\n      noHeader: {\n        type: Boolean,\n        default: !1\n      },\n      noImg: {\n        type: Boolean,\n        default: !1\n      },\n      size: {\n        default: \"md\"\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => ({\n          animation: e.animation,\n          size: e.size,\n          variant: e.variant\n        })),\n        a = k(() => e.noButton ? je : hn);\n      return (o, r) => (b(), I(rn, {\n        \"img-bottom\": o.imgBottom\n      }, La({\n        default: E(() => [T(o.$slots, \"default\", {}, () => [ve(je, K({\n          cols: \"7\"\n        }, l.value), null, 16), ve(je, K({\n          cols: \"4\"\n        }, l.value), null, 16), ve(je, K({\n          cols: \"4\"\n        }, l.value), null, 16), ve(je, K({\n          cols: \"6\"\n        }, l.value), null, 16), ve(je, K({\n          cols: \"8\"\n        }, l.value), null, 16)])]),\n        _: 2\n      }, [e.noImg ? void 0 : {\n        name: \"img\",\n        fn: E(() => [T(o.$slots, \"img\", {}, () => [ve(tl, {\n          blank: !o.imgSrc,\n          \"blank-color\": o.imgBlankColor,\n          height: o.imgSrc ? void 0 : o.imgHeight,\n          src: o.imgSrc,\n          top: !o.imgBottom,\n          bottom: o.imgBottom,\n          style: {\n            cursor: \"wait\"\n          }\n        }, null, 8, [\"blank\", \"blank-color\", \"height\", \"src\", \"top\", \"bottom\"])])]),\n        key: \"0\"\n      }, e.noHeader ? void 0 : {\n        name: \"header\",\n        fn: E(() => [T(o.$slots, \"header\", {}, () => [ve(je, {\n          width: o.headerWidth,\n          variant: o.headerVariant,\n          animation: o.headerAnimation,\n          size: o.headerSize\n        }, null, 8, [\"width\", \"variant\", \"animation\", \"size\"])])]),\n        key: \"1\"\n      }, e.noFooter ? void 0 : {\n        name: \"footer\",\n        fn: E(() => [T(o.$slots, \"footer\", {}, () => [(b(), I(re(a.value), {\n          width: o.footerWidth,\n          animation: o.footerAnimation,\n          size: e.noButton ? o.footerSize : void 0,\n          variant: o.footerVariant\n        }, null, 8, [\"width\", \"animation\", \"size\", \"variant\"]))])]),\n        key: \"2\"\n      }]), 1032, [\"img-bottom\"]));\n    }\n  }),\n  qd = \"300px\",\n  ol = /* @__PURE__ */H({\n    __name: \"BTableSimple\",\n    props: {\n      bordered: {\n        type: Boolean,\n        default: !1\n      },\n      borderless: {\n        type: Boolean,\n        default: !1\n      },\n      borderVariant: {\n        default: null\n      },\n      captionTop: {\n        type: Boolean,\n        default: !1\n      },\n      dark: {\n        type: Boolean,\n        default: !1\n      },\n      fixed: {\n        type: Boolean,\n        default: !1\n      },\n      hover: {\n        type: Boolean,\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      noBorderCollapse: {\n        type: Boolean,\n        default: !1\n      },\n      outlined: {\n        type: Boolean,\n        default: !1\n      },\n      responsive: {\n        type: [Boolean, String],\n        default: !1\n      },\n      small: {\n        type: Boolean,\n        default: !1\n      },\n      stacked: {\n        type: [Boolean, String],\n        default: !1\n      },\n      stickyHeader: {\n        type: [Boolean, String, Number],\n        default: !1\n      },\n      striped: {\n        type: Boolean,\n        default: !1\n      },\n      stripedColumns: {\n        type: Boolean,\n        default: !1\n      },\n      tableClass: {\n        default: void 0\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => [e.tableClass, \"table\", \"b-table\", {\n          \"table-bordered\": e.bordered,\n          \"table-borderless\": e.borderless,\n          [`border-${e.borderVariant}`]: e.borderVariant !== null,\n          \"caption-top\": e.captionTop,\n          \"table-dark\": e.dark,\n          \"table-hover\": e.hover,\n          \"b-table-stacked\": e.stacked === !0,\n          [`b-table-stacked-${e.stacked}`]: typeof e.stacked == \"string\",\n          \"table-striped\": e.striped,\n          \"table-sm\": e.small,\n          [`table-${e.variant}`]: e.variant !== null,\n          \"table-striped-columns\": e.stripedColumns\n        }]),\n        a = w(() => ({\n          id: e.id,\n          class: l.value\n        })),\n        o = ia(w(() => (e.stickyHeader === !0 ? qd : e.stickyHeader) || NaN)),\n        r = w(() => e.stickyHeader !== !1),\n        s = w(() => e.responsive !== !1 || r.value),\n        n = w(() => r.value ? {\n          maxHeight: o.value\n        } : void 0),\n        i = w(() => ({\n          \"table-responsive\": e.responsive === !0,\n          [`table-responsive-${e.responsive}`]: typeof e.responsive == \"string\",\n          \"b-table-sticky-header\": r.value\n        }));\n      return (u, d) => s.value ? (b(), _(\"div\", {\n        key: 0,\n        class: D(i.value),\n        style: Ee(n.value)\n      }, [J(\"table\", ge(we(a.value)), [T(u.$slots, \"default\")], 16)], 6)) : (b(), _(\"table\", ge(K({\n        key: 1\n      }, a.value)), [T(u.$slots, \"default\")], 16));\n    }\n  }),\n  Wd = /* @__PURE__ */H({\n    __name: \"BPlaceholderTable\",\n    props: {\n      animation: {\n        default: void 0\n      },\n      cellWidth: {\n        default: 100\n      },\n      columns: {\n        default: 5\n      },\n      footerAnimation: {\n        default: void 0\n      },\n      footerCellWidth: {\n        default: 100\n      },\n      footerColumns: {\n        default: void 0\n      },\n      footerSize: {\n        default: \"md\"\n      },\n      footerVariant: {\n        default: void 0\n      },\n      headerAnimation: {\n        default: void 0\n      },\n      headerCellWidth: {\n        default: 100\n      },\n      headerColumns: {\n        default: void 0\n      },\n      headerSize: {\n        default: \"md\"\n      },\n      headerVariant: {\n        default: void 0\n      },\n      hideHeader: {\n        type: Boolean,\n        default: !1\n      },\n      rows: {\n        default: 3\n      },\n      showFooter: {\n        type: Boolean,\n        default: !1\n      },\n      size: {\n        default: \"md\"\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = be(() => e.columns),\n        a = be(() => e.rows),\n        o = k(() => e.headerColumns ?? NaN),\n        r = k(() => e.footerColumns ?? NaN),\n        s = be(o),\n        n = be(r),\n        i = k(() => l.value || 5),\n        u = k(() => a.value || 3),\n        d = k(() => e.headerColumns === void 0 ? i.value : s.value),\n        p = k(() => e.footerColumns === void 0 ? i.value : n.value);\n      return (f, m) => (b(), I(ol, null, {\n        default: E(() => [e.hideHeader ? ae(\"\", !0) : T(f.$slots, \"thead\", {\n          key: 0\n        }, () => [J(\"thead\", null, [J(\"tr\", null, [(b(!0), _(de, null, Ce(d.value, (y, h) => (b(), _(\"th\", {\n          key: h\n        }, [ve(je, {\n          size: f.headerSize,\n          variant: f.headerVariant,\n          animation: f.headerAnimation,\n          width: f.headerCellWidth\n        }, null, 8, [\"size\", \"variant\", \"animation\", \"width\"])]))), 128))])])]), T(f.$slots, \"default\", {}, () => [J(\"tbody\", null, [(b(!0), _(de, null, Ce(u.value, (y, h) => (b(), _(\"tr\", {\n          key: h\n        }, [(b(!0), _(de, null, Ce(i.value, (c, g) => (b(), _(\"td\", {\n          key: g\n        }, [ve(je, {\n          size: f.size,\n          variant: f.variant,\n          animation: f.animation,\n          width: f.cellWidth\n        }, null, 8, [\"size\", \"variant\", \"animation\", \"width\"])]))), 128))]))), 128))])]), e.showFooter ? T(f.$slots, \"tfoot\", {\n          key: 1\n        }, () => [J(\"tfoot\", null, [J(\"tr\", null, [(b(!0), _(de, null, Ce(p.value, (y, h) => (b(), _(\"th\", {\n          key: h\n        }, [ve(je, {\n          size: f.footerSize,\n          variant: f.footerVariant,\n          animation: f.footerAnimation,\n          width: f.footerCellWidth\n        }, null, 8, [\"size\", \"variant\", \"animation\", \"width\"])]))), 128))])])]) : ae(\"\", !0)]),\n        _: 3\n      }));\n    }\n  }),\n  Gd = /* @__PURE__ */H({\n    __name: \"BPlaceholderWrapper\",\n    props: {\n      loading: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    setup(t) {\n      const e = t;\n      return (l, a) => e.loading ? T(l.$slots, \"loading\", {\n        key: 0\n      }) : T(l.$slots, \"default\", {\n        key: 1\n      });\n    }\n  }),\n  Hl = fa(\"cols\", [\"\"], {\n    type: [String, Number],\n    default: null\n  }),\n  Ud = H({\n    name: \"BRow\",\n    slots: Object,\n    props: {\n      tag: {\n        type: String,\n        default: \"div\"\n      },\n      gutterX: {\n        type: String,\n        default: null\n      },\n      gutterY: {\n        type: String,\n        default: null\n      },\n      noGutters: {\n        type: Boolean,\n        default: !1\n      },\n      alignV: {\n        type: String,\n        default: null\n      },\n      alignH: {\n        type: String,\n        default: null\n      },\n      alignContent: {\n        type: String,\n        default: null\n      },\n      ...Hl\n    },\n    setup(t) {\n      const e = Dt(() => t.alignH),\n        l = w(() => ho(t, Hl, \"cols\", \"row-cols\"));\n      return {\n        computedClasses: w(() => [l.value, {\n          [`gx-${t.gutterX}`]: t.gutterX !== null,\n          [`gy-${t.gutterY}`]: t.gutterY !== null,\n          \"g-0\": t.noGutters,\n          [`align-items-${t.alignV}`]: t.alignV !== null,\n          [e.value]: t.alignH !== null,\n          [`align-content-${t.alignContent}`]: t.alignContent !== null\n        }])\n      };\n    }\n  });\nfunction Kd(t, e, l, a, o, r) {\n  return b(), I(re(t.tag), {\n    class: D([\"row\", t.computedClasses])\n  }, {\n    default: E(() => [T(t.$slots, \"default\")]),\n    _: 3\n  }, 8, [\"class\"]);\n}\nconst Xd = /* @__PURE__ */qt(Ud, [[\"render\", Kd]]),\n  Ze = t => typeof t == \"object\" && t !== null,\n  Ia = t => typeof t == \"object\" && t !== null && \"key\" in t,\n  Bn = /* @__PURE__ */H({\n    __name: \"BTbody\",\n    props: {\n      variant: {\n        default: null\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => ({\n          [`thead-${e.variant}`]: e.variant !== null\n        }));\n      return (a, o) => (b(), _(\"tbody\", {\n        class: D(l.value)\n      }, [T(a.$slots, \"default\")], 2));\n    }\n  }),\n  Yd = [\"scope\", \"colspan\", \"rowspan\", \"data-label\"],\n  Zd = {\n    key: 0\n  },\n  St = /* @__PURE__ */H({\n    __name: \"BTd\",\n    props: {\n      colspan: {\n        default: void 0\n      },\n      rowspan: {\n        default: void 0\n      },\n      stackedHeading: {\n        default: void 0\n      },\n      stickyColumn: {\n        type: Boolean,\n        default: !1\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => ({\n          [`table-${e.variant}`]: e.variant !== null,\n          \"b-table-sticky-column\": e.stickyColumn,\n          \"table-b-table-default\": e.stickyColumn && e.variant === null\n        })),\n        a = k(() => e.colspan ? \"colspan\" : e.rowspan ? \"rowspan\" : \"col\");\n      return (o, r) => (b(), _(\"td\", {\n        scope: a.value,\n        class: D(l.value),\n        colspan: o.colspan,\n        rowspan: o.rowspan,\n        \"data-label\": o.stackedHeading\n      }, [o.stackedHeading ? (b(), _(\"div\", Zd, [T(o.$slots, \"default\")])) : T(o.$slots, \"default\", {\n        key: 1\n      })], 10, Yd));\n    }\n  }),\n  Pa = /* @__PURE__ */H({\n    __name: \"BTfoot\",\n    props: {\n      variant: {\n        default: null\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => ({\n          [`table-${e.variant}`]: e.variant !== null\n        }));\n      return (a, o) => (b(), _(\"tfoot\", {\n        class: D(l.value)\n      }, [T(a.$slots, \"default\")], 2));\n    }\n  }),\n  Jd = [\"scope\", \"colspan\", \"rowspan\", \"data-label\"],\n  Qd = {\n    key: 0\n  },\n  Ea = /* @__PURE__ */H({\n    __name: \"BTh\",\n    props: {\n      colspan: {\n        default: void 0\n      },\n      rowspan: {\n        default: void 0\n      },\n      stackedHeading: {\n        default: void 0\n      },\n      stickyColumn: {\n        type: Boolean,\n        default: !1\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => ({\n          [`table-${e.variant}`]: e.variant !== null,\n          \"b-table-sticky-column\": e.stickyColumn,\n          \"table-b-table-default\": e.stickyColumn && e.variant === null\n        })),\n        a = k(() => e.colspan ? \"colspan\" : e.rowspan ? \"rowspan\" : \"col\");\n      return (o, r) => (b(), _(\"th\", {\n        scope: a.value,\n        class: D(l.value),\n        colspan: o.colspan,\n        rowspan: o.rowspan,\n        \"data-label\": o.stackedHeading\n      }, [o.stackedHeading !== void 0 ? (b(), _(\"div\", Qd, [T(o.$slots, \"default\")])) : T(o.$slots, \"default\", {\n        key: 1\n      })], 10, Jd));\n    }\n  }),\n  wn = /* @__PURE__ */H({\n    __name: \"BThead\",\n    props: {\n      variant: {\n        default: null\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => ({\n          [`table-${e.variant}`]: e.variant !== null\n        }));\n      return (a, o) => (b(), _(\"thead\", {\n        class: D(l.value)\n      }, [T(a.$slots, \"default\")], 2));\n    }\n  }),\n  Je = /* @__PURE__ */H({\n    __name: \"BTr\",\n    props: {\n      variant: {\n        default: null\n      }\n    },\n    setup(t) {\n      const e = t,\n        l = w(() => ({\n          [`table-${e.variant}`]: e.variant !== null\n        }));\n      return (a, o) => (b(), _(\"tr\", {\n        class: D(l.value)\n      }, [T(a.$slots, \"default\")], 2));\n    }\n  }),\n  ec = {\n    key: 0,\n    class: \"b-table-stacked-label\"\n  },\n  tc = {\n    class: \"d-inline-flex flex-nowrap align-items-center gap-1\"\n  },\n  ac = {\n    key: 2\n  },\n  Cn = /* @__PURE__ */H({\n    __name: \"BTableLite\",\n    props: {\n      align: {\n        default: void 0\n      },\n      caption: {\n        default: void 0\n      },\n      captionHtml: {\n        default: void 0\n      },\n      detailsTdClass: {\n        default: void 0\n      },\n      emptyFilteredText: {\n        default: \"There are no records matching your request\"\n      },\n      emptyText: {\n        default: \"There are no records to show\"\n      },\n      fieldColumnClass: {\n        type: [Function, String, Object, Array],\n        default: void 0\n      },\n      fields: {\n        default: () => []\n      },\n      footClone: {\n        type: Boolean,\n        default: !1\n      },\n      footRowVariant: {\n        default: void 0\n      },\n      footVariant: {\n        default: void 0\n      },\n      headRowVariant: {\n        default: void 0\n      },\n      headVariant: {\n        default: void 0\n      },\n      items: {\n        default: () => []\n      },\n      labelStacked: {\n        type: Boolean,\n        default: !1\n      },\n      modelValue: {\n        default: void 0\n      },\n      primaryKey: {\n        default: void 0\n      },\n      showEmpty: {\n        type: Boolean,\n        default: !1\n      },\n      tbodyClass: {\n        default: void 0\n      },\n      tbodyTrAttr: {\n        default: void 0\n      },\n      tbodyTrClass: {\n        type: [Function, String, Object, Array],\n        default: void 0\n      },\n      tfootClass: {\n        default: void 0\n      },\n      tfootTrClass: {\n        default: void 0\n      },\n      theadClass: {\n        default: void 0\n      },\n      theadTrClass: {\n        default: void 0\n      },\n      bordered: {\n        type: Boolean,\n        default: void 0\n      },\n      borderless: {\n        type: Boolean,\n        default: void 0\n      },\n      borderVariant: {\n        default: void 0\n      },\n      captionTop: {\n        type: Boolean,\n        default: void 0\n      },\n      dark: {\n        type: Boolean,\n        default: void 0\n      },\n      fixed: {\n        type: Boolean,\n        default: void 0\n      },\n      hover: {\n        type: Boolean,\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      noBorderCollapse: {\n        type: Boolean,\n        default: void 0\n      },\n      outlined: {\n        type: Boolean,\n        default: void 0\n      },\n      responsive: {\n        type: [Boolean, String],\n        default: void 0\n      },\n      small: {\n        type: Boolean,\n        default: void 0\n      },\n      stacked: {\n        type: [Boolean, String],\n        default: void 0\n      },\n      stickyHeader: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      striped: {\n        type: Boolean,\n        default: void 0\n      },\n      stripedColumns: {\n        type: Boolean,\n        default: void 0\n      },\n      tableClass: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    emits: [\"head-clicked\", \"row-clicked\", \"row-dbl-clicked\", \"row-hovered\", \"row-unhovered\"],\n    setup(t, {\n      emit: e\n    }) {\n      const l = t,\n        a = e,\n        o = c => [c, c._showDetails],\n        r = x(new WeakMap(l.items.reduce((c, g) => (Ze(g) && c.push(o(g)), c), [])));\n      ue(() => l.items, c => {\n        c.forEach(g => {\n          if (!Ze(g)) return;\n          const v = o(g);\n          r.value.set(v[0], v[1]);\n        });\n      }, {\n        deep: !0\n      });\n      const s = w(() => [l.tableClass, {\n          [`align-${l.align}`]: l.align !== void 0\n        }]),\n        n = w(() => {\n          if (!l.fields.length && l.items.length) {\n            const [c] = l.items;\n            return Ze(c) || Array.isArray(c) ? Object.keys(c).map(g => {\n              const v = ya(g);\n              return {\n                key: g,\n                label: v,\n                tdAttr: l.stacked === !0 ? {\n                  \"data-label\": v\n                } : void 0\n              };\n            }) : [{\n              key: \"\",\n              _noHeader: !0\n            }];\n          }\n          return l.fields.map(c => {\n            if (Ia(c)) return {\n              ...c,\n              tdAttr: l.stacked === !0 ? {\n                \"data-label\": ya(c.key),\n                ...c.tdAttr\n              } : c.tdAttr\n            };\n            const g = ya(c);\n            return {\n              key: c,\n              label: g,\n              tdAttr: l.stacked === !0 ? {\n                \"data-label\": g\n              } : void 0\n            };\n          });\n        }),\n        i = k(() => n.value.length),\n        u = w(() => !(n.value.length > 0 && n.value.every(c => c._noHeader === !0))),\n        d = (c, g, v) => {\n          const $ = qe(c, g);\n          return v && typeof v == \"function\" ? v($, g, c) : v;\n        },\n        p = (c, g, v = !1) => {\n          a(\"head-clicked\", c.key, c, g, v);\n        },\n        f = c => {\n          if (Ze(c)) {\n            const g = r.value.get(c);\n            r.value.set(c, !g);\n          }\n        },\n        m = c => [c.class, c.thClass, {\n          \"b-table-sticky-column\": c.stickyColumn\n        }, l.fieldColumnClass ? typeof l.fieldColumnClass == \"function\" ? l.fieldColumnClass(c) : l.fieldColumnClass : null],\n        y = (c, g) => {\n          var v, $;\n          return [c.class, c.tdClass, Ze(g) && (v = g._cellVariants) != null && v[c.key] ? `table-${($ = g._cellVariants) == null ? void 0 : $[c.key]}` : null, {\n            \"b-table-sticky-column\": c.stickyColumn\n          }];\n        },\n        h = (c, g) => l.tbodyTrClass ? typeof l.tbodyTrClass == \"function\" ? l.tbodyTrClass(c, g) : l.tbodyTrClass : null;\n      return (c, g) => (b(), I(ol, {\n        id: c.id,\n        bordered: c.bordered,\n        borderless: c.borderless,\n        \"border-variant\": c.borderVariant,\n        \"caption-top\": c.captionTop,\n        dark: c.dark,\n        fixed: c.fixed,\n        hover: c.hover,\n        \"no-border-collapse\": c.noBorderCollapse,\n        outlined: c.outlined,\n        responsive: c.responsive,\n        small: c.small,\n        stacked: l.stacked,\n        \"sticky-header\": c.stickyHeader,\n        striped: c.striped,\n        \"table-class\": s.value,\n        variant: c.variant,\n        \"striped-columns\": c.stripedColumns\n      }, {\n        default: E(() => [ut(ve(wn, {\n          variant: c.headVariant,\n          class: D(c.theadClass)\n        }, {\n          default: E(() => [c.$slots[\"thead-top\"] ? T(c.$slots, \"thead-top\", {\n            key: 0\n          }) : ae(\"\", !0), ve(Je, {\n            variant: c.headRowVariant,\n            class: D(c.theadTrClass)\n          }, {\n            default: E(() => [(b(!0), _(de, null, Ce(n.value, v => (b(), I(Ea, K({\n              key: v.key,\n              scope: \"col\",\n              class: m(v),\n              title: v.headerTitle,\n              variant: v.variant,\n              abbr: v.headerAbbr,\n              style: v.thStyle,\n              ref_for: !0\n            }, v.thAttr, {\n              onClick: $ => p(v, $)\n            }), {\n              default: E(() => [T(c.$slots, c.$slots[`head(${String(v.key)})`] ? `head(${String(v.key)})` : \"head()\", {\n                label: v.label,\n                column: v.key,\n                field: v,\n                isFoot: !1\n              }, () => [ne(Y(O(Jt)(v)), 1)])]),\n              _: 2\n            }, 1040, [\"class\", \"title\", \"variant\", \"abbr\", \"style\", \"onClick\"]))), 128))]),\n            _: 3\n          }, 8, [\"variant\", \"class\"]), c.$slots[\"thead-sub\"] ? (b(), I(Je, {\n            key: 1\n          }, {\n            default: E(() => [(b(!0), _(de, null, Ce(n.value, v => (b(), I(St, {\n              key: v.key,\n              scope: \"col\",\n              variant: v.variant,\n              class: D([v.class, v.thClass])\n            }, {\n              default: E(() => [T(c.$slots, \"thead-sub\", K({\n                items: n.value,\n                ref_for: !0\n              }, v), () => [ne(Y(v.label), 1)])]),\n              _: 2\n            }, 1032, [\"variant\", \"class\"]))), 128))]),\n            _: 3\n          })) : ae(\"\", !0)]),\n          _: 3\n        }, 8, [\"variant\", \"class\"]), [[xt, u.value]]), ve(Bn, {\n          class: D(c.tbodyClass)\n        }, {\n          default: E(() => [T(c.$slots, \"custom-body\", {\n            fields: n.value,\n            items: c.items,\n            columns: n.value.length\n          }, () => [!l.stacked && c.$slots[\"top-row\"] ? (b(), I(Je, {\n            key: 0\n          }, {\n            default: E(() => [T(c.$slots, \"top-row\")]),\n            _: 3\n          })) : ae(\"\", !0), (b(!0), _(de, null, Ce(c.items, (v, $) => (b(), _(de, {\n            key: $\n          }, [ve(Je, {\n            class: D(h(v, \"row\")),\n            variant: O(Ze)(v) ? v._rowVariant : void 0,\n            onClick: B => !O(Gt)(B) && a(\"row-clicked\", v, $, B),\n            onDblclick: B => !O(Gt)(B) && a(\"row-dbl-clicked\", v, $, B),\n            onMouseenter: B => !O(Gt)(B) && a(\"row-hovered\", v, $, B),\n            onMouseleave: B => !O(Gt)(B) && a(\"row-unhovered\", v, $, B)\n          }, {\n            default: E(() => [(b(!0), _(de, null, Ce(n.value, B => {\n              var C;\n              return b(), I(St, K({\n                key: B.key,\n                variant: O(Ze)(v) && (C = v._cellVariants) != null && C[B.key] ? null : B.variant,\n                class: y(B, v),\n                ref_for: !0\n              }, d(v, String(B.key), B.tdAttr)), {\n                default: E(() => [l.stacked && l.labelStacked ? (b(), _(\"label\", ec, Y(O(Jt)(B)), 1)) : ae(\"\", !0), T(c.$slots, c.$slots[`cell(${String(B.key)})`] ? `cell(${String(B.key)})` : \"cell()\", {\n                  value: O(qe)(v, String(B.key)),\n                  index: $,\n                  item: v,\n                  field: B,\n                  items: c.items,\n                  toggleDetails: () => {\n                    f(v);\n                  },\n                  detailsShowing: O(Ze)(v) ? r.value.get(v) ?? !1 : !1\n                }, () => [!c.$slots[`cell(${String(B.key)})`] && !c.$slots[\"cell()\"] ? (b(), _(de, {\n                  key: 0\n                }, [ne(Y(O(go)(v, String(B.key), B.formatter)), 1)], 64)) : ae(\"\", !0)])]),\n                _: 2\n              }, 1040, [\"variant\", \"class\"]);\n            }), 128))]),\n            _: 2\n          }, 1032, [\"class\", \"variant\", \"onClick\", \"onDblclick\", \"onMouseenter\", \"onMouseleave\"]), O(Ze)(v) && r.value.get(v) === !0 && c.$slots[\"row-details\"] ? (b(), _(de, {\n            key: 0\n          }, [ve(Je, {\n            \"aria-hidden\": \"true\",\n            role: \"presentation\",\n            class: \"d-none\"\n          }), ve(Je, {\n            class: D(h(v, \"row-details\")),\n            variant: v._rowVariant\n          }, {\n            default: E(() => [ve(St, {\n              colspan: i.value\n            }, {\n              default: E(() => [T(c.$slots, \"row-details\", {\n                item: v,\n                toggleDetails: () => {\n                  f(v);\n                },\n                fields: c.fields,\n                index: $\n              })]),\n              _: 2\n            }, 1032, [\"colspan\"])]),\n            _: 2\n          }, 1032, [\"class\", \"variant\"])], 64)) : ae(\"\", !0)], 64))), 128)), l.showEmpty && c.items.length === 0 ? (b(), I(Je, {\n            key: 1,\n            class: \"b-table-empty-slot\"\n          }, {\n            default: E(() => [ve(St, {\n              colspan: i.value\n            }, {\n              default: E(() => [T(c.$slots, \"empty\", {\n                items: c.items\n              }, () => [ne(Y(c.emptyText), 1)])]),\n              _: 3\n            }, 8, [\"colspan\"])]),\n            _: 3\n          })) : ae(\"\", !0), !l.stacked && c.$slots[\"bottom-row\"] ? (b(), I(Je, {\n            key: 2\n          }, {\n            default: E(() => [T(c.$slots, \"bottom-row\")]),\n            _: 3\n          })) : ae(\"\", !0)])]),\n          _: 3\n        }, 8, [\"class\"]), l.footClone ? (b(), I(Pa, {\n          key: 0,\n          variant: c.footVariant,\n          class: D(c.tfootClass)\n        }, {\n          default: E(() => [ve(Je, {\n            variant: c.footRowVariant,\n            class: D(c.tfootTrClass)\n          }, {\n            default: E(() => [(b(!0), _(de, null, Ce(n.value, v => (b(), I(Ea, K({\n              key: v.key,\n              scope: \"col\",\n              class: m(v),\n              title: v.headerTitle,\n              abbr: v.headerAbbr,\n              style: v.thStyle,\n              variant: v.variant,\n              ref_for: !0\n            }, v.thAttr, {\n              onClick: $ => p(v, $, !0)\n            }), {\n              default: E(() => [J(\"div\", tc, [J(\"div\", null, [T(c.$slots, c.$slots[`foot(${String(v.key)})`] ? `foot(${String(v.key)})` : \"foot()\", {\n                label: v.label,\n                column: v.key,\n                field: v,\n                isFoot: !0\n              }, () => [ne(Y(O(Jt)(v)), 1)])])])]),\n              _: 2\n            }, 1040, [\"class\", \"title\", \"abbr\", \"style\", \"variant\", \"onClick\"]))), 128))]),\n            _: 3\n          }, 8, [\"variant\", \"class\"])]),\n          _: 3\n        }, 8, [\"variant\", \"class\"])) : c.$slots[\"custom-foot\"] ? (b(), I(Pa, {\n          key: 1\n        }, {\n          default: E(() => [T(c.$slots, \"custom-foot\", {\n            fields: n.value,\n            items: c.items,\n            columns: n.value.length\n          })]),\n          _: 3\n        })) : ae(\"\", !0), c.$slots[\"table-caption\"] || c.caption ? (b(), _(\"caption\", ac, [T(c.$slots, \"table-caption\", {}, () => [ne(Y(c.caption), 1)])])) : ae(\"\", !0)]),\n        _: 3\n      }, 8, [\"id\", \"bordered\", \"borderless\", \"border-variant\", \"caption-top\", \"dark\", \"fixed\", \"hover\", \"no-border-collapse\", \"outlined\", \"responsive\", \"small\", \"stacked\", \"sticky-header\", \"striped\", \"table-class\", \"variant\", \"striped-columns\"]));\n    }\n  }),\n  lc = /* @__PURE__ */J(\"svg\", {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: \"24\",\n    height: \"24\",\n    fill: \"currentColor\",\n    class: \"bi bi-arrow-up-short\",\n    viewBox: \"0 0 16 16\",\n    \"aria-hidden\": \"\"\n  }, [/* @__PURE__ */J(\"path\", {\n    \"fill-rule\": \"evenodd\",\n    d: \"M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z\"\n  })], -1),\n  oc = /* @__PURE__ */J(\"svg\", {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: \"24\",\n    height: \"24\",\n    fill: \"currentColor\",\n    class: \"bi bi-arrow-down-short\",\n    viewBox: \"0 0 16 16\",\n    \"aria-hidden\": \"\"\n  }, [/* @__PURE__ */J(\"path\", {\n    \"fill-rule\": \"evenodd\",\n    d: \"M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z\"\n  })], -1),\n  nc = {\n    style: {\n      opacity: 0.4\n    },\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: \"24\",\n    height: \"24\",\n    fill: \"currentColor\",\n    class: \"bi bi-arrow-up-short\",\n    viewBox: \"0 0 16 16\",\n    \"aria-hidden\": \"\"\n  },\n  sc = /* @__PURE__ */J(\"path\", {\n    \"fill-rule\": \"evenodd\",\n    d: \"M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z\"\n  }, null, -1),\n  rc = [sc],\n  ic = {\n    class: \"d-flex align-items-center gap-2 mt-5\"\n  },\n  uc = /* @__PURE__ */H({\n    __name: \"BTable\",\n    props: /* @__PURE__ */pe({\n      provider: {\n        default: void 0\n      },\n      noProvider: {\n        default: void 0\n      },\n      noProviderPaging: {\n        type: Boolean,\n        default: !1\n      },\n      noProviderSorting: {\n        type: Boolean,\n        default: !1\n      },\n      noProviderFiltering: {\n        type: Boolean,\n        default: !1\n      },\n      sortBy: {},\n      mustSort: {\n        type: [Boolean, Array],\n        default: !1\n      },\n      noSortReset: {\n        type: Boolean\n      },\n      selectable: {\n        type: Boolean,\n        default: !1\n      },\n      multisort: {\n        type: Boolean,\n        default: !1\n      },\n      stickySelect: {\n        type: Boolean,\n        default: !1\n      },\n      selectHead: {\n        type: [Boolean, String],\n        default: !0\n      },\n      selectMode: {\n        default: \"multi\"\n      },\n      selectionVariant: {\n        default: \"primary\"\n      },\n      busy: {\n        type: Boolean\n      },\n      busyLoadingText: {\n        default: \"Loading...\"\n      },\n      perPage: {\n        default: Number.POSITIVE_INFINITY\n      },\n      currentPage: {\n        default: 1\n      },\n      filter: {\n        default: void 0\n      },\n      filterable: {\n        default: void 0\n      },\n      noLocalSorting: {\n        type: Boolean,\n        default: !1\n      },\n      noSelectOnClick: {\n        type: Boolean,\n        default: !1\n      },\n      selectedItems: {},\n      noSortableIcon: {\n        type: Boolean,\n        default: !1\n      },\n      align: {\n        default: void 0\n      },\n      caption: {\n        default: void 0\n      },\n      captionHtml: {\n        default: void 0\n      },\n      detailsTdClass: {\n        default: void 0\n      },\n      emptyFilteredText: {\n        default: void 0\n      },\n      emptyText: {\n        default: void 0\n      },\n      fieldColumnClass: {\n        type: [Function, String, Object, Array],\n        default: void 0\n      },\n      fields: {\n        default: () => []\n      },\n      footClone: {\n        type: Boolean,\n        default: void 0\n      },\n      footRowVariant: {\n        default: void 0\n      },\n      footVariant: {\n        default: void 0\n      },\n      headRowVariant: {\n        default: void 0\n      },\n      headVariant: {\n        default: void 0\n      },\n      items: {\n        default: () => []\n      },\n      labelStacked: {\n        type: Boolean,\n        default: void 0\n      },\n      modelValue: {\n        default: void 0\n      },\n      primaryKey: {\n        default: void 0\n      },\n      showEmpty: {\n        type: Boolean,\n        default: void 0\n      },\n      tbodyClass: {\n        default: void 0\n      },\n      tbodyTrAttr: {\n        default: void 0\n      },\n      tbodyTrClass: {\n        type: [Function, String, Object, Array],\n        default: void 0\n      },\n      tfootClass: {\n        default: void 0\n      },\n      tfootTrClass: {\n        default: void 0\n      },\n      theadClass: {\n        default: void 0\n      },\n      theadTrClass: {\n        default: void 0\n      },\n      bordered: {\n        type: Boolean,\n        default: void 0\n      },\n      borderless: {\n        type: Boolean,\n        default: void 0\n      },\n      borderVariant: {\n        default: void 0\n      },\n      captionTop: {\n        type: Boolean,\n        default: void 0\n      },\n      dark: {\n        type: Boolean,\n        default: void 0\n      },\n      fixed: {\n        type: Boolean,\n        default: void 0\n      },\n      hover: {\n        type: Boolean,\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      noBorderCollapse: {\n        type: Boolean,\n        default: void 0\n      },\n      outlined: {\n        type: Boolean,\n        default: void 0\n      },\n      responsive: {\n        type: [Boolean, String],\n        default: void 0\n      },\n      small: {\n        type: Boolean,\n        default: void 0\n      },\n      stacked: {\n        type: [Boolean, String],\n        default: void 0\n      },\n      stickyHeader: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      striped: {\n        type: Boolean,\n        default: void 0\n      },\n      stripedColumns: {\n        type: Boolean,\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      }\n    }, {\n      sortBy: {\n        default: void 0\n      },\n      sortByModifiers: {},\n      busy: {\n        type: Boolean,\n        default: !1\n      },\n      busyModifiers: {},\n      selectedItems: {\n        default: () => []\n      },\n      selectedItemsModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"filtered\", \"head-clicked\", \"row-clicked\", \"row-dbl-clicked\", \"row-hovered\", \"row-unhovered\", \"row-selected\", \"row-unselected\", \"selection\", \"sorted\", \"change\"], [\"update:sortBy\", \"update:busy\", \"update:selectedItems\"]),\n    setup(t, {\n      expose: e,\n      emit: l\n    }) {\n      const a = t,\n        o = l,\n        r = he(t, \"sortBy\"),\n        s = he(t, \"busy\"),\n        n = he(t, \"selectedItems\"),\n        i = w({\n          get: () => /* @__PURE__ */new Set([...n.value]),\n          set: S => {\n            n.value = [...S];\n          }\n        }),\n        u = {\n          add: S => {\n            const P = new Set(i.value);\n            P.add(S), i.value = P, o(\"row-selected\", S);\n          },\n          clear: () => {\n            i.value.forEach(S => {\n              u.delete(S);\n            });\n          },\n          delete: S => {\n            const P = new Set(i.value);\n            P.delete(S), i.value = P, o(\"row-unselected\", S);\n          },\n          set: S => {\n            i.value = new Set(S), i.value.forEach(P => {\n              o(\"row-unselected\", P);\n            });\n          },\n          /* TODO\n          This has method and the delete method suffer from an error when using a non-reactive source as the items prop\n          ```ts\n          const items = [{first_name: 'Geneva', last_name: 'Wilson', age: 89},{first_name: 'Jami', last_name: 'Carney', age: 38}]\n          ```\n          For some reason, the reference of the object gets lost. However, when you use an actual ref(), it works just fine\n          Getting the reference properly will fix all outstanding issues\n          */\n          has: S => {\n            if (!a.primaryKey) return i.value.has(S);\n            const P = a.primaryKey;\n            for (const M of i.value) {\n              const j = qe(M, P),\n                A = qe(S, P);\n              if (j && A && j === A) return !0;\n            }\n            return !1;\n          }\n        },\n        d = x([]),\n        p = be(() => a.perPage, {\n          method: \"parseInt\"\n        }),\n        f = be(() => a.currentPage, {\n          method: \"parseInt\"\n        }),\n        m = k(() => !!a.filter),\n        y = k(() => a.provider !== void 0),\n        h = k(() => i.value.size > 0),\n        c = w(() => r.value !== void 0 || a.fields.some(S => typeof S == \"object\" && S !== null && S.sortable === !0)),\n        g = w(() => a.fields.map(S => {\n          var j;\n          if (!(typeof S == \"object\" && S !== null)) return S;\n          const P = (j = r.value) == null ? void 0 : j.find(A => S.key === A.key),\n            M = c.value === !1 ? void 0 : P === void 0 ? \"none\" : P.order === \"desc\" ? \"descending\" : \"ascending\";\n          return {\n            ...S,\n            thAttr: {\n              \"aria-sort\": M,\n              ...S.thAttr\n            }\n          };\n        })),\n        v = w(() => ({\n          \"b-table-busy\": s.value,\n          \"b-table-selectable\": a.selectable,\n          \"user-select-none\": a.selectable && h.value\n        })),\n        $ = w(() => [a.tbodyTrClass ? typeof a.tbodyTrClass == \"function\" ? a.tbodyTrClass(null, \"table-busy\") : a.tbodyTrClass : null]),\n        B = S => [{\n          \"b-table-sortable-column\": c.value && S.sortable\n        }],\n        C = (S, P) => [{\n          [`selected table-${a.selectionVariant}`]: a.selectable && S && u.has(S)\n        }, a.tbodyTrClass ? typeof a.tbodyTrClass == \"function\" ? a.tbodyTrClass(S, P) : a.tbodyTrClass : null],\n        V = w(() => {\n          const S = j => {\n              var X;\n              const A = (X = r.value) == null ? void 0 : X.filter(G => !!G.order);\n              return !A || A.length === 0 ? j : [...j].sort((G, ie) => {\n                for (let q = 0; q < (A.length ?? 0); q++) {\n                  const se = A[q],\n                    me = U => {\n                      if (!Ze(U)) return String(U);\n                      const z = g.value.find(fe => Ia(fe) ? fe.key === se.key : !1),\n                        oe = qe(U, se.key);\n                      if (Ia(z) && z.sortByFormatted) {\n                        const fe = typeof z.sortByFormatted == \"function\" ? z.sortByFormatted : z.formatter;\n                        if (fe) return go(U, String(z.key), fe);\n                      }\n                      return typeof oe == \"object\" && oe !== null ? JSON.stringify(oe) : (oe == null ? void 0 : oe.toString()) ?? \"\";\n                    },\n                    te = me(G),\n                    ye = me(ie),\n                    ee = se.comparer ? se.comparer(te, ye) : te.localeCompare(ye, void 0, {\n                      numeric: !0\n                    });\n                  if (ee !== 0) return se.order === \"asc\" ? ee : -ee;\n                }\n                return 0;\n              });\n            },\n            P = j => j.filter(A => Ze(A) ? Object.entries(A).some(([X, G]) => {\n              var q, se, me;\n              return G == null || X[0] === \"_\" || !((q = a.filterable) != null && q.includes(X)) && (se = a.filterable) != null && se.length ? !1 : (typeof G == \"object\" ? JSON.stringify(Object.values(G)) : G.toString()).toLowerCase().includes(((me = a.filter) == null ? void 0 : me.toLowerCase()) ?? \"\");\n            }) : !0);\n          let M = y.value ? d.value : a.items;\n          return M = M.map(j => {\n            if (typeof j == \"object\" && j !== null && Object.keys(j).some(A => A.includes(\".\"))) {\n              let A = {};\n              for (const X in j) X.includes(\".\") ? A = Ir(A, X, j[X]) : A[X] = j[X];\n              return A;\n            }\n            return j;\n          }), (m.value === !0 && !y.value || m.value === !0 && y.value && a.noProviderFiltering) && (M = P(M)), (c.value === !0 && !y.value && !a.noLocalSorting || c.value === !0 && y.value && a.noProviderSorting) && (M = S(M)), M;\n        }),\n        L = w(() => Number.isNaN(p.value) || y.value && !a.noProviderPaging ? V.value : V.value.slice((f.value - 1) * (p.value || Number.POSITIVE_INFINITY), f.value * (p.value || Number.POSITIVE_INFINITY)));\n      ue(L, S => {\n        o(\"change\", S);\n      });\n      const Q = (S, P, M = !1, j = !1, A = !1) => {\n          if (a.selectable) {\n            if (a.selectMode === \"single\" || a.selectMode === \"multi\") {\n              if (M || j) return;\n              u.has(S) ? u.delete(S) : a.selectMode === \"single\" ? u.set([S]) : u.add(S);\n            } else if (j || A) u.has(S) ? u.delete(S) : u.add(S);else if (M) {\n              const X = [...i.value].pop(),\n                G = a.items.findIndex(me => me === X),\n                ie = Math.min(G, P),\n                q = Math.max(G, P),\n                se = a.items.slice(ie, q + 1);\n              u.set(se);\n            } else u.set([S]);\n            le();\n          }\n        },\n        W = (S, P, M) => {\n          a.noSelectOnClick === !1 && Q(S, P, M.shiftKey, M.ctrlKey, M.metaKey), o(\"row-clicked\", S, P, M);\n        },\n        F = S => {\n          var se, me;\n          if (!c.value) return;\n          const P = typeof S == \"object\" && S !== null ? S.key : S,\n            M = typeof S == \"object\" && S !== null ? S.sortable : !1;\n          if (!(c.value === !0 && M === !0)) return;\n          const j = te => {\n              if (te === \"asc\") return \"desc\";\n              if (te === void 0 || a.mustSort === !0 || Array.isArray(a.mustSort) && a.mustSort.includes(P)) return \"asc\";\n            },\n            A = ((se = r.value) == null ? void 0 : se.findIndex(te => te.key === P)) ?? -1,\n            X = (me = r.value) == null ? void 0 : me[A],\n            G =\n            // If value is new, we default to ascending\n            // Otherwise we make a temp copy of the value\n            A === -1 || !X ? {\n              key: P,\n              order: \"asc\"\n            } : {\n              ...X\n            },\n            ie = () => {\n              var ye, ee;\n              let te = G;\n              if (A === -1) r.value = [...(r.value ?? []), G];else {\n                const U = j(G.order);\n                te = {\n                  ...G,\n                  order: U\n                }, r.value = U ? (ye = r.value) == null ? void 0 : ye.map(z => z.key === te.key ? te : z) : (ee = r.value) == null ? void 0 : ee.filter(z => z.key !== te.key);\n              }\n              return te;\n            },\n            q = () => {\n              const te = {\n                ...G,\n                order: A === -1 ? G.order : j(G.order)\n              };\n              return r.value = [te], te;\n            };\n          o(\"sorted\", a.multisort === !0 ? ie() : q());\n        },\n        Z = (S, P, M, j = !1) => {\n          o(\"head-clicked\", S, P, M, j), F(P);\n        },\n        R = async () => {\n          if (!y.value || a.provider === void 0 || s.value) return;\n          s.value = !0;\n          const S = a.provider({\n            currentPage: f.value,\n            filter: a.filter,\n            sortBy: r.value,\n            perPage: p.value\n          });\n          try {\n            const P = S instanceof Promise ? await S : S;\n            if (P === void 0) return;\n            d.value = P;\n          } finally {\n            s.value = !1;\n          }\n        },\n        le = () => {\n          a.selectable && o(\"selection\", [...i.value]);\n        },\n        N = async (S, P, M) => {\n          if (P === M) return;\n          const j = ie => {\n              var q;\n              return ((q = a.noProvider) == null ? void 0 : q.includes(ie)) === !0;\n            },\n            A = (S === \"currentPage\" || S === \"perPage\") && (j(\"paging\") || a.noProviderPaging === !0),\n            X = S === \"filter\" && (j(\"filtering\") || a.noProviderFiltering === !0),\n            G = (S === \"sortBy\" || S === \"sortDesc\") && (j(\"sorting\") || a.noProviderSorting === !0);\n          A || X || G || (y.value === !0 && (await R()), S === \"currentPage\" || S === \"perPage\" || o(\"filtered\", [...V.value]));\n        };\n      return ue(() => a.filter, (S, P) => {\n        N(\"filter\", S, P), !(S === P || y.value) && (S || o(\"filtered\", [...V.value]));\n      }), ue(f, (S, P) => {\n        N(\"currentPage\", S, P);\n      }), ue(p, (S, P) => {\n        N(\"perPage\", S, P);\n      }), ue(r, (S, P) => {\n        N(\"sortBy\", S, P);\n      }, {\n        deep: !0\n      }), ue(() => a.provider, S => {\n        if (S === void 0) {\n          d.value = [];\n          return;\n        }\n        R();\n      }), Xe(R), e({\n        // The row selection methods are really for compat. Users should probably use the v-model though\n        clearSelected: () => {\n          a.selectable && (u.clear(), le());\n        },\n        refresh: R,\n        selectAllRows: () => {\n          if (!a.selectable) return;\n          const S = i.value.size > 0 ? [...i.value] : [];\n          i.value = /* @__PURE__ */new Set([...V.value]), i.value.forEach(P => {\n            S.includes(P) || o(\"row-selected\", P);\n          }), le();\n        },\n        selectRow: S => {\n          if (!a.selectable) return;\n          const P = V.value[S];\n          !P || u.has(P) || (u.add(P), le());\n        },\n        unselectRow: S => {\n          if (!a.selectable) return;\n          const P = V.value[S];\n          !P || !u.has(P) || (u.delete(P), le());\n        }\n      }), (S, P) => (b(), I(Cn, K(a, {\n        \"aria-busy\": s.value,\n        items: L.value,\n        fields: g.value,\n        \"table-class\": v.value,\n        \"tbody-tr-class\": C,\n        \"field-column-class\": B,\n        onHeadClicked: Z,\n        onRowDblClicked: P[0] || (P[0] = (M, j, A) => {\n          o(\"row-dbl-clicked\", M, j, A);\n        }),\n        onRowClicked: W,\n        onRowHovered: P[1] || (P[1] = (M, j, A) => {\n          o(\"row-hovered\", M, j, A);\n        }),\n        onRowUnhovered: P[2] || (P[2] = (M, j, A) => {\n          o(\"row-unhovered\", M, j, A);\n        })\n      }), La({\n        \"head()\": E(M => {\n          var j, A, X, G;\n          return [ne(Y(O(Jt)(M.field)) + \" \", 1), c.value && M.field.sortable && a.noSortableIcon === !1 ? (b(), _(de, {\n            key: 0\n          }, [((A = (j = r.value) == null ? void 0 : j.find(ie => ie.key === M.field.key)) == null ? void 0 : A.order) === \"asc\" ? T(S.$slots, S.$slots[`sortAsc(${String(M.field.key)})`] ? `sortAsc(${String(M.field.key)})` : \"sortAsc()\", ge(K({\n            key: 0\n          }, {\n            ...M\n          })), () => [lc]) : ((G = (X = r.value) == null ? void 0 : X.find(ie => ie.key === M.field.key)) == null ? void 0 : G.order) === \"desc\" ? T(S.$slots, S.$slots[`sortDesc(${String(M.field.key)})`] ? `sortDesc(${String(M.field.key)})` : \"sortDesc()\", ge(K({\n            key: 1\n          }, {\n            ...M\n          })), () => [oc]) : T(S.$slots, S.$slots[`sortDefault(${String(M.field.key)})`] ? `sortDefault(${String(M.field.key)})` : \"sortDefault()\", ge(K({\n            key: 2\n          }, {\n            ...M\n          })), () => [(b(), _(\"svg\", nc, rc))])], 64)) : ae(\"\", !0)];\n        }),\n        \"custom-body\": E(M => [s.value ? (b(), I(Je, {\n          key: 0,\n          class: D([\"b-table-busy-slot\", $.value])\n        }, {\n          default: E(() => [ve(St, {\n            colspan: M.fields.length\n          }, {\n            default: E(() => [T(S.$slots, \"table-busy\", {}, () => [ve(ma, {\n              show: \"\"\n            }, {\n              overlay: E(() => [J(\"div\", ic, [ve(pa), J(\"strong\", null, Y(S.busyLoadingText), 1)])]),\n              _: 1\n            })])]),\n            _: 2\n          }, 1032, [\"colspan\"])]),\n          _: 2\n        }, 1032, [\"class\"])) : ae(\"\", !0)]),\n        _: 2\n      }, [Ce(S.$slots, (M, j) => ({\n        name: j,\n        fn: E(A => [T(S.$slots, j, ge(we(A)))])\n      }))]), 1040, [\"aria-busy\", \"items\", \"fields\", \"table-class\"]));\n    }\n  }),\n  dc = /* @__PURE__ */H({\n    inheritAttrs: !1,\n    __name: \"BTab\",\n    props: /* @__PURE__ */pe({\n      active: {\n        type: Boolean\n      },\n      buttonId: {\n        default: void 0\n      },\n      disabled: {\n        type: Boolean,\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      lazy: {\n        type: Boolean,\n        default: void 0\n      },\n      lazyOnce: {\n        type: Boolean,\n        default: void 0\n      },\n      noBody: {\n        type: Boolean,\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      title: {\n        default: void 0\n      },\n      titleItemClass: {\n        default: void 0\n      },\n      titleLinkAttrs: {\n        default: void 0\n      },\n      titleLinkClass: {\n        default: void 0\n      }\n    }, {\n      active: {\n        type: Boolean,\n        default: !1\n      },\n      activeModifiers: {}\n    }),\n    emits: [\"update:active\"],\n    setup(t) {\n      const e = t,\n        l = Le(),\n        a = he(t, \"active\"),\n        o = _e(ko, null),\n        r = Be(() => e.id, \"tabpane\"),\n        s = Be(() => e.buttonId, \"tab\"),\n        n = x(!1),\n        i = x(null),\n        {\n          onClick: u,\n          ...d\n        } = Mt(),\n        p = w(() => ({\n          id: r.value,\n          buttonId: s.value,\n          disabled: e.disabled,\n          title: e.title,\n          titleComponent: l.title,\n          titleItemClass: e.titleItemClass,\n          titleLinkAttrs: e.titleLinkAttrs,\n          titleLinkClass: e.titleLinkClass,\n          onClick: u,\n          el: i.value\n        }));\n      Xe(() => {\n        o && (o.registerTab(p), e.active && o.activateTab(r.value));\n      }), Pn(() => {\n        o && o.unregisterTab(r.value);\n      });\n      const f = k(() => (o == null ? void 0 : o.activeId.value) === r.value),\n        m = x(f.value),\n        y = k(() => !!(o != null && o.lazy.value || (e.lazyOnce ?? e.lazy))),\n        h = k(() => e.lazyOnce !== void 0),\n        c = k(() => f.value && !e.disabled),\n        g = k(() => c.value || !y.value || y.value && h.value && n.value);\n      ue(f, $ => {\n        if ($) {\n          a.value = !0, setTimeout(() => {\n            m.value = !0;\n          }, 0);\n          return;\n        }\n        m.value = !1, a.value = !1;\n      }), ue(() => e.active, $ => {\n        if (o) {\n          if (!$) {\n            f.value && o.activateTab(void 0);\n            return;\n          }\n          o.activateTab(r.value);\n        }\n      });\n      const v = w(() => [{\n        active: f.value,\n        show: m.value,\n        \"card-body\": (o == null ? void 0 : o.card.value) && e.noBody === !1,\n        fade: !(o != null && o.noFade.value)\n      }, m.value ? o == null ? void 0 : o.activeTabClass : o == null ? void 0 : o.inactiveTabClass, o == null ? void 0 : o.tabClass]);\n      return ue(g, $ => {\n        $ && !n.value && (n.value = !0);\n      }), ($, B) => (b(), I(re($.tag), K({\n        id: O(r),\n        ref_key: \"el\",\n        ref: i,\n        class: [\"tab-pane\", v.value],\n        role: \"tabpanel\",\n        \"aria-labelledby\": O(s)\n      }, d), {\n        default: E(() => [g.value ? T($.$slots, \"default\", {\n          key: 0\n        }) : ae(\"\", !0)]),\n        _: 3\n      }, 16, [\"id\", \"class\", \"aria-labelledby\"]));\n    }\n  }),\n  cc = [\"aria-orientation\"],\n  fc = [\"id\", \"aria-controls\", \"aria-selected\", \"onClick\"],\n  vc = /* @__PURE__ */H({\n    __name: \"BTabs\",\n    props: /* @__PURE__ */pe({\n      activeId: {},\n      activeNavItemClass: {\n        default: void 0\n      },\n      activeTabClass: {\n        default: void 0\n      },\n      align: {\n        default: void 0\n      },\n      card: {\n        type: Boolean,\n        default: !1\n      },\n      contentClass: {\n        default: void 0\n      },\n      end: {\n        type: Boolean,\n        default: !1\n      },\n      fill: {\n        type: Boolean,\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      inactiveNavItemClass: {\n        default: void 0\n      },\n      inactiveTabClass: {\n        default: void 0\n      },\n      justified: {\n        type: Boolean,\n        default: !1\n      },\n      lazy: {\n        type: Boolean,\n        default: !1\n      },\n      modelValue: {},\n      navClass: {\n        default: void 0\n      },\n      navItemClass: {\n        default: void 0\n      },\n      navWrapperClass: {\n        default: void 0\n      },\n      noFade: {\n        type: Boolean,\n        default: !1\n      },\n      noNavStyle: {\n        type: Boolean,\n        default: !1\n      },\n      pills: {\n        type: Boolean,\n        default: !1\n      },\n      small: {\n        type: Boolean,\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      tabClass: {\n        default: void 0\n      },\n      vertical: {\n        type: Boolean,\n        default: !1\n      }\n    }, {\n      modelValue: {\n        default: -1\n      },\n      modelModifiers: {},\n      activeId: {\n        default: void 0\n      },\n      activeIdModifiers: {}\n    }),\n    emits: /* @__PURE__ */pe([\"activate-tab\", \"click\"], [\"update:modelValue\", \"update:activeId\"]),\n    setup(t, {\n      emit: e\n    }) {\n      const l = t,\n        a = e,\n        o = he(t, \"modelValue\"),\n        r = he(t, \"activeId\"),\n        s = zt(),\n        n = x([]),\n        i = w(() => n.value.map(B => {\n          const C = O(B),\n            V = C.id === r.value;\n          return {\n            ...C,\n            active: V,\n            navItemClasses: [{\n              active: V,\n              disabled: C.disabled\n            }, V ? l.activeNavItemClass : l.inactiveNavItemClass, l.navItemClass, C.titleLinkClass]\n          };\n        })),\n        u = k(() => !(i != null && i.value && i.value.length > 0)),\n        d = w(() => ({\n          \"d-flex\": l.vertical,\n          \"align-items-start\": l.vertical\n        })),\n        p = Dt(() => l.align),\n        f = w(() => ({\n          \"nav-pills\": l.pills,\n          \"flex-column me-3\": l.vertical,\n          [p.value]: l.align !== void 0,\n          \"nav-fill\": l.fill,\n          \"card-header-tabs\": l.card,\n          \"nav-justified\": l.justified,\n          \"nav-tabs\": !l.noNavStyle && !l.pills,\n          small: l.small\n        })),\n        m = B => {\n          var C;\n          if (B !== void 0) {\n            const V = (C = i.value[B]) == null ? void 0 : C.id;\n            if (B > -1 && B < i.value.length && !i.value[B].disabled && (o.value < 0 || r.value !== V || o.value !== B)) {\n              const L = new nt(\"activate-tab\", {\n                cancelable: !0\n              });\n              a(\"activate-tab\", B, o.value, L), L.defaultPrevented || (r.value !== V && (r.value = V), o.value !== B && (o.value = B));\n            }\n          }\n        },\n        y = (B, C) => {\n          var V, L, Q;\n          m(C), C >= 0 && !i.value[C].disabled && (V = i.value[C]) != null && V.onClick && typeof i.value[C].onClick == \"function\" && ((Q = (L = i.value[C]).onClick) == null || Q.call(L, B));\n        },\n        h = B => {\n          var C, V;\n          i.value.length <= 0 || (o.value = c(o.value + B, B), (V = document.getElementById((C = i.value[o.value]) == null ? void 0 : C.buttonId)) == null || V.focus());\n        },\n        c = (B, C) => {\n          let V = B,\n            L = -1,\n            Q = -1;\n          for (let W = 0; W < i.value.length; W++) i.value[W].disabled || (L === -1 && (L = W), Q = W);\n          for (; V >= L && V <= Q && i.value[V].disabled;) V += C;\n          return V < L && (V = L), V > Q && (V = Q), V;\n        };\n      ue(o, (B, C) => {\n        if (B === C || i.value.length <= 0) return;\n        const V = c(B, B > C ? 1 : -1);\n        Ve(() => {\n          m(V);\n        });\n      }), ue(r, (B, C) => {\n        const V = i.value.findIndex(L => L.id === B);\n        if (B !== C && !(i.value.length <= 0)) {\n          if (V === -1) {\n            m(c(0, 1));\n            return;\n          }\n          m(V);\n        }\n      });\n      const g = B => {\n          n.value.find(C => C.value.id === B.value.id) ? n.value[n.value.findIndex(C => C.value.id === B.value.id)] = B : n.value.push(B), n.value.sort((C, V) => {\n            if (!Node || !C.value.el || !V.value.el) return 0;\n            const L = C.value.el.compareDocumentPosition(V.value.el);\n            return L & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : L & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;\n          });\n        },\n        v = B => {\n          n.value = n.value.filter(C => C.value.id !== B);\n        };\n      ue(n, () => {\n        $();\n      }, {\n        deep: !0\n      });\n      const $ = () => {\n        var B;\n        if (i.value.length === 0) {\n          o.value = -1, r.value = void 0;\n          return;\n        }\n        if (o.value >= 0 && !r.value && (r.value = (B = i.value[o.value]) == null ? void 0 : B.id), i.value.find(C => C.id === r.value)) {\n          m(i.value.findIndex(C => C.id === r.value));\n          return;\n        }\n        m(i.value.map(C => !C.disabled).indexOf(!0));\n      };\n      return at(ko, {\n        lazy: k(() => l.lazy),\n        card: k(() => l.card),\n        noFade: k(() => l.noFade),\n        activeTabClass: k(() => l.activeTabClass),\n        inactiveTabClass: k(() => l.inactiveTabClass),\n        tabClass: k(() => l.tabClass),\n        registerTab: g,\n        unregisterTab: v,\n        activeId: r,\n        activateTab: B => {\n          const C = i.value.findIndex(V => V.id === B);\n          if (B === void 0 || C === -1) {\n            m(c(0, 1));\n            return;\n          }\n          m(C);\n        }\n      }), (B, C) => (b(), I(re(B.tag), {\n        id: B.id,\n        class: D([\"tabs\", d.value])\n      }, {\n        default: E(() => [ve(O(s).define, null, {\n          default: E(() => [J(\"div\", {\n            class: D([\"tab-content\", B.contentClass])\n          }, [T(B.$slots, \"default\"), u.value ? (b(), _(\"div\", {\n            key: \"bv-empty-tab\",\n            class: D([\"tab-pane active\", {\n              \"card-body\": l.card\n            }])\n          }, [T(B.$slots, \"empty\")], 2)) : ae(\"\", !0)], 2)]),\n          _: 3\n        }), l.end ? (b(), I(O(s).reuse, {\n          key: 0\n        })) : ae(\"\", !0), J(\"div\", {\n          class: D([B.navWrapperClass, {\n            \"card-header\": l.card,\n            \"ms-auto\": B.vertical && l.end\n          }])\n        }, [J(\"ul\", {\n          class: D([\"nav\", [f.value, B.navClass]]),\n          role: \"tablist\",\n          \"aria-orientation\": B.vertical ? \"vertical\" : \"horizontal\"\n        }, [T(B.$slots, \"tabs-start\"), (b(!0), _(de, null, Ce(i.value, (V, L) => (b(), _(\"li\", {\n          key: V.id,\n          class: D([\"nav-item\", V.titleItemClass]),\n          role: \"presentation\"\n        }, [J(\"button\", K({\n          id: V.buttonId,\n          class: [\"nav-link\", V.navItemClasses],\n          role: \"tab\",\n          \"aria-controls\": V.id,\n          \"aria-selected\": V.active,\n          ref_for: !0\n        }, V.titleLinkAttrs, {\n          onKeydown: [C[0] || (C[0] = Wt(ft(Q => h(-1), [\"stop\", \"prevent\"]), [\"left\"])), C[1] || (C[1] = Wt(ft(Q => h(1), [\"stop\", \"prevent\"]), [\"right\"])), C[2] || (C[2] = Wt(ft(Q => h(-999), [\"stop\", \"prevent\"]), [\"page-up\"])), C[3] || (C[3] = Wt(ft(Q => h(999), [\"stop\", \"prevent\"]), [\"page-down\"]))],\n          onClick: ft(Q => y(Q, L), [\"stop\", \"prevent\"])\n        }), [V.titleComponent ? (b(), I(re(V.titleComponent), {\n          key: 0\n        })) : (b(), _(de, {\n          key: 1\n        }, [ne(Y(V.title), 1)], 64))], 16, fc)], 2))), 128)), T(B.$slots, \"tabs-end\")], 10, cc)], 2), l.end ? ae(\"\", !0) : (b(), I(O(s).reuse, {\n          key: 1\n        }))]),\n        _: 3\n      }, 8, [\"id\", \"class\"]));\n    }\n  }),\n  pc = {\n    id: \"__BVID__toaster-container\"\n  },\n  mc = /* @__PURE__ */H({\n    __name: \"BToastOrchestrator\",\n    props: {\n      appendToast: {\n        type: Boolean,\n        default: !1\n      },\n      teleportDisabled: {\n        default: !1\n      },\n      teleportTo: {\n        default: \"body\"\n      }\n    },\n    setup(t, {\n      expose: e\n    }) {\n      const l = t,\n        a = {\n          \"top-left\": \"top-0 start-0\",\n          \"top-center\": \"top-0 start-50 translate-middle-x\",\n          \"top-right\": \"top-0 end-0\",\n          \"middle-left\": \"top-50 start-0 translate-middle-y\",\n          \"middle-center\": \"top-50 start-50 translate-middle\",\n          \"middle-right\": \"top-50 end-0 translate-middle-y\",\n          \"bottom-left\": \"bottom-0 start-0\",\n          \"bottom-center\": \"bottom-0 start-50 translate-middle-x\",\n          \"bottom-right\": \"bottom-0 end-0\"\n        },\n        {\n          remove: o,\n          toasts: r,\n          show: s,\n          _setIsAppend: n\n        } = Xo();\n      ue(() => l.appendToast, u => {\n        n == null || n(u);\n      }, {\n        immediate: !0\n      });\n      const i = u => va(u, [\"_modelValue\", \"_self\", \"pos\"]);\n      return e({\n        remove: o,\n        show: s,\n        toasts: r\n      }), (u, d) => (b(), I(ht, {\n        to: u.teleportTo,\n        disabled: l.teleportDisabled\n      }, [J(\"div\", pc, [(b(), _(de, null, Ce(a, (p, f) => J(\"div\", {\n        key: f,\n        class: D([p, \"toast-container position-fixed p-3\"])\n      }, [ve(jl, {\n        name: \"b-list\"\n      }, {\n        default: E(() => {\n          var m;\n          return [(b(!0), _(de, null, Ce((m = O(r)) == null ? void 0 : m.filter(y => y.value.props.pos === f), y => (b(), I(re(y.value.component), K({\n            key: y.value.props._self,\n            ref_for: !0\n          }, i(y.value.props), {\n            modelValue: y.value.props._modelValue,\n            \"onUpdate:modelValue\": h => y.value.props._modelValue = h,\n            \"trans-props\": {\n              ...y.value.props.transProps,\n              appear: !0\n            },\n            onHide: ft(h => {\n              var c;\n              return (c = O(o)) == null ? void 0 : c(y.value.props._self);\n            }, [\"prevent\"])\n          }), null, 16, [\"modelValue\", \"onUpdate:modelValue\", \"trans-props\", \"onHide\"]))), 128))];\n        }),\n        _: 2\n      }, 1024)], 2)), 64))])], 8, [\"to\", \"disabled\"]));\n    }\n  }),\n  bc = /* @__PURE__ */H({\n    __name: \"BTooltip\",\n    props: /* @__PURE__ */pe({\n      interactive: {\n        type: Boolean,\n        default: void 0\n      },\n      boundary: {},\n      boundaryPadding: {},\n      click: {\n        type: Boolean,\n        default: void 0\n      },\n      content: {\n        default: void 0\n      },\n      customClass: {\n        default: void 0\n      },\n      delay: {\n        default: void 0\n      },\n      floatingMiddleware: {\n        default: void 0\n      },\n      hide: {\n        type: Boolean,\n        default: void 0\n      },\n      html: {\n        type: Boolean,\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      inline: {\n        type: Boolean,\n        default: void 0\n      },\n      manual: {\n        type: Boolean,\n        default: void 0\n      },\n      modelValue: {\n        type: Boolean\n      },\n      noAutoClose: {\n        type: Boolean,\n        default: void 0\n      },\n      noFade: {\n        type: Boolean,\n        default: void 0\n      },\n      noFlip: {\n        type: Boolean,\n        default: void 0\n      },\n      noHide: {\n        type: Boolean,\n        default: void 0\n      },\n      noShift: {\n        type: Boolean,\n        default: void 0\n      },\n      noSize: {\n        type: Boolean\n      },\n      noninteractive: {\n        type: Boolean,\n        default: void 0\n      },\n      offset: {\n        default: void 0\n      },\n      placement: {\n        default: void 0\n      },\n      persistent: {\n        type: Boolean\n      },\n      realtime: {\n        type: Boolean,\n        default: void 0\n      },\n      reference: {\n        default: void 0\n      },\n      strategy: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      title: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      },\n      teleportDisabled: {\n        default: void 0\n      },\n      teleportTo: {\n        default: void 0\n      }\n    }, {\n      modelValue: {\n        type: Boolean,\n        default: void 0\n      },\n      modelModifiers: {}\n    }),\n    emits: [\"update:modelValue\"],\n    setup(t, {\n      expose: e\n    }) {\n      var s, n, i;\n      const l = t,\n        a = he(t, \"modelValue\"),\n        o = w(() => {\n          const {\n            interactive: u,\n            noninteractive: d,\n            ...p\n          } = l;\n          return {\n            noninteractive: d !== void 0 ? d : !u,\n            ...p\n          };\n        }),\n        r = x(null);\n      return e({\n        hide: (s = r.value) == null ? void 0 : s.hide,\n        show: (n = r.value) == null ? void 0 : n.show,\n        toggle: (i = r.value) == null ? void 0 : i.toggle\n      }), (u, d) => (b(), I(Ka, K({\n        ref_key: \"popover\",\n        ref: r\n      }, o.value, {\n        modelValue: a.value,\n        \"onUpdate:modelValue\": d[0] || (d[0] = p => a.value = p),\n        tooltip: \"\"\n      }), La({\n        _: 2\n      }, [Ce(u.$slots, (p, f) => ({\n        name: f,\n        fn: E(m => [T(u.$slots, f, ge(we(m)))])\n      }))]), 1040, [\"modelValue\"]));\n    }\n  }),\n  Rl = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    BAccordion: ti,\n    BAccordionItem: li,\n    BAlert: ni,\n    BAvatar: ui,\n    BAvatarGroup: di,\n    BBadge: ci,\n    BBreadcrumb: pi,\n    BBreadcrumbItem: en,\n    BButton: vt,\n    BButtonGroup: mi,\n    BButtonToolbar: yi,\n    BCard: rn,\n    BCardBody: nn,\n    BCardFooter: sn,\n    BCardGroup: Bi,\n    BCardHeader: an,\n    BCardImg: tl,\n    BCardSubtitle: on,\n    BCardText: wi,\n    BCardTitle: ln,\n    BCarousel: Ai,\n    BCarouselSlide: Ei,\n    BCloseButton: Pt,\n    BCol: Ft,\n    BCollapse: Qo,\n    BContainer: zi,\n    BDropdown: un,\n    BDropdownDivider: xi,\n    BDropdownForm: ji,\n    BDropdownGroup: Gi,\n    BDropdownHeader: Ki,\n    BDropdownItem: Xi,\n    BDropdownItemButton: Ji,\n    BDropdownText: eu,\n    BForm: dn,\n    BFormCheckbox: fn,\n    BFormCheckboxGroup: uu,\n    BFormFile: mu,\n    BFormFloatingLabel: ou,\n    BFormGroup: ku,\n    BFormInput: Tu,\n    BFormInvalidFeedback: Va,\n    BFormRadio: pn,\n    BFormRadioGroup: Ou,\n    BFormRow: Qt,\n    BFormSelect: Lu,\n    BFormSelectOption: al,\n    BFormSelectOptionGroup: mn,\n    BFormSpinbutton: Mu,\n    BFormTag: bn,\n    BFormTags: td,\n    BFormText: Aa,\n    BFormTextarea: ld,\n    BFormValidFeedback: Oa,\n    BImg: el,\n    BInputGroup: dd,\n    BInputGroupAddon: ll,\n    BInputGroupAppend: cd,\n    BInputGroupPrepend: fd,\n    BInputGroupText: yn,\n    BLink: ot,\n    BListGroup: vd,\n    BListGroupItem: pd,\n    BModal: _a,\n    BModalOrchestrator: bd,\n    BNav: yd,\n    BNavForm: hd,\n    BNavItem: wd,\n    BNavItemDropdown: kd,\n    BNavText: Td,\n    BNavbar: Sd,\n    BNavbarBrand: _d,\n    BNavbarNav: Vd,\n    BNavbarToggle: zd,\n    BOffcanvas: Md,\n    BOverlay: ma,\n    BPagination: Dd,\n    BPlaceholder: je,\n    BPlaceholderButton: hn,\n    BPlaceholderCard: jd,\n    BPlaceholderTable: Wd,\n    BPlaceholderWrapper: Gd,\n    BPopover: Ka,\n    BProgress: Zo,\n    BProgressBar: Yo,\n    BRow: Xd,\n    BSpinner: pa,\n    BTab: dc,\n    BTable: uc,\n    BTableLite: Cn,\n    BTableSimple: ol,\n    BTabs: vc,\n    BTbody: Bn,\n    BTd: St,\n    BTfoot: Pa,\n    BTh: Ea,\n    BThead: wn,\n    BToast: Jo,\n    BToastOrchestrator: mc,\n    BTooltip: bc,\n    BTr: Je,\n    BTransition: It\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  hc = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    useBreadcrumb: zo,\n    useColorMode: Pr,\n    useModal: zr,\n    useModalController: Go,\n    useScrollspy: Ko,\n    useToast: Xo\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Bc = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    BvCarouselEvent: ql,\n    BvEvent: nt,\n    BvTriggerableEvent: Bt\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  wc = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Cc = ({\n    components: t = !1,\n    directives: e = !1,\n    plugins: l = {}\n  } = {}) => ({\n    install(a) {\n      const o = typeof t == \"boolean\" ? {\n          all: t\n        } : t,\n        r = Object.keys(Rl);\n      Bl(o, r).forEach(u => {\n        const d = Rl[u];\n        a.component(u, d);\n      });\n      const s = typeof e == \"boolean\" ? {\n          all: e\n        } : e,\n        n = Object.keys(Fl),\n        i = u => u.toLowerCase().startsWith(\"v\") ? u.slice(1) : u;\n      Bl(s, n).forEach(u => {\n        const d = i(u),\n          p = Fl[u];\n        a.directive(d, p);\n      }), ((l == null ? void 0 : l.breadcrumb) ?? !0) && a.use(Wr), (((l == null ? void 0 : l.id) ?? !0) || typeof l.id == \"object\") && a.use(Gr, l), ((l == null ? void 0 : l.modalController) ?? !0) && a.use(Zr), ((l == null ? void 0 : l.modalManager) ?? !0) && a.use(Jr), (((l == null ? void 0 : l.rtl) ?? !0) || typeof l.rtl == \"object\") && a.use(Qr, l), ((l == null ? void 0 : l.toast) ?? !0) && a.use(qr);\n    }\n  });\nexport { ti as BAccordion, li as BAccordionItem, ni as BAlert, ui as BAvatar, di as BAvatarGroup, ci as BBadge, pi as BBreadcrumb, en as BBreadcrumbItem, vt as BButton, mi as BButtonGroup, yi as BButtonToolbar, rn as BCard, nn as BCardBody, sn as BCardFooter, Bi as BCardGroup, an as BCardHeader, tl as BCardImg, on as BCardSubtitle, wi as BCardText, ln as BCardTitle, Ai as BCarousel, Ei as BCarouselSlide, Pt as BCloseButton, Ft as BCol, Qo as BCollapse, zi as BContainer, un as BDropdown, xi as BDropdownDivider, ji as BDropdownForm, Gi as BDropdownGroup, Ki as BDropdownHeader, Xi as BDropdownItem, Ji as BDropdownItemButton, eu as BDropdownText, dn as BForm, fn as BFormCheckbox, uu as BFormCheckboxGroup, mu as BFormFile, ou as BFormFloatingLabel, ku as BFormGroup, Tu as BFormInput, Va as BFormInvalidFeedback, pn as BFormRadio, Ou as BFormRadioGroup, Qt as BFormRow, Lu as BFormSelect, al as BFormSelectOption, mn as BFormSelectOptionGroup, Mu as BFormSpinbutton, bn as BFormTag, td as BFormTags, Aa as BFormText, ld as BFormTextarea, Oa as BFormValidFeedback, el as BImg, dd as BInputGroup, ll as BInputGroupAddon, cd as BInputGroupAppend, fd as BInputGroupPrepend, yn as BInputGroupText, ot as BLink, vd as BListGroup, pd as BListGroupItem, _a as BModal, bd as BModalOrchestrator, yd as BNav, hd as BNavForm, wd as BNavItem, kd as BNavItemDropdown, Td as BNavText, Sd as BNavbar, _d as BNavbarBrand, Vd as BNavbarNav, zd as BNavbarToggle, Md as BOffcanvas, ma as BOverlay, Dd as BPagination, je as BPlaceholder, hn as BPlaceholderButton, jd as BPlaceholderCard, Wd as BPlaceholderTable, Gd as BPlaceholderWrapper, Ka as BPopover, Zo as BProgress, Yo as BProgressBar, Xd as BRow, pa as BSpinner, dc as BTab, uc as BTable, Cn as BTableLite, ol as BTableSimple, vc as BTabs, Bn as BTbody, St as BTd, Pa as BTfoot, Ea as BTh, wn as BThead, Jo as BToast, mc as BToastOrchestrator, bc as BTooltip, Je as BTr, It as BTransition, ql as BvCarouselEvent, nt as BvEvent, Bt as BvTriggerableEvent, Rl as Components, hc as Composables, Fl as Directives, wc as Types, Bc as Utils, Cc as createBootstrap, Cc as default, zo as useBreadcrumb, Pr as useColorMode, zr as useModal, Go as useModalController, Ko as useScrollspy, Xo as useToast, Ad as vBColorMode, Na as vBModal, Id as vBPopover, Pd as vBScrollspy, Na as vBToggle, Ed as vBTooltip };","map":{"version":3,"names":["Dt","t","w","e","Se","ua","useAriaInvalid","l","a","nt","constructor","ze","TypeError","name","arguments","length","Object","assign","Defaults","eventType","_preventDefault","cancelable","defaultPrevented","_defaultPrevented","preventDefault","componentId","nativeEvent","relatedTarget","target","Bt","trigger","ql","from","o","direction","r","to","s","En","attemptFocus","getActiveElement","activeElement","document","some","focus","console","error","Ae","Fn","getAttribute","getBoundingClientRect","height","width","wa","window","getComputedStyle","transitionDelay","split","transitionDuration","Number","slice","za","navigator","Ln","passive","WINDOW","addEventListener","removeEventListener","capture","zn","eventOn","Hn","eventOff","sl","eventOnOff","Rn","Mn","join","Gt","disabled","indexOf","tagName","closest","getElementById","querySelector","matches","Wl","rl","il","reduce","concat","tt","Math","min","Ie","max","ea","round","Ut","floor","pt","x","y","xn","left","right","bottom","top","Dn","start","end","Ca","dt","Ue","Qe","Gl","Ha","Nt","includes","Ra","Ul","reference","floating","aa","jn","ta","replace","qn","Wn","map","Gn","Ma","Vt","ul","n","i","u","d","p","f","m","Un","computePosition","placement","strategy","middleware","platform","filter","Boolean","isRTL","getElementRects","h","c","fn","g","v","$","data","B","reset","C","initialPlacement","middlewareData","rects","elements","At","boundary","rootBoundary","elementContext","altBoundary","padding","getClippingRect","element","isElement","contextElement","getDocumentElement","getOffsetParent","getScale","convertOffsetParentRelativeRectToViewportRelativeRect","rect","offsetParent","Kn","options","getDimensions","V","L","Q","W","F","Z","R","le","N","S","P","arrow","M","centerOffset","alignmentOffset","Xn","Yn","autoPlacement","crossAxis","alignment","allowedPlacements","autoAlignment","index","overflows","sort","every","Zn","flip","mainAxis","fallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","push","j","dl","cl","Jn","hide","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","Kl","Qn","es","inline","Array","getClientRects","find","ts","alignmentAxis","Xl","offset","as","shift","limiter","ls","size","apply","availableWidth","availableHeight","st","xa","nodeName","toLowerCase","xe","ownerDocument","defaultView","ct","documentElement","Node","rt","Element","lt","HTMLElement","fl","ShadowRoot","jt","overflow","overflowX","overflowY","display","Ke","test","os","Da","ja","transform","perspective","containerType","backdropFilter","willChange","contain","ns","Ot","da","CSS","supports","ca","scrollLeft","scrollTop","pageXOffset","pageYOffset","assignedSlot","parentNode","host","Yl","body","Lt","visualViewport","frameElement","Zl","parseFloat","offsetWidth","offsetHeight","qa","_t","isFinite","ss","Jl","offsetLeft","offsetTop","rs","yt","clientLeft","paddingLeft","clientTop","paddingTop","is","Ql","us","ds","eo","cs","scrollWidth","clientWidth","scrollHeight","clientHeight","fs","vs","vl","position","ps","get","set","ms","_c","bs","ys","pl","ao","gs","hs","Bs","ws","clearTimeout","disconnect","rootMargin","threshold","intersectionRatio","setTimeout","IntersectionObserver","root","observe","lo","ancestorScroll","ancestorResize","elementResize","ResizeObserver","layoutShift","animationFrame","forEach","unobserve","cancelAnimationFrame","requestAnimationFrame","Cs","oo","no","so","ks","$s","Ts","Ss","Map","_s","ka","$el","Vs","O","ro","devicePixelRatio","ml","io","whileElementsMounted","open","value","bt","then","ue","flush","Ml","xl","kt","isPositioned","floatingStyles","update","As","Set","Os","Ns","Is","Ps","allowedAttribute","has","nodeValue","RegExp","$t","area","b","br","col","code","div","em","hr","h1","h2","h3","h4","h5","h6","img","li","ol","pre","small","span","sub","sup","strong","Tt","sanitizeHtml","DOMParser","parseFromString","querySelectorAll","keys","remove","attributes","removeAttribute","innerHTML","it","Es","Symbol","defineProperty","iterator","enumerable","next","done","Fe","la","WorkerGlobalScope","globalThis","Fs","uo","Ls","prototype","toString","zs","call","Ge","noop","$a","Hs","userAgent","maxTouchPoints","co","Promise","resolve","thisArg","args","catch","fo","Rs","maxWait","rejectOnCancel","Ms","eventFilter","isActive","We","pause","resume","xs","create","Ds","js","toUpperCase","qs","gt","vo","k","_n","Ws","Gs","Ta","stop","Sa","deep","immediate","ltr","rtl","po","Xe","Ve","mo","immediateCallback","clearInterval","setInterval","Sn","be","method","radix","nanToZero","isNaN","zt","inheritAttrs","H","setup","slots","default","attrs","process","env","NODE_ENV","Error","Us","$slots","define","reuse","Me","De","ke","isArray","cleanup","register","flatMap","bl","bo","ignore","detectIframe","children","composedPath","detail","contains","Ks","key","Re","eventName","dedupe","repeat","Xs","Wa","Ys","matchMedia","removeListener","Rt","addListener","Zs","JSON","parse","stringify","Kt","global","self","Xt","Js","Qs","Ga","er","Date","tr","boolean","read","write","String","object","number","any","string","entries","date","toISOString","yl","ar","listenToStorageChanges","writeDefaults","mergeDefaults","shallow","onError","initOnMounted","localStorage","serializer","dispatchEvent","CustomEvent","oldValue","newValue","storageArea","getItem","removeItem","setItem","lr","or","selector","attribute","initialValue","storage","storageKey","storageRef","emitAuto","disableTransition","auto","light","dark","modes","createElement","appendChild","createTextNode","head","values","classList","add","setAttribute","opacity","removeChild","onChanged","store","system","state","nr","MutationObserver","takeRecords","isSupported","Ua","delayEnter","delayLeave","sr","Pe","focusVisible","blur","focused","ba","Window","Document","rr","page","pageX","pageY","client","clientX","clientY","screen","screenX","screenY","movement","Touch","movementX","movementY","ir","type","touch","resetOnTouchEnds","scroll","touches","scrollHandler","MouseEvent","scrollX","scrollY","sourceType","gl","handleOutside","elementX","elementY","elementPositionX","elementPositionY","elementHeight","elementWidth","isOutside","yo","ur","event","Yt","WeakMap","dr","style","lock","unlock","delete","cr","onSwipe","onSwipeEnd","onSwipeStart","nl","abs","updateCoordsStart","updateCoordsEnd","fr","isPassiveEventSupported","isSwiping","coordsStart","coordsEnd","lengthX","lengthY","vr","clone","defaultValue","shouldEmit","emit","$emit","bind","proxy","getValue","he","q","A","X","Event","Be","id","title","content","startsWith","NaN","floatingMiddleware","tooltip","se","noFlip","boundaryPadding","noShift","noHide","noSize","me","te","maxHeight","maxWidth","realtime","variant","show","fade","noFade","customClass","buildTriggerableEvent","delay","manual","noninteractive","ye","ee","toggle","G","mt","warn","nextElementSibling","click","ie","unbind","noAutoClose","Fa","_","de","gr","resolveFloatingPlacement","alignCenter","alignEnd","Ht","active","oa","resolveContent","na","resolveDirectiveProps","modelValue","modifiers","persistent","html","interactive","sa","child","insertBefore","nextSibling","Dl","Ne","Ka","$__element","ra","go","formatItem","qe","fa","getBreakpointProps","charAt","ho","getClasses$1","Br","getSlotElements","__name","Bo","wo","wr","Cr","kr","Zt","$r","Tr","Sr","_r","ya","hl","Vr","trim","Ar","Or","Jt","label","Nr","href","Co","ko","$o","To","So","_o","Vo","Ao","Xa","Oo","Ya","No","Io","Po","Eo","Fo","Lo","Et","normalizeSlot","va","omit","Za","pick","Ir","getOwnPropertyNames","toInt","parseInt","Bl","parseActiveImports","all","wl","suffixPropName","wt","useBLinkHelper","computedLink","computedLinkProps","zo","useBreadcrumb","_e","Pr","useColorMode","persist","et","bgVariant","textVariant","Er","container","Ho","useCountdown","ceil","restart","myPause","myResume","isPaused","Ct","Ro","plain","button","hasDefaultSlot","reverse","switch","Mo","xo","btn","buttonVariant","Do","ariaInvalid","required","jo","validated","buttons","stacked","useId","Fr","getId","random","qo","useFormInput","debounce","debounceMaxWait","lazy","updateModelValue","autofocus","_formatValue","formatter","lazyFormatter","Vn","input","computedId","computedAriaInvalid","onInput","onChange","onBlur","Wo","useFormSelect","text","toLocaleString","valueField","textField","htmlField","disabledField","optionsField","labelField","normalizedOptions","isComplex","ga","Ja","useSharedModalStack","removeStack","removeRegistry","countStack","dispose","Lr","pushRegistry","pushStack","stack","activePosition","findIndex","exposed","activeModalCount","zr","useModal","registry","parent","modal","Go","useModalController","lastStack","hideAll","ia","useNumberishToStyle","Qa","resolveRadiusElement","rounded","roundedTop","roundedBottom","roundedStart","roundedEnd","Hr","useRtl","isRtl","locale","Uo","useSafeScrollLock","Ko","useScrollspy","contentQuery","targetQuery","watchChanges","updateList","el","visible","textContent","isIntersecting","previousSibling","childList","scrollIntoView","scrollTo","behavior","current","list","Xo","useToast","It","enterActiveClass","enterToClass","leaveActiveClass","leaveToClass","enterFromClass","leaveFromClass","mode","css","Cl","ot","Mt","routerComponentName","appContext","app","component","path","query","hash","opacityHover","underlineVariant","underlineOffset","underlineOffsetHover","underlineOpacity","underlineOpacityHover","icon","class","rel","tabindex","stopImmediatePropagation","isNav","autoClose","animated","striped","precision","labelHtml","showValue","toFixed","showProgress","at","interval","showOnPause","onMouseEnter","noHoverPause","showFn","hideFn","onBeforeEnter","onAfterEnter","onAfterLeave","I","K","jr","qr","install","props","Jo","pos","_modelValue","_self","appendToast","provide","_setIsAppend","toasts","Wr","splice","items","Gr","Ur","Le","pressed","tag","pill","squared","stopPropagation","bgColor","spinnerType","spinnerVariant","spinnerSmall","zIndex","noWrap","fixed","backgroundColor","noCenter","kl","Yr","bodyScrolling","autoFocusButton","modalClass","backdropVariant","hideBackdrop","dialogClass","fullscreen","centered","scrollable","bodyBgVariant","bodyTextVariant","bodyVariant","bodyClass","headerBgVariant","headerTextVariant","headerVariant","headerClass","headerBorderVariant","headerCloseVariant","headerCloseClass","footerBgVariant","footerTextVariant","footerVariant","footerClass","footerBorderVariant","titleClass","titleSrOnly","cancelDisabled","busy","okDisabled","U","z","noCloseOnBackdrop","noCloseOnEsc","pickFocusItem","autoFocus","onLeave","cancel","close","ok","Zr","buildPromise","resolveFunc","_a","_isConfirm","_promise","modals","confirm","Jr","uid","Qr","rtlInitial","localeInitial","ei","ti","openItem","free","setOpenItem","collapsing","closing","horizontal","toggleFn","skipAnimation","reveal","wrapperAttrs","dismissible","closeClass","closeVariant","$l","ui","badge","square","badgeVariant","badgeBgVariant","badgeTextVariant","badgeOffset","fontSize","badgeTop","badgeStart","overlapScale","marginLeft","marginRight","overlap","paddingRight","re","textIndicator","dotIndicator","ariaCurrent","vertical","justify","srcset","sizes","blank","blankColor","center","thumbnail","fluid","fluidGrow","block","makeBlankImgSrc","encodeURIComponent","borderVariant","subtitle","overlay","header","footer","align","imgStart","imgEnd","src","imgSrc","alt","imgAlt","imgHeight","imgWidth","imgBottom","imgTop","deck","columns","touchThreshold","rideReverse","ride","prev","keyboard","onMouseLeave","noTouch","resumeRiding","onBeforeLeave","background","textHtml","caption","captionHtml","contentVisibleUp","Tl","Sl","_l","Fi","cols","order","alignSelf","propPrefix","classPrefix","computedClasses","Li","D","E","T","gutterX","gutterY","keynav","dropup","dropstart","dropend","splitClass","toggleClass","noCaret","onButtonClick","onClickInside","headerTag","linkClass","buttonClass","activeClass","forceShow","cn","skip","ht","nu","su","buttonGroup","switches","form","accept","files","multiple","noDrop","vn","bu","yu","gu","hu","Bu","wu","Cu","ku","components","BCol","Ft","BFormInvalidFeedback","Va","BFormRow","Qt","BFormText","Aa","BFormValidFeedback","Oa","contentCols","contentColsLg","contentColsMd","contentColsSm","contentColsXl","description","feedbackAriaLive","invalidFeedback","labelAlign","labelAlignLg","labelAlignMd","labelAlignSm","labelAlignXl","labelClass","labelCols","labelColsLg","labelColsMd","labelColsSm","labelColsXl","labelFor","labelSize","labelSrOnly","validFeedback","getAlignClasses","getColProps","updateAriaDescribedby","escape","ariaDescribedby","contentColProps","isHorizontal","labelAlignClasses","labelColProps","onLegendClick","stateClass","render","$props","for","onClick","tabIndex","ariaLive","descriptionId","labelId","ref","role","$u","Tu","plaintext","selectSize","ut","ha","Vl","Al","Ol","Nl","Ba","zu","Hu","Ru","He","step","repeatDelay","repeatInterval","repeatThreshold","repeatMultiplier","Mu","readonly","oe","repeatStepMultiplier","pow","Intl","NumberFormat","resolvedOptions","defaultFormatter","useGrouping","minimumIntegerDigits","minimumFractionDigits","maximumFractionDigits","notation","format","formatterFn","fe","ce","Oe","$e","wrap","Te","stepUp","stepDown","altKey","ctrlKey","metaKey","handleStepRepeat","Ye","resetTimers","svg","xmlns","fill","viewBox","scale","handler","kn","labelIncrement","slot","labelDecrement","limit","inputId","tagValidator","addButtonText","addButtonVariant","addTag","disableAddButton","duplicateTagText","duplicateTags","inputAttrs","inputHandlers","keydown","change","inputType","invalidTagText","invalidTags","isDuplicate","isInvalid","isLimitReached","limitTagsText","noTagRemove","placeholder","removeTag","separator","tagClass","tagPills","tagRemoveLabel","tagVariant","tags","noOuterFocus","addOnChange","noAddOnEnter","removeOnDelete","resize","noResize","append","appendHtml","prepend","prependHtml","numbered","action","tabs","pills","cardHeader","justified","underline","Bd","Cd","print","sticky","toggleable","Il","setTheme","Ad","mounted","updated","Od","getTargets","arg","Nd","gn","checkVisibility","Pl","handleUpdate","__toggle","Na","unmounted","Id","beforeUnmount","El","$__scrollspy","Pd","Ed","Fl","freeze","noFocus","backdrop","shadow","OnBeforeEnter","OnAfterEnter","OnAfterLeave","Ll","zl","Dd","perPage","totalRows","getBaseButtonProps","classVal","dis","slotName","textValue","hidden","ariaControls","clickHandler","getButtonProps","pageClass","labelPage","firstClass","firstText","labelFirstPage","prevClass","prevText","labelPrevPage","nextClass","nextText","labelNextPage","lastClass","lastText","labelLastPage","ellipsisClass","pageSize","numberOfPages","pageClick","firstNumber","lastNumber","hideEllipsis","hideGotoEndButtons","animation","noButton","je","hn","qd","tableClass","bordered","borderless","captionTop","hover","stripedColumns","stickyHeader","responsive","rows","headerColumns","footerColumns","Hl","Ud","noGutters","alignV","alignH","alignContent","Kd","Ze","Ia","Bn","stickyColumn","colspan","rowspan","_showDetails","fields","tdAttr","_noHeader","itemAttributes","headerClicked","thClass","fieldColumnClass","getFieldRowClasses","tdClass","_cellVariants","getRowClasses","tbodyTrClass","clear","primaryKey","currentPage","provider","sortable","thAttr","selectable","selectionVariant","sortByFormatted","comparer","localeCompare","numeric","filterable","noProviderFiltering","noLocalSorting","noProviderSorting","noProviderPaging","POSITIVE_INFINITY","handleRowSelection","selectMode","pop","onRowClick","noSelectOnClick","shiftKey","mustSort","handleMultiSort","handleSingleSort","multisort","onFieldHeadClick","callItemsProvider","sortBy","notifySelectionEvent","providerPropsWatch","noProvider","clearSelected","refresh","selectAllRows","selectRow","unselectRow","Cn","buttonId","titleComponent","titleItemClass","titleLinkAttrs","titleLinkClass","registerTab","activateTab","Pn","unregisterTab","activeId","lazyOnce","card","noBody","activeTabClass","inactiveTabClass","tabClass","navItemClasses","activeNavItemClass","inactiveNavItemClass","navItemClass","noNavStyle","handleClick","nextIndex","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","findActive","Cc","createBootstrap","directives","plugins","Rl","directive","breadcrumb","use","modalController","modalManager","toast"],"sources":["../src/composables/useAlignment.ts","../src/composables/useAriaInvalid.ts","../src/utils/classes/BvEvent.ts","../src/utils/classes/BvTriggerableEvent.ts","../src/utils/classes/BvCarouselEvent.ts","../src/utils/dom.ts","../src/utils/event.ts","../src/utils/filterEvent.ts","../../../node_modules/.pnpm/@floating-ui+utils@0.2.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../../../node_modules/.pnpm/@floating-ui+core@1.6.0/node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../../../node_modules/.pnpm/@floating-ui+utils@0.2.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../../../node_modules/.pnpm/@floating-ui+dom@1.6.3/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../../../node_modules/.pnpm/@floating-ui+vue@1.0.6_vue@3.4.25/node_modules/@floating-ui/vue/dist/floating-ui.vue.mjs","../src/utils/sanitizer.ts","../../../node_modules/.pnpm/@vueuse+shared@10.9.0_vue@3.4.25/node_modules/@vueuse/shared/index.mjs","../../../node_modules/.pnpm/@vueuse+core@10.9.0_vue@3.4.25/node_modules/@vueuse/core/index.mjs","../src/components/BPopover.vue","../src/utils/floatingUi.ts","../src/utils/formatItem.ts","../src/utils/getBreakpointProps.ts","../src/utils/getClasses.ts","../src/utils/getElement.ts","../src/utils/getSlotElements.ts","../src/constants/regex.ts","../src/utils/stringUtils.ts","../src/utils/getTableFieldHeadLabel.ts","../src/utils/isLink.ts","../src/utils/keys.ts","../src/utils/normalizeSlot.ts","../src/utils/object.ts","../src/utils/parseActiveImports.ts","../src/utils/props.ts","../src/composables/useBLinkHelper.ts","../src/composables/useBreadcrumb.ts","../src/composables/useColorMode.ts","../src/composables/useColorVariantClasses.ts","../src/composables/useContainerClasses.ts","../src/composables/useCountdown.ts","../src/composables/useStateClass.ts","../src/composables/useFormCheck.ts","../src/composables/useId.ts","../src/composables/useFormInput.ts","../src/composables/useFormSelect.ts","../src/composables/useModalManager.ts","../src/composables/useModal.ts","../src/composables/useModalController.ts","../src/composables/useNumberishToStyle.ts","../src/composables/useRadiusElementClasses.ts","../src/composables/useRtl.ts","../src/composables/useSafeScrollLock.ts","../src/composables/useScrollspy.ts","../src/composables/useToast.ts","../src/components/BTransition/BTransition.vue","../src/components/BButton/BCloseButton.vue","../src/components/BLink/BLink.vue","../src/components/BProgress/BProgressBar.vue","../src/components/BProgress/BProgress.vue","../src/components/BToast/BToast.vue","../src/plugins/toastPlugin.ts","../src/plugins/breadcrumbPlugin.ts","../src/plugins/idPlugin.ts","../src/components/BSpinner.vue","../src/components/BButton/BButton.vue","../src/components/BOverlay/BOverlay.vue","../src/components/BModal/BModal.vue","../src/plugins/modalControllerPlugin.ts","../src/plugins/modalManagerPlugin.ts","../src/plugins/rtlPlugin.ts","../src/components/BAccordion/BAccordion.vue","../src/components/BCollapse.vue","../src/components/BAccordion/BAccordionItem.vue","../src/components/BAlert/BAlert.vue","../src/components/BAvatar/BAvatar.vue","../src/components/BAvatar/BAvatarGroup.vue","../src/components/BBadge/BBadge.vue","../src/components/BBreadcrumb/BBreadcrumbItem.vue","../src/components/BBreadcrumb/BBreadcrumb.vue","../src/components/BButton/BButtonGroup.vue","../src/components/BButton/BButtonToolbar.vue","../src/components/BImg.vue","../src/components/BCard/BCardImg.vue","../src/components/BCard/BCardHeadFoot.vue","../src/components/BCard/BCardHeader.vue","../src/components/BCard/BCardSubtitle.vue","../src/components/BCard/BCardBody.vue","../src/components/BCard/BCardFooter.vue","../src/components/BCard/BCard.vue","../src/components/BCard/BCardGroup.vue","../src/components/BCarousel/BCarousel.vue","../src/components/BCarousel/BCarouselSlide.vue","../src/components/BCol.vue","../src/components/BContainer.vue","../src/components/BDropdown/BDropdown.vue","../src/components/BDropdown/BDropdownGroup.vue","../src/components/BDropdown/BDropdownItem.vue","../src/components/BDropdown/BDropdownItemButton.vue","../src/components/BForm/BForm.vue","../src/components/BForm/BFormInvalidFeedback.vue","../src/components/BForm/BFormText.vue","../src/components/BForm/BFormValidFeedback.vue","../src/components/RenderComponentOrSkip.vue","../src/components/BFormCheckbox/BFormCheckbox.vue","../src/components/BFormCheckbox/BFormCheckboxGroup.vue","../src/components/BFormFile/BFormFile.vue","../src/components/BFormGroup/BFormGroup.vue","../src/components/BFormInput/BFormInput.vue","../src/components/BFormRadio/BFormRadio.vue","../src/components/BFormRadio/BFormRadioGroup.vue","../src/components/BFormSelect/BFormSelectOption.vue","../src/components/BFormSelect/BFormSelectOptionGroup.vue","../src/components/BFormSelect/BFormSelect.vue","../src/constants/codes.ts","../src/components/BFormSpinbutton/BFormSpinbutton.vue","../src/components/BFormTags/BFormTag.vue","../src/components/BFormTags/BFormTags.vue","../src/components/BFormTextarea/BFormTextarea.vue","../src/components/BInputGroup/BInputGroup.vue","../src/components/BInputGroup/BInputGroupAddon.vue","../src/components/BListGroup/BListGroup.vue","../src/components/BListGroup/BListGroupItem.vue","../src/components/BModal/BModalOrchestrator.vue","../src/components/BNav/BNav.vue","../src/components/BNav/BNavForm.vue","../src/components/BNav/BNavItem.vue","../src/components/BNav/BNavItemDropdown.vue","../src/components/BNavbar/BNavbar.vue","../src/components/BNavbar/BNavbarBrand.vue","../src/components/BNavbar/BNavbarNav.vue","../src/directives/BColorMode.ts","../src/directives/BToggle.ts","../src/directives/BPopover.ts","../src/directives/BScrollspy.ts","../src/directives/BTooltip.ts","../src/components/BNavbar/BNavbarToggle.vue","../src/components/BOffcanvas/BOffcanvas.vue","../src/components/BPagination/BPagination.vue","../src/components/BPlaceholder/BPlaceholder.vue","../src/components/BPlaceholder/BPlaceholderButton.vue","../src/components/BPlaceholder/BPlaceholderCard.vue","../src/components/BTable/BTableSimple.vue","../src/components/BPlaceholder/BPlaceholderTable.vue","../src/components/BPlaceholder/BPlaceholderWrapper.vue","../src/components/BRow.vue","../src/types/TableTypes.ts","../src/components/BTable/BTbody.vue","../src/components/BTable/BTd.vue","../src/components/BTable/BTfoot.vue","../src/components/BTable/BTh.vue","../src/components/BTable/BThead.vue","../src/components/BTable/BTr.vue","../src/components/BTable/BTableLite.vue","../src/components/BTable/BTable.vue","../src/components/BTabs/BTab.vue","../src/components/BTabs/BTabs.vue","../src/components/BToast/BToastOrchestrator.vue","../src/components/BTooltip.vue","../src/BootstrapVue.ts"],"sourcesContent":["import {computed, type MaybeRefOrGetter, toValue} from 'vue'\nimport type {AlignmentJustifyContent} from '../types'\n\nexport default (align: MaybeRefOrGetter<AlignmentJustifyContent | undefined>) =>\n  computed(() => {\n    const value = toValue(align)\n    return !value ? '' : `justify-content-${value}`\n  })\n","import type {AriaInvalid} from '../types'\nimport {computed, type MaybeRefOrGetter, toValue} from 'vue'\n\nexport default (\n  ariaInvalid: MaybeRefOrGetter<AriaInvalid | undefined>,\n  state: MaybeRefOrGetter<boolean | null | undefined>\n) =>\n  computed(() => {\n    const resolvedAriaInvalid = toValue(ariaInvalid)\n    const resolvedState = toValue(state)\n\n    const resolvedAriaInvalidValue =\n      resolvedAriaInvalid === true\n        ? 'true'\n        : typeof resolvedAriaInvalid === 'string'\n          ? resolvedAriaInvalid\n          : resolvedState === false\n            ? 'true'\n            : resolvedAriaInvalid === false\n              ? 'false'\n              : undefined\n\n    return resolvedAriaInvalidValue\n  })\n","/**\n * Items that are omitted from the BvEventInit constructor arg\n */\nexport type BvEventConstructorOmittables = 'eventType' | 'defaultPrevented'\n\nexport default class BvEvent {\n  readonly cancelable: boolean = true\n  readonly componentId: string | null = null\n  private _defaultPrevented = false\n  readonly eventType: string = ''\n  readonly nativeEvent: string | null = null\n  private _preventDefault: () => void\n  readonly relatedTarget: EventTarget | null = null\n  readonly target: EventTarget | null = null\n  // Readable by everyone,\n  // But only overwritten by inherrited constructors\n  public get defaultPrevented() {\n    return this._defaultPrevented\n  }\n  protected set defaultPrevented(prop) {\n    this._defaultPrevented = prop\n  }\n  // I think this is right\n  // We want to be able to have it callable to everyone,\n  // But only overwritten by inherrited constructors\n  public get preventDefault() {\n    return this._preventDefault\n  }\n  // This may not be correct, because it doesn't get correct type inferences in children\n  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue\n  protected set preventDefault(setter: () => void) {\n    this._preventDefault = setter\n  }\n\n  constructor(\n    eventType: string,\n    eventInit: Partial<Omit<BvEvent, BvEventConstructorOmittables>> = {}\n  ) {\n    if (!eventType) {\n      throw new TypeError(\n        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`\n      )\n    }\n\n    // Merge defaults first, the eventInit, and the type last\n    // so, it can't be overwritten\n    Object.assign(this, BvEvent.Defaults, eventInit, {eventType})\n\n    this._preventDefault = function _preventDefault() {\n      if (this.cancelable) {\n        this.defaultPrevented = true\n      }\n    }\n  }\n\n  static get Defaults() {\n    return {\n      cancelable: true,\n      componentId: null,\n      eventType: '',\n      nativeEvent: null,\n      relatedTarget: null,\n      target: null,\n    }\n  }\n}\n","import BvEvent, {type BvEventConstructorOmittables} from './BvEvent'\n\nexport default class BvTriggerableEvent extends BvEvent {\n  readonly trigger: string | null = null\n\n  constructor(\n    eventType: string,\n    eventInit: Partial<Omit<BvTriggerableEvent, BvEventConstructorOmittables>> = {}\n  ) {\n    super(eventType, eventInit)\n\n    // Merge defaults first, the eventInit, and the type last\n    // so, it can't be overwritten\n    Object.assign(this, BvEvent.Defaults, eventInit, {eventType})\n  }\n\n  static get Defaults() {\n    return {\n      ...super.Defaults,\n      trigger: null,\n    }\n  }\n}\n","import BvEvent, {type BvEventConstructorOmittables} from './BvEvent'\n\nexport default class BvCarouselEvent extends BvEvent {\n  readonly from: number\n  readonly to: number\n  readonly direction: 'left' | 'right'\n\n  constructor(\n    eventType: string,\n    eventInit: Partial<Omit<BvEvent, BvEventConstructorOmittables>> & {\n      from: number\n      to: number\n      direction: 'left' | 'right'\n    }\n  ) {\n    super(eventType, eventInit)\n    Object.assign(this, BvEvent.Defaults, eventInit, {eventType})\n    const {from, direction, to} = eventInit\n    this.from = from\n    this.to = to\n    this.direction = direction\n  }\n\n  static get Defaults() {\n    return {\n      ...super.Defaults,\n    }\n  }\n}\n","import type {Slot} from 'vue'\n\n/**\n * @deprecated only used in BFormGroup, which is not an SFC... Function could probably be replaced with pure Vue\n */\nexport const attemptFocus = (\n  el: Readonly<HTMLElement>,\n  options: Readonly<FocusOptions> = {}\n): boolean => {\n  const getActiveElement = (excludes: readonly HTMLElement[] = []): Element | null => {\n    const {activeElement} = document\n    return activeElement && !excludes.some((el) => el === activeElement) ? activeElement : null\n  }\n\n  const isActiveElement = (el: Readonly<HTMLElement>): boolean => el === getActiveElement()\n\n  try {\n    el.focus(options)\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(e)\n  }\n  return isActiveElement(el)\n}\n\nexport const isEmptySlot = (el: Slot | undefined): boolean => (el?.() ?? []).length === 0\n\n/**\n * @deprecated only used in BFormGroup, which is not an SFC... Function could probably be replaced with pure Vue\n */\nexport const isVisible = (el: Readonly<Element>): boolean => {\n  //if (!isElement(el) || !el.parentNode || !contains(DOCUMENT.body, el)) {\n  // Note this can fail for shadow dom elements since they\n  // are not a direct descendant of document.body\n  //return false\n  //}\n  if (el.getAttribute('display') === 'none') {\n    // We do this check to help with vue-test-utils when using v-show\n    return false\n  }\n  // All browsers support getBoundingClientRect(), except JSDOM as it returns all 0's for values :(\n  // So any tests that need isVisible will fail in JSDOM\n  // Except when we override the getBCR prototype in some tests\n  const bcr = el.getBoundingClientRect()\n  return !!(bcr && bcr.height > 0 && bcr.width > 0)\n}\n\nexport const getTransitionDelay = (element: Readonly<HTMLElement>) => {\n  const style = window.getComputedStyle(element)\n  // if multiple durations are defined, we take the first\n  const transitionDelay = style.transitionDelay.split(',')[0] || ''\n  const transitionDuration = style.transitionDuration.split(',')[0] || ''\n  const transitionDelayMs = Number(transitionDelay.slice(0, -1)) * 1000\n  const transitionDurationMs = Number(transitionDuration.slice(0, -1)) * 1000\n  return transitionDelayMs + transitionDurationMs\n}\n","/**\n * @deprecated remove with parseEventOptions\n */\nexport const IS_BROWSER =\n  typeof window !== 'undefined' &&\n  typeof document !== 'undefined' &&\n  typeof navigator !== 'undefined'\n\n// Normalize event options based on support of passive option\n// Exported only for testing purposes\n/**\n * @deprecated\n */\nexport const parseEventOptions = (\n  options: boolean | Readonly<EventListenerOptions> | undefined\n): boolean | EventListenerOptions | undefined => {\n  const HAS_PASSIVE_EVENT_SUPPORT = (() => {\n    let passiveEventSupported = false\n    if (IS_BROWSER) {\n      try {\n        const options = {\n          // This function will be called when the browser\n          // attempts to access the passive property\n          get passive() {\n            passiveEventSupported = true\n            // eslint-disable-next-line no-useless-return\n            return\n          },\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        WINDOW.addEventListener('test', options, options)\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        WINDOW.removeEventListener('test', options, options)\n      } catch {\n        passiveEventSupported = false\n      }\n    }\n    return passiveEventSupported\n  })()\n\n  if (HAS_PASSIVE_EVENT_SUPPORT) {\n    return typeof options === 'object' ? options : {capture: !!options || false}\n  }\n  // Need to translate to actual Boolean value\n  return typeof options === 'object' ? options.capture : options\n}\n\n// Attach an event listener to an element\n/**\n * @deprecated\n */\nexport const eventOn = (\n  el: Readonly<Element>,\n  eventName: string,\n  handler: EventListener,\n  options: boolean | Readonly<EventListenerOptions> | undefined\n) => {\n  if (el && el.addEventListener) {\n    el.addEventListener(eventName, handler, parseEventOptions(options))\n  }\n}\n\n// Remove an event listener from an element\n/**\n * @deprecated\n */\nexport const eventOff = (\n  el: Readonly<Element>,\n  eventName: string,\n  handler: EventListener,\n  options: boolean | Readonly<EventListenerOptions> | undefined\n) => {\n  if (el && el.removeEventListener) {\n    el.removeEventListener(eventName, handler, options)\n  }\n}\n\n// Utility method to add/remove a event listener based on first argument (boolean)\n// It passes all other arguments to the `eventOn()` or `eventOff` method\n/**\n * @deprecated\n */\nexport const eventOnOff = (on: boolean, eventParams: Parameters<typeof eventOff>) => {\n  const method = on ? eventOn : eventOff\n  method(...eventParams)\n}\n","const TABLE_TAG_NAMES = ['TD', 'TH', 'TR']\n\n// Filter CSS selector for click/dblclick/etc. events\n// If any of these selectors match the clicked element, we ignore the event\nconst eventFilter = [\n  'a',\n  'a *', // Include content inside links\n  'button',\n  'button *', // Include content inside buttons\n  'input:not(.disabled):not([disabled])',\n  'select:not(.disabled):not([disabled])',\n  'textarea:not(.disabled):not([disabled])',\n  '[role=\"link\"]',\n  '[role=\"link\"] *',\n  '[role=\"button\"]',\n  '[role=\"button\"] *',\n  '[tabindex]:not(.disabled):not([disabled])',\n].join(',')\n\n// Returns `true` if we should ignore the click/double-click/keypress event\n// Avoids having the user need to use `@click.stop` on the form control\nexport default (event: Readonly<Event>) => {\n  // Exit early when we don't have a target element\n  if (!event || !event.target) {\n    return false\n  }\n  const el = event.target as HTMLElement\n  // Exit early when element is disabled or a table element\n  if (('disabled' in el && el.disabled) || TABLE_TAG_NAMES.indexOf(el.tagName) !== -1) {\n    return false\n  }\n  // Ignore the click when it was inside a dropdown menu\n  if (el.closest('.dropdown-menu')) return true\n\n  const label = el.tagName === 'LABEL' ? el : el.closest('label')\n  // If the label's form control is not disabled then we don't propagate event\n  // Modern browsers have `label.control` that references the associated input, but IE 11\n  // does not have this property on the label element, so we resort to DOM lookups\n  if (label) {\n    const labelFor = label.getAttribute('for')\n    const input = labelFor\n      ? document.getElementById(labelFor)\n      : label.querySelector('input, select, textarea')\n    if (input && !(input as HTMLInputElement).disabled) {\n      return true\n    }\n  }\n  // Otherwise check if the event target matches one of the selectors in the\n  // event filter (i.e. anchors, non disabled inputs, etc.)\n  // Return `true` if we should ignore the event\n  return el.matches(eventFilter)\n}\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n","import { rectToClientRect, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { detectOverflow, offset } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = currentWin.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = currentWin.frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(floating) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return floating.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x;\n  const y = rect.top + scroll.scrollTop - offsets.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element) || isTopLayer(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(data.floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, flip, hide, inline, limitShift, platform, shift, size };\n","import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport { unref, computed, ref, shallowRef, watch, getCurrentScope, onScopeDispose, shallowReadonly } from 'vue-demi';\nimport { isNode, getNodeName } from '@floating-ui/utils/dom';\n\nfunction isComponentPublicInstance(target) {\n  return target != null && typeof target === 'object' && '$el' in target;\n}\nfunction unwrapElement(target) {\n  if (isComponentPublicInstance(target)) {\n    const element = target.$el;\n    return isNode(element) && getNodeName(element) === '#comment' ? null : element;\n  }\n  return target;\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered to the reference element.\n * @param options The arrow options.\n * @see https://floating-ui.com/docs/arrow\n */\nfunction arrow(options) {\n  return {\n    name: 'arrow',\n    options,\n    fn(args) {\n      const element = unwrapElement(unref(options.element));\n      if (element == null) {\n        return {};\n      }\n      return arrow$1({\n        element,\n        padding: options.padding\n      }).fn(args);\n    }\n  };\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element next to a reference element when it is given a certain CSS positioning strategy.\n * @param reference The reference template ref.\n * @param floating The floating template ref.\n * @param options The floating options.\n * @see https://floating-ui.com/docs/vue\n */\nfunction useFloating(reference, floating, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const whileElementsMountedOption = options.whileElementsMounted;\n  const openOption = computed(() => {\n    var _unref;\n    return (_unref = unref(options.open)) != null ? _unref : true;\n  });\n  const middlewareOption = computed(() => unref(options.middleware));\n  const placementOption = computed(() => {\n    var _unref2;\n    return (_unref2 = unref(options.placement)) != null ? _unref2 : 'bottom';\n  });\n  const strategyOption = computed(() => {\n    var _unref3;\n    return (_unref3 = unref(options.strategy)) != null ? _unref3 : 'absolute';\n  });\n  const transformOption = computed(() => {\n    var _unref4;\n    return (_unref4 = unref(options.transform)) != null ? _unref4 : true;\n  });\n  const referenceElement = computed(() => unwrapElement(reference.value));\n  const floatingElement = computed(() => unwrapElement(floating.value));\n  const x = ref(0);\n  const y = ref(0);\n  const strategy = ref(strategyOption.value);\n  const placement = ref(placementOption.value);\n  const middlewareData = shallowRef({});\n  const isPositioned = ref(false);\n  const floatingStyles = computed(() => {\n    const initialStyles = {\n      position: strategy.value,\n      left: '0',\n      top: '0'\n    };\n    if (!floatingElement.value) {\n      return initialStyles;\n    }\n    const xVal = roundByDPR(floatingElement.value, x.value);\n    const yVal = roundByDPR(floatingElement.value, y.value);\n    if (transformOption.value) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + xVal + \"px, \" + yVal + \"px)\",\n        ...(getDPR(floatingElement.value) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy.value,\n      left: xVal + \"px\",\n      top: yVal + \"px\"\n    };\n  });\n  let whileElementsMountedCleanup;\n  function update() {\n    if (referenceElement.value == null || floatingElement.value == null) {\n      return;\n    }\n    computePosition(referenceElement.value, floatingElement.value, {\n      middleware: middlewareOption.value,\n      placement: placementOption.value,\n      strategy: strategyOption.value\n    }).then(position => {\n      x.value = position.x;\n      y.value = position.y;\n      strategy.value = position.strategy;\n      placement.value = position.placement;\n      middlewareData.value = position.middlewareData;\n      isPositioned.value = true;\n    });\n  }\n  function cleanup() {\n    if (typeof whileElementsMountedCleanup === 'function') {\n      whileElementsMountedCleanup();\n      whileElementsMountedCleanup = undefined;\n    }\n  }\n  function attach() {\n    cleanup();\n    if (whileElementsMountedOption === undefined) {\n      update();\n      return;\n    }\n    if (referenceElement.value != null && floatingElement.value != null) {\n      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);\n      return;\n    }\n  }\n  function reset() {\n    if (!openOption.value) {\n      isPositioned.value = false;\n    }\n  }\n  watch([middlewareOption, placementOption, strategyOption], update, {\n    flush: 'sync'\n  });\n  watch([referenceElement, floatingElement], attach, {\n    flush: 'sync'\n  });\n  watch(openOption, reset, {\n    flush: 'sync'\n  });\n  if (getCurrentScope()) {\n    onScopeDispose(cleanup);\n  }\n  return {\n    x: shallowReadonly(x),\n    y: shallowReadonly(y),\n    strategy: shallowReadonly(strategy),\n    placement: shallowReadonly(placement),\n    middlewareData: shallowReadonly(middlewareData),\n    isPositioned: shallowReadonly(isPositioned),\n    floatingStyles,\n    update\n  };\n}\n\nexport { arrow, useFloating };\n","/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.2.3): util/sanitizer.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nconst uriAttributes = new Set([\n  'background',\n  'cite',\n  'href',\n  'itemtype',\n  'longdesc',\n  'poster',\n  'src',\n  'xlink:href',\n])\n\nconst ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i\n\n/**\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\n *\n * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n */\nconst SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i\n\n/**\n * A pattern that matches safe data URLs. Only matches image, video and audio types.\n *\n * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n */\nconst DATA_URL_PATTERN =\n  /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i\n\nconst allowedAttribute = (\n  attribute: Readonly<Attr>,\n  allowedAttributeList: readonly (string | RegExp)[]\n) => {\n  const attributeName = attribute.nodeName.toLowerCase()\n\n  if (allowedAttributeList.includes(attributeName)) {\n    if (uriAttributes.has(attributeName)) {\n      return Boolean(\n        SAFE_URL_PATTERN.test(attribute.nodeValue || '') ||\n          DATA_URL_PATTERN.test(attribute.nodeValue || '')\n      )\n    }\n\n    return true\n  }\n\n  // Check if a regular expression validates the attribute.\n  return allowedAttributeList\n    .filter((attributeRegex): attributeRegex is RegExp => attributeRegex instanceof RegExp)\n    .some((regex) => regex.test(attributeName))\n}\n\nexport const DefaultAllowlist = {\n  // Global attributes allowed on any supplied element below.\n  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n  'a': ['target', 'href', 'title', 'rel'],\n  'area': [],\n  'b': [],\n  'br': [],\n  'col': [],\n  'code': [],\n  'div': [],\n  'em': [],\n  'hr': [],\n  'h1': [],\n  'h2': [],\n  'h3': [],\n  'h4': [],\n  'h5': [],\n  'h6': [],\n  'i': [],\n  'img': ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n  'li': [],\n  'ol': [],\n  'p': [],\n  'pre': [],\n  's': [],\n  'small': [],\n  'span': [],\n  'sub': [],\n  'sup': [],\n  'strong': [],\n  'u': [],\n  'ul': [],\n}\n\nexport const sanitizeHtml = (\n  unsafeHtml: string,\n  allowList: Readonly<Record<string, (string | RegExp)[]>>,\n  sanitizeFunction?: (unsafeHtml: string) => string\n) => {\n  if (!unsafeHtml.length) {\n    return unsafeHtml\n  }\n\n  if (sanitizeFunction && typeof sanitizeFunction === 'function') {\n    return sanitizeFunction(unsafeHtml)\n  }\n\n  const domParser = new window.DOMParser()\n  const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html')\n  const elements: NodeListOf<Element> = createdDocument.body.querySelectorAll('*')\n\n  for (const element of elements) {\n    const elementName = element.nodeName.toLowerCase()\n\n    if (!Object.keys(allowList).includes(elementName)) {\n      element.remove()\n\n      continue\n    }\n\n    const attributeList = element.attributes\n    const allowedAttributes = [...(allowList['*'] || []), ...(allowList[elementName] || [])]\n\n    for (const attribute of attributeList) {\n      if (!allowedAttribute(attribute, allowedAttributes)) {\n        element.removeAttribute(attribute.nodeName)\n      }\n    }\n  }\n\n  return createdDocument.body.innerHTML\n}\n","import { shallowRef, watchEffect, readonly, ref, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, provide, inject, isVue3, version, isRef, unref, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, isVue2, set as set$1, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';\n\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, {\n    ...options,\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  });\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\" });\n  const get = typeof fn === \"function\" ? fn : fn.get;\n  const set = typeof fn === \"function\" ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createEventHook() {\n  const fns = /* @__PURE__ */ new Set();\n  const off = (fn) => {\n    fns.delete(fn);\n  };\n  const on = (fn) => {\n    fns.add(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (...args) => {\n    return Promise.all(Array.from(fns).map((fn) => fn(...args)));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return (...args) => {\n    if (!initialized) {\n      state = scope.run(() => stateFactory(...args));\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nconst localProvidedStateMap = /* @__PURE__ */ new WeakMap();\n\nconst provideLocal = (key, value) => {\n  var _a;\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"provideLocal must be called in setup\");\n  if (!localProvidedStateMap.has(instance))\n    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));\n  const localProvidedState = localProvidedStateMap.get(instance);\n  localProvidedState[key] = value;\n  provide(key, value);\n};\n\nconst injectLocal = (...args) => {\n  var _a;\n  const key = args[0];\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"injectLocal must be called in setup\");\n  if (localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))\n    return localProvidedStateMap.get(instance)[key];\n  return inject(...args);\n};\n\nfunction createInjectionState(composable, options) {\n  const key = (options == null ? void 0 : options.injectionKey) || Symbol(composable.name || \"InjectionState\");\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provideLocal(key, state);\n    return state;\n  };\n  const useInjectedState = () => injectLocal(key);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] extendRef only works in Vue 2.7 or above.\");\n    return;\n  }\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = { ...obj };\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction toValue(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nconst resolveUnref = toValue;\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : toValue;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(\n    keys.map((key) => {\n      const value = obj[key];\n      return [\n        key,\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n      ];\n    })\n  );\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nconst isClient = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n  var _a, _b;\n  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  const filter = (invoke) => {\n    const duration = toValue(ms);\n    const maxDuration = toValue(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = null;\n          resolve(invoke());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = null;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(...args) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  let ms;\n  let trailing;\n  let leading;\n  let rejectOnCancel;\n  if (!isRef(args[0]) && typeof args[0] === \"object\")\n    ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);\n  else\n    [ms, trailing = true, leading = true, rejectOnCancel = false] = args;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = toValue(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\n}\n\nconst directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nfunction cacheStringFunction(fn) {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?[0-9]+\\.?[0-9]*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = Number.parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n    return (!omitUndefined || value !== void 0) && !keys.includes(key);\n  }));\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\nfunction getLifeCycleTarget(target) {\n  return target || getCurrentInstance();\n}\n\nfunction toRef(...args) {\n  if (args.length !== 1)\n    return toRef$1(...args);\n  const r = args[0];\n  return typeof r === \"function\" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);\n}\nconst resolveRef = toRef;\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = toValue(defaultValue);\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = toValue(defaultValue);\n      trigger();\n    }, toValue(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(\n    debounceFilter(ms, options),\n    fn\n  );\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\n    fn\n  );\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(\n    ref,\n    {\n      get,\n      set,\n      untrackedGet,\n      silentSet,\n      peek,\n      lay\n    },\n    { enumerable: true }\n  );\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction watchWithFilter(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  return watch(\n    source,\n    createFilterWrapper(\n      eventFilter,\n      cb\n    ),\n    watchOptions\n  );\n}\n\nfunction watchPausable(source, cb, options = {}) {\n  const {\n    eventFilter: filter,\n    ...watchOptions\n  } = options;\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter\n    }\n  );\n  return { stop, pause, resume, isActive };\n}\n\nfunction syncRef(left, right, ...[options]) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options || {};\n  const watchers = [];\n  const transformLTR = \"ltr\" in transform && transform.ltr || ((v) => v);\n  const transformRTL = \"rtl\" in transform && transform.rtl || ((v) => v);\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchers.push(watchPausable(\n      left,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        right.value = transformLTR(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchers.push(watchPausable(\n      right,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        left.value = transformRTL(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  const stop = () => {\n    watchers.forEach((w) => w.stop());\n  };\n  return stop;\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(\n    source,\n    (newValue) => targets.forEach((target) => target.value = newValue),\n    { flush, deep, immediate }\n  );\n}\n\nfunction toRefs(objectRef, options = {}) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        var _a;\n        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;\n        if (replaceRef) {\n          if (Array.isArray(objectRef.value)) {\n            const copy = [...objectRef.value];\n            copy[key] = v;\n            objectRef.value = copy;\n          } else {\n            const newObject = { ...objectRef.value, [key]: v };\n            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));\n            objectRef.value = newObject;\n          }\n        } else {\n          objectRef.value[key] = v;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeMount(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeUnmount(fn, target);\n}\n\nfunction tryOnMounted(fn, sync = true, target) {\n  const instance = getLifeCycleTarget();\n  if (instance)\n    onMounted(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onUnmounted(fn, target);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        r,\n        (v) => {\n          if (condition(v) !== isNot) {\n            stop == null ? void 0 : stop();\n            resolve(v);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => stop == null ? void 0 : stop())\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        [r, value],\n        ([v1, v2]) => {\n          if (isNot !== (v1 === v2)) {\n            stop == null ? void 0 : stop();\n            resolve(v1);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => {\n          stop == null ? void 0 : stop();\n          return toValue(r);\n        })\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(toValue(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(toValue(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction defaultComparator(value, othVal) {\n  return value === othVal;\n}\nfunction useArrayDifference(...args) {\n  var _a;\n  const list = args[0];\n  const values = args[1];\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\n  if (typeof compareFn === \"string\") {\n    const key = compareFn;\n    compareFn = (value, othVal) => value[key] === othVal[key];\n  }\n  return computed(() => toValue(list).filter((x) => toValue(values).findIndex((y) => compareFn(x, y)) === -1));\n}\n\nfunction useArrayEvery(list, fn) {\n  return computed(() => toValue(list).every((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return computed(() => toValue(\n    toValue(list).find((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => toValue(list).findIndex((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction findLast(arr, cb) {\n  let index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr))\n      return arr[index];\n  }\n  return void 0;\n}\nfunction useArrayFindLast(list, fn) {\n  return computed(() => toValue(\n    !Array.prototype.findLast ? findLast(toValue(list), (element, index, array) => fn(toValue(element), index, array)) : toValue(list).findLast((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction isArrayIncludesOptions(obj) {\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\nfunction useArrayIncludes(...args) {\n  var _a;\n  const list = args[0];\n  const value = args[1];\n  let comparator = args[2];\n  let formIndex = 0;\n  if (isArrayIncludesOptions(comparator)) {\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\n    comparator = comparator.comparator;\n  }\n  if (typeof comparator === \"string\") {\n    const key = comparator;\n    comparator = (element, value2) => element[key] === toValue(value2);\n  }\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue(value2);\n  return computed(() => toValue(list).slice(formIndex).some((element, index, array) => comparator(\n    toValue(element),\n    toValue(value),\n    index,\n    toValue(array)\n  )));\n}\n\nfunction useArrayJoin(list, separator) {\n  return computed(() => toValue(list).map((i) => toValue(i)).join(toValue(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(toValue(sum), toValue(value), index);\n  return computed(() => {\n    const resolved = toValue(list);\n    return args.length ? resolved.reduce(reduceCallback, toValue(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return computed(() => toValue(list).some((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n  return array.reduce((acc, v) => {\n    if (!acc.some((x) => fn(v, x, array)))\n      acc.push(v);\n    return acc;\n  }, []);\n}\nfunction useArrayUnique(list, compareFn) {\n  return computed(() => {\n    const resolvedList = toValue(list).map((element) => toValue(element));\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n  });\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  let _initialValue = unref(initialValue);\n  const count = ref(initialValue);\n  const {\n    max = Number.POSITIVE_INFINITY,\n    min = Number.NEGATIVE_INFINITY\n  } = options;\n  const inc = (delta = 1) => count.value = Math.max(Math.min(max, count.value + delta), min);\n  const dec = (delta = 1) => count.value = Math.min(Math.max(min, count.value - delta), max);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = _initialValue) => {\n    _initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/;\nconst REGEX_FORMAT = /[YMDHhms]o|\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n}\nfunction formatOrdinal(num) {\n  const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\n  const v = num % 100;\n  return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\n}\nfunction formatDate(date, formatStr, options = {}) {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    Yo: () => formatOrdinal(years),\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    Mo: () => formatOrdinal(month + 1),\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(options.locales, { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(options.locales, { month: \"long\" }),\n    D: () => String(days),\n    Do: () => formatOrdinal(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    Ho: () => formatOrdinal(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    ho: () => formatOrdinal(hours % 12 || 12),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mo: () => formatOrdinal(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    so: () => formatOrdinal(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(options.locales, { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(options.locales, { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(options.locales, { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\n    var _a2, _b;\n    return (_b = $1 != null ? $1 : (_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) != null ? _b : match;\n  });\n}\nfunction normalizeDate(date) {\n  if (date === null)\n    return new Date(Number.NaN);\n  if (date === void 0)\n    return /* @__PURE__ */ new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n}\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(toValue(date)), toValue(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    const intervalValue = toValue(interval);\n    if (intervalValue <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || typeof interval === \"function\") {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = ref(0);\n  const update = () => counter.value += 1;\n  const reset = () => {\n    counter.value = 0;\n  };\n  const controls = useIntervalFn(\n    callback ? () => {\n      update();\n      callback(counter.value);\n    } : update,\n    interval,\n    { immediate }\n  );\n  if (exposeControls) {\n    return {\n      counter,\n      reset,\n      ...controls\n    };\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(\n    source,\n    () => ms.value = timestamp(),\n    options\n  );\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, toValue(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: readonly(isPending),\n    start,\n    stop\n  };\n}\n\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(\n    callback != null ? callback : noop,\n    interval,\n    options\n  );\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return {\n      ready,\n      ...controls\n    };\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = toValue(value);\n    if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && Number.isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return computed(() => `${toValue(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = toValue(truthyValue);\n      _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [...source instanceof Function ? source() : Array.isArray(source) ? source : toValue(source)];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = Array.from({ length: oldList.length });\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nfunction watchAtMost(source, cb, options) {\n  const {\n    count,\n    ...watchOptions\n  } = options;\n  const current = ref(0);\n  const stop = watchWithFilter(\n    source,\n    (...args) => {\n      current.value += 1;\n      if (current.value >= toValue(count))\n        nextTick(() => stop());\n      cb(...args);\n    },\n    watchOptions\n  );\n  return { count: current, stop };\n}\n\nfunction watchDebounced(source, cb, options = {}) {\n  const {\n    debounce = 0,\n    maxWait = void 0,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: debounceFilter(debounce, { maxWait })\n    }\n  );\n}\n\nfunction watchDeep(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      deep: true\n    }\n  );\n}\n\nfunction watchIgnorable(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  const filteredCb = createFilterWrapper(\n    eventFilter,\n    cb\n  );\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(\n      source,\n      (...args) => {\n        if (!ignore.value)\n          filteredCb(...args);\n      },\n      watchOptions\n    );\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(\n      watch(\n        source,\n        () => {\n          syncCounter.value++;\n        },\n        { ...watchOptions, flush: \"sync\" }\n      )\n    );\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(\n      watch(\n        source,\n        (...args) => {\n          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n          ignoreCounter.value = 0;\n          syncCounter.value = 0;\n          if (ignore)\n            return;\n          filteredCb(...args);\n        },\n        watchOptions\n      )\n    );\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchImmediate(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      immediate: true\n    }\n  );\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n  return stop;\n}\n\nfunction watchThrottled(source, cb, options = {}) {\n  const {\n    throttle = 0,\n    trailing = true,\n    leading = true,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: throttleFilter(throttle, trailing, leading)\n    }\n  );\n}\n\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return {\n    ...res,\n    trigger\n  };\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => toValue(item));\n  return toValue(sources);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  const stop = watch(\n    source,\n    (v, ov, onInvalidate) => {\n      if (v) {\n        if (options == null ? void 0 : options.once)\n          nextTick(() => stop());\n        cb(v, ov, onInvalidate);\n      }\n    },\n    {\n      ...options,\n      once: false\n    }\n  );\n  return stop;\n}\n\nexport { assert, refAutoReset as autoResetRef, bypassFilter, camelize, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, getLifeCycleTarget, hasOwn, hyphenate, identity, watchIgnorable as ignorableWatch, increaseWithUnit, injectLocal, invoke, isClient, isDef, isDefined, isIOS, isObject, isWorker, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, provideLocal, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRef, toRefs, toValue, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","import { noop, makeDestructurable, camelize, toValue, isClient, isObject, tryOnScopeDispose, isIOS, tryOnMounted, objectOmit, promiseTimeout, until, increaseWithUnit, objectEntries, createSingletonPromise, useTimeoutFn, pausableWatch, toRef, createEventHook, notNullish, computedWithControl, timestamp, pausableFilter, watchIgnorable, debounceFilter, createFilterWrapper, bypassFilter, toRefs, useIntervalFn, containsProp, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, clamp, syncRef, objectPick, tryOnUnmounted, watchWithFilter, tryOnBeforeUnmount, identity, isDef, isWorker } from '@vueuse/shared';\nexport * from '@vueuse/shared';\nimport { isRef, ref, shallowRef, watchEffect, computed, inject, isVue3, version, defineComponent, h, TransitionGroup, shallowReactive, Fragment, watch, getCurrentInstance, customRef, onUpdated, onMounted, isVue2, readonly, nextTick, reactive, markRaw, unref, getCurrentScope, set, del, isReadonly, onBeforeUpdate } from 'vue-demi';\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  let options;\n  if (isRef(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    evaluating = void 0,\n    shallow = true,\n    onError = noop\n  } = options;\n  const started = ref(!lazy);\n  const current = shallow ? shallowRef(initialState) : ref(initialState);\n  let counter = 0;\n  watchEffect(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  });\n  if (lazy) {\n    return computed(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = inject(key);\n  if (defaultSource)\n    source = inject(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = inject(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return computed((ctx) => options(source, ctx));\n  } else {\n    return computed({\n      get: (ctx) => options.get(source, ctx),\n      set: options.set\n    });\n  }\n}\n\nfunction createReusableTemplate(options = {}) {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createReusableTemplate only works in Vue 2.7 or above.\");\n    return;\n  }\n  const {\n    inheritAttrs = true\n  } = options;\n  const render = shallowRef();\n  const define = /* #__PURE__ */ defineComponent({\n    setup(_, { slots }) {\n      return () => {\n        render.value = slots.default;\n      };\n    }\n  });\n  const reuse = /* #__PURE__ */ defineComponent({\n    inheritAttrs,\n    setup(_, { attrs, slots }) {\n      return () => {\n        var _a;\n        if (!render.value && process.env.NODE_ENV !== \"production\")\n          throw new Error(\"[VueUse] Failed to find the definition of reusable template\");\n        const vnode = (_a = render.value) == null ? void 0 : _a.call(render, { ...keysToCamelKebabCase(attrs), $slots: slots });\n        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;\n      };\n    }\n  });\n  return makeDestructurable(\n    { define, reuse },\n    [define, reuse]\n  );\n}\nfunction keysToCamelKebabCase(obj) {\n  const newObj = {};\n  for (const key in obj)\n    newObj[camelize(key)] = obj[key];\n  return newObj;\n}\n\nfunction createTemplatePromise(options = {}) {\n  if (!isVue3) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createTemplatePromise only works in Vue 3 or above.\");\n    return;\n  }\n  let index = 0;\n  const instances = ref([]);\n  function create(...args) {\n    const props = shallowReactive({\n      key: index++,\n      args,\n      promise: void 0,\n      resolve: () => {\n      },\n      reject: () => {\n      },\n      isResolving: false,\n      options\n    });\n    instances.value.push(props);\n    props.promise = new Promise((_resolve, _reject) => {\n      props.resolve = (v) => {\n        props.isResolving = true;\n        return _resolve(v);\n      };\n      props.reject = _reject;\n    }).finally(() => {\n      props.promise = void 0;\n      const index2 = instances.value.indexOf(props);\n      if (index2 !== -1)\n        instances.value.splice(index2, 1);\n    });\n    return props.promise;\n  }\n  function start(...args) {\n    if (options.singleton && instances.value.length > 0)\n      return instances.value[0].promise;\n    return create(...args);\n  }\n  const component = /* #__PURE__ */ defineComponent((_, { slots }) => {\n    const renderList = () => instances.value.map((props) => {\n      var _a;\n      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));\n    });\n    if (options.transition)\n      return () => h(TransitionGroup, options.transition, renderList);\n    return renderList;\n  });\n  component.start = start;\n  return component;\n}\n\nfunction createUnrefFn(fn) {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => toValue(i)));\n  };\n}\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = toValue(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\nfunction useEventListener(...args) {\n  let target;\n  let events;\n  let listeners;\n  let options;\n  if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n    [events, listeners, options] = args;\n    target = defaultWindow;\n  } else {\n    [target, events, listeners, options] = args;\n  }\n  if (!target)\n    return noop;\n  if (!Array.isArray(events))\n    events = [events];\n  if (!Array.isArray(listeners))\n    listeners = [listeners];\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener, options2) => {\n    el.addEventListener(event, listener, options2);\n    return () => el.removeEventListener(event, listener, options2);\n  };\n  const stopWatch = watch(\n    () => [unrefElement(target), toValue(options)],\n    ([el, options2]) => {\n      cleanup();\n      if (!el)\n        return;\n      const optionsClone = isObject(options2) ? { ...options2 } : options2;\n      cleanups.push(\n        ...events.flatMap((event) => {\n          return listeners.map((listener) => register(el, event, listener, optionsClone));\n        })\n      );\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return stop;\n}\n\nlet _iOSWorkaround = false;\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;\n  if (!window)\n    return noop;\n  if (isIOS && !_iOSWorkaround) {\n    _iOSWorkaround = true;\n    Array.from(window.document.body.children).forEach((el) => el.addEventListener(\"click\", noop));\n    window.document.documentElement.addEventListener(\"click\", noop);\n  }\n  let shouldListen = true;\n  const shouldIgnore = (event) => {\n    return ignore.some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  const listener = (event) => {\n    const el = unrefElement(target);\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  const cleanup = [\n    useEventListener(window, \"click\", listener, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      setTimeout(() => {\n        var _a;\n        const el = unrefElement(target);\n        if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement)))\n          handler(event);\n      }, 0);\n    })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction createKeyPredicate(keyFilter) {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n}\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const {\n    target = defaultWindow,\n    eventName = \"keydown\",\n    passive = false,\n    dedupe = false\n  } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (e.repeat && toValue(dedupe))\n      return;\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keydown\" });\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keypress\" });\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keyup\" });\n}\n\nconst DEFAULT_DELAY = 500;\nconst DEFAULT_THRESHOLD = 10;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = computed(() => unrefElement(target));\n  let timeout;\n  let posStart;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n    posStart = void 0;\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    posStart = {\n      x: ev.x,\n      y: ev.y\n    };\n    timeout = setTimeout(\n      () => handler(ev),\n      (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY\n    );\n  }\n  function onMove(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if (!posStart || (options == null ? void 0 : options.distanceThreshold) === false)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - posStart.x;\n    const dy = ev.y - posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    if (distance >= ((_d = options == null ? void 0 : options.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD))\n      clear();\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  const cleanup = [\n    useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions),\n    useEventListener(elementRef, \"pointermove\", onMove, listenerOptions),\n    useEventListener(elementRef, [\"pointerup\", \"pointerleave\"], clear, listenerOptions)\n  ];\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction isFocusedElementEditable() {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n}\nfunction isTypedCharValid({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  if (keyCode >= 97 && keyCode <= 122)\n    return true;\n  return false;\n}\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\nfunction templateRef(key, initialValue = null) {\n  const instance = getCurrentInstance();\n  let _trigger = () => {\n  };\n  const element = customRef((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  tryOnMounted(_trigger);\n  onUpdated(_trigger);\n  return element;\n}\n\nfunction useActiveElement(options = {}) {\n  var _a;\n  const {\n    window = defaultWindow,\n    deep = true\n  } = options;\n  const document = (_a = options.document) != null ? _a : window == null ? void 0 : window.document;\n  const getDeepActiveElement = () => {\n    var _a2;\n    let element = document == null ? void 0 : document.activeElement;\n    if (deep) {\n      while (element == null ? void 0 : element.shadowRoot)\n        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;\n    }\n    return element;\n  };\n  const activeElement = ref();\n  const trigger = () => {\n    activeElement.value = getDeepActiveElement();\n  };\n  if (window) {\n    useEventListener(window, \"blur\", (event) => {\n      if (event.relatedTarget !== null)\n        return;\n      trigger();\n    }, true);\n    useEventListener(window, \"focus\", trigger, true);\n  }\n  trigger();\n  return activeElement;\n}\n\nfunction useMounted() {\n  const isMounted = ref(false);\n  const instance = getCurrentInstance();\n  if (instance) {\n    onMounted(() => {\n      isMounted.value = true;\n    }, isVue2 ? null : instance);\n  }\n  return isMounted;\n}\n\nfunction useSupported(callback) {\n  const isMounted = useMounted();\n  return computed(() => {\n    isMounted.value;\n    return Boolean(callback());\n  });\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    fpsLimit = void 0,\n    window = defaultWindow\n  } = options;\n  const isActive = ref(false);\n  const intervalLimit = fpsLimit ? 1e3 / fpsLimit : null;\n  let previousFrameTimestamp = 0;\n  let rafId = null;\n  function loop(timestamp) {\n    if (!isActive.value || !window)\n      return;\n    if (!previousFrameTimestamp)\n      previousFrameTimestamp = timestamp;\n    const delta = timestamp - previousFrameTimestamp;\n    if (intervalLimit && delta < intervalLimit) {\n      rafId = window.requestAnimationFrame(loop);\n      return;\n    }\n    previousFrameTimestamp = timestamp;\n    fn({ delta, timestamp });\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      previousFrameTimestamp = 0;\n      rafId = window.requestAnimationFrame(loop);\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive: readonly(isActive),\n    pause,\n    resume\n  };\n}\n\nfunction useAnimate(target, keyframes, options) {\n  let config;\n  let animateOptions;\n  if (isObject(options)) {\n    config = options;\n    animateOptions = objectOmit(options, [\"window\", \"immediate\", \"commitStyles\", \"persist\", \"onReady\", \"onError\"]);\n  } else {\n    config = { duration: options };\n    animateOptions = options;\n  }\n  const {\n    window = defaultWindow,\n    immediate = true,\n    commitStyles,\n    persist,\n    playbackRate: _playbackRate = 1,\n    onReady,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = config;\n  const isSupported = useSupported(() => window && HTMLElement && \"animate\" in HTMLElement.prototype);\n  const animate = shallowRef(void 0);\n  const store = shallowReactive({\n    startTime: null,\n    currentTime: null,\n    timeline: null,\n    playbackRate: _playbackRate,\n    pending: false,\n    playState: immediate ? \"idle\" : \"paused\",\n    replaceState: \"active\"\n  });\n  const pending = computed(() => store.pending);\n  const playState = computed(() => store.playState);\n  const replaceState = computed(() => store.replaceState);\n  const startTime = computed({\n    get() {\n      return store.startTime;\n    },\n    set(value) {\n      store.startTime = value;\n      if (animate.value)\n        animate.value.startTime = value;\n    }\n  });\n  const currentTime = computed({\n    get() {\n      return store.currentTime;\n    },\n    set(value) {\n      store.currentTime = value;\n      if (animate.value) {\n        animate.value.currentTime = value;\n        syncResume();\n      }\n    }\n  });\n  const timeline = computed({\n    get() {\n      return store.timeline;\n    },\n    set(value) {\n      store.timeline = value;\n      if (animate.value)\n        animate.value.timeline = value;\n    }\n  });\n  const playbackRate = computed({\n    get() {\n      return store.playbackRate;\n    },\n    set(value) {\n      store.playbackRate = value;\n      if (animate.value)\n        animate.value.playbackRate = value;\n    }\n  });\n  const play = () => {\n    if (animate.value) {\n      try {\n        animate.value.play();\n        syncResume();\n      } catch (e) {\n        syncPause();\n        onError(e);\n      }\n    } else {\n      update();\n    }\n  };\n  const pause = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.pause();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const reverse = () => {\n    var _a;\n    !animate.value && update();\n    try {\n      (_a = animate.value) == null ? void 0 : _a.reverse();\n      syncResume();\n    } catch (e) {\n      syncPause();\n      onError(e);\n    }\n  };\n  const finish = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.finish();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const cancel = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.cancel();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  watch(() => unrefElement(target), (el) => {\n    el && update();\n  });\n  watch(() => keyframes, (value) => {\n    !animate.value && update();\n    if (!unrefElement(target) && animate.value) {\n      animate.value.effect = new KeyframeEffect(\n        unrefElement(target),\n        toValue(value),\n        animateOptions\n      );\n    }\n  }, { deep: true });\n  tryOnMounted(() => {\n    nextTick(() => update(true));\n  });\n  tryOnScopeDispose(cancel);\n  function update(init) {\n    const el = unrefElement(target);\n    if (!isSupported.value || !el)\n      return;\n    if (!animate.value)\n      animate.value = el.animate(toValue(keyframes), animateOptions);\n    if (commitStyles)\n      animate.value.commitStyles();\n    if (persist)\n      animate.value.persist();\n    if (_playbackRate !== 1)\n      animate.value.playbackRate = _playbackRate;\n    if (init && !immediate)\n      animate.value.pause();\n    else\n      syncResume();\n    onReady == null ? void 0 : onReady(animate.value);\n  }\n  useEventListener(animate, [\"cancel\", \"finish\", \"remove\"], syncPause);\n  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {\n    if (!animate.value)\n      return;\n    store.pending = animate.value.pending;\n    store.playState = animate.value.playState;\n    store.replaceState = animate.value.replaceState;\n    store.startTime = animate.value.startTime;\n    store.currentTime = animate.value.currentTime;\n    store.timeline = animate.value.timeline;\n    store.playbackRate = animate.value.playbackRate;\n  }, { immediate: false });\n  function syncResume() {\n    if (isSupported.value)\n      resumeRef();\n  }\n  function syncPause() {\n    if (isSupported.value && window)\n      window.requestAnimationFrame(pauseRef);\n  }\n  return {\n    isSupported,\n    animate,\n    // actions\n    play,\n    pause,\n    reverse,\n    finish,\n    cancel,\n    // state\n    pending,\n    playState,\n    replaceState,\n    startTime,\n    currentTime,\n    timeline,\n    playbackRate\n  };\n}\n\nfunction useAsyncQueue(tasks, options) {\n  const {\n    interrupt = true,\n    onError = noop,\n    onFinished = noop,\n    signal\n  } = options || {};\n  const promiseState = {\n    aborted: \"aborted\",\n    fulfilled: \"fulfilled\",\n    pending: \"pending\",\n    rejected: \"rejected\"\n  };\n  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }));\n  const result = reactive(initialResult);\n  const activeIndex = ref(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, new Error(\"aborted\"));\n        return;\n      }\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      const done = curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        activeIndex.value === tasks.length - 1 && onFinished();\n        return currentRes;\n      });\n      if (!signal)\n        return done;\n      return Promise.race([done, whenAborted(signal)]);\n    }).catch((e) => {\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, e);\n        return e;\n      }\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\nfunction whenAborted(signal) {\n  return new Promise((resolve, reject) => {\n    const error = new Error(\"aborted\");\n    if (signal.aborted)\n      reject(error);\n    else\n      signal.addEventListener(\"abort\", () => reject(error), { once: true });\n  });\n}\n\nfunction useAsyncState(promise, initialState, options) {\n  const {\n    immediate = true,\n    delay = 0,\n    onError = noop,\n    onSuccess = noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = ref(false);\n  const isLoading = ref(false);\n  const error = shallowRef(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = initialState;\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n      onSuccess(data);\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw e;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate)\n    execute(delay);\n  const shell = {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute\n  };\n  function waitUntilIsLoaded() {\n    return new Promise((resolve, reject) => {\n      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilIsLoaded().then(onFulfilled, onRejected);\n    }\n  };\n}\n\nconst defaults = {\n  array: (v) => JSON.stringify(v),\n  object: (v) => JSON.stringify(v),\n  set: (v) => JSON.stringify(Array.from(v)),\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\n  null: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n  if (!target)\n    return defaults.null;\n  if (target instanceof Map)\n    return defaults.map;\n  else if (target instanceof Set)\n    return defaults.set;\n  else if (Array.isArray(target))\n    return defaults.array;\n  else\n    return defaults.object;\n}\n\nfunction useBase64(target, options) {\n  const base64 = ref(\"\");\n  const promise = ref();\n  function execute() {\n    if (!isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = toValue(target);\n        if (_target == null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else if (typeof _target === \"object\") {\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\n          const serialized = _serializeFn(_target);\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => base64.value = res);\n    return promise.value;\n  }\n  if (isRef(target) || typeof target === \"function\")\n    watch(target, execute, { immediate: true });\n  else\n    execute();\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\nfunction useBattery(options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator && typeof navigator.getBattery === \"function\");\n  const charging = ref(false);\n  const chargingTime = ref(0);\n  const dischargingTime = ref(0);\n  const level = ref(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported.value) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      useEventListener(battery, events, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\nfunction useBluetooth(options) {\n  let {\n    acceptAllDevices = false\n  } = options || {};\n  const {\n    filters = void 0,\n    optionalServices = void 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\n  const device = shallowRef(void 0);\n  const error = shallowRef(null);\n  watch(device, () => {\n    connectToBluetoothGATTServer();\n  });\n  async function requestDevice() {\n    if (!isSupported.value)\n      return;\n    error.value = null;\n    if (filters && filters.length > 0)\n      acceptAllDevices = false;\n    try {\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\n        acceptAllDevices,\n        filters,\n        optionalServices\n      }));\n    } catch (err) {\n      error.value = err;\n    }\n  }\n  const server = ref();\n  const isConnected = computed(() => {\n    var _a;\n    return ((_a = server.value) == null ? void 0 : _a.connected) || false;\n  });\n  async function connectToBluetoothGATTServer() {\n    error.value = null;\n    if (device.value && device.value.gatt) {\n      device.value.addEventListener(\"gattserverdisconnected\", () => {\n      });\n      try {\n        server.value = await device.value.gatt.connect();\n      } catch (err) {\n        error.value = err;\n      }\n    }\n  }\n  tryOnMounted(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\n  });\n  tryOnScopeDispose(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\n  });\n  return {\n    isSupported,\n    isConnected,\n    // Device:\n    device,\n    requestDevice,\n    // Server:\n    server,\n    // Errors:\n    error\n  };\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  let mediaQuery;\n  const matches = ref(false);\n  const handler = (event) => {\n    matches.value = event.matches;\n  };\n  const cleanup = () => {\n    if (!mediaQuery)\n      return;\n    if (\"removeEventListener\" in mediaQuery)\n      mediaQuery.removeEventListener(\"change\", handler);\n    else\n      mediaQuery.removeListener(handler);\n  };\n  const stopWatch = watchEffect(() => {\n    if (!isSupported.value)\n      return;\n    cleanup();\n    mediaQuery = window.matchMedia(toValue(query));\n    if (\"addEventListener\" in mediaQuery)\n      mediaQuery.addEventListener(\"change\", handler);\n    else\n      mediaQuery.addListener(handler);\n    matches.value = mediaQuery.matches;\n  });\n  tryOnScopeDispose(() => {\n    stopWatch();\n    cleanup();\n    mediaQuery = void 0;\n  });\n  return matches;\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetifyV2 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1264,\n  xl: 1904\n};\nconst breakpointsVuetifyV3 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1280,\n  xl: 1920,\n  xxl: 2560\n};\nconst breakpointsVuetify = breakpointsVuetifyV2;\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 0,\n  sm: 600,\n  md: 1024,\n  lg: 1440,\n  xl: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\nconst breakpointsMasterCss = {\n  \"3xs\": 360,\n  \"2xs\": 480,\n  \"xs\": 600,\n  \"sm\": 768,\n  \"md\": 1024,\n  \"lg\": 1280,\n  \"xl\": 1440,\n  \"2xl\": 1600,\n  \"3xl\": 1920,\n  \"4xl\": 2560\n};\nconst breakpointsPrimeFlex = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200\n};\n\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = toValue(breakpoints[toValue(k)]);\n    if (delta != null)\n      v = increaseWithUnit(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow, strategy = \"min-width\" } = options;\n  function match(query) {\n    if (!window)\n      return false;\n    return window.matchMedia(query).matches;\n  }\n  const greaterOrEqual = (k) => {\n    return useMediaQuery(() => `(min-width: ${getValue(k)})`, options);\n  };\n  const smallerOrEqual = (k) => {\n    return useMediaQuery(() => `(max-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => strategy === \"min-width\" ? greaterOrEqual(k) : smallerOrEqual(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  function current() {\n    const points = Object.keys(breakpoints).map((i) => [i, greaterOrEqual(i)]);\n    return computed(() => points.filter(([, v]) => v.value).map(([k]) => k));\n  }\n  return Object.assign(shortcutMethods, {\n    greaterOrEqual,\n    smallerOrEqual,\n    greater(k) {\n      return useMediaQuery(() => `(min-width: ${getValue(k, 0.1)})`, options);\n    },\n    smaller(k) {\n      return useMediaQuery(() => `(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(() => `(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(`(min-width: ${getValue(k, 0.1)})`);\n    },\n    isGreaterOrEqual(k) {\n      return match(`(min-width: ${getValue(k)})`);\n    },\n    isSmaller(k) {\n      return match(`(max-width: ${getValue(k, -0.1)})`);\n    },\n    isSmallerOrEqual(k) {\n      return match(`(max-width: ${getValue(k)})`);\n    },\n    isInBetween(a, b) {\n      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\n    },\n    current,\n    active() {\n      const bps = current();\n      return computed(() => bps.value.length === 0 ? \"\" : bps.value.at(-1));\n    }\n  });\n}\n\nfunction useBroadcastChannel(options) {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\n  const isClosed = ref(false);\n  const channel = ref();\n  const data = ref();\n  const error = shallowRef(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported.value) {\n    tryOnMounted(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      channel.value.addEventListener(\"message\", (e) => {\n        data.value = e.data;\n      }, { passive: true });\n      channel.value.addEventListener(\"messageerror\", (e) => {\n        error.value = e;\n      }, { passive: true });\n      channel.value.addEventListener(\"close\", () => {\n        isClosed.value = true;\n      });\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n}\n\nconst WRITABLE_PROPERTIES = [\n  \"hash\",\n  \"host\",\n  \"hostname\",\n  \"href\",\n  \"pathname\",\n  \"port\",\n  \"protocol\",\n  \"search\"\n];\nfunction useBrowserLocation(options = {}) {\n  const { window = defaultWindow } = options;\n  const refs = Object.fromEntries(\n    WRITABLE_PROPERTIES.map((key) => [key, ref()])\n  );\n  for (const [key, ref2] of objectEntries(refs)) {\n    watch(ref2, (value) => {\n      if (!(window == null ? void 0 : window.location) || window.location[key] === value)\n        return;\n      window.location[key] = value;\n    });\n  }\n  const buildState = (trigger) => {\n    var _a;\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { origin } = (window == null ? void 0 : window.location) || {};\n    for (const key of WRITABLE_PROPERTIES)\n      refs[key].value = (_a = window == null ? void 0 : window.location) == null ? void 0 : _a[key];\n    return reactive({\n      trigger,\n      state: state2,\n      length,\n      origin,\n      ...refs\n    });\n  };\n  const state = ref(buildState(\"load\"));\n  if (window) {\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), { passive: true });\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), { passive: true });\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, watchOptions) {\n  const cachedValue = ref(refValue.value);\n  watch(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\n  let permissionStatus;\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = ref();\n  const onChange = () => {\n    if (permissionStatus)\n      state.value = permissionStatus.state;\n  };\n  const query = createSingletonPromise(async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionStatus) {\n      try {\n        permissionStatus = await navigator.permissions.query(desc);\n        useEventListener(permissionStatus, \"change\", onChange);\n        onChange();\n      } catch (e) {\n        state.value = \"prompt\";\n      }\n    }\n    return permissionStatus;\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500,\n    legacy = false\n  } = options;\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const permissionRead = usePermission(\"clipboard-read\");\n  const permissionWrite = usePermission(\"clipboard-write\");\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\n  const text = ref(\"\");\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateText() {\n    if (isClipboardApiSupported.value && isAllowed(permissionRead.value)) {\n      navigator.clipboard.readText().then((value) => {\n        text.value = value;\n      });\n    } else {\n      text.value = legacyRead();\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateText);\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      if (isClipboardApiSupported.value && isAllowed(permissionWrite.value))\n        await navigator.clipboard.writeText(value);\n      else\n        legacyCopy(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  function legacyCopy(value) {\n    const ta = document.createElement(\"textarea\");\n    ta.value = value != null ? value : \"\";\n    ta.style.position = \"absolute\";\n    ta.style.opacity = \"0\";\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand(\"copy\");\n    ta.remove();\n  }\n  function legacyRead() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\n  }\n  function isAllowed(status) {\n    return status === \"granted\" || status === \"prompt\";\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nfunction useClipboardItems(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500\n  } = options;\n  const isSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const content = ref([]);\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateContent() {\n    if (isSupported.value) {\n      navigator.clipboard.read().then((items) => {\n        content.value = items;\n      });\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateContent);\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      await navigator.clipboard.write(value);\n      content.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  return {\n    isSupported,\n    content,\n    copied,\n    copy\n  };\n}\n\nfunction cloneFnJSON(source) {\n  return JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n  const cloned = ref({});\n  const {\n    manual,\n    clone = cloneFnJSON,\n    // watch options\n    deep = true,\n    immediate = true\n  } = options;\n  function sync() {\n    cloned.value = clone(toValue(source));\n  }\n  if (!manual && (isRef(source) || typeof source === \"function\")) {\n    watch(source, sync, {\n      ...options,\n      deep,\n      immediate\n    });\n  } else {\n    sync();\n  }\n  return { cloned, sync };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\nconst handlers = /* @__PURE__ */ getHandlers();\nfunction getHandlers() {\n  if (!(globalKey in _global))\n    _global[globalKey] = _global[globalKey] || {};\n  return _global[globalKey];\n}\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nconst customStorageEventName = \"vueuse-storage\";\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    },\n    initOnMounted\n  } = options;\n  const data = (shallow ? shallowRef : ref)(typeof defaults === \"function\" ? defaults() : defaults);\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = toValue(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(\n    data,\n    () => write(data.value),\n    { flush, deep, eventFilter }\n  );\n  if (window && listenToStorageChanges) {\n    tryOnMounted(() => {\n      useEventListener(window, \"storage\", update);\n      useEventListener(window, customStorageEventName, updateFromCustomEvent);\n      if (initOnMounted)\n        update();\n    });\n  }\n  if (!initOnMounted)\n    update();\n  function dispatchWriteEvent(oldValue, newValue) {\n    if (window) {\n      window.dispatchEvent(new CustomEvent(customStorageEventName, {\n        detail: {\n          key,\n          oldValue,\n          newValue,\n          storageArea: storage\n        }\n      }));\n    }\n  }\n  function write(v) {\n    try {\n      const oldValue = storage.getItem(key);\n      if (v == null) {\n        dispatchWriteEvent(oldValue, null);\n        storage.removeItem(key);\n      } else {\n        const serialized = serializer.write(v);\n        if (oldValue !== serialized) {\n          storage.setItem(key, serialized);\n          dispatchWriteEvent(oldValue, serialized);\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(key);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit != null)\n        storage.setItem(key, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (typeof mergeDefaults === \"function\")\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return { ...rawInit, ...value };\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== key)\n      return;\n    pauseWatch();\n    try {\n      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))\n        data.value = read(event);\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        nextTick(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n  function updateFromCustomEvent(event) {\n    update(event.detail);\n  }\n  return data;\n}\n\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto,\n    disableTransition = true\n  } = options;\n  const modes = {\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\",\n    ...options.modes || {}\n  };\n  const preferredDark = usePreferredDark({ window });\n  const system = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = computed(() => store.value === \"auto\" ? system.value : store.value);\n  const updateHTMLAttrs = getSSRHandler(\n    \"updateHTMLAttrs\",\n    (selector2, attribute2, value) => {\n      const el = typeof selector2 === \"string\" ? window == null ? void 0 : window.document.querySelector(selector2) : unrefElement(selector2);\n      if (!el)\n        return;\n      let style;\n      if (disableTransition) {\n        style = window.document.createElement(\"style\");\n        const styleString = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\n        style.appendChild(document.createTextNode(styleString));\n        window.document.head.appendChild(style);\n      }\n      if (attribute2 === \"class\") {\n        const current = value.split(/\\s/g);\n        Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n          if (current.includes(v))\n            el.classList.add(v);\n          else\n            el.classList.remove(v);\n        });\n      } else {\n        el.setAttribute(attribute2, value);\n      }\n      if (disableTransition) {\n        window.getComputedStyle(style).opacity;\n        document.head.removeChild(style);\n      }\n    }\n  );\n  function defaultOnChanged(mode) {\n    var _a;\n    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  tryOnMounted(() => onChanged(state.value));\n  const auto = computed({\n    get() {\n      return emitAuto ? store.value : state.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  try {\n    return Object.assign(auto, { store, system, state });\n  } catch (e) {\n    return auto;\n  }\n}\n\nfunction useConfirmDialog(revealed = ref(false)) {\n  const confirmHook = createEventHook();\n  const cancelHook = createEventHook();\n  const revealHook = createEventHook();\n  let _resolve = noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: computed(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nfunction useMutationObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...mutationOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => {\n    const value = toValue(target);\n    const items = (Array.isArray(value) ? value : [value]).map(unrefElement).filter(notNullish);\n    return new Set(items);\n  });\n  const stopWatch = watch(\n    () => targets.value,\n    (targets2) => {\n      cleanup();\n      if (isSupported.value && window && targets2.size) {\n        observer = new MutationObserver(callback);\n        targets2.forEach((el) => observer.observe(el, mutationOptions));\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const takeRecords = () => {\n    return observer == null ? void 0 : observer.takeRecords();\n  };\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop,\n    takeRecords\n  };\n}\n\nfunction useCssVar(prop, target, options = {}) {\n  const { window = defaultWindow, initialValue = \"\", observe = false } = options;\n  const variable = ref(initialValue);\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  function updateCssVar() {\n    var _a;\n    const key = toValue(prop);\n    const el = toValue(elRef);\n    if (el && window) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();\n      variable.value = value || initialValue;\n    }\n  }\n  if (observe) {\n    useMutationObserver(elRef, updateCssVar, {\n      attributeFilter: [\"style\", \"class\"],\n      window\n    });\n  }\n  watch(\n    [elRef, () => toValue(prop)],\n    updateCssVar,\n    { immediate: true }\n  );\n  watch(\n    variable,\n    (val) => {\n      var _a;\n      if ((_a = elRef.value) == null ? void 0 : _a.style)\n        elRef.value.style.setProperty(toValue(prop), val);\n    }\n  );\n  return variable;\n}\n\nfunction useCurrentElement(rootComponent) {\n  const vm = getCurrentInstance();\n  const currentElement = computedWithControl(\n    () => null,\n    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el\n  );\n  onUpdated(currentElement.trigger);\n  onMounted(currentElement.trigger);\n  return currentElement;\n}\n\nfunction useCycleList(list, options) {\n  const state = shallowRef(getInitialValue());\n  const listRef = toRef(list);\n  const index = computed({\n    get() {\n      var _a;\n      const targetList = listRef.value;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const targetList = listRef.value;\n    const length = targetList.length;\n    const index2 = (i % length + length) % length;\n    const value = targetList[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  function getInitialValue() {\n    var _a, _b;\n    return (_b = toValue((_a = options == null ? void 0 : options.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;\n  }\n  watch(listRef, () => set(index.value));\n  return {\n    state,\n    index,\n    next,\n    prev,\n    go: set\n  };\n}\n\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\",\n    window = defaultWindow\n  } = options;\n  const mode = useColorMode({\n    ...options,\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\", defaultHandler, mode2);\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  });\n  const system = computed(() => {\n    if (mode.system) {\n      return mode.system.value;\n    } else {\n      const preferredDark = usePreferredDark({ window });\n      return preferredDark.value ? \"dark\" : \"light\";\n    }\n  });\n  const isDark = computed({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      const modeVal = v ? \"dark\" : \"light\";\n      if (system.value === modeVal)\n        mode.value = \"auto\";\n      else\n        mode.value = modeVal;\n    }\n  });\n  return isDark;\n}\n\nfunction fnBypass(v) {\n  return v;\n}\nfunction fnSetSource(source, value) {\n  return source.value = value;\n}\nfunction defaultDump(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return markRaw({\n      snapshot: dump(source.value),\n      timestamp: timestamp()\n    });\n  }\n  const last = ref(_createHistoryRecord());\n  const undoStack = ref([]);\n  const redoStack = ref([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = computed(() => [last.value, ...undoStack.value]);\n  const canUndo = computed(() => undoStack.value.length > 0);\n  const canRedo = computed(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = pausableFilter(eventFilter);\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = watchIgnorable(\n    source,\n    commit,\n    { deep, flush, eventFilter: composedFilter }\n  );\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, { ...options, clone: options.clone || deep, setSource });\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return {\n    ...manualHistory,\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  };\n}\n\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    eventFilter = bypassFilter\n  } = options;\n  const acceleration = ref({ x: null, y: null, z: null });\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\n  const interval = ref(0);\n  const accelerationIncludingGravity = ref({\n    x: null,\n    y: null,\n    z: null\n  });\n  if (window) {\n    const onDeviceMotion = createFilterWrapper(\n      eventFilter,\n      (event) => {\n        acceleration.value = event.acceleration;\n        accelerationIncludingGravity.value = event.accelerationIncludingGravity;\n        rotationRate.value = event.rotationRate;\n        interval.value = event.interval;\n      }\n    );\n    useEventListener(window, \"devicemotion\", onDeviceMotion);\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval\n  };\n}\n\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = ref(false);\n  const alpha = ref(null);\n  const beta = ref(null);\n  const gamma = ref(null);\n  if (window && isSupported.value) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\nfunction useDevicePixelRatio(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const pixelRatio = ref(1);\n  if (window) {\n    let observe2 = function() {\n      pixelRatio.value = window.devicePixelRatio;\n      cleanup2();\n      media = window.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);\n      media.addEventListener(\"change\", observe2, { once: true });\n    }, cleanup2 = function() {\n      media == null ? void 0 : media.removeEventListener(\"change\", observe2);\n    };\n    let media;\n    observe2();\n    tryOnScopeDispose(cleanup2);\n  }\n  return { pixelRatio };\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = ref([]);\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n  const permissionGranted = ref(false);\n  let stream;\n  async function update() {\n    if (!isSupported.value)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n    if (stream) {\n      stream.getTracks().forEach((t) => t.stop());\n      stream = null;\n    }\n  }\n  async function ensurePermissions() {\n    if (!isSupported.value)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(\"camera\", { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      stream = await navigator.mediaDevices.getUserMedia(constraints);\n      update();\n      permissionGranted.value = true;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (isSupported.value) {\n    if (requestPermissions)\n      ensurePermissions();\n    useEventListener(navigator.mediaDevices, \"devicechange\", update);\n    update();\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\n  });\n  const constraint = { audio, video };\n  const stream = shallowRef();\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\nfunction useDocumentVisibility(options = {}) {\n  const { document = defaultDocument } = options;\n  if (!document)\n    return ref(\"visible\");\n  const visibility = ref(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  });\n  return visibility;\n}\n\nfunction useDraggable(target, options = {}) {\n  var _a, _b;\n  const {\n    pointerTypes,\n    preventDefault,\n    stopPropagation,\n    exact,\n    onMove,\n    onEnd,\n    onStart,\n    initialValue,\n    axis = \"both\",\n    draggingElement = defaultWindow,\n    containerElement,\n    handle: draggingHandle = target\n  } = options;\n  const position = ref(\n    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }\n  );\n  const pressedDelta = ref();\n  const filterEvent = (e) => {\n    if (pointerTypes)\n      return pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if (toValue(preventDefault))\n      e.preventDefault();\n    if (toValue(stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    var _a2;\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (toValue(exact) && e.target !== toValue(target))\n      return;\n    const container = toValue(containerElement);\n    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);\n    const targetRect = toValue(target).getBoundingClientRect();\n    const pos = {\n      x: e.clientX - (container ? targetRect.left - containerRect.left + container.scrollLeft : targetRect.left),\n      y: e.clientY - (container ? targetRect.top - containerRect.top + container.scrollTop : targetRect.top)\n    };\n    if ((onStart == null ? void 0 : onStart(pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    const container = toValue(containerElement);\n    const targetRect = toValue(target).getBoundingClientRect();\n    let { x, y } = position.value;\n    if (axis === \"x\" || axis === \"both\") {\n      x = e.clientX - pressedDelta.value.x;\n      if (container)\n        x = Math.min(Math.max(0, x), container.scrollWidth - targetRect.width);\n    }\n    if (axis === \"y\" || axis === \"both\") {\n      y = e.clientY - pressedDelta.value.y;\n      if (container)\n        y = Math.min(Math.max(0, y), container.scrollHeight - targetRect.height);\n    }\n    position.value = {\n      x,\n      y\n    };\n    onMove == null ? void 0 : onMove(position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    onEnd == null ? void 0 : onEnd(position.value, e);\n    handleEvent(e);\n  };\n  if (isClient) {\n    const config = { capture: (_b = options.capture) != null ? _b : true };\n    useEventListener(draggingHandle, \"pointerdown\", start, config);\n    useEventListener(draggingElement, \"pointermove\", move, config);\n    useEventListener(draggingElement, \"pointerup\", end, config);\n  }\n  return {\n    ...toRefs(position),\n    position,\n    isDragging: computed(() => !!pressedDelta.value),\n    style: computed(\n      () => `left:${position.value.x}px;top:${position.value.y}px;`\n    )\n  };\n}\n\nfunction useDropZone(target, options = {}) {\n  const isOverDropZone = ref(false);\n  const files = shallowRef(null);\n  let counter = 0;\n  let isDataTypeIncluded = true;\n  if (isClient) {\n    const _options = typeof options === \"function\" ? { onDrop: options } : options;\n    const getFiles = (event) => {\n      var _a, _b;\n      const list = Array.from((_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);\n      return files.value = list.length === 0 ? null : list;\n    };\n    useEventListener(target, \"dragenter\", (event) => {\n      var _a, _b;\n      const types = Array.from(((_a = event == null ? void 0 : event.dataTransfer) == null ? void 0 : _a.items) || []).map((i) => i.kind === \"file\" ? i.type : null).filter(notNullish);\n      if (_options.dataTypes && event.dataTransfer) {\n        const dataTypes = unref(_options.dataTypes);\n        isDataTypeIncluded = typeof dataTypes === \"function\" ? dataTypes(types) : dataTypes ? dataTypes.some((item) => types.includes(item)) : true;\n        if (!isDataTypeIncluded)\n          return;\n      }\n      event.preventDefault();\n      counter += 1;\n      isOverDropZone.value = true;\n      (_b = _options.onEnter) == null ? void 0 : _b.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"dragover\", (event) => {\n      var _a;\n      if (!isDataTypeIncluded)\n        return;\n      event.preventDefault();\n      (_a = _options.onOver) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"dragleave\", (event) => {\n      var _a;\n      if (!isDataTypeIncluded)\n        return;\n      event.preventDefault();\n      counter -= 1;\n      if (counter === 0)\n        isOverDropZone.value = false;\n      (_a = _options.onLeave) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"drop\", (event) => {\n      var _a;\n      event.preventDefault();\n      counter = 0;\n      isOverDropZone.value = false;\n      (_a = _options.onDrop) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n  }\n  return {\n    files,\n    isOverDropZone\n  };\n}\n\nfunction useResizeObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...observerOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]);\n  const stopWatch = watch(\n    targets,\n    (els) => {\n      cleanup();\n      if (isSupported.value && window) {\n        observer = new ResizeObserver(callback);\n        for (const _el of els)\n          _el && observer.observe(_el, observerOptions);\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true\n  } = options;\n  const height = ref(0);\n  const bottom = ref(0);\n  const left = ref(0);\n  const right = ref(0);\n  const top = ref(0);\n  const width = ref(0);\n  const x = ref(0);\n  const y = ref(0);\n  function update() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  useResizeObserver(target, update);\n  watch(() => unrefElement(target), (ele) => !ele && update());\n  useMutationObserver(target, update, {\n    attributeFilter: [\"style\", \"class\"]\n  });\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { capture: true, passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  tryOnMounted(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nfunction useElementByPoint(options) {\n  const {\n    x,\n    y,\n    document = defaultDocument,\n    multiple,\n    interval = \"requestAnimationFrame\",\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => {\n    if (toValue(multiple))\n      return document && \"elementsFromPoint\" in document;\n    return document && \"elementFromPoint\" in document;\n  });\n  const element = ref(null);\n  const cb = () => {\n    var _a, _b;\n    element.value = toValue(multiple) ? (_a = document == null ? void 0 : document.elementsFromPoint(toValue(x), toValue(y))) != null ? _a : [] : (_b = document == null ? void 0 : document.elementFromPoint(toValue(x), toValue(y))) != null ? _b : null;\n  };\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  return {\n    isSupported,\n    element,\n    ...controls\n  };\n}\n\nfunction useElementHover(el, options = {}) {\n  const {\n    delayEnter = 0,\n    delayLeave = 0,\n    window = defaultWindow\n  } = options;\n  const isHovered = ref(false);\n  let timer;\n  const toggle = (entering) => {\n    const delay = entering ? delayEnter : delayLeave;\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n    if (delay)\n      timer = setTimeout(() => isHovered.value = entering, delay);\n    else\n      isHovered.value = entering;\n  };\n  if (!window)\n    return isHovered;\n  useEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\n  useEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { window = defaultWindow, box = \"content-box\" } = options;\n  const isSVG = computed(() => {\n    var _a, _b;\n    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes(\"svg\");\n  });\n  const width = ref(initialSize.width);\n  const height = ref(initialSize.height);\n  const { stop: stop1 } = useResizeObserver(\n    target,\n    ([entry]) => {\n      const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n      if (window && isSVG.value) {\n        const $elem = unrefElement(target);\n        if ($elem) {\n          const styles = window.getComputedStyle($elem);\n          width.value = Number.parseFloat(styles.width);\n          height.value = Number.parseFloat(styles.height);\n        }\n      } else {\n        if (boxSize) {\n          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];\n          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n        } else {\n          width.value = entry.contentRect.width;\n          height.value = entry.contentRect.height;\n        }\n      }\n    },\n    options\n  );\n  tryOnMounted(() => {\n    const ele = unrefElement(target);\n    if (ele) {\n      width.value = \"offsetWidth\" in ele ? ele.offsetWidth : initialSize.width;\n      height.value = \"offsetHeight\" in ele ? ele.offsetHeight : initialSize.height;\n    }\n  });\n  const stop2 = watch(\n    () => unrefElement(target),\n    (ele) => {\n      width.value = ele ? initialSize.width : 0;\n      height.value = ele ? initialSize.height : 0;\n    }\n  );\n  function stop() {\n    stop1();\n    stop2();\n  }\n  return {\n    width,\n    height,\n    stop\n  };\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0.1,\n    window = defaultWindow,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  const targets = computed(() => {\n    const _target = toValue(target);\n    return (Array.isArray(_target) ? _target : [_target]).map(unrefElement).filter(notNullish);\n  });\n  let cleanup = noop;\n  const isActive = ref(immediate);\n  const stopWatch = isSupported.value ? watch(\n    () => [targets.value, unrefElement(root), isActive.value],\n    ([targets2, root2]) => {\n      cleanup();\n      if (!isActive.value)\n        return;\n      if (!targets2.length)\n        return;\n      const observer = new IntersectionObserver(\n        callback,\n        {\n          root: unrefElement(root2),\n          rootMargin,\n          threshold\n        }\n      );\n      targets2.forEach((el) => el && observer.observe(el));\n      cleanup = () => {\n        observer.disconnect();\n        cleanup = noop;\n      };\n    },\n    { immediate, flush: \"post\" }\n  ) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n    isActive.value = false;\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    isActive,\n    pause() {\n      cleanup();\n      isActive.value = false;\n    },\n    resume() {\n      isActive.value = true;\n    },\n    stop\n  };\n}\n\nfunction useElementVisibility(element, options = {}) {\n  const { window = defaultWindow, scrollTarget, threshold = 0 } = options;\n  const elementIsVisible = ref(false);\n  useIntersectionObserver(\n    element,\n    (intersectionObserverEntries) => {\n      let isIntersecting = elementIsVisible.value;\n      let latestTime = 0;\n      for (const entry of intersectionObserverEntries) {\n        if (entry.time >= latestTime) {\n          latestTime = entry.time;\n          isIntersecting = entry.isIntersecting;\n        }\n      }\n      elementIsVisible.value = isIntersecting;\n    },\n    {\n      root: scrollTarget,\n      window,\n      threshold\n    }\n  );\n  return elementIsVisible;\n}\n\nconst events = /* @__PURE__ */ new Map();\n\nfunction useEventBus(key) {\n  const scope = getCurrentScope();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || /* @__PURE__ */ new Set();\n    listeners.add(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    listeners.delete(listener);\n    if (!listeners.size)\n      reset();\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction resolveNestedOptions$1(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useEventSource(url, events = [], options = {}) {\n  const event = ref(null);\n  const data = ref(null);\n  const status = ref(\"CONNECTING\");\n  const eventSource = ref(null);\n  const error = shallowRef(null);\n  const urlRef = toRef(url);\n  let explicitlyClosed = false;\n  let retried = 0;\n  const {\n    withCredentials = false,\n    immediate = true\n  } = options;\n  const close = () => {\n    if (isClient && eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n      explicitlyClosed = true;\n    }\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const es = new EventSource(urlRef.value, { withCredentials });\n    status.value = \"CONNECTING\";\n    eventSource.value = es;\n    es.onopen = () => {\n      status.value = \"OPEN\";\n      error.value = null;\n    };\n    es.onerror = (e) => {\n      status.value = \"CLOSED\";\n      error.value = e;\n      if (es.readyState === 2 && !explicitlyClosed && options.autoReconnect) {\n        es.close();\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions$1(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    es.onmessage = (e) => {\n      event.value = null;\n      data.value = e.data;\n    };\n    for (const event_name of events) {\n      useEventListener(es, event_name, (e) => {\n        event.value = event_name;\n        data.value = e.data || null;\n      });\n    }\n  };\n  const open = () => {\n    if (!isClient)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    watch(urlRef, open, { immediate: true });\n  tryOnScopeDispose(close);\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    open,\n    close\n  };\n}\n\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = ref(initialValue);\n  async function open(openOptions) {\n    if (!isSupported.value)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = toRef(newIcon);\n  const applyIcon = (icon) => {\n    const elements = document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`);\n    if (!elements || elements.length === 0) {\n      const link = document == null ? void 0 : document.createElement(\"link\");\n      if (link) {\n        link.rel = rel;\n        link.href = `${baseUrl}${icon}`;\n        link.type = `image/${icon.split(\".\").pop()}`;\n        document == null ? void 0 : document.head.append(link);\n      }\n      return;\n    }\n    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  watch(\n    favicon,\n    (i, o) => {\n      if (typeof i === \"string\" && i !== o)\n        applyIcon(i);\n    },\n    { immediate: true }\n  );\n  return favicon;\n}\n\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\"\n};\nfunction isFetchOptions(obj) {\n  return obj && containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\", \"updateDataOnError\");\n}\nfunction isAbsoluteURL(url) {\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\nfunction headersToObject(headers) {\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\n    return Object.fromEntries(headers.entries());\n  return headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n  if (combination === \"overwrite\") {\n    return async (ctx) => {\n      const callback = callbacks[callbacks.length - 1];\n      if (callback)\n        return { ...ctx, ...await callback(ctx) };\n      return ctx;\n    };\n  } else {\n    return async (ctx) => {\n      for (const callback of callbacks) {\n        if (callback)\n          ctx = { ...ctx, ...await callback(ctx) };\n      }\n      return ctx;\n    };\n  }\n}\nfunction createFetch(config = {}) {\n  const _combination = config.combination || \"chain\";\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = computed(() => {\n      const baseUrl = toValue(config.baseUrl);\n      const targetUrl = toValue(url);\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n    });\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = {\n          ...options,\n          ...args[0],\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n        };\n      } else {\n        fetchOptions = {\n          ...fetchOptions,\n          ...args[0],\n          headers: {\n            ...headersToObject(fetchOptions.headers) || {},\n            ...headersToObject(args[0].headers) || {}\n          }\n        };\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1])) {\n      options = {\n        ...options,\n        ...args[1],\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n      };\n    }\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = {\n    immediate: true,\n    refetch: false,\n    timeout: 0,\n    updateDataOnError: false\n  };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = { ...options, ...args[0] };\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = { ...options, ...args[1] };\n  }\n  const {\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = createEventHook();\n  const errorEvent = createEventHook();\n  const finallyEvent = createEventHook();\n  const isFinished = ref(false);\n  const isFetching = ref(false);\n  const aborted = ref(false);\n  const statusCode = ref(null);\n  const response = shallowRef(null);\n  const error = shallowRef(null);\n  const data = shallowRef(initialData || null);\n  const canAbort = computed(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = () => {\n    if (supportsAbort) {\n      controller == null ? void 0 : controller.abort();\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = {\n        ...fetchOptions,\n        signal: controller.signal\n      };\n    }\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\n  let executeCounter = 0;\n  const execute = async (throwOnFailed = false) => {\n    var _a2, _b;\n    abort();\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    executeCounter += 1;\n    const currentExecuteCounter = executeCounter;\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    if (config.payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      const payload = toValue(config.payload);\n      if (!config.payloadType && payload && Object.getPrototypeOf(payload) === Object.prototype && !(payload instanceof FormData))\n        config.payloadType = \"json\";\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n    }\n    let isCanceled = false;\n    const context = {\n      url: toValue(url),\n      options: {\n        ...defaultFetchOptions,\n        ...fetchOptions\n      },\n      cancel: () => {\n        isCanceled = true;\n      }\n    };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return fetch(\n      context.url,\n      {\n        ...defaultFetchOptions,\n        ...context.options,\n        headers: {\n          ...headersToObject(defaultFetchOptions.headers),\n          ...headersToObject((_b = context.options) == null ? void 0 : _b.headers)\n        }\n      }\n    ).then(async (fetchResponse) => {\n      response.value = fetchResponse;\n      statusCode.value = fetchResponse.status;\n      responseData = await fetchResponse.clone()[config.type]();\n      if (!fetchResponse.ok) {\n        data.value = initialData || null;\n        throw new Error(fetchResponse.statusText);\n      }\n      if (options.afterFetch) {\n        ({ data: responseData } = await options.afterFetch({\n          data: responseData,\n          response: fetchResponse\n        }));\n      }\n      data.value = responseData;\n      responseEvent.trigger(fetchResponse);\n      return fetchResponse;\n    }).catch(async (fetchError) => {\n      let errorData = fetchError.message || fetchError.name;\n      if (options.onFetchError) {\n        ({ error: errorData, data: responseData } = await options.onFetchError({\n          data: responseData,\n          error: fetchError,\n          response: response.value\n        }));\n      }\n      error.value = errorData;\n      if (options.updateDataOnError)\n        data.value = responseData;\n      errorEvent.trigger(fetchError);\n      if (throwOnFailed)\n        throw fetchError;\n      return null;\n    }).finally(() => {\n      if (currentExecuteCounter === executeCounter)\n        loading(false);\n      if (timer)\n        timer.stop();\n      finallyEvent.trigger(null);\n    });\n  };\n  const refetch = toRef(options.refetch);\n  watch(\n    [\n      refetch,\n      toRef(url)\n    ],\n    ([refetch2]) => refetch2 && execute(),\n    { deep: true }\n  );\n  const shell = {\n    isFinished: readonly(isFinished),\n    isFetching: readonly(isFetching),\n    statusCode,\n    response,\n    error,\n    data,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    // method\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    // type\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if (isRef(config.payload)) {\n          watch(\n            [\n              refetch,\n              toRef(config.payload)\n            ],\n            ([refetch2]) => refetch2 && execute(),\n            { deep: true }\n          );\n        }\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    Promise.resolve().then(() => execute());\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  };\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\"))\n    return `${start}/${end}`;\n  return `${start}${end}`;\n}\n\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: \"*\",\n  reset: false,\n  directory: false\n};\nfunction useFileDialog(options = {}) {\n  const {\n    document = defaultDocument\n  } = options;\n  const files = ref(null);\n  const { on: onChange, trigger } = createEventHook();\n  let input;\n  if (document) {\n    input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.onchange = (event) => {\n      const result = event.target;\n      files.value = result.files;\n      trigger(files.value);\n    };\n  }\n  const reset = () => {\n    files.value = null;\n    if (input) {\n      input.value = \"\";\n      trigger(null);\n    }\n  };\n  const open = (localOptions) => {\n    if (!input)\n      return;\n    const _options = {\n      ...DEFAULT_OPTIONS,\n      ...options,\n      ...localOptions\n    };\n    input.multiple = _options.multiple;\n    input.accept = _options.accept;\n    input.webkitdirectory = _options.directory;\n    if (hasOwn(_options, \"capture\"))\n      input.capture = _options.capture;\n    if (_options.reset)\n      reset();\n    input.click();\n  };\n  return {\n    files: readonly(files),\n    open,\n    reset,\n    onChange\n  };\n}\n\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = options;\n  const window = _window;\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = ref();\n  const data = ref();\n  const file = ref();\n  const fileName = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported.value)\n      return;\n    const [handle] = await window.showOpenFilePicker({ ...toValue(options), ..._options });\n    fileHandle.value = handle;\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    data.value = void 0;\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported.value)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    await updateFile();\n    const type = toValue(dataType);\n    if (type === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    else if (type === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    else if (type === \"Blob\")\n      data.value = file.value;\n  }\n  watch(() => toValue(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false, focusVisible = false } = options;\n  const innerFocused = ref(false);\n  const targetElement = computed(() => unrefElement(target));\n  useEventListener(targetElement, \"focus\", (event) => {\n    var _a, _b;\n    if (!focusVisible || ((_b = (_a = event.target).matches) == null ? void 0 : _b.call(_a, \":focus-visible\")))\n      innerFocused.value = true;\n  });\n  useEventListener(targetElement, \"blur\", () => innerFocused.value = false);\n  const focused = computed({\n    get: () => innerFocused.value,\n    set(value) {\n      var _a, _b;\n      if (!value && innerFocused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      else if (value && !innerFocused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus();\n    }\n  });\n  watch(\n    targetElement,\n    () => {\n      focused.value = initialValue;\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  return { focused };\n}\n\nfunction useFocusWithin(target, options = {}) {\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);\n  return { focused };\n}\n\nfunction useFps(options) {\n  var _a;\n  const fps = ref(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst eventHandlers = [\n  \"fullscreenchange\",\n  \"webkitfullscreenchange\",\n  \"webkitendfullscreen\",\n  \"mozfullscreenchange\",\n  \"MSFullscreenChange\"\n];\nfunction useFullscreen(target, options = {}) {\n  const {\n    document = defaultDocument,\n    autoExit = false\n  } = options;\n  const targetRef = computed(() => {\n    var _a;\n    return (_a = unrefElement(target)) != null ? _a : document == null ? void 0 : document.querySelector(\"html\");\n  });\n  const isFullscreen = ref(false);\n  const requestMethod = computed(() => {\n    return [\n      \"requestFullscreen\",\n      \"webkitRequestFullscreen\",\n      \"webkitEnterFullscreen\",\n      \"webkitEnterFullScreen\",\n      \"webkitRequestFullScreen\",\n      \"mozRequestFullScreen\",\n      \"msRequestFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const exitMethod = computed(() => {\n    return [\n      \"exitFullscreen\",\n      \"webkitExitFullscreen\",\n      \"webkitExitFullScreen\",\n      \"webkitCancelFullScreen\",\n      \"mozCancelFullScreen\",\n      \"msExitFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenEnabled = computed(() => {\n    return [\n      \"fullScreen\",\n      \"webkitIsFullScreen\",\n      \"webkitDisplayingFullscreen\",\n      \"mozFullScreen\",\n      \"msFullscreenElement\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenElementMethod = [\n    \"fullscreenElement\",\n    \"webkitFullscreenElement\",\n    \"mozFullScreenElement\",\n    \"msFullscreenElement\"\n  ].find((m) => document && m in document);\n  const isSupported = useSupported(() => targetRef.value && document && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);\n  const isCurrentElementFullScreen = () => {\n    if (fullscreenElementMethod)\n      return (document == null ? void 0 : document[fullscreenElementMethod]) === targetRef.value;\n    return false;\n  };\n  const isElementFullScreen = () => {\n    if (fullscreenEnabled.value) {\n      if (document && document[fullscreenEnabled.value] != null) {\n        return document[fullscreenEnabled.value];\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {\n          return Boolean(target2[fullscreenEnabled.value]);\n        }\n      }\n    }\n    return false;\n  };\n  async function exit() {\n    if (!isSupported.value || !isFullscreen.value)\n      return;\n    if (exitMethod.value) {\n      if ((document == null ? void 0 : document[exitMethod.value]) != null) {\n        await document[exitMethod.value]();\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)\n          await target2[exitMethod.value]();\n      }\n    }\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported.value || isFullscreen.value)\n      return;\n    if (isElementFullScreen())\n      await exit();\n    const target2 = targetRef.value;\n    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {\n      await target2[requestMethod.value]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    await (isFullscreen.value ? exit() : enter());\n  }\n  const handlerCallback = () => {\n    const isElementFullScreenValue = isElementFullScreen();\n    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())\n      isFullscreen.value = isElementFullScreenValue;\n  };\n  useEventListener(document, eventHandlers, handlerCallback, false);\n  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, false);\n  if (autoExit)\n    tryOnScopeDispose(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return computed(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\n  const gamepads = ref([]);\n  const onConnectedHook = createEventHook();\n  const onDisconnectedHook = createEventHook();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return {\n      ...gamepad,\n      id: gamepad.id,\n      hapticActuators,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value })),\n      index: gamepad.index\n    };\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        gamepads.value[gamepad.index] = stateFromGamepad(gamepad);\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad));\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad));\n  tryOnMounted(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        onGamepadConnected(gamepad);\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\n  const locatedAt = ref(null);\n  const error = shallowRef(null);\n  const coords = ref({\n    accuracy: 0,\n    latitude: Number.POSITIVE_INFINITY,\n    longitude: Number.POSITIVE_INFINITY,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  function resume() {\n    if (isSupported.value) {\n      watcher = navigator.geolocation.watchPosition(\n        updatePosition,\n        (err) => error.value = err,\n        {\n          enableHighAccuracy,\n          maximumAge,\n          timeout\n        }\n      );\n    }\n  }\n  if (immediate)\n    resume();\n  function pause() {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  }\n  tryOnScopeDispose(() => {\n    pause();\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error,\n    resume,\n    pause\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = throttleFilter(50)\n  } = options;\n  const idle = ref(initialState);\n  const lastActive = ref(timestamp());\n  let timer;\n  const reset = () => {\n    idle.value = false;\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  };\n  const onEvent = createFilterWrapper(\n    eventFilter,\n    () => {\n      lastActive.value = timestamp();\n      reset();\n    }\n  );\n  if (window) {\n    const document = window.document;\n    for (const event of events)\n      useEventListener(window, event, onEvent, { passive: true });\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      });\n    }\n    reset();\n  }\n  return {\n    idle,\n    lastActive,\n    reset\n  };\n}\n\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy } = options;\n    img.src = src;\n    if (srcset)\n      img.srcset = srcset;\n    if (sizes)\n      img.sizes = sizes;\n    if (clazz)\n      img.className = clazz;\n    if (loading)\n      img.loading = loading;\n    if (crossorigin)\n      img.crossOrigin = crossorigin;\n    if (referrerPolicy)\n      img.referrerPolicy = referrerPolicy;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nfunction useImage(options, asyncStateOptions = {}) {\n  const state = useAsyncState(\n    () => loadImage(toValue(options)),\n    void 0,\n    {\n      resetOnExecute: true,\n      ...asyncStateOptions\n    }\n  );\n  watch(\n    () => toValue(options),\n    () => state.execute(asyncStateOptions.delay),\n    { deep: true }\n  );\n  return state;\n}\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\",\n    window = defaultWindow,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const internalX = ref(0);\n  const internalY = ref(0);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c;\n    if (!window)\n      return;\n    const _element = toValue(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? window.document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = toValue(_y)) != null ? _a : y.value,\n      left: (_b = toValue(_x)) != null ? _b : x.value,\n      behavior: toValue(behavior)\n    });\n  }\n  const isScrolling = ref(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = (e) => {\n    if (!isScrolling.value)\n      return;\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  };\n  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);\n  const setArrivedState = (target) => {\n    var _a;\n    if (!window)\n      return;\n    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);\n    const { display, flexDirection } = getComputedStyle(el);\n    const scrollLeft = el.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalX.value;\n    const left = Math.abs(scrollLeft) <= (offset.left || 0);\n    const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"row-reverse\") {\n      arrivedState.left = right;\n      arrivedState.right = left;\n    } else {\n      arrivedState.left = left;\n      arrivedState.right = right;\n    }\n    internalX.value = scrollLeft;\n    let scrollTop = el.scrollTop;\n    if (target === window.document && !scrollTop)\n      scrollTop = window.document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    const top = Math.abs(scrollTop) <= (offset.top || 0);\n    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"column-reverse\") {\n      arrivedState.top = bottom;\n      arrivedState.bottom = top;\n    } else {\n      arrivedState.top = top;\n      arrivedState.bottom = bottom;\n    }\n    internalY.value = scrollTop;\n  };\n  const onScrollHandler = (e) => {\n    var _a;\n    if (!window)\n      return;\n    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;\n    setArrivedState(eventTarget);\n    isScrolling.value = true;\n    onScrollEndDebounced(e);\n    onScroll(e);\n  };\n  useEventListener(\n    element,\n    \"scroll\",\n    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,\n    eventListenerOptions\n  );\n  tryOnMounted(() => {\n    try {\n      const _element = toValue(element);\n      if (!_element)\n        return;\n      setArrivedState(_element);\n    } catch (e) {\n      onError(e);\n    }\n  });\n  useEventListener(\n    element,\n    \"scrollend\",\n    onScrollEnd,\n    eventListenerOptions\n  );\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions,\n    measure() {\n      const _element = toValue(element);\n      if (window && _element)\n        setArrivedState(_element);\n    }\n  };\n}\n\nfunction resolveElement(el) {\n  if (typeof Window !== \"undefined\" && el instanceof Window)\n    return el.document.documentElement;\n  if (typeof Document !== \"undefined\" && el instanceof Document)\n    return el.documentElement;\n  return el;\n}\n\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a;\n  const {\n    direction = \"bottom\",\n    interval = 100,\n    canLoadMore = () => true\n  } = options;\n  const state = reactive(useScroll(\n    element,\n    {\n      ...options,\n      offset: {\n        [direction]: (_a = options.distance) != null ? _a : 0,\n        ...options.offset\n      }\n    }\n  ));\n  const promise = ref();\n  const isLoading = computed(() => !!promise.value);\n  const observedElement = computed(() => {\n    return resolveElement(toValue(element));\n  });\n  const isElementVisible = useElementVisibility(observedElement);\n  function checkAndLoad() {\n    state.measure();\n    if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value))\n      return;\n    const { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value;\n    const isNarrower = direction === \"bottom\" || direction === \"top\" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;\n    if (state.arrivedState[direction] || isNarrower) {\n      if (!promise.value) {\n        promise.value = Promise.all([\n          onLoadMore(state),\n          new Promise((resolve) => setTimeout(resolve, interval))\n        ]).finally(() => {\n          promise.value = null;\n          nextTick(() => checkAndLoad());\n        });\n      }\n    }\n  }\n  watch(\n    () => [state.arrivedState[direction], isElementVisible.value],\n    checkAndLoad,\n    { immediate: true }\n  );\n  return {\n    isLoading\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = ref(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = noop\n  } = options;\n  const current = reactive(/* @__PURE__ */ new Set());\n  const obj = {\n    toJSON() {\n      return {};\n    },\n    current\n  };\n  const refs = useReactive ? reactive(obj) : obj;\n  const metaDeps = /* @__PURE__ */ new Set();\n  const usedKeys = /* @__PURE__ */ new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function reset() {\n    current.clear();\n    for (const key of usedKeys)\n      setRefs(key, false);\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (key) {\n      if (value)\n        current.add(key);\n      else\n        current.delete(key);\n    }\n    for (const key2 of values) {\n      usedKeys.add(key2);\n      setRefs(key2, value);\n    }\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  useEventListener(target, \"keydown\", (e) => {\n    updateRefs(e, true);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(target, \"keyup\", (e) => {\n    updateRefs(e, false);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(\"blur\", reset, { passive: true });\n  useEventListener(\"focus\", reset, { passive: true });\n  const proxy = new Proxy(\n    refs,\n    {\n      get(target2, prop, rec) {\n        if (typeof prop !== \"string\")\n          return Reflect.get(target2, prop, rec);\n        prop = prop.toLowerCase();\n        if (prop in aliasMap)\n          prop = aliasMap[prop];\n        if (!(prop in refs)) {\n          if (/[+_-]/.test(prop)) {\n            const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n            refs[prop] = computed(() => keys.every((key) => toValue(proxy[key])));\n          } else {\n            refs[prop] = ref(false);\n          }\n        }\n        const r = Reflect.get(target2, prop, rec);\n        return useReactive ? toValue(r) : r;\n      }\n    }\n  );\n  return proxy;\n}\n\nfunction usingElRef(source, cb) {\n  if (toValue(source))\n    cb(toValue(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  options = {\n    ...defaultOptions,\n    ...options\n  };\n  const {\n    document = defaultDocument\n  } = options;\n  const currentTime = ref(0);\n  const duration = ref(0);\n  const seeking = ref(false);\n  const volume = ref(1);\n  const waiting = ref(false);\n  const ended = ref(false);\n  const playing = ref(false);\n  const rate = ref(1);\n  const stalled = ref(false);\n  const buffered = ref([]);\n  const tracks = ref([]);\n  const selectedTrack = ref(-1);\n  const isPictureInPicture = ref(false);\n  const muted = ref(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = createEventHook();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = typeof track === \"number\" ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = typeof track === \"number\" ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  watchEffect(() => {\n    if (!document)\n      return;\n    const el = toValue(target);\n    if (!el)\n      return;\n    const src = toValue(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (typeof src === \"string\")\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if (isObject(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.removeEventListener(\"error\", sourceErrorEvent.trigger);\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.addEventListener(\"error\", sourceErrorEvent.trigger);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  tryOnScopeDispose(() => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.querySelectorAll(\"source\").forEach((e) => e.removeEventListener(\"error\", sourceErrorEvent.trigger));\n  });\n  watch([target, volume], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.volume = volume.value;\n  });\n  watch([target, muted], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.muted = muted.value;\n  });\n  watch([target, rate], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.playbackRate = rate.value;\n  });\n  watchEffect(() => {\n    if (!document)\n      return;\n    const textTracks = toValue(options.tracks);\n    const el = toValue(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    isPlaying ? el.play() : el.pause();\n  });\n  useEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime));\n  useEventListener(target, \"durationchange\", () => duration.value = toValue(target).duration);\n  useEventListener(target, \"progress\", () => buffered.value = timeRangeToArray(toValue(target).buffered));\n  useEventListener(target, \"seeking\", () => seeking.value = true);\n  useEventListener(target, \"seeked\", () => seeking.value = false);\n  useEventListener(target, [\"waiting\", \"loadstart\"], () => {\n    waiting.value = true;\n    ignorePlayingUpdates(() => playing.value = false);\n  });\n  useEventListener(target, \"loadeddata\", () => waiting.value = false);\n  useEventListener(target, \"playing\", () => {\n    waiting.value = false;\n    ended.value = false;\n    ignorePlayingUpdates(() => playing.value = true);\n  });\n  useEventListener(target, \"ratechange\", () => rate.value = toValue(target).playbackRate);\n  useEventListener(target, \"stalled\", () => stalled.value = true);\n  useEventListener(target, \"ended\", () => ended.value = true);\n  useEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false));\n  useEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true));\n  useEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true);\n  useEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false);\n  useEventListener(target, \"volumechange\", () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    volume.value = el.volume;\n    muted.value = el.muted;\n  });\n  const listeners = [];\n  const stop = watch([target], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks));\n  });\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    // Volume\n    volume,\n    muted,\n    // Tracks\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    // Picture in Picture\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    // Events\n    onSourceError: sourceErrorEvent.on\n  };\n}\n\nfunction getMapVue2Compat() {\n  const data = shallowReactive({});\n  return {\n    get: (key) => data[key],\n    set: (key, value) => set(data, key, value),\n    has: (key) => hasOwn(data, key),\n    delete: (key) => del(data, key),\n    clear: () => {\n      Object.keys(data).forEach((key) => {\n        del(data, key);\n      });\n    }\n  };\n}\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return shallowReactive(options.cache);\n    if (isVue2)\n      return getMapVue2Compat();\n    return shallowReactive(/* @__PURE__ */ new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\nfunction useMemory(options = {}) {\n  const memory = ref();\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n  if (isSupported.value) {\n    const { interval = 1e3 } = options;\n    useIntervalFn(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nconst UseMouseBuiltinExtractors = {\n  page: (event) => [event.pageX, event.pageY],\n  client: (event) => [event.clientX, event.clientY],\n  screen: (event) => [event.screenX, event.screenY],\n  movement: (event) => event instanceof Touch ? null : [event.movementX, event.movementY]\n};\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    target = window,\n    scroll = true,\n    eventFilter\n  } = options;\n  let _prevMouseEvent = null;\n  const x = ref(initialValue.x);\n  const y = ref(initialValue.y);\n  const sourceType = ref(null);\n  const extractor = typeof type === \"function\" ? type : UseMouseBuiltinExtractors[type];\n  const mouseHandler = (event) => {\n    const result = extractor(event);\n    _prevMouseEvent = event;\n    if (result) {\n      [x.value, y.value] = result;\n      sourceType.value = \"mouse\";\n    }\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const result = extractor(event.touches[0]);\n      if (result) {\n        [x.value, y.value] = result;\n        sourceType.value = \"touch\";\n      }\n    }\n  };\n  const scrollHandler = () => {\n    if (!_prevMouseEvent || !window)\n      return;\n    const pos = extractor(_prevMouseEvent);\n    if (_prevMouseEvent instanceof MouseEvent && pos) {\n      x.value = pos[0] + window.scrollX;\n      y.value = pos[1] + window.scrollY;\n    }\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);\n  const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);\n  const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"mousemove\", \"dragover\"], mouseHandlerWrapper, listenerOptions);\n    if (touch && type !== \"movement\") {\n      useEventListener(target, [\"touchstart\", \"touchmove\"], touchHandlerWrapper, listenerOptions);\n      if (resetOnTouchEnds)\n        useEventListener(target, \"touchend\", reset, listenerOptions);\n    }\n    if (scroll && type === \"page\")\n      useEventListener(window, \"scroll\", scrollHandlerWrapper, { passive: true });\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const type = options.type || \"page\";\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = ref(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = ref(0);\n  const elementY = ref(0);\n  const elementPositionX = ref(0);\n  const elementPositionY = ref(0);\n  const elementHeight = ref(0);\n  const elementWidth = ref(0);\n  const isOutside = ref(true);\n  let stop = () => {\n  };\n  if (window) {\n    stop = watch(\n      [targetRef, x, y],\n      () => {\n        const el = unrefElement(targetRef);\n        if (!el)\n          return;\n        const {\n          left,\n          top,\n          width,\n          height\n        } = el.getBoundingClientRect();\n        elementPositionX.value = left + (type === \"page\" ? window.pageXOffset : 0);\n        elementPositionY.value = top + (type === \"page\" ? window.pageYOffset : 0);\n        elementHeight.value = height;\n        elementWidth.value = width;\n        const elX = x.value - elementPositionX.value;\n        const elY = y.value - elementPositionY.value;\n        isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n        if (handleOutside || !isOutside.value) {\n          elementX.value = elX;\n          elementY.value = elY;\n        }\n      },\n      { immediate: true }\n    );\n    useEventListener(document, \"mouseleave\", () => {\n      isOutside.value = true;\n    });\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    capture = false,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = ref(initialValue);\n  const sourceType = ref(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => () => {\n    pressed.value = true;\n    sourceType.value = srcType;\n  };\n  const onReleased = () => {\n    pressed.value = false;\n    sourceType.value = null;\n  };\n  const target = computed(() => unrefElement(options.target) || window);\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), { passive: true, capture });\n  useEventListener(window, \"mouseleave\", onReleased, { passive: true, capture });\n  useEventListener(window, \"mouseup\", onReleased, { passive: true, capture });\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), { passive: true, capture });\n    useEventListener(window, \"drop\", onReleased, { passive: true, capture });\n    useEventListener(window, \"dragend\", onReleased, { passive: true, capture });\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), { passive: true, capture });\n    useEventListener(window, \"touchend\", onReleased, { passive: true, capture });\n    useEventListener(window, \"touchcancel\", onReleased, { passive: true, capture });\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\nfunction useNavigatorLanguage(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\n  const language = ref(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  });\n  return {\n    isSupported,\n    language\n  };\n}\n\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\n  const isOnline = ref(true);\n  const saveData = ref(false);\n  const offlineAt = ref(void 0);\n  const onlineAt = ref(void 0);\n  const downlink = ref(void 0);\n  const downlinkMax = ref(void 0);\n  const rtt = ref(void 0);\n  const effectiveType = ref(void 0);\n  const type = ref(\"unknown\");\n  const connection = isSupported.value && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    });\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    });\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, false);\n  updateNetworkInformation();\n  return {\n    isSupported,\n    isOnline,\n    saveData,\n    offlineAt,\n    onlineAt,\n    downlink,\n    downlinkMax,\n    effectiveType,\n    rtt,\n    type\n  };\n}\n\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\"\n  } = options;\n  const now = ref(/* @__PURE__ */ new Date());\n  const update = () => now.value = /* @__PURE__ */ new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });\n  if (exposeControls) {\n    return {\n      now,\n      ...controls\n    };\n  } else {\n    return now;\n  }\n}\n\nfunction useObjectUrl(object) {\n  const url = ref();\n  const release = () => {\n    if (url.value)\n      URL.revokeObjectURL(url.value);\n    url.value = void 0;\n  };\n  watch(\n    () => toValue(object),\n    (newObject) => {\n      release();\n      if (newObject)\n        url.value = URL.createObjectURL(newObject);\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(release);\n  return readonly(url);\n}\n\nfunction useClamp(value, min, max) {\n  if (typeof value === \"function\" || isReadonly(value))\n    return computed(() => clamp(toValue(value), toValue(min), toValue(max)));\n  const _value = ref(value);\n  return computed({\n    get() {\n      return _value.value = clamp(_value.value, toValue(min), toValue(max));\n    },\n    set(value2) {\n      _value.value = clamp(value2, toValue(min), toValue(max));\n    }\n  });\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Number.POSITIVE_INFINITY,\n    pageSize = 10,\n    page = 1,\n    onPageChange = noop,\n    onPageSizeChange = noop,\n    onPageCountChange = noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);\n  const pageCount = computed(() => Math.max(\n    1,\n    Math.ceil(toValue(total) / toValue(currentPageSize))\n  ));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = computed(() => currentPage.value === 1);\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\n  if (isRef(page)) {\n    syncRef(page, currentPage, {\n      direction: isReadonly(page) ? \"ltr\" : \"both\"\n    });\n  }\n  if (isRef(pageSize)) {\n    syncRef(pageSize, currentPageSize, {\n      direction: isReadonly(pageSize) ? \"ltr\" : \"both\"\n    });\n  }\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  watch(currentPage, () => {\n    onPageChange(reactive(returnValue));\n  });\n  watch(currentPageSize, () => {\n    onPageSizeChange(reactive(returnValue));\n  });\n  watch(pageCount, () => {\n    onPageCountChange(reactive(returnValue));\n  });\n  return returnValue;\n}\n\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = ref(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    useEventListener(window, \"mouseout\", handler, { passive: true });\n    useEventListener(window.document, \"mouseleave\", handler, { passive: true });\n    useEventListener(window.document, \"mouseenter\", handler, { passive: true });\n  }\n  return isLeft;\n}\n\nfunction useScreenOrientation(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\n  const orientation = ref(screenOrientation.type);\n  const angle = ref(screenOrientation.angle || 0);\n  if (isSupported.value) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    });\n  }\n  const lockOrientation = (type) => {\n    if (isSupported.value && typeof screenOrientation.lock === \"function\")\n      return screenOrientation.lock(type);\n    return Promise.reject(new Error(\"Not supported\"));\n  };\n  const unlockOrientation = () => {\n    if (isSupported.value && typeof screenOrientation.unlock === \"function\")\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = reactive(useDeviceOrientation({ window }));\n  const screenOrientation = reactive(useScreenOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = computed(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0))\n      return \"deviceOrientation\";\n    return \"mouse\";\n  });\n  const roll = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        case \"portrait-primary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-secondary\":\n          value = orientation.beta / 90;\n          break;\n        default:\n          value = -orientation.beta / 90;\n      }\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.beta / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"portrait-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        default:\n          value = orientation.gamma / 90;\n      }\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nfunction useParentElement(element = useCurrentElement()) {\n  const parentElement = shallowRef();\n  const update = () => {\n    const el = unrefElement(element);\n    if (el)\n      parentElement.value = el.parentElement;\n  };\n  tryOnMounted(update);\n  watch(() => toValue(element), update);\n  return parentElement;\n}\n\nfunction usePerformanceObserver(options, callback) {\n  const {\n    window = defaultWindow,\n    immediate = true,\n    ...performanceOptions\n  } = options;\n  const isSupported = useSupported(() => window && \"PerformanceObserver\" in window);\n  let observer;\n  const stop = () => {\n    observer == null ? void 0 : observer.disconnect();\n  };\n  const start = () => {\n    if (isSupported.value) {\n      stop();\n      observer = new PerformanceObserver(callback);\n      observer.observe(performanceOptions);\n    }\n  };\n  tryOnScopeDispose(stop);\n  if (immediate)\n    start();\n  return {\n    isSupported,\n    start,\n    stop\n  };\n}\n\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = ref(false);\n  const state = ref(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = objectPick(event, keys, false);\n  };\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"pointerdown\", \"pointermove\", \"pointerup\"], handler, listenerOptions);\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, listenerOptions);\n  }\n  return {\n    ...toRefs(state),\n    isInside\n  };\n}\n\nfunction usePointerLock(target, options = {}) {\n  const { document = defaultDocument } = options;\n  const isSupported = useSupported(() => document && \"pointerLockElement\" in document);\n  const element = ref();\n  const triggerElement = ref();\n  let targetElement;\n  if (isSupported.value) {\n    useEventListener(document, \"pointerlockchange\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        element.value = document.pointerLockElement;\n        if (!element.value)\n          targetElement = triggerElement.value = null;\n      }\n    });\n    useEventListener(document, \"pointerlockerror\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        const action = document.pointerLockElement ? \"release\" : \"acquire\";\n        throw new Error(`Failed to ${action} pointer lock.`);\n      }\n    });\n  }\n  async function lock(e) {\n    var _a;\n    if (!isSupported.value)\n      throw new Error(\"Pointer Lock API is not supported by your browser.\");\n    triggerElement.value = e instanceof Event ? e.currentTarget : null;\n    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);\n    if (!targetElement)\n      throw new Error(\"Target element undefined.\");\n    targetElement.requestPointerLock();\n    return await until(element).toBe(targetElement);\n  }\n  async function unlock() {\n    if (!element.value)\n      return false;\n    document.exitPointerLock();\n    await until(element).toBeNull();\n    return true;\n  }\n  return {\n    isSupported,\n    element,\n    triggerElement,\n    lock,\n    unlock\n  };\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = toRef(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    disableTextSelect = false\n  } = options;\n  const posStart = reactive({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = reactive({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = computed(() => posStart.x - posEnd.x);\n  const distanceY = computed(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const isPointerDown = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return distanceY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const eventIsAllowed = (e) => {\n    var _a, _b, _c;\n    const isReleasingButton = e.buttons === 0;\n    const isPrimaryButton = e.buttons === 1;\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\n  };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      isPointerDown.value = true;\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }),\n    useEventListener(target, \"pointerup\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n    })\n  ];\n  tryOnMounted(() => {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\n    if (disableTextSelect) {\n      (_d = (_c = targetRef.value) == null ? void 0 : _c.style) == null ? void 0 : _d.setProperty(\"-webkit-user-select\", \"none\");\n      (_f = (_e = targetRef.value) == null ? void 0 : _e.style) == null ? void 0 : _f.setProperty(\"-ms-user-select\", \"none\");\n      (_h = (_g = targetRef.value) == null ? void 0 : _g.style) == null ? void 0 : _h.setProperty(\"user-select\", \"none\");\n    }\n  });\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: readonly(isSwiping),\n    direction: readonly(direction),\n    posStart: readonly(posStart),\n    posEnd: readonly(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return computed(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredContrast(options) {\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n  return computed(() => {\n    if (isMore.value)\n      return \"more\";\n    if (isLess.value)\n      return \"less\";\n    if (isCustom.value)\n      return \"custom\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref([\"en\"]);\n  const navigator = window.navigator;\n  const value = ref(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  });\n  return value;\n}\n\nfunction usePreferredReducedMotion(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePrevious(value, initialValue) {\n  const previous = shallowRef(initialValue);\n  watch(\n    toRef(value),\n    (_, oldValue) => {\n      previous.value = oldValue;\n    },\n    { flush: \"sync\" }\n  );\n  return readonly(previous);\n}\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = ref(\"\");\n  const right = ref(\"\");\n  const bottom = ref(\"\");\n  const left = ref(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    update();\n    useEventListener(\"resize\", useDebounceFn(update));\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {}\n  } = options;\n  const scriptTag = ref(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = toValue(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    el.addEventListener(\"error\", (event) => reject(event));\n    el.addEventListener(\"abort\", (event) => reject(event));\n    el.addEventListener(\"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    });\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnUnmounted(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction checkOverflowScroll(ele) {\n  const style = window.getComputedStyle(ele);\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientWidth < ele.scrollWidth || style.overflowY === \"auto\" && ele.clientHeight < ele.scrollHeight) {\n    return true;\n  } else {\n    const parent = ele.parentNode;\n    if (!parent || parent.tagName === \"BODY\")\n      return false;\n    return checkOverflowScroll(parent);\n  }\n}\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  const _target = e.target;\n  if (checkOverflowScroll(_target))\n    return false;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nconst elInitialOverflow = /* @__PURE__ */ new WeakMap();\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = ref(initialState);\n  let stopTouchMoveListener = null;\n  watch(toRef(element), (el) => {\n    const target = resolveElement(toValue(el));\n    if (target) {\n      const ele = target;\n      if (!elInitialOverflow.get(ele))\n        elInitialOverflow.set(ele, ele.style.overflow);\n      if (isLocked.value)\n        ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(\n        el,\n        \"touchmove\",\n        (e) => {\n          preventDefault(e);\n        },\n        { passive: false }\n      );\n    }\n    el.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    var _a;\n    const el = resolveElement(toValue(element));\n    if (!el || !isLocked.value)\n      return;\n    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());\n    el.style.overflow = (_a = elInitialOverflow.get(el)) != null ? _a : \"\";\n    elInitialOverflow.delete(el);\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else\n        unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\n  const share = async (overrideOptions = {}) => {\n    if (isSupported.value) {\n      const data = {\n        ...toValue(shareOptions),\n        ...toValue(overrideOptions)\n      };\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n  var _a, _b, _c, _d;\n  const [source] = args;\n  let compareFn = defaultCompare;\n  let options = {};\n  if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      options = args[1];\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\n    } else {\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\n    }\n  } else if (args.length > 2) {\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\n    options = (_d = args[2]) != null ? _d : {};\n  }\n  const {\n    dirty = false,\n    sortFn = defaultSortFn\n  } = options;\n  if (!dirty)\n    return computed(() => sortFn([...toValue(source)], compareFn));\n  watchEffect(() => {\n    const result = sortFn(toValue(source), compareFn);\n    if (isRef(source))\n      source.value = result;\n    else\n      source.splice(0, source.length, ...result);\n  });\n  return source;\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    window = defaultWindow\n  } = options;\n  const lang = toRef(options.lang || \"en-US\");\n  const isListening = ref(false);\n  const isFinal = ref(false);\n  const result = ref(\"\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isListening.value) => {\n    isListening.value = value;\n  };\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = useSupported(() => SpeechRecognition);\n  let recognition;\n  if (isSupported.value) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = toValue(lang);\n    recognition.onstart = () => {\n      isFinal.value = false;\n    };\n    watch(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const transcript = Array.from(event.results).map((result2) => {\n        isFinal.value = result2.isFinal;\n        return result2[0];\n      }).map((result2) => result2.transcript).join(\"\");\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = toValue(lang);\n    };\n    watch(isListening, () => {\n      if (isListening.value)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isListening.value = false;\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = useSupported(() => synth);\n  const isPlaying = ref(false);\n  const status = ref(\"init\");\n  const spokenText = toRef(text || \"\");\n  const lang = toRef(options.lang || \"en-US\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = toValue(lang);\n    utterance2.voice = toValue(options.voice) || null;\n    utterance2.pitch = toValue(pitch);\n    utterance2.rate = toValue(rate);\n    utterance2.volume = volume;\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n  };\n  const utterance = computed(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    utterance && synth.speak(utterance.value);\n  };\n  const stop = () => {\n    synth.cancel();\n    isPlaying.value = false;\n  };\n  if (isSupported.value) {\n    bindEventsForUtterance(utterance.value);\n    watch(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    if (options.voice) {\n      watch(options.voice, () => {\n        synth.cancel();\n      });\n    }\n    watch(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    utterance,\n    error,\n    stop,\n    toggle,\n    speak\n  };\n}\n\nfunction useStepper(steps, initialStep) {\n  const stepsRef = ref(steps);\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\n  const current = computed(() => at(index.value));\n  const isFirst = computed(() => index.value === 0);\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\n  const next = computed(() => stepNames.value[index.value + 1]);\n  const previous = computed(() => stepNames.value[index.value - 1]);\n  function at(index2) {\n    if (Array.isArray(stepsRef.value))\n      return stepsRef.value[index2];\n    return stepsRef.value[stepNames.value[index2]];\n  }\n  function get(step) {\n    if (!stepNames.value.includes(step))\n      return;\n    return at(stepNames.value.indexOf(step));\n  }\n  function goTo(step) {\n    if (stepNames.value.includes(step))\n      index.value = stepNames.value.indexOf(step);\n  }\n  function goToNext() {\n    if (isLast.value)\n      return;\n    index.value++;\n  }\n  function goToPrevious() {\n    if (isFirst.value)\n      return;\n    index.value--;\n  }\n  function goBackTo(step) {\n    if (isAfter(step))\n      goTo(step);\n  }\n  function isNext(step) {\n    return stepNames.value.indexOf(step) === index.value + 1;\n  }\n  function isPrevious(step) {\n    return stepNames.value.indexOf(step) === index.value - 1;\n  }\n  function isCurrent(step) {\n    return stepNames.value.indexOf(step) === index.value;\n  }\n  function isBefore(step) {\n    return index.value < stepNames.value.indexOf(step);\n  }\n  function isAfter(step) {\n    return index.value > stepNames.value.indexOf(step);\n  }\n  return {\n    steps: stepsRef,\n    stepNames,\n    index,\n    current,\n    next,\n    previous,\n    isFirst,\n    isLast,\n    at,\n    get,\n    goTo,\n    goToNext,\n    goToPrevious,\n    goBackTo,\n    isNext,\n    isPrevious,\n    isCurrent,\n    isBefore,\n    isAfter\n  };\n}\n\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const rawInit = toValue(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? shallowRef : ref)(initialValue);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorageAsync\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else if (mergeDefaults) {\n        const value = await serializer.read(rawValue);\n        if (typeof mergeDefaults === \"function\")\n          data.value = mergeDefaults(value, rawInit);\n        else if (type === \"object\" && !Array.isArray(value))\n          data.value = { ...rawInit, ...value };\n        else\n          data.value = value;\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  read();\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => Promise.resolve().then(() => read(e)));\n  if (storage) {\n    watchWithFilter(\n      data,\n      async () => {\n        try {\n          if (data.value == null)\n            await storage.removeItem(key);\n          else\n            await storage.setItem(key, await serializer.write(data.value));\n        } catch (e) {\n          onError(e);\n        }\n      },\n      {\n        flush,\n        deep,\n        eventFilter\n      }\n    );\n  }\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = ref(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = ref(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    if (!el.isConnected) {\n      el.id = id;\n      if (options.media)\n        el.media = options.media;\n      document.head.appendChild(el);\n    }\n    if (isLoaded.value)\n      return;\n    stop = watch(\n      cssRef,\n      (value) => {\n        el.textContent = value;\n      },\n      { immediate: true }\n    );\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnScopeDispose(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: readonly(isLoaded)\n  };\n}\n\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true,\n    window = defaultWindow\n  } = options;\n  const coordsStart = reactive({ x: 0, y: 0 });\n  const coordsEnd = reactive({ x: 0, y: 0 });\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return diffY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  let listenerOptions;\n  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);\n  if (!passive)\n    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };\n  else\n    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      if (listenerOptions.capture && !listenerOptions.passive)\n        e.preventDefault();\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, [\"touchend\", \"touchcancel\"], onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isPassiveEventSupported,\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop\n  };\n}\nfunction checkPassiveEventSupport(document) {\n  if (!document)\n    return false;\n  let supportsPassive = false;\n  const optionsBlock = {\n    get passive() {\n      supportsPassive = true;\n      return false;\n    }\n  };\n  document.addEventListener(\"x\", noop, optionsBlock);\n  document.removeEventListener(\"x\", noop);\n  return supportsPassive;\n}\n\nfunction useTemplateRefsList() {\n  const refs = ref([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  onBeforeUpdate(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\nfunction useTextDirection(options = {}) {\n  const {\n    document = defaultDocument,\n    selector = \"html\",\n    observe = false,\n    initialValue = \"ltr\"\n  } = options;\n  function getValue() {\n    var _a, _b;\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\n  }\n  const dir = ref(getValue());\n  tryOnMounted(() => dir.value = getValue());\n  if (observe && document) {\n    useMutationObserver(\n      document.querySelector(selector),\n      () => dir.value = getValue(),\n      { attributes: true }\n    );\n  }\n  return computed({\n    get() {\n      return dir.value;\n    },\n    set(v) {\n      var _a, _b;\n      dir.value = v;\n      if (!document)\n        return;\n      if (dir.value)\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\n      else\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\n    }\n  });\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));\n}\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = ref(null);\n  const text = computed(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange);\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nfunction useTextareaAutosize(options) {\n  var _a;\n  const textarea = ref(options == null ? void 0 : options.element);\n  const input = ref(options == null ? void 0 : options.input);\n  const styleProp = (_a = options == null ? void 0 : options.styleProp) != null ? _a : \"height\";\n  const textareaScrollHeight = ref(1);\n  function triggerResize() {\n    var _a2, _b;\n    if (!textarea.value)\n      return;\n    let height = \"\";\n    textarea.value.style[styleProp] = \"1px\";\n    textareaScrollHeight.value = (_a2 = textarea.value) == null ? void 0 : _a2.scrollHeight;\n    if (options == null ? void 0 : options.styleTarget)\n      toValue(options.styleTarget).style[styleProp] = `${textareaScrollHeight.value}px`;\n    else\n      height = `${textareaScrollHeight.value}px`;\n    textarea.value.style[styleProp] = height;\n    (_b = options == null ? void 0 : options.onResize) == null ? void 0 : _b.call(options);\n  }\n  watch([input, textarea], () => nextTick(triggerResize), { immediate: true });\n  useResizeObserver(textarea, () => triggerResize());\n  if (options == null ? void 0 : options.watch)\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\n  return {\n    textarea,\n    input,\n    triggerResize\n  };\n}\n\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = throttleFilter(throttle, trailing);\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nconst DEFAULT_UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n  invalid: \"\"\n};\nfunction DEFAULT_FORMATTER(date) {\n  return date.toISOString().slice(0, 10);\n}\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });\n  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now)));\n  if (exposeControls) {\n    return {\n      timeAgo,\n      ...controls\n    };\n  } else {\n    return timeAgo;\n  }\n}\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\n  var _a;\n  const {\n    max,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER,\n    units = DEFAULT_UNITS,\n    showSecond = false,\n    rounding = \"round\"\n  } = options;\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n  const diff = +now - +from;\n  const absDiff = Math.abs(diff);\n  function getValue(diff2, unit) {\n    return roundFn(Math.abs(diff2) / unit.value);\n  }\n  function format(diff2, unit) {\n    const val = getValue(diff2, unit);\n    const past = diff2 > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  if (absDiff < 6e4 && !showSecond)\n    return messages.justNow;\n  if (typeof max === \"number\" && absDiff > max)\n    return fullDateFormatter(new Date(from));\n  if (typeof max === \"string\") {\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\n    if (unitMax && absDiff > unitMax)\n      return fullDateFormatter(new Date(from));\n  }\n  for (const [idx, unit] of units.entries()) {\n    const val = getValue(diff, unit);\n    if (val <= 0 && units[idx - 1])\n      return format(diff, units[idx - 1]);\n    if (absDiff < unit.max)\n      return format(diff, unit);\n  }\n  return messages.invalid;\n}\n\nfunction useTimeoutPoll(fn, interval, timeoutPollOptions) {\n  const { start } = useTimeoutFn(loop, interval, { immediate: false });\n  const isActive = ref(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      loop();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\",\n    callback\n  } = options;\n  const ts = ref(timestamp() + offset);\n  const update = () => ts.value = timestamp() + offset;\n  const cb = callback ? () => {\n    update();\n    callback(ts.value);\n  } : update;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  if (exposeControls) {\n    return {\n      timestamp: ts,\n      ...controls\n    };\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b, _c;\n  const {\n    document = defaultDocument,\n    restoreOnUnmount = (t) => t\n  } = options;\n  const originalTitle = (_a = document == null ? void 0 : document.title) != null ? _a : \"\";\n  const title = toRef((_b = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _b : null);\n  const isReadonly = newTitle && typeof newTitle === \"function\";\n  function format(t) {\n    if (!(\"titleTemplate\" in options))\n      return t;\n    const template = options.titleTemplate || \"%s\";\n    return typeof template === \"function\" ? template(t) : toValue(template).replace(/%s/g, t);\n  }\n  watch(\n    title,\n    (t, o) => {\n      if (t !== o && document)\n        document.title = format(typeof t === \"string\" ? t : \"\");\n    },\n    { immediate: true }\n  );\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\n    useMutationObserver(\n      (_c = document.head) == null ? void 0 : _c.querySelector(\"title\"),\n      () => {\n        if (document && document.title !== title.value)\n          title.value = format(document.title);\n      },\n      { childList: true }\n    );\n  }\n  tryOnBeforeUnmount(() => {\n    if (restoreOnUnmount) {\n      const restoredTitle = restoreOnUnmount(originalTitle, title.value || \"\");\n      if (restoredTitle != null && document)\n        document.title = restoredTitle;\n    }\n  });\n  return title;\n}\n\nconst _TransitionPresets = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nconst TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction lerp(a, b, alpha) {\n  return a + alpha * (b - a);\n}\nfunction toVec(t) {\n  return (typeof t === \"number\" ? [t] : t) || [];\n}\nfunction executeTransition(source, from, to, options = {}) {\n  var _a, _b;\n  const fromVal = toValue(from);\n  const toVal = toValue(to);\n  const v1 = toVec(fromVal);\n  const v2 = toVec(toVal);\n  const duration = (_a = toValue(options.duration)) != null ? _a : 1e3;\n  const startedAt = Date.now();\n  const endAt = Date.now() + duration;\n  const trans = typeof options.transition === \"function\" ? options.transition : (_b = toValue(options.transition)) != null ? _b : identity;\n  const ease = typeof trans === \"function\" ? trans : createEasingFunction(trans);\n  return new Promise((resolve) => {\n    source.value = fromVal;\n    const tick = () => {\n      var _a2;\n      if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {\n        resolve();\n        return;\n      }\n      const now = Date.now();\n      const alpha = ease((now - startedAt) / duration);\n      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha));\n      if (Array.isArray(source.value))\n        source.value = arr.map((n, i) => {\n          var _a3, _b2;\n          return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);\n        });\n      else if (typeof source.value === \"number\")\n        source.value = arr[0];\n      if (now < endAt) {\n        requestAnimationFrame(tick);\n      } else {\n        source.value = toVal;\n        resolve();\n      }\n    };\n    tick();\n  });\n}\nfunction useTransition(source, options = {}) {\n  let currentId = 0;\n  const sourceVal = () => {\n    const v = toValue(source);\n    return typeof v === \"number\" ? v : v.map(toValue);\n  };\n  const outputRef = ref(sourceVal());\n  watch(sourceVal, async (to) => {\n    var _a, _b;\n    if (toValue(options.disabled))\n      return;\n    const id = ++currentId;\n    if (options.delay)\n      await promiseTimeout(toValue(options.delay));\n    if (id !== currentId)\n      return;\n    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);\n    (_a = options.onStarted) == null ? void 0 : _a.call(options);\n    await executeTransition(outputRef, outputRef.value, toVal, {\n      ...options,\n      abort: () => {\n        var _a2;\n        return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));\n      }\n    });\n    (_b = options.onFinished) == null ? void 0 : _b.call(options);\n  }, { deep: true });\n  watch(() => toValue(options.disabled), (disabled) => {\n    if (disabled) {\n      currentId++;\n      outputRef.value = sourceVal();\n    }\n  });\n  tryOnScopeDispose(() => {\n    currentId++;\n  });\n  return computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value);\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    write: enableWrite = true,\n    window = defaultWindow\n  } = options;\n  if (!window)\n    return reactive(initialValue);\n  const state = reactive({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = params.toString();\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = pausableWatch(\n    state,\n    () => {\n      const params = new URLSearchParams(\"\");\n      Object.keys(state).forEach((key) => {\n        const mapEntry = state[key];\n        if (Array.isArray(mapEntry))\n          mapEntry.forEach((value) => params.append(key, value));\n        else if (removeNullishValues && mapEntry == null)\n          params.delete(key);\n        else if (removeFalsyValues && !mapEntry)\n          params.delete(key);\n        else\n          params.set(key, mapEntry);\n      });\n      write(params);\n    },\n    { deep: true }\n  );\n  function write(params, shouldUpdate) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    window.history.replaceState(\n      window.history.state,\n      window.document.title,\n      window.location.pathname + constructQuery(params)\n    );\n    resume();\n  }\n  function onChanged() {\n    if (!enableWrite)\n      return;\n    write(read(), true);\n  }\n  useEventListener(window, \"popstate\", onChanged, false);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, false);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = ref((_b = options.autoSwitch) != null ? _b : true);\n  const constraints = ref(options.constraints);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\n  });\n  const stream = shallowRef();\n  function getDeviceOptions(type) {\n    switch (type) {\n      case \"video\": {\n        if (constraints.value)\n          return constraints.value.video || false;\n        break;\n      }\n      case \"audio\": {\n        if (constraints.value)\n          return constraints.value.audio || false;\n        break;\n      }\n    }\n  }\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(\"video\"),\n      audio: getDeviceOptions(\"audio\")\n    });\n    return stream.value;\n  }\n  function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  watch(\n    constraints,\n    () => {\n      if (autoSwitch.value && stream.value)\n        restart();\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(() => {\n    stop();\n  });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    constraints,\n    enabled,\n    autoSwitch\n  };\n}\n\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c, _d, _e;\n  const {\n    clone = false,\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue,\n    shouldEmit\n  } = options;\n  const vm = getCurrentInstance();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\n  let event = eventName;\n  if (!key) {\n    if (isVue2) {\n      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;\n      key = (modelOptions == null ? void 0 : modelOptions.value) || \"value\";\n      if (!eventName)\n        event = (modelOptions == null ? void 0 : modelOptions.event) || \"input\";\n    } else {\n      key = \"modelValue\";\n    }\n  }\n  event = event || `update:${key.toString()}`;\n  const cloneFn = (val) => !clone ? val : typeof clone === \"function\" ? clone(val) : cloneFnJSON(val);\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\n  const triggerEmit = (value) => {\n    if (shouldEmit) {\n      if (shouldEmit(value))\n        _emit(event, value);\n    } else {\n      _emit(event, value);\n    }\n  };\n  if (passive) {\n    const initialValue = getValue();\n    const proxy = ref(initialValue);\n    let isUpdating = false;\n    watch(\n      () => props[key],\n      (v) => {\n        if (!isUpdating) {\n          isUpdating = true;\n          proxy.value = cloneFn(v);\n          nextTick(() => isUpdating = false);\n        }\n      }\n    );\n    watch(\n      proxy,\n      (v) => {\n        if (!isUpdating && (v !== props[key] || deep))\n          triggerEmit(v);\n      },\n      { deep }\n    );\n    return proxy;\n  } else {\n    return computed({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        triggerEmit(value);\n      }\n    });\n  }\n}\n\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props) {\n    ret[key] = useVModel(\n      props,\n      key,\n      emit,\n      options\n    );\n  }\n  return ret;\n}\n\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\n  const patternRef = toRef(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported.value)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported.value)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = useIntervalFn(\n      vibrate,\n      interval,\n      {\n        immediate: false,\n        immediateCallback: false\n      }\n    );\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\nfunction useVirtualListResources(list) {\n  const containerRef = ref(null);\n  const size = useElementSize(containerRef);\n  const currentList = ref([]);\n  const source = shallowRef(list);\n  const state = ref({ start: 0, end: 10 });\n  return { state, source, currentList, size, containerRef };\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n  return (containerSize) => {\n    if (typeof itemSize === \"number\")\n      return Math.ceil(containerSize / itemSize);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      capacity = i;\n      if (sum > containerSize)\n        break;\n    }\n    return capacity - start;\n  };\n}\nfunction createGetOffset(source, itemSize) {\n  return (scrollDirection) => {\n    if (typeof itemSize === \"number\")\n      return Math.floor(scrollDirection / itemSize) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      if (sum >= scrollDirection) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n  return () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n}\nfunction createGetDistance(itemSize, source) {\n  return (index) => {\n    if (typeof itemSize === \"number\") {\n      const size2 = index * itemSize;\n      return size2;\n    }\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n    return size;\n  };\n}\nfunction useWatchForSizes(size, list, calculateRange) {\n  watch([size.width, size.height, list], () => {\n    calculateRange();\n  });\n}\nfunction createComputedTotalSize(itemSize, source) {\n  return computed(() => {\n    if (typeof itemSize === \"number\")\n      return source.value.length * itemSize;\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n  });\n}\nconst scrollToDictionaryForElementScrollKey = {\n  horizontal: \"scrollLeft\",\n  vertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n  return (index) => {\n    if (containerRef.value) {\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n      calculateRange();\n    }\n  };\n}\nfunction useHorizontalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowX: \"auto\" };\n  const { itemWidth, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n  const getOffset = createGetOffset(source, itemWidth);\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceLeft = createGetDistance(itemWidth, source);\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\n  const totalWidth = createComputedTotalSize(itemWidth, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        height: \"100%\",\n        width: `${totalWidth.value - offsetLeft.value}px`,\n        marginLeft: `${offsetLeft.value}px`,\n        display: \"flex\"\n      }\n    };\n  });\n  return {\n    scrollTo,\n    calculateRange,\n    wrapperProps,\n    containerStyle,\n    currentList,\n    containerRef\n  };\n}\nfunction useVerticalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowY: \"auto\" };\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n  const getOffset = createGetOffset(source, itemHeight);\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceTop = createGetDistance(itemHeight, source);\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\n  const totalHeight = createComputedTotalSize(itemHeight, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  return {\n    calculateRange,\n    scrollTo,\n    containerStyle,\n    wrapperProps,\n    currentList,\n    containerRef\n  };\n}\n\nfunction useWakeLock(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  let wakeLock;\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\n  const isActive = ref(false);\n  async function onVisibilityChange() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    if (document && document.visibilityState === \"visible\")\n      wakeLock = await navigator.wakeLock.request(\"screen\");\n    isActive.value = !wakeLock.released;\n  }\n  if (document)\n    useEventListener(document, \"visibilitychange\", onVisibilityChange, { passive: true });\n  async function request(type) {\n    if (!isSupported.value)\n      return;\n    wakeLock = await navigator.wakeLock.request(type);\n    isActive.value = !wakeLock.released;\n  }\n  async function release() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    await wakeLock.release();\n    isActive.value = !wakeLock.released;\n    wakeLock = null;\n  }\n  return {\n    isSupported,\n    isActive,\n    request,\n    release\n  };\n}\n\nfunction useWebNotification(options = {}) {\n  const {\n    window = defaultWindow,\n    requestPermissions: _requestForPermissions = true\n  } = options;\n  const defaultWebNotificationOptions = options;\n  const isSupported = useSupported(() => !!window && \"Notification\" in window);\n  const permissionGranted = ref(isSupported.value && \"permission\" in Notification && Notification.permission === \"granted\");\n  const notification = ref(null);\n  const ensurePermissions = async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionGranted.value && Notification.permission !== \"denied\") {\n      const result = await Notification.requestPermission();\n      if (result === \"granted\")\n        permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  };\n  const { on: onClick, trigger: clickTrigger } = createEventHook();\n  const { on: onShow, trigger: showTrigger } = createEventHook();\n  const { on: onError, trigger: errorTrigger } = createEventHook();\n  const { on: onClose, trigger: closeTrigger } = createEventHook();\n  const show = async (overrides) => {\n    if (!isSupported.value || !permissionGranted.value)\n      return;\n    const options2 = Object.assign({}, defaultWebNotificationOptions, overrides);\n    notification.value = new Notification(options2.title || \"\", options2);\n    notification.value.onclick = clickTrigger;\n    notification.value.onshow = showTrigger;\n    notification.value.onerror = errorTrigger;\n    notification.value.onclose = closeTrigger;\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  if (_requestForPermissions)\n    tryOnMounted(ensurePermissions);\n  tryOnScopeDispose(close);\n  if (isSupported.value && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    ensurePermissions,\n    permissionGranted,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n}\n\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = ref(null);\n  const status = ref(\"CLOSED\");\n  const wsRef = ref();\n  const urlRef = toRef(url);\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  let pongTimeoutWait;\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const resetHeartbeat = () => {\n    clearTimeout(pongTimeoutWait);\n    pongTimeoutWait = void 0;\n  };\n  const close = (code = 1e3, reason) => {\n    if (!isClient || !wsRef.value)\n      return;\n    explicitlyClosed = true;\n    resetHeartbeat();\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n    wsRef.value = void 0;\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const ws = new WebSocket(urlRef.value, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      if (options.heartbeat) {\n        resetHeartbeat();\n        const {\n          message = DEFAULT_PING_MESSAGE\n        } = resolveNestedOptions(options.heartbeat);\n        if (e.data === message)\n          return;\n      }\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = DEFAULT_PING_MESSAGE,\n      interval = 1e3,\n      pongTimeout = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = useIntervalFn(\n      () => {\n        send(message, false);\n        if (pongTimeoutWait != null)\n          return;\n        pongTimeoutWait = setTimeout(() => {\n          close();\n          explicitlyClosed = false;\n        }, pongTimeout);\n      },\n      interval,\n      { immediate: false }\n    );\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (autoClose) {\n    if (isClient)\n      useEventListener(\"beforeunload\", () => close());\n    tryOnScopeDispose(close);\n  }\n  const open = () => {\n    if (!isClient && !isWorker)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    open();\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(arg0, workerOptions, options) {\n  const {\n    window = defaultWindow\n  } = options != null ? options : {};\n  const data = ref(null);\n  const worker = shallowRef();\n  const post = (...args) => {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(...args);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    if (typeof arg0 === \"string\")\n      worker.value = new Worker(arg0, workerOptions);\n    else if (typeof arg0 === \"function\")\n      worker.value = arg0();\n    else\n      worker.value = arg0;\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    tryOnScopeDispose(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nfunction jobRunner(userFunc) {\n  return (e) => {\n    const userFuncArgs = e.data[0];\n    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n      postMessage([\"SUCCESS\", result]);\n    }).catch((error) => {\n      postMessage([\"ERROR\", error]);\n    });\n  };\n}\n\nfunction depsParser(deps) {\n  if (deps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  return `importScripts(${depsString})`;\n}\n\nfunction createWorkerBlobUrl(fn, deps) {\n  const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n}\n\nfunction useWebWorkerFn(fn, options = {}) {\n  const {\n    dependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = ref();\n  const workerStatus = ref(\"PENDING\");\n  const promise = ref({});\n  const timeoutId = ref();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  tryOnScopeDispose(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      e.preventDefault();\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(\n        () => workerTerminate(\"TIMEOUT_EXPIRED\"),\n        timeout\n      );\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    promise.value = {\n      resolve,\n      reject\n    };\n    worker.value && worker.value.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\n        \"[useWebWorkerFn] You can only run one instance of the worker at a time.\"\n      );\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n}\n\nfunction useWindowFocus(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref(false);\n  const focused = ref(window.document.hasFocus());\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  });\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  });\n  return focused;\n}\n\nfunction useWindowScroll(options = {}) {\n  const { window = defaultWindow, behavior = \"auto\" } = options;\n  if (!window) {\n    return {\n      x: ref(0),\n      y: ref(0)\n    };\n  }\n  const internalX = ref(window.scrollX);\n  const internalY = ref(window.scrollY);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo({ left: x2, behavior });\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo({ top: y2, behavior });\n    }\n  });\n  useEventListener(\n    window,\n    \"scroll\",\n    () => {\n      internalX.value = window.scrollX;\n      internalY.value = window.scrollY;\n    },\n    {\n      capture: false,\n      passive: true\n    }\n  );\n  return { x, y };\n}\n\nfunction useWindowSize(options = {}) {\n  const {\n    window = defaultWindow,\n    initialWidth = Number.POSITIVE_INFINITY,\n    initialHeight = Number.POSITIVE_INFINITY,\n    listenOrientation = true,\n    includeScrollbar = true\n  } = options;\n  const width = ref(initialWidth);\n  const height = ref(initialHeight);\n  const update = () => {\n    if (window) {\n      if (includeScrollbar) {\n        width.value = window.innerWidth;\n        height.value = window.innerHeight;\n      } else {\n        width.value = window.document.documentElement.clientWidth;\n        height.value = window.document.documentElement.clientHeight;\n      }\n    }\n  };\n  update();\n  tryOnMounted(update);\n  useEventListener(\"resize\", update, { passive: true });\n  if (listenOrientation) {\n    const matches = useMediaQuery(\"(orientation: portrait)\");\n    watch(matches, () => update());\n  }\n  return { width, height };\n}\n\nexport { DefaultMagicKeysAliasMap, StorageSerializers, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsMasterCss, breakpointsPrimeFlex, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, breakpointsVuetifyV2, breakpointsVuetifyV3, cloneFnJSON, computedAsync, computedInject, createFetch, createReusableTemplate, createTemplatePromise, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, executeTransition, formatTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, setSSRHandler, templateRef, unrefElement, useActiveElement, useAnimate, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useClipboardItems, useCloned, useColorMode, useConfirmDialog, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, useParentElement, usePerformanceObserver, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePrevious, useRafFn, useRefHistory, useResizeObserver, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\n","<template>\n  <span :id=\"computedId + '_placeholder'\" ref=\"placeholder\" />\n  <slot name=\"target\" :show=\"show\" :hide=\"hide\" :toggle=\"toggle\" :show-state=\"showState\" />\n  <Teleport :to=\"teleportTo\" :disabled=\"!teleportTo || teleportDisabled\">\n    <div\n      v-if=\"showStateInternal || props.persistent\"\n      :id=\"computedId\"\n      v-bind=\"$attrs\"\n      ref=\"element\"\n      :class=\"computedClasses\"\n      role=\"tooltip\"\n      tabindex=\"-1\"\n      :style=\"floatingStyles\"\n    >\n      <div\n        ref=\"arrow\"\n        :class=\"`${props.tooltip ? 'tooltip' : 'popover'}-arrow`\"\n        :style=\"arrowStyle\"\n        data-popper-arrow\n      />\n      <div class=\"overflow-auto\" :style=\"sizeStyles\">\n        <template v-if=\"title || $slots.title\">\n          <div\n            v-if=\"!props.html\"\n            class=\"position-sticky top-0\"\n            :class=\"props.tooltip ? 'tooltip-inner' : 'popover-header'\"\n          >\n            <slot name=\"title\">\n              {{ title }}\n            </slot>\n          </div>\n          <!-- eslint-disable vue/no-v-html -->\n          <div\n            v-else\n            class=\"position-sticky top-0\"\n            :class=\"props.tooltip ? 'tooltip-inner' : 'popover-header'\"\n            v-html=\"sanitizedTitle\"\n          />\n          <!-- eslint-enable vue/no-v-html -->\n        </template>\n        <template v-if=\"(props.tooltip && !$slots.title && !title) || !props.tooltip\">\n          <div v-if=\"!props.html\" :class=\"props.tooltip ? 'tooltip-inner' : 'popover-body'\">\n            <slot>\n              {{ content }}\n            </slot>\n          </div>\n          <!-- eslint-disable vue/no-v-html -->\n          <div\n            v-else\n            :class=\"props.tooltip ? 'tooltip-inner' : 'popover-body'\"\n            v-html=\"sanitizedContent\"\n          />\n          <!-- eslint-enable vue/no-v-html -->\n        </template>\n      </div>\n    </div>\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport {\n  type Alignment,\n  arrow as arrowMiddleware,\n  autoPlacement,\n  autoUpdate,\n  type Boundary,\n  flip,\n  hide as hideMiddleware,\n  inline as inlineMiddleware,\n  type Middleware,\n  offset as offsetMiddleware,\n  type Placement as OriginalPlacement,\n  type RootBoundary,\n  shift,\n  size as sizeMiddleware,\n  useFloating,\n} from '@floating-ui/vue'\nimport {onClickOutside, useMouseInElement, useToNumber} from '@vueuse/core'\nimport {\n  computed,\n  type CSSProperties,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  ref,\n  toRef,\n  watch,\n  watchEffect,\n} from 'vue'\nimport {useId} from '../composables'\nimport type {BPopoverProps} from '../types'\nimport {\n  BvTriggerableEvent,\n  getElement,\n  getTransitionDelay,\n  IS_BROWSER,\n  resolveBootstrapPlacement,\n} from '../utils'\nimport {DefaultAllowlist, sanitizeHtml} from '../utils/sanitizer'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<BPopoverProps>(), {\n  boundary: 'clippingAncestors',\n  boundaryPadding: undefined,\n  click: false,\n  teleportTo: undefined,\n  teleportDisabled: false,\n  content: undefined,\n  customClass: '',\n  delay: () => ({show: 100, hide: 300}),\n  floatingMiddleware: undefined,\n  hide: undefined,\n  html: false,\n  id: undefined,\n  inline: false,\n  manual: false,\n  noAutoClose: false,\n  noFade: false,\n  noFlip: false,\n  noHide: false,\n  noShift: false,\n  noSize: false,\n  noninteractive: false,\n  offset: null,\n  persistent: false,\n  placement: 'top',\n  realtime: false,\n  reference: null,\n  strategy: 'absolute',\n  target: null,\n  title: undefined,\n  tooltip: false,\n  variant: null,\n})\n\nconst emit = defineEmits<{\n  'hidden': [value: BvTriggerableEvent]\n  'hide': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'shown': [value: BvTriggerableEvent]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  target?: (props: {\n    show: () => void\n    hide: (e: Event) => void\n    toggle: (e: Event) => void\n    showState: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  title?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = defineModel<boolean>({\n  default: false,\n})\n\nconst showState = ref(modelValue.value)\nconst showStateInternal = ref(modelValue.value)\nwatchEffect(() => {\n  modelValue.value = showState.value\n})\n\nwatch(modelValue, (newValue) => {\n  if (newValue === showState.value) return\n  newValue ? show() : hide(new Event('update:modelValue'))\n})\n\nconst computedId = useId(() => props.id, 'popover')\n\nconst hidden = ref(false)\n\nconst element = ref<HTMLElement | null>(null)\nconst targetTrigger = ref<HTMLElement | null>(null)\nconst arrow = ref<HTMLElement | null>(null)\nconst trigger = ref<HTMLElement | null>(null)\nconst placeholder = ref<HTMLElement | null>(null)\n\nconst sanitizedTitle = computed(() =>\n  props.title ? sanitizeHtml(props.title, DefaultAllowlist) : ''\n)\n\nconst sanitizedContent = computed(() =>\n  props.content ? sanitizeHtml(props.content, DefaultAllowlist) : ''\n)\nconst isAutoPlacement = toRef(() => props.placement.startsWith('auto'))\nconst offsetNumber = useToNumber(() => props.offset ?? NaN)\n\nconst boundary = computed<Boundary | undefined>(() =>\n  props.boundary === 'document' || props.boundary === 'viewport' ? undefined : props.boundary\n)\nconst rootBoundary = computed<RootBoundary | undefined>(() =>\n  props.boundary === 'document' || props.boundary === 'viewport' ? props.boundary : undefined\n)\n\nconst sizeStyles = ref<CSSProperties>({})\nconst floatingMiddleware = computed<Middleware[]>(() => {\n  if (props.floatingMiddleware !== undefined) {\n    return props.floatingMiddleware\n  }\n  const off = props.offset !== null ? offsetNumber.value : props.tooltip ? 6 : 8\n  const arr: Middleware[] = [offsetMiddleware(off)]\n  if (props.noFlip === false && !isAutoPlacement.value) {\n    arr.push(\n      flip({\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n      })\n    )\n  }\n  if (isAutoPlacement.value) {\n    arr.push(\n      autoPlacement({\n        alignment: (props.placement.split('-')[1] as Alignment) || undefined,\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n      })\n    )\n  }\n  if (props.noShift === false) {\n    arr.push(\n      shift({\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n      })\n    )\n  }\n  if (props.noHide === false) {\n    arr.push(\n      hideMiddleware({\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n      })\n    )\n  }\n  if (props.inline === true) {\n    arr.push(inlineMiddleware())\n  }\n  arr.push(arrowMiddleware({element: arrow, padding: 10}))\n  if (props.noSize === false) {\n    arr.push(\n      sizeMiddleware({\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n        apply({availableWidth, availableHeight}) {\n          sizeStyles.value = {\n            maxHeight: availableHeight ? `${availableHeight}px` : undefined,\n            maxWidth: availableWidth ? `${availableWidth}px` : undefined,\n          }\n        },\n      })\n    )\n  }\n  return arr\n})\n\nconst placementRef = toRef(() =>\n  isAutoPlacement.value ? undefined : (props.placement as OriginalPlacement)\n)\n\nconst {floatingStyles, middlewareData, placement, update} = useFloating(targetTrigger, element, {\n  placement: placementRef,\n  middleware: floatingMiddleware,\n  strategy: toRef(() => props.strategy),\n  whileElementsMounted: (...args) => {\n    const cleanup = autoUpdate(...args, {animationFrame: props.realtime})\n    // Important! Always return the cleanup function.\n    return cleanup\n  },\n})\n\nconst arrowStyle = ref<CSSProperties>({position: 'absolute'})\n\nwatch(middlewareData, () => {\n  if (props.noHide === false) {\n    if (middlewareData.value.hide?.referenceHidden) {\n      hidden.value = true\n    } else {\n      hidden.value = false\n    }\n  }\n  if (middlewareData.value.arrow) {\n    const {x, y} = middlewareData.value.arrow\n    arrowStyle.value = {\n      position: 'absolute',\n      top: y ? `${y}px` : '',\n      left: x ? `${x}px` : '',\n    }\n  }\n})\n\nconst computedClasses = computed(() => {\n  const type = props.tooltip ? 'tooltip' : 'popover'\n  return [\n    type,\n    `b-${type}`,\n    {\n      [`b-${type}-${props.variant}`]: props.variant !== null,\n      show: showState.value && !hidden.value,\n      ['pe-none']: !showState.value,\n      fade: !props.noFade,\n      ['d-none']: !showState.value && props.noFade,\n      [`${props.customClass}`]: props.customClass !== undefined,\n      [`bs-${type}-${resolveBootstrapPlacement(placement.value)}`]: placement.value !== undefined,\n    },\n  ]\n})\n\nconst {isOutside} = useMouseInElement(element)\nconst {isOutside: triggerIsOutside} = useMouseInElement(trigger)\n\nconst toggle = (e?: Event) => {\n  const event = e ?? new Event('click')\n  showState.value ? hide(event) : show()\n}\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Partial<BvTriggerableEvent> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nlet showTimeout: ReturnType<typeof setTimeout> | undefined\nconst show = () => {\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    emit('show-prevented')\n    return\n  }\n  showStateInternal.value = true\n  nextTick(() => {\n    update()\n    showTimeout = setTimeout(\n      () => {\n        update()\n        showState.value = true\n        nextTick(() => {\n          emit('shown', buildTriggerableEvent('shown'))\n        })\n      },\n      typeof props.delay === 'number' ? props.delay : props.delay?.show || 0\n    )\n  })\n}\n\nconst hide = (e: Readonly<Event>) => {\n  const event = buildTriggerableEvent('hide', {cancelable: true})\n  emit('hide', event)\n  if (event.defaultPrevented) {\n    emit('hide-prevented')\n    return\n  }\n  if (showTimeout) {\n    clearTimeout(showTimeout)\n    showTimeout = undefined\n  }\n  const delay = typeof props.delay === 'number' ? props.delay : props.delay?.hide || 0\n  setTimeout(() => {\n    if (\n      e?.type === 'click' ||\n      e?.type === 'forceHide' ||\n      (e?.type === 'update:modelValue' && props.manual) ||\n      (!props.noninteractive &&\n        isOutside.value &&\n        triggerIsOutside.value &&\n        !element.value?.contains(document?.activeElement) &&\n        !trigger.value?.contains(document?.activeElement)) ||\n      (props.noninteractive && triggerIsOutside.value)\n    ) {\n      showState.value = false\n      nextTick(() => {\n        setTimeout(\n          () => {\n            showStateInternal.value = false\n          },\n          element.value ? getTransitionDelay(element.value) : 150\n        )\n        emit('hidden', buildTriggerableEvent('hidden'))\n      })\n    } else {\n      setTimeout(\n        () => {\n          hide(e)\n        },\n        delay < 50 ? 50 : delay\n      )\n    }\n  }, delay)\n}\n\ndefineExpose({\n  hide,\n  show,\n  toggle,\n})\n\nconst bind = () => {\n  // TODO: is this the best way to bind the events?\n  // we place a span and get the next element sibling fo rthe listeners\n  if (props.target) {\n    const elem = getElement(props.target)\n    if (elem) {\n      trigger.value = elem\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn('Target element not found', props.target)\n    }\n  } else {\n    trigger.value = placeholder.value?.nextElementSibling as HTMLElement\n  }\n  if (props.reference) {\n    const elem = getElement(props.reference)\n    if (elem) {\n      targetTrigger.value = elem\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn('Reference element not found', props.reference)\n    }\n  } else {\n    targetTrigger.value = trigger.value\n  }\n  if (!trigger.value || props.manual) {\n    return\n  }\n  if (!IS_BROWSER) return\n  trigger.value.addEventListener('forceHide', hide)\n  if (props.click) {\n    trigger.value.addEventListener('click', toggle)\n    return\n  }\n  trigger.value.addEventListener('pointerenter', show)\n  trigger.value.addEventListener('pointerleave', hide)\n  trigger.value.addEventListener('focus', show)\n  trigger.value.addEventListener('blur', hide)\n}\n\nconst unbind = () => {\n  if (trigger.value) {\n    trigger.value.removeEventListener('forceHide', hide)\n    trigger.value.removeEventListener('click', toggle)\n    trigger.value.removeEventListener('pointerenter', show)\n    trigger.value.removeEventListener('pointerleave', hide)\n    trigger.value.removeEventListener('focus', show)\n    trigger.value.removeEventListener('blur', hide)\n  }\n}\n\nonClickOutside(\n  element,\n  () => {\n    if (showState.value && props.click && !props.noAutoClose && !props.manual)\n      hide(new Event('clickOutside'))\n  },\n  {ignore: [trigger]}\n)\n\nwatch([() => props.click, () => props.target, () => props.reference], () => {\n  unbind()\n  bind()\n  // update()\n})\n\nonMounted(bind)\n\nonBeforeUnmount(unbind)\n</script>\n","import type {Placement} from '@floating-ui/vue'\nexport {autoUpdate} from '@floating-ui/vue'\n\nimport {type DirectiveBinding, h, render} from 'vue'\nimport {DefaultAllowlist, sanitizeHtml} from './sanitizer'\nimport BPopover from '../components/BPopover.vue'\nimport type {BPopoverProps} from '../types'\n\n// TODO this function doesn't currently resolve with RTL in mind. Once Bootstrap finalizes their RTL, we should make this change here\n/**\n * Configures Bootstrap-like placement props to floating-ui Placement strings.\n * Top drops up, bottom drops down, end drops right, start drops left, dropend will _align_ the drop to the 'end',\n * dropstart will _align_ the drop to the 'start'. Bottom is default, so it is the last in the order. Bottom should essentially be the opposite of top\n * @param {top: boolean; bottom: boolean; start: boolean; end: boolean; dropstart: boolean; dropend: boolean}\n * @returns {Placement} Placement\n */\nexport const resolveFloatingPlacement = ({\n  top,\n  end,\n  start,\n  alignCenter,\n  alignEnd,\n}: Readonly<{\n  top: boolean\n  start: boolean\n  end: boolean\n  alignCenter: boolean\n  alignEnd: boolean\n}>): Placement => {\n  const direction = top ? 'top' : start ? 'left' : end ? 'right' : 'bottom'\n  const align = alignEnd ? 'end' : alignCenter ? null : 'start'\n  return `${direction}${align ? `-${align}` : ''}` as Placement\n}\n\nexport const resolveBootstrapPlacement = (placement: Placement): string => {\n  const [_placement] = placement.split('-')\n  switch (_placement) {\n    case 'left':\n      return 'start'\n    case 'right':\n      return 'end'\n    default:\n      return _placement\n  }\n}\n\nexport const resolveActiveStatus = (values: DirectiveBinding['value']): boolean =>\n  typeof values !== 'object' || values.active !== false\n\nexport const resolveContent = (\n  values: DirectiveBinding['value'],\n  el: HTMLElement\n): {title?: string; content?: string} => {\n  const isActive = resolveActiveStatus(values)\n  if (!isActive) return {}\n\n  const missingBindingValue =\n    typeof values === 'undefined' ||\n    (typeof values === 'object' && !values.title && !values.content)\n  const title = el.getAttribute('title') || el.getAttribute('data-original-title')\n  if (missingBindingValue) {\n    if (title) {\n      el.removeAttribute('title')\n      el.setAttribute('data-original-title', title)\n\n      return {\n        content: sanitizeHtml(title, DefaultAllowlist),\n      }\n    }\n    return {}\n  }\n  if (typeof values === 'string') {\n    return {\n      content: sanitizeHtml(values, DefaultAllowlist),\n    }\n  }\n  return {\n    title: values?.title ? sanitizeHtml(values?.title, DefaultAllowlist) : undefined,\n    content: values?.content ? sanitizeHtml(values?.content, DefaultAllowlist) : undefined,\n  }\n}\n\nexport const resolveDirectiveProps = (\n  binding: Readonly<DirectiveBinding>,\n  el: Readonly<HTMLElement>\n) => ({\n  target: el,\n  modelValue: binding.modifiers.show,\n  inline: binding.modifiers.inline,\n  click: binding.modifiers.click,\n  realtime: binding.modifiers.realtime,\n  persistent: binding.modifiers.persistent,\n  placement: binding.modifiers.left\n    ? 'left'\n    : binding.modifiers.right\n      ? 'right'\n      : binding.modifiers.bottom\n        ? 'bottom'\n        : binding.modifiers.top\n          ? 'top'\n          : undefined,\n  html: true,\n  ...(typeof binding.value === 'object' ? binding.value : {}),\n  ...(binding.modifiers.interactive ? {noninteractive: false} : {}),\n  title: null,\n  content: null,\n})\n\nexport interface ElementWithPopper extends HTMLElement {\n  $__element?: HTMLElement\n}\n\nexport const bind = (\n  el: ElementWithPopper,\n  binding: Readonly<DirectiveBinding>,\n  props: BPopoverProps\n) => {\n  const div = document.createElement('span')\n  if (binding.modifiers.body) document.body.appendChild(div)\n  else if (binding.modifiers.child) el.appendChild(div)\n  else el.parentNode?.insertBefore(div, el.nextSibling)\n  render(h(BPopover, props), div)\n  el.$__element = div\n}\n\nexport const unbind = (el: ElementWithPopper) => {\n  const div = el.$__element\n  if (div) render(null, div)\n  setTimeout(() => {\n    div?.remove()\n  }, 0)\n  delete el.$__element\n}\n","import type {TableFieldFormatter} from '../types'\nimport {get} from '.'\n\nexport default (\n  item: unknown,\n  // Weakly type fieldKey because it can be a nested string, such as 'foo.bar.baz'\n  fieldKey: string,\n  formatter?: TableFieldFormatter<unknown>\n) => {\n  const val = get(item, fieldKey)\n  return formatter && typeof formatter === 'function' ? formatter(val, fieldKey, item) : val\n}\n","import type {ComponentProps, PropDefinition} from '../types'\n\nexport default (\n  prefix: string,\n  breakpoints: readonly string[],\n  definition: Readonly<PropDefinition>\n): ComponentProps =>\n  breakpoints.concat(['sm', 'md', 'lg', 'xl', 'xxl']).reduce((props, breakpoint) => {\n    props[\n      !prefix ? breakpoint : `${prefix}${breakpoint.charAt(0).toUpperCase() + breakpoint.slice(1)}`\n    ] = definition\n    return props\n  }, {} as ComponentProps)\n","import type {ComponentProps} from '../types'\n\nexport default (\n  props: Readonly<Record<PropertyKey, unknown>>,\n  els: Readonly<ComponentProps>,\n  propPrefix: string,\n  classPrefix = propPrefix\n): string[] =>\n  Object.keys(els).reduce((arr: string[], prop) => {\n    if (!props[prop]) return arr\n\n    arr.push(\n      [classPrefix, prop.replace(propPrefix, ''), props[prop]]\n        .filter((e) => e && typeof e !== 'boolean')\n        .join('-')\n        .toLowerCase()\n    )\n\n    return arr\n  }, [] as string[])\n","import type {ComponentPublicInstance} from 'vue'\n\nexport default (\n  element: string | Readonly<ComponentPublicInstance> | Readonly<HTMLElement> | null\n): HTMLElement | undefined => {\n  if (!element) return undefined\n  if (typeof element === 'string') {\n    if (typeof document === 'undefined') return undefined\n    const idElement = document.getElementById(element)\n    return idElement ?? (document.querySelector(element) as HTMLElement) ?? undefined\n  }\n  return (element as ComponentPublicInstance).$el ?? element\n}\n","import type {Slot, VNode} from 'vue'\n\nexport default (slot: Slot | undefined, filterBy: string): VNode[] =>\n  (slot?.() ?? [])\n    .reduce((arr: VNode[], slot: VNode) => {\n      if (typeof slot.type === 'symbol') {\n        arr = arr.concat(slot.children as unknown as VNode)\n      } else {\n        arr.push(slot)\n      }\n      return arr\n    }, [])\n    .filter((child) => (child.type as {__name: string} | undefined)?.__name === filterBy)\n","export const RX_UNDERSCORE = /_/g\nexport const RX_LOWER_UPPER = /([a-z])([A-Z])/g\nexport const RX_NUMBER = /^[0-9]*\\.?[0-9]+$/\nexport const RX_START_SPACE_WORD = /(\\s|^)(\\w)/g\nexport const RX_FIRST_START_SPACE_WORD = /(\\s|^)(\\w)/\nexport const RX_SPACE_SPLIT = /\\s+/\nexport const RX_HASH = /^#/\nexport const RX_HASH_ID = /^#[A-Za-z]+[\\w\\-:.]*$/\n\nexport const RX_STRIP_LOCALE_MODS = /-u-.+/\nexport const RX_REGEXP_REPLACE = /[-/\\\\^$*+?.()|[\\]{}]/g\nexport const RX_SPACES = /[\\s\\uFEFF\\xA0]+/g\n","import {\n  RX_FIRST_START_SPACE_WORD,\n  RX_LOWER_UPPER,\n  RX_REGEXP_REPLACE,\n  RX_SPACES,\n  RX_START_SPACE_WORD,\n  RX_UNDERSCORE,\n} from '../constants/regex'\n\n/**\n * @param str\n * @returns\n */\nexport const startCase = (str: string): string =>\n  str\n    .replace(RX_UNDERSCORE, ' ')\n    .replace(RX_LOWER_UPPER, (_, $1, $2) => `${$1} ${$2}`)\n    .replace(RX_FIRST_START_SPACE_WORD, (_, $1, $2) => $1 + $2.toUpperCase())\n\n/**\n * @param str\n * @returns\n */\nexport const titleCase = (str: string): string =>\n  str\n    .replace(RX_UNDERSCORE, ' ')\n    .replace(RX_LOWER_UPPER, (_, $1, $2) => `${$1} ${$2}`)\n    .replace(RX_START_SPACE_WORD, (_, $1, $2) => $1 + $2.toUpperCase())\n\n/**\n * Uppercases the first letter of a string and returns a new string\n *\n * @param str\n * @returns\n */\nexport const upperFirst = (str: string): string => {\n  const trim = str.trim()\n  return trim.charAt(0).toUpperCase() + trim.slice(1)\n}\n\n/**\n * Escapes a string for RegExp usage.\n *\n * @param str\n * @returns\n */\nexport const escapeRegExp = (str: string): string => str.replace(RX_REGEXP_REPLACE, '\\\\$&')\n\n/**\n * Escapes special chars in string and replaces\n * contiguous spaces with a whitespace match\n *\n * @param str\n * @returns\n */\nexport const escapeRegExpChars = (str: string): string =>\n  escapeRegExp(str).replace(RX_SPACES, '\\\\s')\n","import {titleCase} from './stringUtils'\nimport type {TableFieldRaw} from '../types'\n\nexport default (field: Readonly<TableFieldRaw<unknown>>) =>\n  typeof field === 'string'\n    ? titleCase(field)\n    : field.label !== undefined\n      ? field.label\n      : typeof field.key === 'string'\n        ? titleCase(field.key)\n        : field.key\n","import type {RouteLocationRaw} from 'vue-router'\n\nexport default (props: Readonly<{href?: string; to?: RouteLocationRaw}>): boolean =>\n  !!(props.href || props.to)\n","import type {\n  Component,\n  ComponentInternalInstance,\n  ComputedRef,\n  InjectionKey,\n  MaybeRefOrGetter,\n  Ref,\n  ShallowRef,\n} from 'vue'\nimport type {\n  BModalProps,\n  BreadcrumbItemRaw,\n  ButtonVariant,\n  CheckboxValue,\n  ClassValue,\n  ColorVariant,\n  LiteralUnion,\n  Numberish,\n  OrchestratedModal,\n  OrchestratedToast,\n  RadioValue,\n  RadiusElement,\n  Size,\n  TabType,\n  TextColorVariant,\n} from '../types'\n\n// BCarousel\nexport const carouselInjectionKey: InjectionKey<{\n  background: Readonly<Ref<string | undefined>>\n  width: Readonly<Ref<string | undefined>>\n  height: Readonly<Ref<string | undefined>>\n}> = Symbol('carousel')\n\n// BTabs\nexport const tabsInjectionKey: InjectionKey<{\n  lazy: Readonly<Ref<boolean>>\n  card: Readonly<Ref<boolean>>\n  noFade: Readonly<Ref<boolean>>\n  registerTab: (tab: Readonly<Ref<TabType>>) => void\n  unregisterTab: (id: string) => void\n  activateTab: (id: string | undefined) => void\n  activeTabClass: Readonly<Ref<ClassValue>>\n  inactiveTabClass: Readonly<Ref<ClassValue>>\n  tabClass: Readonly<Ref<ClassValue>>\n  activeId: Readonly<Ref<string | undefined>>\n}> = Symbol('tabs')\n\n// BProgress\nexport const progressInjectionKey: InjectionKey<{\n  animated: Readonly<Ref<boolean | undefined>>\n  max: Readonly<Ref<Numberish>>\n  showProgress: Readonly<Ref<boolean | undefined>>\n  showValue: Readonly<Ref<boolean | undefined>>\n  striped: Readonly<Ref<boolean | undefined>>\n}> = Symbol('progress')\n\n// BListGroup\nexport const listGroupInjectionKey: InjectionKey<{\n  numbered: Readonly<Ref<boolean>>\n}> = Symbol('listGroup')\n\n// BAvatarGroup\nexport const avatarGroupInjectionKey: InjectionKey<{\n  overlapScale: Readonly<Ref<number>>\n  size: Readonly<Ref<LiteralUnion<Size, Numberish> | undefined>>\n  square: Readonly<Ref<boolean>>\n  rounded: Readonly<Ref<RadiusElement | boolean>>\n  roundedTop: Readonly<Ref<RadiusElement | boolean | undefined>>\n  roundedBottom: Readonly<Ref<RadiusElement | boolean | undefined>>\n  roundedStart: Readonly<Ref<RadiusElement | boolean | undefined>>\n  roundedEnd: Readonly<Ref<RadiusElement | boolean | undefined>>\n  variant: Readonly<Ref<ColorVariant | null>>\n  bgVariant: Readonly<Ref<ColorVariant | null>>\n  textVariant: Readonly<Ref<TextColorVariant | null>>\n}> = Symbol('avatarGroup')\n\n// BAccordion\nexport const accordionInjectionKey: InjectionKey<{\n  openItem: Readonly<Ref<string | undefined>>\n  free: Readonly<Ref<boolean>>\n  setOpenItem: (id: string) => void\n}> = Symbol('accordion')\n\n// BFormCheckboxGroup\nexport const checkboxGroupKey: InjectionKey<{\n  modelValue: Ref<readonly CheckboxValue[]>\n  switch: Readonly<Ref<boolean>>\n  buttonVariant: Readonly<Ref<ButtonVariant | null>>\n  form: Readonly<Ref<string | undefined>>\n  name: Readonly<Ref<string>>\n  state: Readonly<Ref<boolean | undefined | null>>\n  plain: Readonly<Ref<boolean>>\n  size: Readonly<Ref<Size>>\n  inline: Readonly<Ref<boolean>>\n  reverse: Readonly<Ref<boolean>>\n  required: Readonly<Ref<boolean>>\n  buttons: Readonly<Ref<boolean>>\n  disabled: Readonly<Ref<boolean>>\n}> = Symbol('checkboxGroup')\n\nexport const radioGroupKey: InjectionKey<{\n  modelValue: Ref<RadioValue>\n  buttonVariant: Readonly<Ref<ButtonVariant | null>>\n  form: Readonly<Ref<string | undefined>>\n  name: Readonly<Ref<string>>\n  buttons: Readonly<Ref<boolean>>\n  state: Readonly<Ref<boolean | undefined | null>>\n  plain: Readonly<Ref<boolean>>\n  size: Readonly<Ref<Size>>\n  inline: Readonly<Ref<boolean>>\n  reverse: Readonly<Ref<boolean>>\n  required: Readonly<Ref<boolean>>\n  disabled: Readonly<Ref<boolean>>\n}> = Symbol('radioGroup')\n\n// Collapse\nexport const collapseInjectionKey: InjectionKey<{\n  id?: Readonly<Ref<string>>\n  readonly hide?: () => void\n  readonly show?: () => void\n  readonly toggle?: () => void\n  visible?: Readonly<Ref<boolean>>\n  isNav?: Readonly<Ref<boolean>>\n}> = Symbol('collapse')\n\nexport const dropdownInjectionKey: InjectionKey<{\n  id?: Readonly<Ref<string>>\n  readonly hide?: () => void\n  readonly show?: () => void\n  readonly toggle?: () => void\n  visible?: Readonly<Ref<boolean>>\n  isNav?: Readonly<Ref<boolean>>\n}> = Symbol('collapse')\n\nexport const navbarInjectionKey: InjectionKey<{\n  tag?: Readonly<Ref<string>>\n  autoClose?: Readonly<Ref<boolean>>\n}> = Symbol('navbar')\n\nexport const toastPluginKey: InjectionKey<{\n  toasts: ShallowRef<\n    ComputedRef<{\n      component: unknown\n      props: Omit<OrchestratedToast, 'value'> & {\n        _self: symbol\n        _modelValue: OrchestratedToast['value'] // Convert it to be the same name as useModalController.\n        // The difference between the two is that unlike that one, this value can be defined (there's cannot be).\n      }\n    }>[]\n  >\n  _setIsAppend: (value: boolean) => void\n  show: (obj: {\n    component?: Readonly<Component>\n    props?: MaybeRefOrGetter<Readonly<OrchestratedToast>>\n  }) => symbol\n  remove: (self: symbol) => void\n}> = Symbol('toastPlugin')\n\nexport const rtlPluginKey: InjectionKey<{\n  isRtl: Ref<boolean>\n  locale: Ref<string | undefined>\n}> = Symbol('rtlPlugin')\n\nexport const breadcrumbPluginKey: InjectionKey<{\n  items: Ref<BreadcrumbItemRaw[]>\n  reset: () => void\n}> = Symbol('breadcrumbPlugin')\n\nexport const modalControllerPluginKey: InjectionKey<{\n  modals: ShallowRef<\n    ComputedRef<{\n      component: unknown // TS being weird here, just use unknown\n      props: OrchestratedModal & {\n        _self: symbol\n        _modelValue: BModalProps['modelValue']\n        _promise: {\n          value: Promise<boolean | null>\n          resolve: (value: boolean | null) => void\n        }\n        _isConfirm: boolean\n      }\n    }>[]\n  >\n  show: (obj: {\n    component?: Readonly<Component>\n    props?: MaybeRefOrGetter<Readonly<OrchestratedModal>>\n  }) => Promise<boolean | null>\n  confirm: (obj: {\n    component?: Readonly<Component>\n    props?: MaybeRefOrGetter<Readonly<OrchestratedModal>>\n  }) => Promise<boolean | null>\n  remove: (self: symbol) => void\n}> = Symbol('modalControllerPlugin')\n\nexport const modalManagerPluginKey: InjectionKey<{\n  stack: ShallowRef<Readonly<ComponentInternalInstance>[]>\n  countStack: Readonly<Ref<number>>\n  lastStack: Readonly<Ref<ComponentInternalInstance | undefined>>\n  pushStack: (modal: Readonly<ComponentInternalInstance>) => void\n  removeStack: (modal: Readonly<ComponentInternalInstance>) => void\n  registry: ShallowRef<Readonly<ComponentInternalInstance>[]>\n  pushRegistry: (modal: Readonly<ComponentInternalInstance>) => void\n  removeRegistry: (modal: Readonly<ComponentInternalInstance>) => void\n}> = Symbol('modalManagerPlugin')\n\nexport const idPluginKey: InjectionKey<() => string> = Symbol('idPluginKey')\n","import type {Slots, VNode} from 'vue'\n\nexport default (name: string, scope = {}, $slots: Slots = {}): VNode => {\n  // Ensure names is an array\n  const names = [name]\n  let slot\n  for (let i = 0; i < names.length && !slot; i++) {\n    const name = names[i]\n    slot = $slots[name]\n  }\n  // Note: in Vue 3.x, slots have been unified. No more scoped slots and all slots are exposed as functions\n  return (slot && typeof slot === 'function' ? slot(scope) : slot) as unknown as VNode\n}\n","/**\n * Removes properties from an object, based on the values in an array, and returns the new object.\n * Equivalent to an object version of TS Omit<>\n */\nexport const omit = <\n  A extends Record<PropertyKey, unknown>,\n  const B extends ReadonlyArray<PropertyKey>,\n>(\n  objToPluck: Readonly<A>,\n  keysToPluck: Readonly<B> | readonly (keyof A)[]\n): Omit<A, B[number]> =>\n  Object.keys(objToPluck)\n    .filter((key) => !keysToPluck.map((el) => el.toString()).includes(key))\n    .reduce((result, key) => ({...result, [key]: objToPluck[key]}), {} as Omit<A, B[number]>)\n\n/**\n * Picks properties from an object, base on the values in an array, and returns the new object.\n * Equivalent to an object version of TS Pick<>\n */\nexport const pick = <\n  A extends Record<PropertyKey, unknown>,\n  const B extends ReadonlyArray<PropertyKey>,\n>(\n  objToPluck: Readonly<A>,\n  keysToPluck: Readonly<B> | readonly (keyof A)[]\n): Pick<A, B[number]> =>\n  [...keysToPluck].reduce(\n    (memo, prop) => {\n      memo[prop] = objToPluck[prop]\n      return memo\n    },\n    {} as Record<PropertyKey, unknown>\n  ) as Pick<A, B[number]>\n\n/**\n * Dynamically get a nested value from an array or\n * object with a string.\n *\n * @example get(person, 'friends[0].name')\n *\n * Thanks to\n * @link https://github.com/rayepps/radash/blob/master/src/object.ts#L214\n */\nexport const get = <TDefault = unknown>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  path: string,\n  defaultValue?: Readonly<TDefault>\n): TDefault => {\n  const segments = path.split(/[.[\\]]/g)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let current: any = value\n  for (const key of segments) {\n    if (current === null) return defaultValue as TDefault\n    if (current === undefined) return defaultValue as TDefault\n    if (key.trim() === '') continue\n    current = current[key]\n  }\n  if (current === undefined) return defaultValue as TDefault\n  return current\n}\n\n/**\n * Opposite of get, dynamically set a nested value into\n * an object using a key path. Does not modify the given\n * initial object.\n *\n * @example\n * set({}, 'name', 'ra') // => { name: 'ra' }\n * set({}, 'cards[0].value', 2) // => { cards: [{ value: 2 }] }\n *\n * Thanks to\n * @link https://github.com/rayepps/radash/blob/master/src/object.ts#L214\n */\nexport const set = <T extends object, K>(initial: T, path: string, value: K): T => {\n  const clone = <T>(obj: T): T => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const isPrimitive = (value: any): boolean =>\n      value === undefined ||\n      value === null ||\n      (typeof value !== 'object' && typeof value !== 'function')\n    // Primitive values do not need cloning.\n    if (isPrimitive(obj)) {\n      return obj\n    }\n\n    if (typeof obj === 'function') {\n      return obj.bind({})\n    }\n\n    const newObj = new ((obj as object).constructor as {new (): T})()\n\n    // Assign the props.\n    Object.getOwnPropertyNames(obj).forEach((prop) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      ;(newObj as any)[prop] = (obj as any)[prop]\n    })\n\n    return newObj\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const toInt = <T extends number | null = number>(value: any, defaultValue?: T): number | T => {\n    const def = defaultValue === undefined ? 0 : defaultValue\n    if (value === null || value === undefined) {\n      return def\n    }\n    const result = Number.parseInt(value)\n    return Number.isNaN(result) ? def : result\n  }\n\n  if (!initial) return {} as T\n  if (!path || value === undefined) return initial\n  const segments = path.split(/[.[\\]]/g).filter((x) => !!x.trim())\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const _set = (node: any) => {\n    if (segments.length > 1) {\n      const key = segments.shift() as string\n      const nextIsNum = toInt(segments[0], null) === null ? false : true\n      node[key] = node[key] === undefined ? (nextIsNum ? [] : {}) : node[key]\n      _set(node[key])\n    } else {\n      node[segments[0]] = value\n    }\n  }\n  const cloned = clone(initial)\n  _set(cloned)\n  return cloned\n}\n","import type {ConfigurationOption} from '../types'\n\nexport default <Type extends string, Base extends ConfigurationOption<Type>>(\n  options: Readonly<Base>,\n  values: readonly Type[]\n): Type[] => {\n  const {all, ...others} = options\n  const valuesCopy: Partial<Record<keyof Base, boolean>> = {}\n  if (all) {\n    values.forEach((el) => {\n      valuesCopy[el] = all\n    })\n  }\n  const merge: Record<string, boolean> = {...valuesCopy, ...others}\n  return (\n    Object.entries(merge)\n      // filtering possible invalid keys\n      .filter(([name, value]) => !!value && values.includes(name as Type))\n      .map(([name]) => name as Type)\n  )\n}\n","// Suffix can be a falsey value so nothing is appended to string\n// (helps when looping over props & some shouldn't change)\n\nimport {upperFirst} from './stringUtils'\n\n/**\n * Use data last parameters to allow for currying\n *\n * @param suffix\n * @param value\n * @returns\n */\nexport const suffixPropName = (suffix: string, value: string): string =>\n  value + (suffix ? upperFirst(suffix) : '')\n","import {computed, type MaybeRefOrGetter, toRef} from 'vue'\nimport {isLink, pick} from '../utils'\n\nexport default <T extends Record<string, unknown>, const B extends ReadonlyArray<PropertyKey>>(\n  props: MaybeRefOrGetter<T>,\n  pickProps?: MaybeRefOrGetter<B | (keyof T)[]>\n) => {\n  const pickPropsResolved = toRef(pickProps)\n  const resolvedProps = toRef(props)\n\n  const computedLink = toRef(() => isLink(resolvedProps.value))\n  const computedLinkProps = computed(() =>\n    computedLink.value\n      ? pick(\n          resolvedProps.value,\n          pickPropsResolved.value ?? [\n            'active',\n            'activeClass',\n            'append',\n            'href',\n            'rel',\n            'replace',\n            'routerComponentName',\n            'target',\n            'to',\n            'variant',\n            'opacity',\n            'opacityHover',\n            'underlineVariant',\n            'underlineOffset',\n            'underlineOffsetHover',\n            'underlineOpacity',\n            'underlineOpacityHover',\n          ]\n        )\n      : {}\n  )\n\n  return {computedLink, computedLinkProps}\n}\n","import {inject} from 'vue'\nimport {breadcrumbPluginKey} from '../utils'\n\nexport default () => ({...inject(breadcrumbPluginKey)})\n","import {useColorMode, type UseColorModeOptions} from '@vueuse/core'\n\nexport interface ColorModeOptions extends UseColorModeOptions {\n  /**\n   * When set to true, useColorMode will automatically store itself and persist (default localstorage).\n   * @default false\n   */\n  persist?: boolean\n}\n\nexport default (opts: Readonly<ColorModeOptions> = {}) => {\n  const persist = opts.persist ?? false\n  const attribute = 'data-bs-theme'\n  const selector = 'body'\n  return useColorMode({\n    attribute,\n    selector,\n    storageKey:\n      persist === true\n        ? `bv-color-${opts.attribute ?? attribute}-${opts.selector ?? selector}`\n        : null,\n    ...opts,\n  })\n}\n","import {computed, type MaybeRefOrGetter, toValue} from 'vue'\nimport type {ColorExtendables} from '../types'\n\nexport default (obj: MaybeRefOrGetter<ColorExtendables>) =>\n  computed(() => {\n    let props = toValue(obj)\n    props = {\n      ...props,\n      variant: props.variant ?? null,\n      bgVariant: props.bgVariant ?? null,\n      textVariant: props.textVariant ?? null,\n    }\n    return {\n      [`text-bg-${props.variant}`]: props.variant !== null,\n      [`text-${props.textVariant}`]: props.textVariant !== null && props.variant === null,\n      [`bg-${props.bgVariant}`]: props.bgVariant !== null && props.variant === null,\n    }\n  })\n","import type {Breakpoint} from '../types'\nimport {computed, type MaybeRefOrGetter, toValue} from 'vue'\n\nexport default (value: MaybeRefOrGetter<boolean | Breakpoint | 'fluid'>) =>\n  computed(() => {\n    const resolvedValue = toValue(value)\n    return {\n      container: resolvedValue === true,\n      [`container-${resolvedValue}`]: typeof resolvedValue === 'string',\n    }\n  })\n","import {useIntervalFn, type UseIntervalFnOptions} from '@vueuse/core'\nimport {type MaybeRefOrGetter, readonly, ref, type Ref, toRef, watch, watchEffect} from 'vue'\n\ntype VoidFn = () => void\n\ninterface CountdownReturn {\n  isActive: Readonly<Ref<boolean>>\n  isPaused: Readonly<Ref<boolean>>\n  restart: VoidFn\n  stop: VoidFn\n  resume: VoidFn\n  pause: VoidFn\n  value: Readonly<Ref<number>>\n}\n\n/**\n * A simple interval timer that counts down the remaining seconds\n *\n * @param {MaybeRefOrGetter<number>} length the total amount of time to loop through in ms\n * @param {MaybeRefOrGetter<number>} interval how often the interval should refresh. Default 1000\n * @param {Readonly<UseIntervalFnOptions>} intervalOpts opts to pass to the interval fn. Default {}\n * @important ensure that you call `stop()` before unmount in the component\n */\nexport default (\n  length: MaybeRefOrGetter<number>,\n  interval: MaybeRefOrGetter<number> = ref(1000),\n  intervalOpts: Readonly<UseIntervalFnOptions> = {}\n): CountdownReturn => {\n  const resolvedLength = readonly(toRef(length))\n\n  const resolvedInterval = readonly(toRef(interval))\n\n  const isPaused = ref(false)\n\n  const intervalsPassed = ref(0)\n\n  const amountOfIntervals = toRef(() => Math.ceil(resolvedLength.value / resolvedInterval.value))\n\n  const value = toRef(() =>\n    isActive.value || isPaused.value\n      ? Math.round(resolvedLength.value - intervalsPassed.value * resolvedInterval.value)\n      : 0\n  )\n\n  const {pause, resume, isActive} = useIntervalFn(\n    () => {\n      intervalsPassed.value = intervalsPassed.value + 1\n    },\n    interval,\n    intervalOpts\n  )\n\n  const restart = () => {\n    isPaused.value = false\n    intervalsPassed.value = 0\n    resume()\n  }\n\n  const stop = () => {\n    isPaused.value = false\n    intervalsPassed.value = amountOfIntervals.value\n    // pause() // Only here for the sake of demonstrating the flow. It will be called in the watchEffect\n  }\n  watchEffect(() => {\n    if (intervalsPassed.value > amountOfIntervals.value) {\n      intervalsPassed.value = amountOfIntervals.value\n    }\n    if (intervalsPassed.value === amountOfIntervals.value) {\n      pause()\n    }\n  })\n\n  watch([resolvedInterval, resolvedLength], () => {\n    stop()\n    restart()\n  })\n\n  const myPause = () => {\n    if (isActive.value === false) return\n    isPaused.value = true\n    pause()\n  }\n\n  const myResume = () => {\n    if (intervalsPassed.value === amountOfIntervals.value) return\n    isPaused.value = false\n    resume()\n  }\n\n  return {\n    isActive: readonly(isActive),\n    isPaused: readonly(isPaused),\n    restart,\n    stop,\n    pause: myPause,\n    resume: myResume,\n    value,\n  }\n}\n","import {computed, type MaybeRefOrGetter, toValue} from 'vue'\n\nexport default (value: MaybeRefOrGetter<boolean | null>) =>\n  computed(() => {\n    const resolvedValue = toValue(value)\n\n    return resolvedValue === true ? 'is-valid' : resolvedValue === false ? 'is-invalid' : null\n  })\n","import type {AriaInvalid, ButtonVariant, Size} from '../types'\nimport {computed, type MaybeRefOrGetter, toRef, toValue} from 'vue'\nimport useAriaInvalid from './useAriaInvalid'\nimport useStateClass from './useStateClass'\n\ninterface ClassesItemsInput {\n  plain?: boolean\n  button?: boolean\n  inline?: boolean\n  reverse?: boolean\n  switch?: boolean\n  size?: Size\n  hasDefaultSlot?: boolean\n}\n\nconst getClasses = (items: MaybeRefOrGetter<ClassesItemsInput>) =>\n  computed(() => {\n    const resolvedItems = toValue(items)\n    return {\n      'form-check':\n        resolvedItems.plain === false &&\n        resolvedItems.button === false &&\n        resolvedItems.hasDefaultSlot,\n      'form-check-reverse': resolvedItems.reverse === true,\n      'form-check-inline': resolvedItems.inline === true,\n      'form-switch': resolvedItems.switch === true,\n      [`form-control-${resolvedItems.size}`]:\n        resolvedItems.size !== undefined &&\n        resolvedItems.size !== 'md' &&\n        resolvedItems.button === false,\n    }\n  })\n\ninterface InputClassesItemsInput {\n  plain?: boolean\n  button?: boolean\n  state?: boolean | null\n}\n\nconst getInputClasses = (items: MaybeRefOrGetter<InputClassesItemsInput>) => {\n  const resolvedItems = toRef(items)\n\n  const stateClass = useStateClass(() => resolvedItems.value.state ?? null)\n\n  return computed(() => [\n    stateClass.value,\n    {\n      'form-check-input':\n        resolvedItems.value.plain === false && resolvedItems.value.button === false,\n      'btn-check': resolvedItems.value.button === true,\n    },\n  ])\n}\n\ninterface LabelClasesItemsInput {\n  plain?: boolean\n  button?: boolean\n  buttonVariant?: ButtonVariant | null\n  size?: Size\n}\n\nconst getLabelClasses = (items: MaybeRefOrGetter<LabelClasesItemsInput>) =>\n  computed(() => {\n    const resolvedItems = toValue(items)\n    return {\n      'form-check-label': resolvedItems.plain === false && resolvedItems.button === false,\n      'btn': resolvedItems.button === true,\n      [`btn-${resolvedItems.buttonVariant}`]:\n        resolvedItems.button === true &&\n        resolvedItems.buttonVariant !== undefined &&\n        resolvedItems.buttonVariant !== null,\n      [`btn-${resolvedItems.size}`]:\n        resolvedItems.button && resolvedItems.size && resolvedItems.size !== 'md',\n    }\n  })\n\ninterface GroupAttrItemsInput {\n  required?: boolean\n  ariaInvalid?: AriaInvalid\n  state?: boolean | null\n}\n\nconst getGroupAttr = (items: MaybeRefOrGetter<GroupAttrItemsInput>) => {\n  const resolvedItems = toRef(items)\n  const computedAriaInvalid = useAriaInvalid(\n    () => resolvedItems.value.ariaInvalid,\n    () => resolvedItems.value.state\n  )\n  return computed(() => ({\n    'aria-invalid': computedAriaInvalid.value as Exclude<AriaInvalid, ''> | undefined,\n    'aria-required': resolvedItems.value.required === true ? true : undefined,\n  }))\n}\n\ninterface GroupClassesItemsInput {\n  validated?: boolean\n  buttons?: boolean\n  stacked?: boolean\n  size?: Size\n}\n\nconst getGroupClasses = (items: MaybeRefOrGetter<GroupClassesItemsInput>) =>\n  computed(() => {\n    const resolvedItems = toValue(items)\n    return {\n      'was-validated': resolvedItems.validated === true,\n      'btn-group': resolvedItems.buttons === true && resolvedItems.stacked === false,\n      'btn-group-vertical': resolvedItems.stacked === true && resolvedItems.buttons === true,\n      [`btn-group-${resolvedItems.size}`]: resolvedItems.size !== undefined,\n    }\n  })\n\nexport {getClasses, getInputClasses, getLabelClasses, getGroupAttr, getGroupClasses}\n","import {idPluginKey} from '../utils'\nimport {computed, type ComputedRef, inject, type MaybeRefOrGetter, toValue} from 'vue'\n\nexport default (id?: MaybeRefOrGetter<string | undefined>, suffix?: string): ComputedRef<string> =>\n  computed(() => toValue(id) || getId(suffix))\n\nexport const getId = (suffix = '') => {\n  const getId = inject(idPluginKey, () => Math.random().toString().slice(2, 8))\n  return `__BVID__${getId()}___BV_${suffix}__`\n}\n","import type {Numberish} from '../types'\nimport {nextTick, onActivated, onMounted, ref} from 'vue'\nimport useAriaInvalid from './useAriaInvalid'\nimport useId from './useId'\nimport {useDebounceFn, useFocus, useToNumber, useVModel} from '@vueuse/core'\nimport type {CommonInputProps} from '../types/FormCommonInputProps'\n\nexport default (\n  props: Readonly<CommonInputProps>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  emit: (evt: 'update:modelValue', val: any) => void\n) => {\n  const input = ref<HTMLInputElement | null>(null)\n\n  const modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\n  const computedId = useId(() => props.id, 'input')\n  const debounceNumber = useToNumber(() => props.debounce ?? 0)\n  const debounceMaxWaitNumber = useToNumber(() => props.debounceMaxWait ?? NaN)\n\n  const internalUpdateModelValue = useDebounceFn(\n    (value: Numberish | undefined) => {\n      modelValue.value = value\n    },\n    () => (props.lazy === true ? 0 : debounceNumber.value),\n    {maxWait: () => (props.lazy === true ? NaN : debounceMaxWaitNumber.value)}\n  )\n\n  const updateModelValue = (value: Numberish | undefined, force = false) => {\n    if (props.lazy === true && force === false) return\n    internalUpdateModelValue(value)\n  }\n\n  const {focused} = useFocus(input, {\n    initialValue: props.autofocus,\n  })\n\n  const _formatValue = (value: string, evt: Readonly<Event>, force = false) => {\n    if (props.formatter !== undefined && (!props.lazyFormatter || force)) {\n      return props.formatter(value, evt)\n    }\n    return value\n  }\n\n  const _getModelValue = (value: string) => {\n    if (props.trim) return value.trim()\n    if (props.number) return Number.parseFloat(value)\n\n    return value\n  }\n\n  onMounted(() => {\n    if (input.value) {\n      input.value.value = modelValue.value?.toString() ?? ''\n    }\n  })\n\n  onActivated(() => {\n    nextTick(() => {\n      if (props.autofocus) {\n        focused.value = true\n      }\n    })\n  })\n\n  const computedAriaInvalid = useAriaInvalid(\n    () => props.ariaInvalid,\n    () => props.state\n  )\n\n  const onInput = (evt: Readonly<Event>) => {\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt)\n    if (evt.defaultPrevented) {\n      evt.preventDefault()\n      return\n    }\n\n    const nextModel = _getModelValue(formattedValue)\n\n    updateModelValue(nextModel)\n  }\n\n  const onChange = (evt: Readonly<Event>) => {\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt)\n    if (evt.defaultPrevented) {\n      evt.preventDefault()\n      return\n    }\n\n    const nextModel = _getModelValue(formattedValue)\n    if (modelValue.value !== nextModel) {\n      updateModelValue(formattedValue, true)\n    }\n  }\n\n  const onBlur = (evt: Readonly<FocusEvent>) => {\n    if (!props.lazy && !props.lazyFormatter) return\n\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt, true)\n\n    const nextModel = _getModelValue(formattedValue)\n    if (modelValue.value !== nextModel) {\n      updateModelValue(formattedValue, true)\n    }\n  }\n\n  const focus = () => {\n    if (!props.disabled) {\n      focused.value = true\n    }\n  }\n\n  const blur = () => {\n    if (!props.disabled) {\n      focused.value = false\n    }\n  }\n\n  return {\n    input,\n    computedId,\n    computedAriaInvalid,\n    onInput,\n    onChange,\n    onBlur,\n    focus,\n    blur,\n  }\n}\n","import {computed, type MaybeRefOrGetter, toValue} from 'vue'\nimport {get} from '../utils'\nimport type {ComplexSelectOptionRaw, SelectOption} from '../types'\n\nexport default (options: MaybeRefOrGetter, props: Record<string, unknown>) => {\n  const isComplex = (option: unknown): option is ComplexSelectOptionRaw =>\n    typeof option === 'object' && option !== null && 'label' in option\n\n  const normalizeOption = (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    option: any\n  ): ComplexSelectOptionRaw | SelectOption => {\n    if (typeof option === 'string') {\n      return {value: option, text: option}\n    }\n    if (typeof option === 'number') {\n      return {value: option, text: `${option}`}\n    }\n    if (option instanceof Date) {\n      return {value: option, text: option.toLocaleString()}\n    }\n\n    const value: unknown = get(option, props.valueField as string)\n    const text: string = get(option, props.textField as string)\n    const html: string = get(option, props.htmlField as string)\n    const disabled: boolean = get(option, props.disabledField as string)\n\n    const opts: undefined | (unknown | Record<string, unknown>)[] = props.optionsField\n      ? get(option, props.optionsField as string)\n      : undefined\n\n    if (opts !== undefined) {\n      return {\n        label: get(option, props.labelField as string) || text,\n        options: opts,\n      } as ComplexSelectOptionRaw\n    }\n\n    return {\n      value,\n      text,\n      html,\n      disabled,\n    } as SelectOption\n  }\n\n  const normalizeOptions = (\n    options: (unknown | Record<string, unknown>)[]\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): (ComplexSelectOptionRaw | SelectOption)[] => options.map((option) => normalizeOption(option))\n\n  const normalizedOptions = computed(() => normalizeOptions(toValue(options)))\n\n  return {normalizedOptions, isComplex}\n}\n","import {getSSRHandler, tryOnScopeDispose, unrefElement} from '@vueuse/core'\nimport {\n  type ComponentInternalInstance,\n  computed,\n  getCurrentInstance,\n  inject,\n  type Ref,\n  watch,\n} from 'vue'\nimport {modalManagerPluginKey} from '../utils'\n\nconst modalOpenClassName = 'modal-open'\n\nexport const useSharedModalStack = () => {\n  const modalManagerPlugin = inject(modalManagerPluginKey)\n\n  /**\n   * Removes an item from both the stack and registry\n   */\n  const dispose = (modal: Readonly<ComponentInternalInstance>): void => {\n    modalManagerPlugin?.removeStack(modal)\n    modalManagerPlugin?.removeRegistry(modal)\n  }\n\n  const updateHTMLAttrs = getSSRHandler('updateHTMLAttrs', (selector, attribute, value) => {\n    const el =\n      typeof selector === 'string'\n        ? window?.document.querySelector(selector)\n        : unrefElement(selector)\n    if (!el) return\n\n    if (attribute === 'class') {\n      el.classList.toggle(modalOpenClassName, value === modalOpenClassName)\n    } else {\n      el.setAttribute(attribute, value)\n    }\n  })\n\n  tryOnScopeDispose(() => {\n    updateHTMLAttrs('body', 'class', '')\n  })\n\n  watch(\n    () => modalManagerPlugin?.countStack.value,\n    (newValue) => {\n      if (newValue === undefined) return\n      updateHTMLAttrs('body', 'class', newValue > 0 ? modalOpenClassName : '')\n    }\n  )\n\n  return {\n    ...modalManagerPlugin,\n    dispose,\n  }\n}\n\nexport default (modalOpen: Readonly<Ref<boolean>>) => {\n  const {pushRegistry, pushStack, removeStack, stack, dispose, countStack} = useSharedModalStack()\n\n  const currentModal = getCurrentInstance()\n\n  if (!currentModal || currentModal.type.__name !== 'BModal') {\n    throw new Error('useModalManager must only use in BModal component')\n  }\n\n  pushRegistry?.(currentModal)\n\n  tryOnScopeDispose(() => {\n    dispose(currentModal)\n  })\n\n  watch(\n    modalOpen,\n    (newValue, oldValue) => {\n      if (newValue) {\n        pushStack?.(currentModal)\n      } else if (oldValue && !newValue) {\n        removeStack?.(currentModal)\n      }\n    },\n    {immediate: true}\n  )\n\n  return {\n    activePosition: computed(() =>\n      stack?.value.findIndex((el) => el.exposed?.id === currentModal.exposed?.id)\n    ),\n    activeModalCount: countStack,\n  }\n}\n","import {\n  type ComponentInternalInstance,\n  computed,\n  getCurrentInstance,\n  type MaybeRefOrGetter,\n  toRef,\n  toValue,\n} from 'vue'\nimport {useSharedModalStack} from './useModalManager'\n\nexport default (id: MaybeRefOrGetter<string | undefined> = undefined) => {\n  const {registry} = useSharedModalStack()\n  const instance = getCurrentInstance()\n\n  const findBModal = (component: ComponentInternalInstance): ComponentInternalInstance | null => {\n    if (!component.parent) {\n      return null\n    }\n\n    if (component.parent.type.__name === 'BModal') {\n      return component.parent\n    }\n\n    return findBModal(component.parent)\n  }\n\n  const modalComponent = computed(() => {\n    const resolvedId = toValue(id)\n    if (resolvedId) {\n      return registry?.value.find((modal) => modal.exposed?.id.value === resolvedId) || null\n    }\n\n    if (!instance) {\n      return null\n    }\n\n    return findBModal(instance)\n  })\n\n  const modal = toRef(() => modalComponent.value?.proxy)\n\n  return {\n    show() {\n      modalComponent.value?.exposed?.show()\n    },\n    hide(trigger = '') {\n      modalComponent.value?.exposed?.hide(trigger)\n    },\n    modal,\n  }\n}\n","import {inject} from 'vue'\nimport {useSharedModalStack} from './useModalManager'\nimport {modalControllerPluginKey} from '../utils'\n\nexport default () => {\n  const {lastStack, stack} = useSharedModalStack()\n\n  const modalControllerPlugin = inject(modalControllerPluginKey)\n\n  const hide = (trigger = '') => {\n    if (lastStack?.value) {\n      lastStack?.value.exposed?.hide(trigger)\n    }\n  }\n\n  const hideAll = (trigger = '') => {\n    stack?.value.forEach((modal) => {\n      modal.exposed?.hide(trigger)\n    })\n  }\n\n  return {\n    ...modalControllerPlugin,\n    hide,\n    hideAll,\n    // Todo: Supports listening events globally in the future\n  }\n}\n","import {computed, type MaybeRefOrGetter, toValue} from 'vue'\nimport type {Numberish} from '../types'\nimport {RX_NUMBER} from '../constants/regex'\n\nexport default (\n  el: MaybeRefOrGetter<Numberish | undefined>,\n  /**\n   * The unit to use when converting a numeric value to a string\n   *\n   * @default 'px'\n   */\n  unit: MaybeRefOrGetter<string> = 'px'\n) =>\n  computed(() => {\n    const value = toValue(el)\n    const resolvedUnit = toValue(unit)\n    // If num is non-numeric, return val as-is (sm, md, lg, undefined or any other custom value), otherwise return num as a px value\n    return RX_NUMBER.test(String(value))\n      ? `${Number(value)}${resolvedUnit}`\n      : (value as string | undefined)\n  })\n","import {computed, type MaybeRefOrGetter, toValue} from 'vue'\nimport type {RadiusElement, RadiusElementExtendables} from '../types'\n\nexport default (obj: MaybeRefOrGetter<RadiusElementExtendables>) => {\n  const resolveRadiusElement = (\n    value: boolean | RadiusElement,\n    str: 'top' | 'bottom' | 'start' | 'end' | null\n  ): string => {\n    const strValue = str === null ? '' : `${str}-`\n\n    return value === 'circle'\n      ? `${strValue}rounded-circle`\n      : value === 'pill'\n        ? `${strValue}rounded-pill`\n        : typeof value === 'number' ||\n            value === '0' ||\n            value === '1' ||\n            value === '2' ||\n            value === '3' ||\n            value === '4' ||\n            value === '5'\n          ? `${strValue}rounded-${value}`\n          : value === 'none'\n            ? `${strValue}rounded-0`\n            : value === 'sm'\n              ? `${strValue}rounded-1`\n              : value === 'lg'\n                ? `${strValue}rounded-5`\n                : `${strValue}rounded` // true is last\n  }\n\n  return computed(() => {\n    const props = toValue(obj)\n\n    return {\n      [`${resolveRadiusElement(props.rounded as boolean | RadiusElement, null)}`]: !!props.rounded,\n      [`${resolveRadiusElement(props.roundedTop as boolean | RadiusElement, 'top')}`]:\n        !!props.roundedTop,\n      [`${resolveRadiusElement(props.roundedBottom as boolean | RadiusElement, 'bottom')}`]:\n        !!props.roundedBottom,\n      [`${resolveRadiusElement(props.roundedStart as boolean | RadiusElement, 'start')}`]:\n        !!props.roundedStart,\n      [`${resolveRadiusElement(props.roundedEnd as boolean | RadiusElement, 'end')}`]:\n        !!props.roundedEnd,\n    }\n  })\n}\n","import {inject, onMounted, watch} from 'vue'\nimport {rtlPluginKey} from '../utils'\n\nexport default () => {\n  const rtlPlugin = inject(rtlPluginKey)\n\n  onMounted(() => {\n    watch(\n      [() => rtlPlugin?.isRtl.value, () => rtlPlugin?.locale.value],\n      ([rtlNew, localeNew]) => {\n        const html = document.documentElement\n\n        // I can't think of a reason why one might want to destroy these if unmounted...\n        html.setAttribute('dir', rtlNew ?? false ? 'rtl' : 'ltr')\n        html.setAttribute('lang', localeNew ?? '')\n      },\n      {immediate: true}\n    )\n  })\n\n  return {...rtlPlugin}\n}\n","import {type MaybeRefOrGetter, onMounted, readonly, toRef, watch} from 'vue'\nimport {useScrollLock} from '@vueuse/core'\n\nexport default (isOpen: MaybeRefOrGetter<boolean>, bodyScroll: MaybeRefOrGetter<boolean>) => {\n  const resolvedIsOpen = readonly(toRef(isOpen))\n  const resolvedBodyScrolling = readonly(toRef(bodyScroll))\n\n  /**\n   * We use the inverse because bodyScrolling === true means we allow scrolling, while bodyScrolling === false means we disallow\n   */\n  const inverseBodyScrollingValue = toRef(() => !resolvedBodyScrolling.value)\n\n  onMounted(() => {\n    const isLocked = useScrollLock(\n      document.body,\n      resolvedIsOpen.value && inverseBodyScrollingValue.value\n    )\n\n    watch([resolvedIsOpen, inverseBodyScrollingValue], ([modelVal, bodyVal]) => {\n      isLocked.value = modelVal && bodyVal\n    })\n  })\n}\n","import {syncRef, useIntersectionObserver, useMutationObserver} from '@vueuse/core'\nimport {\n  type ComponentPublicInstance,\n  computed,\n  getCurrentInstance,\n  type MaybeRefOrGetter,\n  nextTick,\n  onMounted,\n  readonly,\n  type Ref,\n  ref,\n  toRef,\n  watch,\n} from 'vue'\nimport {getElement} from '../utils'\n\ntype ScrollspyList = {\n  id: string | null\n  el: HTMLElement | null\n  visible: boolean\n  text: string | null\n}[]\n\ninterface ScrollspyReturn {\n  current: Readonly<Ref<string | null>>\n  list: Readonly<Ref<ScrollspyList>>\n  content: Ref<HTMLElement | undefined>\n  target: Ref<HTMLElement | undefined>\n  scrollIntoView: (event: MouseEvent) => void\n  updateList: () => void\n  cleanup: () => void\n}\n\ninterface ScrollspyOptions {\n  contentQuery: string\n  targetQuery: string\n  manual: boolean\n  root: string | ComponentPublicInstance | HTMLElement | null\n  rootMargin: string\n  threshold: number | number[]\n  watchChanges: boolean\n}\n\nexport default (\n  content: MaybeRefOrGetter<string | ComponentPublicInstance | HTMLElement | null>,\n  target: MaybeRefOrGetter<string | ComponentPublicInstance | HTMLElement | null>,\n  options: Readonly<Partial<ScrollspyOptions>> = {}\n): ScrollspyReturn => {\n  const cont = toRef(content)\n  const tar = toRef(target)\n\n  const resolvedContent = ref(getElement(cont.value))\n  const resolvedTarget = ref(getElement(tar.value))\n\n  watch([cont, tar], () => {\n    updateList()\n  })\n  const {\n    contentQuery = ':scope > [id]',\n    targetQuery = '[href]',\n    manual = false,\n    root,\n    rootMargin = '0px 0px -25%',\n    threshold = [0.1, 0.5, 1],\n    watchChanges = true,\n  } = options\n  const current = ref<string | null>(null)\n  const list = ref<ScrollspyList>([])\n  const nodeList = ref<HTMLElement[]>([])\n\n  // are we called in directive?\n  const ctx = getCurrentInstance()\n  if (!ctx) {\n    nextTick(() => {\n      updateList()\n    })\n  } else {\n    onMounted(() => {\n      syncRef(cont, resolvedContent, {\n        transform: {\n          ltr: (v) => getElement(v),\n        },\n        direction: 'ltr',\n        immediate: true,\n      })\n      syncRef(tar, resolvedTarget, {\n        transform: {\n          ltr: (v) => getElement(v),\n        },\n        direction: 'ltr',\n        immediate: true,\n      })\n      updateList()\n    })\n  }\n\n  const updateList = () => {\n    nodeList.value = resolvedContent.value\n      ? (Array.from(resolvedContent.value.querySelectorAll(contentQuery)) as HTMLElement[])\n      : []\n    list.value = nodeList.value.map((el) => ({\n      id: el.id,\n      el,\n      visible: false,\n      text: el.textContent,\n    }))\n  }\n\n  let isScrollingDown = true\n  let previousScrollTop = 0\n  const scrollRoot = computed(() =>\n    resolvedContent.value && getComputedStyle(resolvedContent.value).overflowY === 'visible'\n      ? null\n      : resolvedContent.value\n  )\n\n  const iobs = useIntersectionObserver(\n    nodeList,\n    (entries) => {\n      const scrollTop = (scrollRoot.value || document?.documentElement)?.scrollTop\n      isScrollingDown = scrollTop > previousScrollTop\n      previousScrollTop = scrollTop\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          list.value.forEach((node) => {\n            if (node.el === entry.target) {\n              node.visible = true\n            }\n          })\n          return\n        }\n        list.value.forEach((node) => {\n          if (node.el === entry.target) {\n            node.visible = false\n          }\n        })\n      })\n      let newId: string | null = null\n      if (isScrollingDown) {\n        newId = [...list.value].reverse().find((node) => node.visible)?.id || null\n      } else {\n        newId = list.value.find((node) => node.visible)?.id || null\n      }\n      if (newId !== null) {\n        current.value = newId\n      }\n      if (!current.value) {\n        current.value = list.value[0]?.id || null\n      }\n    },\n    {\n      root: root ? getElement(root) : scrollRoot,\n      rootMargin,\n      threshold,\n    }\n  )\n  watch(current, (newId) => {\n    if (manual) return\n    const nodes = resolvedTarget.value?.querySelectorAll(targetQuery)\n    if (nodes === undefined) return\n    let foundParent = false\n    let activeElement: HTMLElement | null = null\n    nodes.forEach((node) => {\n      const parentDropdown = node.closest('.dropdown')\n\n      if (node.getAttribute('href')?.includes(`#${newId}`)) {\n        activeElement = node as HTMLElement\n        node.classList.add('active')\n        if (parentDropdown) {\n          parentDropdown?.querySelector('.dropdown-toggle')?.classList.add('active')\n          foundParent = true\n        }\n        let parentNav = node.closest('.nav')?.previousSibling as HTMLElement\n        while (parentNav?.classList?.contains('nav-item')) {\n          foundParent = true\n          parentNav.querySelector('.nav-link')?.classList.add('active')\n          parentNav = parentNav.closest('.nav')?.previousSibling as HTMLElement\n        }\n      } else {\n        node.classList.remove('active')\n        if (parentDropdown && !foundParent) {\n          parentDropdown?.querySelector('.dropdown-toggle')?.classList.remove('active')\n        }\n\n        if (!foundParent) {\n          let parentNav = node.closest('.nav')?.previousSibling as HTMLElement\n          while (parentNav?.classList?.contains('nav-item')) {\n            foundParent = true\n            parentNav.querySelector('.nav-link') !== activeElement &&\n              parentNav.querySelector('.nav-link')?.classList.remove('active')\n            parentNav = parentNav.closest('.nav')?.previousSibling as HTMLElement\n          }\n        }\n      }\n    })\n  })\n\n  const mobs = !watchChanges\n    ? {stop: () => {}}\n    : useMutationObserver(\n        resolvedContent,\n        () => {\n          updateList()\n        },\n        {\n          childList: true,\n        }\n      )\n  const scrollIntoView = (event: Readonly<MouseEvent>, smooth: boolean = false) => {\n    event.preventDefault()\n    const href = (event.target as HTMLElement)?.getAttribute?.('href')\n    const el: HTMLElement | null = href ? document?.querySelector(href) : null\n    // console.log('scrollIntoView', event, el, content.value.$el)\n    if (el && resolvedContent.value) {\n      resolvedContent.value.scrollTo\n        ? resolvedContent.value.scrollTo({top: el.offsetTop, behavior: smooth ? 'smooth' : 'auto'})\n        : (resolvedContent.value.scrollTop = el.offsetTop)\n    }\n  }\n  const cleanup = () => {\n    iobs.stop()\n    mobs.stop()\n  }\n  return {\n    current: readonly(current),\n    list,\n    content: resolvedContent,\n    target: resolvedTarget,\n    scrollIntoView,\n    updateList,\n    cleanup,\n  }\n}\n","import {inject} from 'vue'\nimport {toastPluginKey} from '../utils'\n\nexport default () => ({...inject(toastPluginKey)})\n","<template>\n  <Transition\n    v-bind=\"{...baseProperties, ...transProps}\"\n    :appear=\"props.appear\"\n    @after-appear=\"emit('after-appear', $event)\"\n    @after-enter=\"emit('after-enter', $event)\"\n    @after-leave=\"emit('after-leave', $event)\"\n    @appear=\"emit('appear', $event)\"\n    @before-appear=\"emit('before-appear', $event)\"\n    @before-enter=\"emit('before-enter', $event)\"\n    @before-leave=\"emit('before-leave', $event)\"\n    @enter=\"emit('enter', $event)\"\n    @appear-cancelled=\"emit('appear-cancelled', $event)\"\n    @enter-cancelled=\"emit('enter-cancelled', $event)\"\n    @leave=\"emit('leave', $event)\"\n    @leave-cancelled=\"emit('leave-cancelled', $event)\"\n  >\n    <slot />\n  </Transition>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BTransitionProps} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(defineProps<BTransitionProps>(), {\n  appear: false,\n  mode: undefined,\n  noFade: false,\n  transProps: undefined,\n})\n\nconst emit = defineEmits<{\n  'after-appear': [value: Element]\n  'after-enter': [value: Element]\n  'after-leave': [value: Element]\n  'appear': [value: Element]\n  'before-appear': [value: Element]\n  'before-enter': [value: Element]\n  'before-leave': [value: Element]\n  'enter': [value: Element]\n  'appear-cancelled': [value: Element]\n  'enter-cancelled': [value: Element]\n  'leave': [value: Element]\n  'leave-cancelled': [value: Element]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst fadeProperties = computed(() => {\n  const NO_FADE_PROPS = {\n    name: '',\n    enterActiveClass: '',\n    enterToClass: '',\n    leaveActiveClass: '',\n    leaveToClass: 'showing',\n    enterFromClass: 'showing',\n    leaveFromClass: '',\n  }\n  const FADE_PROPS = {\n    ...NO_FADE_PROPS,\n    enterActiveClass: 'fade showing',\n    leaveActiveClass: 'fade showing',\n  }\n  return props.noFade ? NO_FADE_PROPS : FADE_PROPS\n})\n\nconst baseProperties = computed(() => ({mode: props.mode, css: true, ...fadeProperties.value}))\n</script>\n\n<style lang=\"scss\">\n.fade-enter-active,\n.fade-leave-active {\n  transition: opacity 0.25s linear;\n}\n\n.fade-enter-from,\n.fade-leave-to {\n  opacity: 0;\n}\n</style>\n","<template>\n  <button\n    :type=\"type\"\n    class=\"btn-close\"\n    :disabled=\"props.disabled\"\n    :aria-label=\"ariaLabel\"\n    @click=\"emit('click', $event)\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport type {BCloseButtonProps} from '../../types'\n\nconst props = withDefaults(defineProps<BCloseButtonProps>(), {\n  ariaLabel: 'Close',\n  disabled: false,\n  type: 'button',\n})\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    v-if=\"tag === 'router-link'\"\n    v-slot=\"//@ts-ignore \n    {href: localHref, navigate, isActive, isExactActive}\"\n    v-bind=\"routerAttr\"\n    custom\n  >\n    <component\n      :is=\"routerTag\"\n      :href=\"localHref\"\n      :class=\"{\n        [defaultActiveClass]: props.active,\n        [activeClass]: isActive,\n        [exactActiveClass]: isExactActive,\n      }\"\n      v-bind=\"$attrs\"\n      @click=\";[navigate($event), clicked($event)]\"\n    >\n      <slot />\n    </component>\n  </component>\n  <component :is=\"tag\" v-else :class=\"computedLinkClasses\" v-bind=\"routerAttr\" @click=\"clicked\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BLinkProps} from '../../types'\nimport {collapseInjectionKey, navbarInjectionKey} from '../../utils'\nimport {computed, getCurrentInstance, inject, useAttrs} from 'vue'\n\n// TODO this component will likely have an issue with inheritAttrs\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(defineProps<BLinkProps>(), {\n  active: undefined,\n  activeClass: 'router-link-active',\n  append: false,\n  disabled: false,\n  exactActiveClass: 'router-link-exact-active',\n  href: undefined,\n  icon: false,\n  opacity: undefined,\n  opacityHover: undefined,\n  // noPrefetch: {type: Boolean, default: false},\n  // prefetch: {type: Boolean, default: null},\n  rel: undefined,\n  replace: false,\n  routerComponentName: 'router-link',\n  routerTag: 'a',\n  target: undefined,\n  to: undefined,\n  underlineOffset: undefined,\n  underlineOffsetHover: undefined,\n  underlineOpacity: undefined,\n  underlineOpacityHover: undefined,\n  underlineVariant: null,\n  variant: null,\n})\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst attrs = useAttrs()\n\n// TODO append not yet implemented\n\n// TODO replace not yet implemented\nconst collapseData = inject(collapseInjectionKey, null)\nconst navbarData = inject(navbarInjectionKey, null)\n\nconst instance = getCurrentInstance()\n\nconst defaultActiveClass = 'active' as const\n\nconst tag = computed(() => {\n  const routerName = props.routerComponentName\n    .split('-')\n    .map((e) => e.charAt(0).toUpperCase() + e.slice(1))\n    .join('')\n  const hasRouter = instance?.appContext.app.component(routerName) !== undefined\n  if (!hasRouter || props.disabled || !props.to) {\n    return 'a'\n  }\n  return props.routerComponentName\n})\n\nconst computedHref = computed(() => {\n  const toFallback = '#'\n  if (props.href) return props.href\n\n  if (typeof props.to === 'string') return props.to || toFallback\n\n  const {to} = props\n\n  if (to !== undefined && 'path' in to) {\n    const path = to.path || ''\n    const query = to.query\n      ? `?${Object.keys(to.query)\n          .map((e) => `${e}=${to.query?.[e]}`)\n          .join('=')}`\n      : ''\n    const hash = !to.hash || to.hash.charAt(0) === '#' ? to.hash || '' : `#${to.hash}`\n    return `${path}${query}${hash}` || toFallback\n  }\n  // There is no resolver for `RouteLocationNamedRaw`. Which, I'm not sure there can be one in this context.\n\n  return toFallback\n})\n\nconst computedClasses = computed(() => ({\n  [`link-${props.variant}`]: props.variant !== null,\n  [`link-opacity-${props.opacity}`]: props.opacity !== undefined,\n  [`link-opacity-${props.opacityHover}-hover`]: props.opacityHover !== undefined,\n  [`link-underline-${props.underlineVariant}`]: props.underlineVariant !== null,\n  [`link-offset-${props.underlineOffset}`]: props.underlineOffset !== undefined,\n  [`link-offset-${props.underlineOffsetHover}-hover`]: props.underlineOffsetHover !== undefined,\n  [`link-underline-opacity-${props.underlineOpacity}`]: props.underlineOpacity !== undefined,\n  [`link-underline-opacity-${props.underlineOpacityHover}-hover`]:\n    props.underlineOpacityHover !== undefined,\n  'icon-link': props.icon === true,\n}))\n\nconst routerAttr = computed(() => ({\n  'class': computedClasses.value,\n  'to': props.to,\n  'href': computedHref.value,\n  'target': props.target,\n  'rel': props.target === '_blank' ? props.rel ?? 'noopener' : undefined,\n  'tabindex': props.disabled ? '-1' : typeof attrs.tabindex === 'undefined' ? null : attrs.tabindex,\n  'aria-disabled': props.disabled ? true : null,\n}))\n\nconst computedLinkClasses = computed(() => ({\n  [defaultActiveClass]: props.active,\n  disabled: props.disabled,\n}))\n\nconst clicked = (e: Readonly<MouseEvent>): void => {\n  if (props.disabled) {\n    e.preventDefault()\n    e.stopImmediatePropagation()\n    return\n  }\n\n  if (\n    (collapseData?.isNav?.value === true && navbarData === null) ||\n    (navbarData !== null && navbarData.autoClose?.value === true)\n  ) {\n    collapseData?.hide?.()\n  }\n\n  emit('click', e)\n}\n</script>\n","<template>\n  <div\n    class=\"progress-bar\"\n    :class=\"computedClasses\"\n    role=\"progressbar\"\n    :aria-valuenow=\"value\"\n    aria-valuemin=\"0\"\n    :aria-valuemax=\"max\"\n    :style=\"{width: computedWidth}\"\n  >\n    <slot>\n      {{ computedLabel }}\n    </slot>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BProgressBarProps} from '../../types'\nimport {useColorVariantClasses} from '../../composables'\nimport {computed, inject} from 'vue'\nimport {progressInjectionKey} from '../../utils'\nimport {useToNumber} from '@vueuse/core'\n\nconst props = withDefaults(defineProps<BProgressBarProps>(), {\n  animated: false,\n  bgVariant: null,\n  label: undefined,\n  labelHtml: undefined,\n  max: undefined,\n  precision: 0,\n  showProgress: false,\n  showValue: false,\n  striped: false,\n  textVariant: null,\n  value: 0,\n  variant: null,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst parentData = inject(progressInjectionKey, null)\n\nconst resolvedBackgroundClasses = useColorVariantClasses(props)\n\nconst computedClasses = computed(() => [\n  resolvedBackgroundClasses.value,\n  {\n    'progress-bar-animated': props.animated || parentData?.animated.value,\n    'progress-bar-striped':\n      props.striped || parentData?.striped.value || props.animated || parentData?.animated.value,\n  },\n])\n\nconst numberPrecision = useToNumber(() => props.precision)\nconst numberValue = useToNumber(() => props.value)\nconst numberMax = useToNumber(() => props.max ?? NaN)\nconst parentMaxNumber = useToNumber(() => parentData?.max.value ?? NaN)\n\nconst computedLabel = computed(() =>\n  props.labelHtml !== undefined\n    ? props.labelHtml\n    : props.showValue || parentData?.showValue.value\n      ? numberValue.value.toFixed(numberPrecision.value)\n      : props.showProgress || parentData?.showProgress.value\n        ? ((numberValue.value * 100) / (numberMax.value || 100)).toFixed(numberPrecision.value)\n        : props.label !== undefined\n          ? props.label\n          : ''\n)\n\nconst computedWidth = computed(() =>\n  parentMaxNumber.value\n    ? `${(numberValue.value * 100) / parentMaxNumber.value}%`\n    : numberMax.value\n      ? `${(numberValue.value * 100) / numberMax.value}%`\n      : typeof props.value === 'string'\n        ? props.value\n        : `${props.value}%`\n)\n</script>\n","<template>\n  <div class=\"progress\" :style=\"{height}\">\n    <slot>\n      <BProgressBar\n        :animated=\"animated\"\n        :max=\"max\"\n        :precision=\"precision\"\n        :show-progress=\"showProgress\"\n        :show-value=\"showValue\"\n        :striped=\"striped\"\n        :value=\"value\"\n        :variant=\"variant\"\n        :text-variant=\"textVariant\"\n        :bg-variant=\"bgVariant\"\n      />\n    </slot>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport BProgressBar from './BProgressBar.vue'\nimport type {BProgressProps} from '../../types'\nimport {provide, toRef} from 'vue'\nimport {progressInjectionKey} from '../../utils'\n\nconst props = withDefaults(defineProps<BProgressProps>(), {\n  height: undefined,\n  // BProgressBar props\n  animated: undefined,\n  bgVariant: undefined,\n  max: 100,\n  precision: undefined,\n  showProgress: undefined,\n  showValue: undefined,\n  striped: undefined,\n  textVariant: undefined,\n  value: undefined,\n  variant: undefined,\n  // End BProgressBar props\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nprovide(progressInjectionKey, {\n  animated: toRef(() => props.animated),\n  max: toRef(() => props.max),\n  showProgress: toRef(() => props.showProgress),\n  showValue: toRef(() => props.showValue),\n  striped: toRef(() => props.striped),\n})\n</script>\n","<template>\n  <BTransition\n    :no-fade=\"props.noFade\"\n    v-bind=\"transProps\"\n    @before-enter=\"onBeforeEnter\"\n    @after-enter=\"onAfterEnter\"\n    @after-leave=\"onAfterLeave\"\n  >\n    <div\n      v-if=\"isToastVisible\"\n      :id=\"id\"\n      ref=\"element\"\n      class=\"toast\"\n      :class=\"[toastClass, computedClasses]\"\n      tabindex=\"0\"\n      :role=\"!isToastVisible ? undefined : props.isStatus ? 'status' : 'alert'\"\n      :aria-live=\"!isToastVisible ? undefined : props.isStatus ? 'polite' : 'assertive'\"\n      :aria-atomic=\"!isToastVisible ? undefined : true\"\n    >\n      <component :is=\"headerTag\" v-if=\"$slots.title || title\" class=\"toast-header\">\n        <slot name=\"title\" :hide=\"hideFn\">\n          <strong class=\"me-auto\">\n            {{ title }}\n          </strong>\n        </slot>\n        <BCloseButton v-if=\"!props.noCloseButton\" @click=\"hideFn('close')\" />\n      </component>\n      <template v-if=\"$slots.default || body\">\n        <component\n          :is=\"computedTag\"\n          class=\"toast-body\"\n          style=\"display: block\"\n          :class=\"bodyClass\"\n          v-bind=\"computedLinkProps\"\n          @click=\"computedLink ? hideFn() : () => {}\"\n        >\n          <slot :hide=\"hideFn\">\n            {{ body }}\n          </slot>\n        </component>\n      </template>\n      <BProgress\n        v-if=\"typeof modelValue === 'number' && progressProps !== undefined\"\n        :animated=\"progressProps.animated\"\n        :precision=\"progressProps.precision\"\n        :show-progress=\"progressProps.showProgress\"\n        :show-value=\"progressProps.showValue\"\n        :striped=\"progressProps.striped\"\n        :variant=\"progressProps.variant\"\n        :max=\"modelValue\"\n        :value=\"remainingMs\"\n        height=\"4px\"\n      />\n    </div>\n  </BTransition>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, onBeforeUnmount, ref, toRef, watch, watchEffect} from 'vue'\nimport {useBLinkHelper, useColorVariantClasses, useCountdown} from '../../composables'\nimport type {BToastProps} from '../../types'\nimport BTransition from '../BTransition/BTransition.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BLink from '../BLink/BLink.vue'\nimport {useElementHover, useToNumber} from '@vueuse/core'\nimport BProgress from '../BProgress/BProgress.vue'\nimport {BvTriggerableEvent} from '../../utils'\n\nconst props = withDefaults(defineProps<BToastProps>(), {\n  bgVariant: null,\n  body: undefined,\n  bodyClass: undefined,\n  headerClass: undefined,\n  headerTag: 'div',\n  id: undefined,\n  interval: 1000,\n  isStatus: false,\n  noCloseButton: false,\n  noFade: false,\n  noHoverPause: false,\n  progressProps: undefined,\n  showOnPause: true,\n  solid: false,\n  textVariant: null,\n  title: undefined,\n  toastClass: undefined,\n  transProps: undefined,\n  // Link props\n  // All others use defaults\n  active: undefined,\n  activeClass: undefined,\n  append: undefined,\n  disabled: undefined,\n  exactActiveClass: undefined,\n  href: undefined,\n  icon: undefined,\n  opacity: undefined,\n  opacityHover: undefined,\n  rel: undefined,\n  replace: undefined,\n  routerComponentName: undefined,\n  target: undefined,\n  to: undefined,\n  underlineOffset: undefined,\n  underlineOffsetHover: undefined,\n  underlineOpacity: undefined,\n  underlineOpacityHover: undefined,\n  underlineVariant: undefined,\n  variant: undefined,\n  // End link props\n})\n\nconst emit = defineEmits<{\n  'close': [value: BvTriggerableEvent]\n  'close-countdown': [value: number]\n  'hide': [value: BvTriggerableEvent]\n  'hidden': [value: BvTriggerableEvent]\n  'show': [value: BvTriggerableEvent]\n  'shown': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'hide-prevented': []\n}>()\n\nconst element = ref<HTMLElement | null>(null)\n\nconst isHovering = useElementHover(element)\n// Note: passive: true will sync an internal ref... This is required for useToast to exit,\n// Since the modelValue that's passed from that composable is not reactive, this internal ref _is_ and thus it will trigger closing the toast\nconst modelValue = defineModel<boolean | number>({default: false})\n\nconst {computedLink, computedLinkProps} = useBLinkHelper(props)\n\nconst intervalNumber = useToNumber(() => props.interval)\n// TODO solid is never used\nconst resolvedBackgroundClasses = useColorVariantClasses(props)\nconst countdownLength = toRef(() => (typeof modelValue.value === 'boolean' ? 0 : modelValue.value))\n\nconst {\n  isActive,\n  pause,\n  restart,\n  resume,\n  stop,\n  isPaused,\n  value: remainingMs,\n} = useCountdown(countdownLength, intervalNumber, {\n  immediate: typeof modelValue.value === 'number',\n})\n\nwatchEffect(() => {\n  emit('close-countdown', remainingMs.value)\n})\n\nconst computedTag = toRef(() => (computedLink.value ? BLink : 'div'))\n\nconst isToastVisible = toRef(() =>\n  typeof modelValue.value === 'boolean'\n    ? modelValue.value\n    : isActive.value || (props.showOnPause && isPaused.value)\n)\n\nconst computedClasses = computed(() => [\n  resolvedBackgroundClasses.value,\n  {\n    show: isToastVisible.value,\n  },\n])\n\nconst onMouseEnter = () => {\n  if (props.noHoverPause) return\n  pause()\n}\n\nwatch(isHovering, (newValue) => {\n  if (newValue) {\n    onMouseEnter()\n    return\n  }\n  resume()\n})\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Readonly<Partial<BvTriggerableEvent>> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: props.id,\n  })\n\nconst showFn = () => {\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    if (modelValue.value) modelValue.value = false\n    emit('show-prevented')\n    return\n  }\n  if (!modelValue.value) modelValue.value = true\n}\nconst hideFn = (trigger = '') => {\n  const event = buildTriggerableEvent('hide', {cancelable: trigger !== '', trigger})\n\n  emit('hide', event)\n\n  if (trigger === 'close') {\n    emit('close', event)\n  }\n\n  if (event.defaultPrevented) {\n    emit('hide-prevented')\n    if (!modelValue.value) modelValue.value = true\n    return\n  }\n\n  if (typeof modelValue.value === 'boolean') {\n    modelValue.value = false\n  } else {\n    modelValue.value = 0\n    stop()\n  }\n}\n\nconst onBeforeEnter = () => {\n  showFn()\n}\nconst onAfterEnter = () => {\n  emit('shown', buildTriggerableEvent('shown'))\n}\nconst onAfterLeave = () => {\n  emit('hidden', buildTriggerableEvent('hidden'))\n}\n\n// isActive in the composable will cause the toast to hide when the countdown is done\nwatch(isActive, (newValue) => {\n  if (newValue === false && isPaused.value === false && !!modelValue.value) {\n    hideFn()\n  }\n})\n\nonBeforeUnmount(stop)\n\ndefineExpose({\n  pause,\n  restart,\n  resume,\n  stop,\n})\n</script>\n","import {\n  type Component,\n  computed,\n  type ComputedRef,\n  type MaybeRefOrGetter,\n  type Plugin,\n  ref,\n  shallowRef,\n  toValue,\n} from 'vue'\nimport BToast from '../components/BToast/BToast.vue'\nimport type {OrchestratedToast} from '../types'\nimport {toastPluginKey} from '../utils'\n\nconst posDefault = 'top-right'\n\nexport default {\n  install(app) {\n    const toasts = shallowRef<\n      ComputedRef<{\n        component: unknown\n        props: Omit<OrchestratedToast, 'value'> & {\n          _self: symbol\n          _modelValue: OrchestratedToast['value'] // Convert it to be the same name as useModalController.\n          // The difference between the two is that unlike that one, this value can be defined (there's cannot be).\n        }\n      }>[]\n    >([])\n\n    const _isAppend = ref(false)\n\n    const _setIsAppend = (value: boolean) => {\n      _isAppend.value = value\n    }\n\n    /**\n     * @returns {symbol} A symbol that corresponds to its unique id. You can pass this id to the hide function to force a Toast to hide\n     */\n    const show = (obj: {\n      component?: MaybeRefOrGetter<Readonly<Component>>\n      props?: MaybeRefOrGetter<Readonly<OrchestratedToast>>\n    }): symbol => {\n      const _self = Symbol()\n\n      const toastToAdd = computed(() => {\n        const unwrappedProps = toValue(obj.props)\n        return {\n          component: toValue(obj.component) ?? BToast,\n          props: {\n            ...unwrappedProps,\n            pos: unwrappedProps?.pos || posDefault,\n            _modelValue: unwrappedProps?.value || 5000,\n            _self,\n          },\n        }\n      })\n\n      if (\n        toastToAdd.value.props.appendToast !== undefined\n          ? toastToAdd.value.props.appendToast\n          : _isAppend.value\n      ) {\n        toasts.value = [...toasts.value, toastToAdd]\n      } else {\n        toasts.value = [toastToAdd, ...toasts.value]\n      }\n\n      return _self\n    }\n\n    /**\n     * You can get the symbol param from the return value from the show method\n     */\n    const remove = (self: symbol) => {\n      toasts.value = toasts.value.filter((el) => el.value.props._self !== self)\n    }\n\n    app.provide(toastPluginKey, {\n      _setIsAppend,\n      toasts,\n      show,\n      remove,\n    })\n  },\n} satisfies Plugin\n","import {type Plugin, ref} from 'vue'\nimport type {BreadcrumbItemRaw} from '../types'\nimport {breadcrumbPluginKey} from '../utils'\n\nexport default {\n  install(app) {\n    const items = ref<BreadcrumbItemRaw[]>([])\n    const reset = () => {\n      items.value.splice(0, items.value.length)\n    }\n\n    app.provide(breadcrumbPluginKey, {items, reset})\n  },\n} satisfies Plugin\n","import {type Plugin} from 'vue'\nimport type {BootstrapVueOptions} from '../types'\nimport {idPluginKey} from '../utils'\n\nexport default {\n  install(app, options: BootstrapVueOptions['plugins']) {\n    if (options?.id instanceof Object && typeof options.id.getId === 'function') {\n      app.provide(idPluginKey, options.id.getId)\n    }\n  },\n} satisfies Plugin\n","<template>\n  <component\n    :is=\"tag\"\n    :class=\"computedClasses\"\n    :role=\"label || hasLabelSlot ? role : null\"\n    :aria-hidden=\"label || hasLabelSlot ? null : true\"\n  >\n    <span v-if=\"label || hasLabelSlot\" class=\"visually-hidden\">\n      <slot name=\"label\">{{ label }}</slot>\n    </span>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport type {BSpinnerProps} from '../types'\nimport {isEmptySlot} from '../utils'\n\nconst props = withDefaults(defineProps<BSpinnerProps>(), {\n  label: undefined,\n  role: 'status',\n  small: false,\n  tag: 'span',\n  type: 'border',\n  variant: null,\n})\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  label?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => [\n  `spinner-${props.type}`,\n  {\n    [`spinner-${props.type}-sm`]: props.small,\n    [`text-${props.variant}`]: props.variant !== null,\n  },\n])\n\nconst hasLabelSlot = toRef(() => !isEmptySlot(slots.label))\n</script>\n","<template>\n  <component\n    :is=\"computedTag\"\n    class=\"btn\"\n    v-bind=\"linkProps\"\n    :class=\"computedClasses\"\n    :aria-disabled=\"nonStandardTag ? props.disabled : null\"\n    :aria-pressed=\"isToggle ? props.pressed : null\"\n    :autocomplete=\"isToggle ? 'off' : null\"\n    :disabled=\"isButton ? props.disabled : null\"\n    :href=\"href\"\n    :rel=\"computedLink ? rel : null\"\n    :role=\"nonStandardTag || computedLink ? 'button' : null\"\n    :target=\"computedLink ? target : null\"\n    :type=\"isButton ? type : null\"\n    :to=\"!isButton ? to : null\"\n    :append=\"computedLink ? append : null\"\n    @click=\"clicked\"\n  >\n    <template v-if=\"props.loading\">\n      <slot name=\"loading\">\n        <template v-if=\"!props.loadingFill\">\n          {{ loadingText }}\n        </template>\n        <slot name=\"loading-spinner\">\n          <BSpinner :small=\"size !== 'lg'\" :label=\"props.loadingFill ? loadingText : undefined\" />\n        </slot>\n      </slot>\n    </template>\n    <template v-else>\n      <slot />\n    </template>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport BSpinner from '../BSpinner.vue'\nimport {useBLinkHelper} from '../../composables'\nimport type {BButtonProps} from '../../types'\nimport BLink from '../BLink/BLink.vue'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'loading'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'loading-spinner'?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(defineProps<BButtonProps>(), {\n  loading: false,\n  loadingFill: false,\n  loadingText: 'Loading...',\n  pill: false,\n  size: 'md',\n  squared: false,\n  tag: 'button',\n  type: 'button',\n  // Link props\n  active: false, // Why is this active: false?\n  variant: 'secondary',\n  // All others use defaults\n  activeClass: undefined,\n  append: undefined,\n  disabled: undefined,\n  exactActiveClass: undefined,\n  href: undefined,\n  icon: undefined,\n  opacity: undefined,\n  opacityHover: undefined,\n  rel: undefined,\n  replace: undefined,\n  routerComponentName: undefined,\n  routerTag: undefined,\n  target: undefined,\n  to: undefined,\n  underlineOffset: undefined,\n  underlineOffsetHover: undefined,\n  underlineOpacity: undefined,\n  underlineOpacityHover: undefined,\n  underlineVariant: undefined,\n  // End link props\n})\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst pressedValue = defineModel<boolean | undefined>('pressed', {default: undefined})\n\nconst {computedLink, computedLinkProps} = useBLinkHelper(props, [\n  'active-class',\n  'exact-active-class',\n  'replace',\n  'routerComponentName',\n  'routerTag',\n])\n\nconst isToggle = toRef(() => typeof props.pressed === 'boolean')\nconst isButton = toRef(\n  () => props.tag === 'button' && props.href === undefined && props.to === undefined\n)\nconst isBLink = toRef(() => props.to !== undefined)\nconst nonStandardTag = toRef(() => (props.href !== undefined ? false : !isButton.value))\n\nconst linkProps = computed(() => (isBLink.value ? computedLinkProps.value : []))\n\nconst computedClasses = computed(() => [\n  [`btn-${props.size}`],\n  {\n    [`btn-${props.variant}`]: props.variant !== null,\n    'active': props.active || props.pressed,\n    'rounded-pill': props.pill,\n    'rounded-0': props.squared,\n    'disabled': props.disabled,\n  },\n])\n\nconst computedTag = toRef(() => (isBLink.value ? BLink : props.href ? 'a' : props.tag))\n\nconst clicked = (e: Readonly<MouseEvent>): void => {\n  if (props.disabled) {\n    e.preventDefault()\n    e.stopPropagation()\n    return\n  }\n  emit('click', e)\n  if (isToggle.value) {\n    pressedValue.value = !props.pressed\n  }\n}\n</script>\n","<template>\n  <component :is=\"wrapTag\" class=\"b-overlay-wrap position-relative\" :aria-busy=\"computedAriaBusy\">\n    <slot />\n    <BTransition\n      :no-fade=\"noFade\"\n      :trans-props=\"{enterToClass: 'show'}\"\n      name=\"fade\"\n      @after-enter=\"emit('shown')\"\n      @after-leave=\"emit('hidden')\"\n    >\n      <component\n        :is=\"overlayTag\"\n        v-if=\"props.show\"\n        class=\"b-overlay\"\n        :class=\"overlayClasses\"\n        :style=\"overlayStyles\"\n        @click=\"emit('click', $event)\"\n      >\n        <div class=\"position-absolute\" :class=\"blurClasses\" :style=\"blurStyles\" />\n\n        <div class=\"position-absolute\" :style=\"spinWrapperStyles\">\n          <slot name=\"overlay\" v-bind=\"spinnerAttrs\">\n            <BSpinner v-if=\"!props.noSpinner\" v-bind=\"spinnerAttrs\" />\n          </slot>\n        </div>\n      </component>\n    </BTransition>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport type {BOverlayProps} from '../../types'\nimport {useRadiusElementClasses} from '../../composables'\nimport BTransition from '../BTransition/BTransition.vue'\nimport BSpinner from '../BSpinner.vue'\n\nconst props = withDefaults(defineProps<BOverlayProps>(), {\n  blur: '2px',\n  bgColor: undefined,\n  fixed: false,\n  noCenter: false,\n  noFade: false,\n  noSpinner: false,\n  noWrap: false,\n  opacity: 0.85,\n  overlayTag: 'div',\n  show: false,\n  spinnerSmall: false,\n  spinnerType: 'border',\n  spinnerVariant: undefined,\n  variant: 'light',\n  wrapTag: 'div',\n  zIndex: 10,\n  // RadiusElementExtendables props\n  rounded: false,\n  roundedBottom: undefined,\n  roundedEnd: undefined,\n  roundedStart: undefined,\n  roundedTop: undefined,\n  // End RadiusElementExtendables props\n})\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n  hidden: []\n  shown: []\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  overlay?: (props: typeof spinnerAttrs.value) => any\n}>()\n\nconst positionStyles = {top: 0, left: 0, bottom: 0, right: 0} as const\n\nconst radiusElementClasses = useRadiusElementClasses(() => ({\n  rounded: props.rounded,\n  roundedTop: props.roundedTop,\n  roundedBottom: props.roundedBottom,\n  roundedStart: props.roundedStart,\n  roundedEnd: props.roundedEnd,\n}))\n\nconst computedVariant = toRef(() =>\n  props.variant !== null && !props.bgColor ? `bg-${props.variant}` : ''\n)\n\nconst computedAriaBusy = toRef(() => (props.show ? true : null))\n\nconst spinnerAttrs = computed(() => ({\n  type: props.spinnerType,\n  variant: props.spinnerVariant,\n  small: props.spinnerSmall,\n}))\n\nconst overlayStyles = computed(() => ({\n  ...positionStyles,\n  zIndex: props.zIndex || 10,\n}))\n\nconst overlayClasses = computed(() => ({\n  'position-absolute': !props.noWrap || !props.fixed,\n  'position-fixed': props.noWrap && props.fixed,\n}))\n\nconst blurClasses = computed(() => [computedVariant.value, radiusElementClasses.value])\n\nconst blurStyles = computed(() => ({\n  ...positionStyles,\n  opacity: props.opacity,\n  backgroundColor: props.bgColor || undefined,\n  backdropFilter: props.blur ? `blur(${props.blur})` : undefined,\n}))\n\nconst spinWrapperStyles = computed(() =>\n  props.noCenter\n    ? positionStyles\n    : {\n        top: '50%',\n        left: '50%',\n        transform: 'translateX(-50%) translateY(-50%)',\n      }\n)\n</script>\n","<template>\n  <Teleport :to=\"teleportTo\" :disabled=\"props.teleportDisabled\">\n    <BTransition\n      :no-fade=\"true\"\n      v-bind=\"transProps\"\n      :trans-props=\"{enterToClass: 'show', ...transProps?.transProps}\"\n      @before-enter=\"onBeforeEnter\"\n      @after-enter=\"onAfterEnter\"\n      @leave=\"onLeave\"\n      @after-leave=\"onAfterLeave\"\n    >\n      <div\n        v-show=\"modelValue\"\n        :id=\"computedId\"\n        ref=\"element\"\n        class=\"modal\"\n        :class=\"modalClasses\"\n        role=\"dialog\"\n        :aria-labelledby=\"!props.hideHeader ? `${computedId}-label` : undefined\"\n        :aria-describedby=\"`${computedId}-body`\"\n        tabindex=\"-1\"\n        v-bind=\"$attrs\"\n        :style=\"computedZIndex\"\n      >\n        <div class=\"modal-dialog\" :class=\"modalDialogClasses\">\n          <div v-if=\"lazyShowing\" class=\"modal-content\" :class=\"contentClass\">\n            <div v-if=\"!props.hideHeader\" class=\"modal-header\" :class=\"headerClasses\">\n              <slot name=\"header\" v-bind=\"sharedSlots\">\n                <component\n                  :is=\"titleTag\"\n                  :id=\"`${computedId}-label`\"\n                  class=\"modal-title\"\n                  :class=\"titleClasses\"\n                >\n                  <slot name=\"title\" v-bind=\"sharedSlots\">\n                    {{ title }}\n                  </slot>\n                </component>\n                <template v-if=\"!props.hideHeaderClose\">\n                  <BButton\n                    v-if=\"hasHeaderCloseSlot\"\n                    v-bind=\"headerCloseAttrs\"\n                    @click=\"hideFn('close')\"\n                  >\n                    <slot name=\"header-close\" />\n                  </BButton>\n                  <BCloseButton\n                    v-else\n                    :aria-label=\"headerCloseLabel\"\n                    v-bind=\"headerCloseAttrs\"\n                    @click=\"hideFn('close')\"\n                  />\n                </template>\n              </slot>\n            </div>\n            <div\n              :id=\"`${computedId}-body`\"\n              class=\"modal-body\"\n              :class=\"bodyClasses\"\n              v-bind=\"bodyAttrs\"\n            >\n              <slot v-bind=\"sharedSlots\">\n                {{ body }}\n              </slot>\n            </div>\n            <div v-if=\"!props.hideFooter\" class=\"modal-footer\" :class=\"footerClasses\">\n              <slot name=\"footer\" v-bind=\"sharedSlots\">\n                <slot name=\"cancel\" v-bind=\"sharedSlots\">\n                  <BButton\n                    v-if=\"!props.okOnly\"\n                    ref=\"cancelButton\"\n                    :disabled=\"disableCancel\"\n                    :size=\"buttonSize\"\n                    :variant=\"cancelVariant\"\n                    @click=\"hideFn('cancel')\"\n                  >\n                    {{ cancelTitle }}\n                  </BButton>\n                </slot>\n                <slot name=\"ok\" v-bind=\"sharedSlots\">\n                  <BButton\n                    ref=\"okButton\"\n                    :disabled=\"disableOk\"\n                    :size=\"buttonSize\"\n                    :variant=\"okVariant\"\n                    @click=\"hideFn('ok')\"\n                  >\n                    {{ okTitle }}\n                  </BButton>\n                </slot>\n              </slot>\n            </div>\n          </div>\n        </div>\n        <slot name=\"backdrop\">\n          <BOverlay\n            :variant=\"computedBackdropVariant\"\n            :show=\"modelValue\"\n            no-spinner\n            fixed\n            no-wrap\n            :blur=\"null\"\n            @click=\"hideFn('backdrop')\"\n          />\n        </slot>\n      </div>\n    </BTransition>\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport {onKeyStroke, useEventListener, useFocus} from '@vueuse/core'\nimport {computed, type CSSProperties, ref, toRef, watch} from 'vue'\nimport {useColorVariantClasses, useId, useModalManager, useSafeScrollLock} from '../../composables'\nimport type {BModalProps} from '../../types'\nimport {BvTriggerableEvent, isEmptySlot} from '../../utils'\nimport BButton from '../BButton/BButton.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BOverlay from '../BOverlay/BOverlay.vue'\nimport BTransition from '../BTransition/BTransition.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\n// aria\n// autofocus\n// close on escape when autofocus\n\n// Note, attempt to return focus to item that openned the modal after close\n// Implement auto focus props like autoFocusButton\n\nconst props = withDefaults(defineProps<BModalProps>(), {\n  autoFocus: true,\n  autoFocusButton: undefined,\n  backdropVariant: undefined,\n  body: undefined,\n  bodyBgVariant: null,\n  bodyAttrs: undefined,\n  bodyClass: null,\n  bodyScrolling: false,\n  bodyTextVariant: null,\n  bodyVariant: null,\n  busy: false,\n  buttonSize: 'md',\n  cancelDisabled: false,\n  cancelTitle: 'Cancel',\n  cancelVariant: 'secondary',\n  centered: false,\n  contentClass: undefined,\n  dialogClass: undefined,\n  footerBgVariant: null,\n  footerBorderVariant: null,\n  footerClass: undefined,\n  footerTextVariant: null,\n  footerVariant: null,\n  fullscreen: false,\n  headerBgVariant: null,\n  headerBorderVariant: null,\n  headerClass: undefined,\n  headerCloseClass: undefined,\n  headerCloseLabel: 'Close',\n  headerCloseVariant: 'secondary',\n  headerTextVariant: null,\n  headerVariant: null,\n  hideBackdrop: false,\n  hideFooter: false,\n  hideHeader: false,\n  hideHeaderClose: false,\n  id: undefined,\n  lazy: false,\n  modalClass: undefined,\n  noCloseOnBackdrop: false,\n  noCloseOnEsc: false,\n  noFade: false,\n  okDisabled: false,\n  okOnly: false,\n  okTitle: 'Ok',\n  okVariant: 'primary',\n  scrollable: false,\n  size: 'md',\n  teleportDisabled: false,\n  teleportTo: 'body',\n  title: undefined,\n  titleClass: undefined,\n  titleSrOnly: false,\n  titleTag: 'h5',\n  transProps: undefined,\n})\n\nconst emit = defineEmits<{\n  'cancel': [value: BvTriggerableEvent]\n  'close': [value: BvTriggerableEvent]\n  'hidden': [value: BvTriggerableEvent]\n  'hide': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'ok': [value: BvTriggerableEvent]\n  'show': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'shown': [value: BvTriggerableEvent]\n}>()\n\ntype SharedSlotsData = {\n  cancel: () => void\n  close: () => void\n  hide: (trigger?: string) => void\n  ok: () => void\n  visible: boolean\n}\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'backdrop'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'cancel'?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'footer'?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'header'?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'header-close'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'ok'?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'title'?: (props: SharedSlotsData) => any\n}>()\n\nconst computedId = useId(() => props.id, 'modal')\n// Note: passive: true will sync an internal ref... This is required for useModalManager to exit,\n// Since the modelValue that's passed from that composable is not reactive, this internal ref _is_ and thus it will trigger closing the modal\nconst modelValue = defineModel<boolean>({default: false})\n\nconst element = ref<HTMLElement | null>(null)\nconst okButton = ref<HTMLElement | null>(null)\nconst cancelButton = ref<HTMLElement | null>(null)\nconst closeButton = ref<HTMLElement | null>(null)\nconst isActive = ref(modelValue.value)\nconst lazyLoadCompleted = ref(false)\n\nonKeyStroke(\n  'Escape',\n  () => {\n    hideFn('esc')\n  },\n  {target: element}\n)\nuseSafeScrollLock(modelValue, () => props.bodyScrolling)\nconst {focused: modalFocus} = useFocus(element, {\n  initialValue: modelValue.value && props.autoFocusButton === undefined,\n})\nconst {focused: okButtonFocus} = useFocus(okButton, {\n  initialValue: modelValue.value && props.autoFocusButton === 'ok',\n})\nconst {focused: cancelButtonFocus} = useFocus(cancelButton, {\n  initialValue: modelValue.value && props.autoFocusButton === 'cancel',\n})\nconst {focused: closeButtonFocus} = useFocus(closeButton, {\n  initialValue: modelValue.value && props.autoFocusButton === 'close',\n})\n\nconst modalClasses = computed(() => [\n  props.modalClass,\n  {\n    fade: !props.noFade,\n    show: isActive.value,\n  },\n])\n\nconst lazyShowing = toRef(\n  () =>\n    props.lazy === false ||\n    (props.lazy === true && lazyLoadCompleted.value === true) ||\n    (props.lazy === true && modelValue.value === true)\n)\n\nconst computedBackdropVariant = toRef(() =>\n  props.backdropVariant !== undefined\n    ? props.backdropVariant\n    : props.hideBackdrop\n      ? 'transparent'\n      : 'dark'\n)\n\nconst hasHeaderCloseSlot = toRef(() => !isEmptySlot(slots['header-close']))\n\nconst modalDialogClasses = computed(() => [\n  props.dialogClass,\n  {\n    'modal-fullscreen': props.fullscreen === true,\n    [`modal-fullscreen-${props.fullscreen}-down`]: typeof props.fullscreen === 'string',\n    [`modal-${props.size}`]: props.size !== 'md',\n    'modal-dialog-centered': props.centered,\n    'modal-dialog-scrollable': props.scrollable,\n  },\n])\n\nconst resolvedBodyBgClasses = useColorVariantClasses(() => ({\n  bgVariant: props.bodyBgVariant,\n  textVariant: props.bodyTextVariant,\n  variant: props.bodyVariant,\n}))\n\nconst bodyClasses = computed(() => [props.bodyClass, resolvedBodyBgClasses.value])\n\nconst resolvedHeaderBgClasses = useColorVariantClasses(() => ({\n  bgVariant: props.headerBgVariant,\n  textVariant: props.headerTextVariant,\n  variant: props.headerVariant,\n}))\n\nconst headerClasses = computed(() => [\n  props.headerClass,\n  resolvedHeaderBgClasses.value,\n  {\n    [`border-${props.headerBorderVariant}`]: props.headerBorderVariant !== null,\n  },\n])\n\nconst headerCloseAttrs = computed(() => ({\n  variant: hasHeaderCloseSlot.value ? props.headerCloseVariant : undefined,\n  class: props.headerCloseClass,\n}))\n\nconst resolvedFooterBgClasses = useColorVariantClasses(() => ({\n  bgVariant: props.footerBgVariant,\n  textVariant: props.footerTextVariant,\n  variant: props.footerVariant,\n}))\n\nconst footerClasses = computed(() => [\n  props.footerClass,\n  resolvedFooterBgClasses.value,\n  {\n    [`border-${props.footerBorderVariant}`]: props.footerBorderVariant !== null,\n  },\n])\n\nconst titleClasses = computed(() => [\n  props.titleClass,\n  {\n    ['visually-hidden']: props.titleSrOnly,\n  },\n])\nconst disableCancel = toRef(() => props.cancelDisabled || props.busy)\nconst disableOk = toRef(() => props.okDisabled || props.busy)\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Readonly<Partial<BvTriggerableEvent>> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nwatch(modelValue, (newValue, oldValue) => {\n  if (newValue === oldValue) return\n  if (newValue === true) {\n    showFn()\n  } else {\n    hideFn()\n  }\n})\n\nconst hideFn = (trigger = '') => {\n  if (\n    (trigger === 'backdrop' && props.noCloseOnBackdrop) ||\n    (trigger === 'esc' && props.noCloseOnEsc)\n  ) {\n    emit('hide-prevented')\n    return\n  }\n\n  const event = buildTriggerableEvent('hide', {cancelable: trigger !== '', trigger})\n\n  if (trigger === 'ok') {\n    emit(trigger, event)\n  }\n  if (trigger === 'cancel') {\n    emit(trigger, event)\n  }\n  if (trigger === 'close') {\n    emit(trigger, event)\n  }\n  emit('hide', event)\n\n  if (event.defaultPrevented) {\n    emit('hide-prevented')\n    if (!modelValue.value) modelValue.value = true\n    return\n  }\n  if (modelValue.value) modelValue.value = false\n}\n\n// TODO: If a show is prevented, it will briefly show the animation. This is a bug\n// I'm not sure how to wait for the event to be determined. Before showing\nconst showFn = () => {\n  if (isActive.value) return\n\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    if (modelValue.value) modelValue.value = false\n    emit('show-prevented')\n    return\n  }\n  if (!modelValue.value) modelValue.value = true\n}\n\nconst pickFocusItem = () => {\n  if (props.autoFocus === false) return\n  props.autoFocusButton === 'ok'\n    ? (okButtonFocus.value = true)\n    : props.autoFocusButton === 'close'\n      ? (closeButtonFocus.value = true)\n      : props.autoFocusButton === 'cancel'\n        ? (cancelButtonFocus.value = true)\n        : (modalFocus.value = true)\n}\n\nconst onBeforeEnter = () => {\n  showFn()\n}\nconst onAfterEnter = () => {\n  isActive.value = true\n  pickFocusItem()\n  emit('shown', buildTriggerableEvent('shown'))\n  if (props.lazy === true) lazyLoadCompleted.value = true\n}\nconst onLeave = () => {\n  isActive.value = false\n}\nconst onAfterLeave = () => {\n  emit('hidden', buildTriggerableEvent('hidden'))\n  if (props.lazy === true) lazyLoadCompleted.value = false\n}\n\nconst {activePosition, activeModalCount} = useModalManager(isActive)\nconst defaultModalDialogZIndex = 1056\nconst computedZIndex = computed<CSSProperties>(() => ({\n  // Make sure that newly opened modals have a higher z-index than currently active ones.\n  // All active modals have a z-index of ('defaultZIndex' - 'stackSize' - 'positionInStack').\n  //\n  // This means inactive modals will already be higher than active ones when opened.\n  'z-index': isActive.value\n    ? defaultModalDialogZIndex - ((activeModalCount?.value ?? 0) - (activePosition?.value ?? 0))\n    : defaultModalDialogZIndex,\n}))\n\nuseEventListener(element, 'bv-toggle', () => {\n  modelValue.value ? hideFn() : showFn()\n})\n\nconst sharedSlots = computed<SharedSlotsData>(() => ({\n  cancel: () => {\n    hideFn('cancel')\n  },\n  close: () => {\n    hideFn('close')\n  },\n  hide: hideFn,\n  ok: () => {\n    hideFn('ok')\n  },\n  visible: modelValue.value,\n}))\n\ndefineExpose({\n  hide: hideFn,\n  id: computedId,\n  show: showFn,\n})\n</script>\n\n<style lang=\"scss\" scoped>\n.modal {\n  display: block;\n}\n\n.modal-dialog {\n  z-index: 1051;\n}\n</style>\n","import {\n  type Component,\n  computed,\n  type ComputedRef,\n  type MaybeRefOrGetter,\n  type Plugin,\n  shallowRef,\n  toValue,\n} from 'vue'\nimport {modalControllerPluginKey} from '../utils'\nimport type {BModalProps, OrchestratedModal} from '../types'\nimport BModal from '../components/BModal/BModal.vue'\n\nexport default {\n  install(app) {\n    const modals = shallowRef<\n      ComputedRef<{\n        component: unknown // TS being weird here, just use unknown\n        props: OrchestratedModal & {\n          _self: symbol\n          _modelValue: BModalProps['modelValue']\n          _promise: {\n            value: Promise<boolean | null>\n            resolve: (value: boolean | null) => void\n          }\n          _isConfirm: boolean\n        }\n      }>[]\n    >([])\n\n    const buildPromise = (): {\n      value: Promise<boolean | null>\n      resolve: (value: boolean | null) => void\n    } => {\n      let resolveFunc: (value: boolean | null) => void = () => {\n        /* empty */\n      }\n\n      const promise = new Promise<boolean | null>((resolve) => {\n        resolveFunc = resolve\n      })\n\n      return {\n        value: promise,\n        resolve: resolveFunc,\n      }\n    }\n\n    const show = (obj: {\n      component?: MaybeRefOrGetter<Readonly<Component>>\n      props?: MaybeRefOrGetter<Readonly<OrchestratedModal>>\n    }) => {\n      const _promise = buildPromise()\n      const _self = Symbol()\n\n      modals.value = [\n        ...modals.value,\n        computed(() => ({\n          component: toValue(obj.component) ?? BModal,\n          props: {...toValue(obj.props), _isConfirm: false, _promise, _self, _modelValue: true},\n        })),\n      ]\n\n      return _promise.value\n    }\n\n    const confirm = (obj: {\n      component?: MaybeRefOrGetter<Readonly<Component>>\n      props?: MaybeRefOrGetter<Readonly<OrchestratedModal>>\n    }) => {\n      const _promise = buildPromise()\n      const _self = Symbol()\n\n      modals.value = [\n        ...modals.value,\n        computed(() => ({\n          component: toValue(obj.component) ?? BModal,\n          props: {...toValue(obj.props), _isConfirm: true, _promise, _self, _modelValue: true},\n        })),\n      ]\n\n      return _promise.value\n    }\n\n    const remove = (self: symbol) => {\n      modals.value = modals.value.filter((el) => el.value.props._self !== self)\n    }\n\n    app.provide(modalControllerPluginKey, {\n      modals,\n      remove,\n      show,\n      confirm,\n    })\n  },\n} satisfies Plugin\n","import {type ComponentInternalInstance, type Plugin, type Ref, shallowRef, toRef} from 'vue'\nimport {modalManagerPluginKey} from '../utils'\n\nexport default {\n  install(app) {\n    /**\n     * A collection of all currently active modals\n     */\n    const stack: Ref<ComponentInternalInstance[]> = shallowRef([])\n\n    const countStack = toRef(() => stack.value.length)\n    const lastStack = toRef(() => stack.value[stack.value.length - 1])\n\n    const pushStack = (modal: Readonly<ComponentInternalInstance>) => {\n      stack.value = [...stack.value, modal]\n    }\n    const removeStack = (modal: Readonly<ComponentInternalInstance>) => {\n      stack.value = stack.value.filter((item) => item.uid !== modal.uid)\n    }\n\n    /**\n     * A collection of all registered modals\n     */\n    const registry: Ref<ComponentInternalInstance[]> = shallowRef([])\n\n    // Utility getters not made, would not be used (count, last)\n\n    const pushRegistry = (modal: Readonly<ComponentInternalInstance>) => {\n      registry.value = [...registry.value, modal]\n    }\n    const removeRegistry = (modal: Readonly<ComponentInternalInstance>) => {\n      registry.value = registry.value.filter((item) => item.uid !== modal.uid)\n    }\n\n    app.provide(modalManagerPluginKey, {\n      stack,\n      countStack,\n      lastStack,\n      registry,\n      pushStack,\n      removeStack,\n      pushRegistry,\n      removeRegistry,\n    })\n  },\n} satisfies Plugin\n","import {type Plugin, ref} from 'vue'\nimport {rtlPluginKey} from '../utils'\nimport type {BootstrapVueOptions} from '../types'\n\nexport default {\n  install(app, options: BootstrapVueOptions['plugins']) {\n    const rtlDefault = false\n    const localeDefault = undefined\n\n    const rtlInitial =\n      typeof options?.rtl === 'boolean' ? rtlDefault : options?.rtl?.rtlInitial ?? rtlDefault\n\n    const localeInitial =\n      typeof options?.rtl === 'boolean'\n        ? localeDefault\n        : options?.rtl?.localeInitial ?? localeDefault\n\n    const isRtl = ref(rtlInitial)\n    const locale = ref(localeInitial)\n\n    app.provide(rtlPluginKey, {isRtl, locale})\n  },\n} satisfies Plugin\n","<template>\n  <div :id=\"computedId\" class=\"accordion\" :class=\"computedClasses\">\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, provide, readonly, toRef} from 'vue'\nimport {accordionInjectionKey} from '../../utils'\nimport {useId} from '../../composables'\nimport type {BAccordionProps} from '../../types'\n\nconst props = withDefaults(defineProps<BAccordionProps>(), {\n  flush: false,\n  free: false,\n  id: undefined,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = defineModel<string | undefined>({\n  default: undefined,\n})\n\nconst computedId = useId(() => props.id, 'accordion')\n\nconst computedClasses = computed(() => ({\n  'accordion-flush': props.flush,\n}))\n\nprovide(accordionInjectionKey, {\n  openItem: readonly(modelValue),\n  free: toRef(() => props.free),\n  setOpenItem: (id: string) => {\n    modelValue.value = id\n  },\n})\n</script>\n","<template>\n  <slot name=\"header\" v-bind=\"sharedSlots\" />\n  <component\n    :is=\"tag\"\n    :id=\"computedId\"\n    ref=\"element\"\n    class=\"collapse\"\n    :class=\"computedClasses\"\n    :is-nav=\"props.isNav\"\n    v-bind=\"$attrs\"\n  >\n    <slot v-bind=\"sharedSlots\" />\n  </component>\n  <slot name=\"footer\" v-bind=\"sharedSlots\" />\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, nextTick, onMounted, provide, readonly, ref, toRef, watch} from 'vue'\nimport {useId} from '../composables'\nimport {useEventListener} from '@vueuse/core'\nimport {BvTriggerableEvent, collapseInjectionKey, getTransitionDelay} from '../utils'\nimport type {BCollapseProps} from '../types'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<BCollapseProps>(), {\n  horizontal: false,\n  id: undefined,\n  isNav: false,\n  skipAnimation: false,\n  tag: 'div',\n  toggle: false,\n  visible: false,\n})\n\nconst emit = defineEmits<{\n  'hidden': []\n  'hide': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'shown': []\n}>()\n\ntype SharedSlotsData = {\n  hide: () => void\n  id: string\n  show: () => void\n  toggle: () => void\n  visible: boolean\n}\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  footer?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  header?: (props: SharedSlotsData) => any\n}>()\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Readonly<Partial<BvTriggerableEvent>> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nconst modelValue = defineModel<boolean>({\n  default: false,\n})\n\nconst computedId = useId(() => props.id, 'collapse')\n\nconst element = ref<HTMLElement | null>(null)\nconst isCollapsing = ref(false)\nconst showRef = ref(modelValue.value)\n\nconst computedClasses = computed(() => ({\n  'show': showRef.value,\n  'navbar-collapse': props.isNav,\n  'collapsing': isCollapsing.value,\n  'closing': showRef.value && !modelValue.value,\n  'collapse-horizontal': props.horizontal,\n}))\n\nconst hide = () => {\n  modelValue.value = false\n}\nconst show = () => {\n  modelValue.value = true\n}\nconst toggleFn = () => {\n  modelValue.value = !modelValue.value\n}\n\nconst sharedSlots = computed<SharedSlotsData>(() => ({\n  toggle: toggleFn,\n  show,\n  hide,\n  id: computedId.value,\n  visible: modelValue.value,\n}))\n\nlet revealTimeout: ReturnType<typeof setTimeout> | undefined\nlet hideTimeout: ReturnType<typeof setTimeout> | undefined\nlet _skipAnimation = props.skipAnimation\n\nconst reveal = () => {\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    emit('show-prevented')\n    return\n  }\n  clearTimeout(hideTimeout)\n  clearTimeout(revealTimeout)\n  showRef.value = true\n  if (_skipAnimation) return\n  isCollapsing.value = true\n  nextTick(() => {\n    if (element.value === null) return\n    if (props.horizontal) {\n      element.value.style.width = `${element.value.scrollWidth}px`\n    } else {\n      element.value.style.height = `${element.value.scrollHeight}px`\n    }\n    revealTimeout = setTimeout(() => {\n      isCollapsing.value = false\n      emit('shown')\n      if (element.value === null) return\n      element.value.style.height = ''\n      element.value.style.width = ''\n    }, getTransitionDelay(element.value))\n  })\n}\n\nconst hideFn = () => {\n  const event = buildTriggerableEvent('hide', {cancelable: true})\n  emit('hide', event)\n  if (event.defaultPrevented) {\n    emit('hide-prevented')\n    return\n  }\n  clearTimeout(revealTimeout)\n  clearTimeout(hideTimeout)\n  if (element.value === null) return\n  if (_skipAnimation) {\n    showRef.value = false\n    return\n  }\n  if (isCollapsing.value) {\n    element.value.style.height = ``\n    element.value.style.width = ``\n    // return\n  } else {\n    if (props.horizontal) {\n      element.value.style.width = `${element.value.scrollWidth}px`\n    } else {\n      element.value.style.height = `${element.value.scrollHeight}px`\n    }\n  }\n  // element.value.style.height = `${element.value.scrollHeight}px`\n  element.value.offsetHeight // force reflow\n  isCollapsing.value = true\n  nextTick(() => {\n    if (element.value === null) return\n    element.value.style.height = ``\n    element.value.style.width = ``\n    hideTimeout = setTimeout(() => {\n      showRef.value = false\n      isCollapsing.value = false\n      emit('hidden')\n    }, getTransitionDelay(element.value))\n  })\n}\n\nwatch(modelValue, () => {\n  modelValue.value ? reveal() : hideFn()\n})\n\nonMounted(() => {\n  if (element.value === null) return\n  if (!modelValue.value && props.toggle) {\n    nextTick(() => {\n      modelValue.value = true\n    })\n  }\n})\n\nwatch(\n  () => props.skipAnimation,\n  (newval) => {\n    _skipAnimation = newval\n  }\n)\n\nif (props.visible) {\n  _skipAnimation = true\n  modelValue.value = true\n  nextTick(() => {\n    _skipAnimation = props.skipAnimation\n  })\n}\n\nwatch(\n  () => props.visible,\n  (newval) => {\n    _skipAnimation = true\n    newval ? show() : hide()\n    nextTick(() => {\n      _skipAnimation = props.skipAnimation\n    })\n  }\n)\n\nuseEventListener(element, 'bv-toggle', () => {\n  modelValue.value = !modelValue.value\n})\n\ndefineExpose({\n  hide,\n  isNav: props.isNav,\n  show,\n  toggle: toggleFn,\n  visible: readonly(showRef),\n})\n\nprovide(collapseInjectionKey, {\n  id: computedId,\n  hide,\n  show,\n  toggle: toggleFn,\n  visible: readonly(showRef),\n  isNav: toRef(() => props.isNav),\n})\n</script>\n","<template>\n  <div class=\"accordion-item\" v-bind=\"wrapperAttrs\" :class=\"wrapperClass\">\n    <BCollapse\n      :id=\"computedId\"\n      v-model=\"modelValue\"\n      class=\"accordion-collapse\"\n      :class=\"collapseClass\"\n      :aria-labelledby=\"`${computedId}-heading`\"\n      v-bind=\"collapseAttrs\"\n      :tag=\"tag\"\n      :toggle=\"toggle\"\n      :horizontal=\"horizontal\"\n      :visible=\"visible\"\n      :is-nav=\"isNav\"\n      @show=\"emit('show', $event)\"\n      @shown=\"emit('shown')\"\n      @hide=\"emit('hide', $event)\"\n      @hidden=\"emit('hidden')\"\n      @hide-prevented=\"emit('hide-prevented')\"\n      @show-prevented=\"emit('show-prevented')\"\n    >\n      <template #header=\"{visible: toggleVisible, toggle: slotToggle}\">\n        <component\n          :is=\"headerTag\"\n          :id=\"`${computedId}-heading`\"\n          class=\"accordion-header\"\n          :class=\"headerClass\"\n          v-bind=\"headerAttrs\"\n        >\n          <button\n            class=\"accordion-button\"\n            v-bind=\"buttonAttrs\"\n            :class=\"[{collapsed: !toggleVisible}, buttonClass]\"\n            type=\"button\"\n            :aria-expanded=\"toggleVisible ? 'true' : 'false'\"\n            :aria-controls=\"computedId\"\n            @click=\"slotToggle\"\n          >\n            <slot name=\"title\"> {{ title }} </slot>\n          </button>\n        </component>\n      </template>\n      <div class=\"accordion-body\" v-bind=\"bodyAttrs\" :class=\"bodyClass\">\n        <slot />\n      </div>\n    </BCollapse>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {inject, onMounted, useAttrs, watch} from 'vue'\nimport BCollapse from '../BCollapse.vue'\nimport {accordionInjectionKey, BvTriggerableEvent} from '../../utils'\nimport {useId} from '../../composables'\nimport type {BAccordionItemProps} from '../../types'\n\ndefineOptions({\n  inheritAttrs: false,\n})\nconst {class: wrapperClass, ...collapseAttrs} = useAttrs()\n\nconst props = withDefaults(defineProps<BAccordionItemProps>(), {\n  bodyAttrs: undefined,\n  bodyClass: undefined,\n  buttonAttrs: undefined,\n  buttonClass: undefined,\n  collapseClass: undefined,\n  headerAttrs: undefined,\n  headerClass: undefined,\n  headerTag: 'h2',\n  horizontal: undefined,\n  id: undefined,\n  isNav: undefined,\n  tag: undefined,\n  title: undefined,\n  toggle: undefined,\n  visible: false,\n  wrapperAttrs: undefined,\n})\n\nconst emit = defineEmits<{\n  'hidden': []\n  'hide': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'shown': []\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  title?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = defineModel<boolean>({default: false})\n\nconst parentData = inject(accordionInjectionKey, null)\n\nconst computedId = useId(() => props.id, 'accordion_item')\n\nonMounted(() => {\n  if (modelValue.value && !parentData?.free.value) {\n    parentData?.setOpenItem(computedId.value)\n  }\n  if (!modelValue.value && parentData?.openItem.value === computedId.value) {\n    modelValue.value = true\n  }\n})\n\nwatch(\n  () => parentData?.openItem.value,\n  () =>\n    (modelValue.value = parentData?.openItem.value === computedId.value && !parentData?.free.value)\n)\nwatch(modelValue, () => {\n  if (modelValue.value && !parentData?.free.value) parentData?.setOpenItem(computedId.value)\n})\n</script>\n","<template>\n  <BTransition :no-fade=\"!props.fade\" :trans-props=\"{enterToClass: 'show'}\">\n    <div\n      v-if=\"isAlertVisible\"\n      ref=\"element\"\n      class=\"alert\"\n      role=\"alert\"\n      aria-live=\"polite\"\n      aria-atomic=\"true\"\n      :class=\"computedClasses\"\n    >\n      <slot />\n      <template v-if=\"props.dismissible\">\n        <BButton v-if=\"hasCloseSlot || closeContent\" v-bind=\"closeAttrs\" @click=\"hide\">\n          <slot name=\"close\">\n            {{ closeContent }}\n          </slot>\n        </BButton>\n        <BCloseButton v-else :aria-label=\"closeLabel\" v-bind=\"closeAttrs\" @click=\"hide\" />\n      </template>\n    </div>\n  </BTransition>\n</template>\n\n<script setup lang=\"ts\">\nimport BTransition from '../BTransition/BTransition.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BButton from '../BButton/BButton.vue'\nimport type {BAlertProps} from '../../types'\nimport {computed, onBeforeUnmount, ref, toRef, watch, watchEffect} from 'vue'\nimport {useCountdown} from '../../composables'\nimport {isEmptySlot} from '../../utils'\nimport {useElementHover, useToNumber} from '@vueuse/core'\n\nconst props = withDefaults(defineProps<BAlertProps>(), {\n  closeClass: undefined,\n  closeContent: undefined,\n  closeLabel: 'Close',\n  closeVariant: 'secondary',\n  dismissible: false,\n  fade: false,\n  immediate: true,\n  interval: 1000,\n  noHoverPause: false,\n  showOnPause: true,\n  variant: 'info',\n})\n\nconst emit = defineEmits<{\n  'close': []\n  'close-countdown': [value: number]\n  'closed': []\n}>()\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  close?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst element = ref<HTMLElement | null>(null)\n\nconst modelValue = defineModel<boolean | number>({default: false})\n\nconst isHovering = useElementHover(element)\n\nconst intervalNumber = useToNumber(() => props.interval)\n\nconst hasCloseSlot = toRef(() => !isEmptySlot(slots.close))\n\nconst countdownLength = toRef(() => (typeof modelValue.value === 'boolean' ? 0 : modelValue.value))\n\nconst computedClasses = computed(() => ({\n  [`alert-${props.variant}`]: props.variant !== null,\n  'alert-dismissible': props.dismissible,\n}))\n\nconst closeClasses = computed(() => [props.closeClass, {'btn-close-custom': hasCloseSlot.value}])\n\nconst {\n  isActive,\n  pause,\n  restart,\n  resume,\n  stop,\n  isPaused,\n  value: remainingMs,\n} = useCountdown(countdownLength, intervalNumber, {\n  immediate: typeof modelValue.value === 'number' && props.immediate,\n})\n\nconst isAlertVisible = toRef(() =>\n  typeof modelValue.value === 'boolean'\n    ? modelValue.value\n    : isActive.value || (props.showOnPause && isPaused.value)\n)\n\nconst closeAttrs = computed(() => ({\n  variant: hasCloseSlot.value ? props.closeVariant : undefined,\n  class: closeClasses.value,\n}))\n\nwatchEffect(() => {\n  emit('close-countdown', remainingMs.value)\n})\n\nconst hide = () => {\n  emit('close')\n\n  if (typeof modelValue.value === 'boolean') {\n    modelValue.value = false\n  } else {\n    modelValue.value = 0\n    stop()\n  }\n\n  emit('closed')\n}\n\nconst onMouseEnter = () => {\n  if (props.noHoverPause) return\n  pause()\n}\n\nwatch(isHovering, (newValue) => {\n  if (newValue) {\n    onMouseEnter()\n    return\n  }\n  resume()\n})\n\nonBeforeUnmount(stop)\n\ndefineExpose({\n  pause,\n  restart,\n  resume,\n  stop,\n})\n</script>\n\n<style lang=\"scss\" scoped>\n.btn-close-custom {\n  position: absolute;\n  top: 0;\n  right: 0;\n  z-index: 2;\n  margin: var(--bs-alert-padding-y) var(--bs-alert-padding-x);\n}\n</style>\n","<template>\n  <component\n    :is=\"computedTag\"\n    class=\"b-avatar\"\n    :class=\"computedClasses\"\n    :style=\"computedStyle\"\n    v-bind=\"computedLinkProps\"\n    :type=\"props.button && !computedLink ? props.buttonType : undefined\"\n    :disabled=\"props.disabled || null\"\n    @click=\"clicked\"\n  >\n    <span v-if=\"hasDefaultSlot\" class=\"b-avatar-custom\">\n      <slot />\n    </span>\n    <span v-else-if=\"!!src\" class=\"b-avatar-img\">\n      <img :src=\"src\" :alt=\"alt\" @error=\"onImgError\" />\n    </span>\n    <span v-else-if=\"!!text\" class=\"b-avatar-text\" :style=\"textFontStyle\">\n      {{ text }}\n    </span>\n    <span v-if=\"showBadge\" class=\"b-avatar-badge\" :class=\"badgeClasses\" :style=\"badgeStyle\">\n      <slot name=\"badge\">\n        {{ badgeText }}\n      </slot>\n    </span>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {avatarGroupInjectionKey, isEmptySlot} from '../../utils'\nimport {computed, type CSSProperties, inject, type StyleValue, toRef} from 'vue'\nimport type {BAvatarProps} from '../../types'\nimport {\n  useBLinkHelper,\n  useColorVariantClasses,\n  useNumberishToStyle,\n  useRadiusElementClasses,\n} from '../../composables'\nimport BLink from '../BLink/BLink.vue'\n\nconst props = withDefaults(defineProps<BAvatarProps>(), {\n  alt: 'avatar',\n  badge: false,\n  badgeBgVariant: null,\n  badgeOffset: undefined,\n  badgeStart: false,\n  badgeTextVariant: null,\n  badgeTop: false,\n  badgeVariant: 'primary',\n  button: false,\n  buttonType: 'button',\n  size: undefined,\n  square: false,\n  src: undefined,\n  text: undefined,\n  // Link props\n  variant: 'secondary',\n  // All others use defaults\n  active: undefined,\n  activeClass: undefined,\n  append: undefined,\n  disabled: undefined,\n  exactActiveClass: undefined,\n  href: undefined,\n  icon: undefined,\n  opacity: undefined,\n  opacityHover: undefined,\n  rel: undefined,\n  replace: undefined,\n  routerComponentName: undefined,\n  target: undefined,\n  to: undefined,\n  underlineOffset: undefined,\n  underlineOffsetHover: undefined,\n  underlineOpacity: undefined,\n  underlineOpacityHover: undefined,\n  underlineVariant: undefined,\n  // End link props\n  // ColorExtendables props\n  // Variant is here as well\n  bgVariant: null,\n  textVariant: null,\n  // End ColorExtendables props\n  // RadiusElementExtendables props\n  rounded: false,\n  roundedBottom: undefined,\n  roundedEnd: undefined,\n  roundedStart: undefined,\n  roundedTop: undefined,\n  // End RadiusElementExtendables props\n})\n\nconst emit = defineEmits<{\n  'click': [value: MouseEvent]\n  'img-error': [value: Event]\n}>()\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  badge?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst {computedLink, computedLinkProps} = useBLinkHelper(props)\n\nconst parentData = inject(avatarGroupInjectionKey, null)\n\nconst SIZES = ['sm', null, 'lg']\nconst FONT_SIZE_SCALE = 0.4\nconst BADGE_FONT_SIZE_SCALE = FONT_SIZE_SCALE * 0.7\n\nconst hasDefaultSlot = toRef(() => !isEmptySlot(slots.default))\nconst hasBadgeSlot = toRef(() => !isEmptySlot(slots.badge))\n\nconst showBadge = toRef(() => !!props.badge || props.badge === '' || hasBadgeSlot.value)\nconst computedSquare = toRef(() => parentData?.size.value ?? props.square)\n\nconst computedPropSize = useNumberishToStyle(() => props.size)\nconst computedParentSize = useNumberishToStyle(() => parentData?.size.value)\nconst computedSize = computed(() => computedParentSize.value ?? computedPropSize.value)\n\nconst computedVariant = toRef(() => parentData?.variant.value ?? props.variant)\nconst computedRounded = toRef(() => parentData?.rounded.value ?? props.rounded)\nconst computedRoundedTop = toRef(() => parentData?.roundedTop.value ?? props.roundedTop)\nconst computedRoundedBottom = toRef(() => parentData?.roundedBottom.value ?? props.roundedBottom)\nconst computedRoundedStart = toRef(() => parentData?.roundedStart.value ?? props.roundedStart)\nconst computedRoundedEnd = toRef(() => parentData?.roundedEnd.value ?? props.roundedEnd)\n\nconst radiusElementClasses = useRadiusElementClasses(() => ({\n  rounded: computedRounded.value,\n  roundedTop: computedRoundedTop.value,\n  roundedBottom: computedRoundedBottom.value,\n  roundedStart: computedRoundedStart.value,\n  roundedEnd: computedRoundedEnd.value,\n}))\nconst badgeClasses = useColorVariantClasses(() => ({\n  variant: props.badgeVariant,\n  bgVariant: props.badgeBgVariant,\n  textVariant: props.badgeTextVariant,\n}))\n\nconst badgeText = toRef(() => (props.badge === true ? '' : props.badge))\n\nconst computedTextVariant = toRef(() => parentData?.textVariant.value ?? props.textVariant)\nconst computedBgVariant = toRef(() => parentData?.bgVariant.value ?? props.bgVariant)\n\nconst resolvedBackgroundClasses = useColorVariantClasses(() => ({\n  bgVariant: computedBgVariant.value,\n  textVariant: computedTextVariant.value,\n  variant: computedVariant.value,\n}))\n\nconst computedClasses = computed(() => [\n  resolvedBackgroundClasses.value,\n  // Square overwrites all else\n  computedSquare.value === true ? undefined : radiusElementClasses.value,\n  {\n    [`b-avatar-${props.size}`]:\n      !!props.size && SIZES.indexOf(computedPropSize.value as string) !== -1,\n    [`btn-${computedVariant.value}`]: props.button ? computedVariant.value !== null : false,\n    'badge': !props.button && computedVariant.value !== null && hasDefaultSlot.value,\n    'btn': props.button,\n    // Square is the same as rounded-0 class\n    'rounded-0': computedSquare.value === true,\n  },\n])\n\nconst badgeStyle = computed<StyleValue>(() => {\n  const offset = props.badgeOffset || '0px'\n  const fontSize =\n    SIZES.indexOf((computedSize.value as string | undefined) || null) === -1\n      ? `calc(${computedSize.value} * ${BADGE_FONT_SIZE_SCALE})`\n      : ''\n  return {\n    fontSize: fontSize || '',\n    top: props.badgeTop ? offset : '',\n    bottom: props.badgeTop ? '' : offset,\n    left: props.badgeStart ? offset : '',\n    right: props.badgeStart ? '' : offset,\n  }\n})\n\nconst textFontStyle = computed<StyleValue>(() => {\n  const fontSize =\n    SIZES.indexOf((computedSize.value as string | undefined) || null) === -1\n      ? `calc(${computedSize.value} * ${FONT_SIZE_SCALE})`\n      : null\n  return fontSize ? {fontSize} : {}\n})\n\nconst marginStyle = computed(() => {\n  const overlapScale = parentData?.overlapScale?.value || 0\n\n  const value =\n    computedSize.value && overlapScale ? `calc(${computedSize.value} * -${overlapScale})` : null\n  return value ? {marginLeft: value, marginRight: value} : {}\n})\n\nconst computedTag = toRef(() => (computedLink.value ? BLink : props.button ? 'button' : 'span'))\n\nconst computedStyle = computed<CSSProperties>(() => ({\n  ...marginStyle.value,\n  width: computedSize.value ?? undefined,\n  height: computedSize.value ?? undefined,\n}))\n\nconst clicked = (e: Readonly<MouseEvent>): void => {\n  if (!props.disabled && (computedLink.value || props.button)) emit('click', e)\n}\n\nconst onImgError = (e: Readonly<Event>) => {\n  emit('img-error', e)\n}\n</script>\n","<template>\n  <component :is=\"tag\" class=\"b-avatar-group\" role=\"group\">\n    <div class=\"b-avatar-group-inner\" :style=\"paddingStyle\">\n      <slot />\n    </div>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, provide, type StyleValue, toRef} from 'vue'\nimport type {BAvatarGroupProps} from '../../types'\nimport {avatarGroupInjectionKey} from '../../utils'\nimport {useNumberishToStyle} from '../../composables'\nimport {useToNumber} from '@vueuse/core'\n\nconst props = withDefaults(defineProps<BAvatarGroupProps>(), {\n  overlap: 0.3,\n  size: undefined,\n  square: false,\n  tag: 'div',\n  // RadiusElementExtendables props\n  rounded: false,\n  roundedBottom: undefined,\n  roundedEnd: undefined,\n  roundedStart: undefined,\n  roundedTop: undefined,\n  // End RadiusElementExtendables props\n  // ColorExtendables props\n  bgVariant: null,\n  textVariant: null,\n  variant: null,\n  // End ColorExtendables props\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst overlapNumber = useToNumber(() => props.overlap)\n\nconst computedSize = useNumberishToStyle(() => props.size)\nconst overlapScale = toRef(() => Math.min(Math.max(overlapNumber.value, 0), 1) / 2)\n\nconst paddingStyle = computed<StyleValue>(() => {\n  const value = computedSize.value ? `calc(${computedSize.value} * ${overlapScale.value})` : null\n  return value ? {paddingLeft: value, paddingRight: value} : {}\n})\n\nprovide(avatarGroupInjectionKey, {\n  overlapScale,\n  size: toRef(() => props.size),\n  square: toRef(() => props.square),\n  rounded: toRef(() => props.rounded),\n  roundedTop: toRef(() => props.roundedTop),\n  roundedBottom: toRef(() => props.roundedBottom),\n  roundedStart: toRef(() => props.roundedStart),\n  roundedEnd: toRef(() => props.roundedEnd),\n  variant: toRef(() => props.variant),\n  bgVariant: toRef(() => props.bgVariant),\n  textVariant: toRef(() => props.textVariant),\n})\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"badge\" :class=\"computedClasses\" v-bind=\"computedLinkProps\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {useBLinkHelper, useColorVariantClasses} from '../../composables'\nimport {computed, toRef} from 'vue'\nimport type {BBadgeProps} from '../../types'\nimport BLink from '../BLink/BLink.vue'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(defineProps<BBadgeProps>(), {\n  dotIndicator: false,\n  pill: false,\n  tag: 'span',\n  textIndicator: false,\n  // Link props\n  variant: 'secondary',\n  // All others use defaults\n  active: undefined,\n  activeClass: undefined,\n  append: undefined,\n  disabled: undefined,\n  exactActiveClass: undefined,\n  href: undefined,\n  icon: undefined,\n  opacity: undefined,\n  opacityHover: undefined,\n  rel: undefined,\n  replace: undefined,\n  routerComponentName: undefined,\n  target: undefined,\n  to: undefined,\n  underlineOffset: undefined,\n  underlineOffsetHover: undefined,\n  underlineOpacity: undefined,\n  underlineOpacityHover: undefined,\n  underlineVariant: undefined,\n  // End link props\n  // ColorExtendables props\n  // Variant is here as well\n  textVariant: null,\n  bgVariant: null,\n  // End ColorExtendables props\n})\n\nconst resolvedBackgroundClasses = useColorVariantClasses(props)\n\nconst {computedLink, computedLinkProps} = useBLinkHelper(props, [\n  'active',\n  'activeClass',\n  'append',\n  'disabled',\n  'href',\n  'rel',\n  'replace',\n  'routerComponentName',\n  'target',\n  'to',\n  'opacity',\n  'opacityHover',\n  'underlineVariant',\n  'underlineOffset',\n  'underlineOffsetHover',\n  'underlineOpacity',\n  'underlineOpacityHover',\n  'icon',\n])\n\nconst computedTag = toRef(() => (computedLink.value ? BLink : props.tag))\n\nconst computedClasses = computed(() => [\n  resolvedBackgroundClasses.value,\n  {\n    'active': props.active,\n    'disabled': props.disabled,\n    'rounded-pill': props.pill,\n    'position-absolute top-0 start-100 translate-middle': props.textIndicator || props.dotIndicator,\n    'p-2 border border-light rounded-circle': props.dotIndicator,\n    'text-decoration-none': computedLink.value,\n  },\n])\n</script>\n","<template>\n  <li class=\"breadcrumb-item\" :class=\"computedClasses\">\n    <component\n      :is=\"computedTag\"\n      :aria-current=\"computedAriaCurrent\"\n      v-bind=\"computedLinkProps\"\n      @click=\"clicked\"\n    >\n      <slot>\n        {{ text }}\n      </slot>\n    </component>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport {pick} from '../../utils'\nimport {computed, toRef} from 'vue'\nimport BLink from '../BLink/BLink.vue'\nimport type {BBreadcrumbItemProps} from '../../types'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(defineProps<BBreadcrumbItemProps>(), {\n  ariaCurrent: 'location',\n  text: undefined,\n  // Link props\n  active: false, // Why is this active: false?\n  // All others use defaults\n  activeClass: undefined,\n  append: undefined,\n  disabled: undefined,\n  exactActiveClass: undefined,\n  href: undefined,\n  icon: undefined,\n  opacity: undefined,\n  opacityHover: undefined,\n  rel: undefined,\n  replace: undefined,\n  routerComponentName: undefined,\n  routerTag: undefined,\n  target: undefined,\n  to: undefined,\n  underlineOffset: undefined,\n  underlineOffsetHover: undefined,\n  underlineOpacity: undefined,\n  underlineOpacityHover: undefined,\n  underlineVariant: undefined,\n  variant: undefined,\n  // End link props\n})\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst computedClasses = computed(() => ({\n  active: props.active,\n}))\n\nconst computedTag = toRef(() => (props.active ? 'span' : BLink))\n\nconst computedAriaCurrent = toRef(() => (props.active ? props.ariaCurrent : undefined))\n\nconst computedLinkProps = computed(() =>\n  computedTag.value !== 'span'\n    ? pick(props, [\n        'active',\n        'activeClass',\n        'append',\n        'disabled',\n        'href',\n        'rel',\n        'replace',\n        'routerComponentName',\n        'target',\n        'to',\n        'variant',\n        'opacity',\n        'opacityHover',\n        'underlineVariant',\n        'underlineOffset',\n        'underlineOffsetHover',\n        'underlineOpacity',\n        'underlineOpacityHover',\n        'icon',\n      ])\n    : {}\n)\n\nconst clicked = (e: Readonly<MouseEvent>): void => {\n  if (props.disabled || props.active) {\n    e.preventDefault()\n    e.stopImmediatePropagation()\n    return\n  }\n  if (!props.disabled) emit('click', e)\n}\n</script>\n","<template>\n  <nav aria-label=\"breadcrumb\">\n    <ol class=\"breadcrumb\">\n      <slot name=\"prepend\" />\n      <BBreadcrumbItem v-for=\"(item, i) in breadcrumbItemObjects\" :key=\"i\" v-bind=\"item\">\n        {{ item.text }}\n      </BBreadcrumbItem>\n      <slot />\n      <slot name=\"append\" />\n    </ol>\n  </nav>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport {useBreadcrumb} from '../../composables'\nimport type {BBreadcrumbProps, BreadcrumbItem} from '../../types'\nimport BBreadcrumbItem from './BBreadcrumbItem.vue'\n\nconst props = withDefaults(defineProps<BBreadcrumbProps>(), {items: undefined})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  append?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  prepend?: (props: Record<string, never>) => any\n}>()\n\nconst breadcrumb = useBreadcrumb()\n\nconst breadcrumbItemObjects = computed<BreadcrumbItem[]>(() => {\n  const localItems = props.items || breadcrumb.items?.value || []\n  let activeDefined = false\n  const items = localItems.map((item, idx) => {\n    if (typeof item === 'string') {\n      item = {text: item}\n      if (idx < localItems.length - 1) item.href = '#'\n    }\n    if (item.active) activeDefined = true\n\n    // Auto-detect active by position in list\n    if (!item.active && !activeDefined) {\n      item.active = idx + 1 === localItems.length\n    }\n    return item\n  })\n  return items\n})\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\" role=\"group\" :aria-label=\"ariaLabel\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BButtonGroupProps} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(defineProps<BButtonGroupProps>(), {\n  ariaLabel: 'Group',\n  size: 'md',\n  tag: 'div',\n  vertical: false,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  'btn-group': !props.vertical,\n  [`btn-group-${props.size}`]: props.size !== 'md',\n  'btn-group-vertical': props.vertical,\n}))\n</script>\n","<template>\n  <div :class=\"computedClasses\" class=\"btn-toolbar\" :role=\"role\" :aria-label=\"ariaLabel\">\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BButtonToolbarProps} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(defineProps<BButtonToolbarProps>(), {\n  ariaLabel: 'Group',\n  justify: false,\n  role: 'toolbar',\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  'justify-content-between': props.justify,\n}))\n</script>\n","<template>\n  <img\n    :class=\"computedClasses\"\n    :src=\"!props.blank ? src : computedBlankImgSrc\"\n    :width=\"computedDimentions.width || undefined\"\n    :height=\"computedDimentions.height || undefined\"\n    :srcset=\"!props.blank ? computedSrcset : undefined\"\n    :sizes=\"!props.blank ? computedSizes : undefined\"\n    :loading=\"props.lazy ? 'lazy' : 'eager'\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport type {BImgProps} from '../types'\nimport {useRadiusElementClasses} from '../composables'\nimport {computed, toRef} from 'vue'\nimport {useToNumber} from '@vueuse/core'\n\nconst props = withDefaults(defineProps<BImgProps>(), {\n  blank: false,\n  blankColor: 'transparent',\n  block: false,\n  center: false,\n  end: false,\n  fluid: false,\n  fluidGrow: false,\n  height: undefined,\n  lazy: false,\n  sizes: undefined,\n  src: undefined,\n  srcset: undefined,\n  start: false,\n  thumbnail: false,\n  width: undefined,\n  // RadiusElementExtendables props\n  rounded: false,\n  roundedBottom: undefined,\n  roundedEnd: undefined,\n  roundedStart: undefined,\n  roundedTop: undefined,\n  // End RadiusElementExtendables props\n})\n\nconst heightNumber = useToNumber(() => props.height ?? NaN)\nconst widthNumber = useToNumber(() => props.width ?? NaN)\n\nconst radiusElementClasses = useRadiusElementClasses(() => ({\n  rounded: props.rounded,\n  roundedTop: props.roundedTop,\n  roundedBottom: props.roundedBottom,\n  roundedStart: props.roundedStart,\n  roundedEnd: props.roundedEnd,\n}))\n\nconst computedSrcset = computed(() =>\n  typeof props.srcset === 'string'\n    ? props.srcset\n        .split(',')\n        .filter((x) => x)\n        .join(',')\n    : Array.isArray(props.srcset)\n      ? props.srcset.filter((x) => x).join(',')\n      : undefined\n)\n\nconst computedSizes = computed(() =>\n  typeof props.sizes === 'string'\n    ? props.sizes\n        .split(',')\n        .filter((x) => x)\n        .join(',')\n    : Array.isArray(props.sizes)\n      ? props.sizes.filter((x) => x).join(',')\n      : undefined\n)\n\nconst computedDimentions = computed<{height: number | undefined; width: number | undefined}>(() => {\n  const width = Number.isNaN(widthNumber.value) ? undefined : widthNumber.value\n  const height = Number.isNaN(heightNumber.value) ? undefined : heightNumber.value\n  if (props.blank) {\n    if (width !== undefined && height === undefined) {\n      return {height: width, width}\n    }\n    if (width === undefined && height !== undefined) {\n      return {height, width: height}\n    }\n    return {height: 1, width: 1}\n  }\n  return {\n    width,\n    height,\n  }\n})\n\nconst computedBlankImgSrc = toRef(() =>\n  makeBlankImgSrc(computedDimentions.value.width, computedDimentions.value.height, props.blankColor)\n)\n\nconst alignment = toRef(() =>\n  props.start ? 'float-start' : props.end ? 'float-end' : props.center ? 'mx-auto' : undefined\n)\n\nconst computedClasses = computed(() => [\n  radiusElementClasses.value,\n  {\n    'img-thumbnail': props.thumbnail,\n    'img-fluid': props.fluid || props.fluidGrow,\n    'w-100': props.fluidGrow,\n    [`${alignment.value}`]: alignment.value !== undefined,\n    'd-block': props.block || props.center,\n  },\n])\n\nconst makeBlankImgSrc = (width: number | undefined, height: number | undefined, color: string) =>\n  `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"none\">\n    <rect width=\"100%\" height=\"100%\" style=\"fill:${color};\"></rect>\n    </svg>`)}`\n</script>\n","<template>\n  <BImg v-bind=\"computedImgProps\" :class=\"baseClass\" />\n</template>\n\n<script setup lang=\"ts\">\nimport BImg from '../BImg.vue'\nimport type {BCardImageProps} from '../../types'\nimport {omit} from '../../utils'\nimport {computed, toRef} from 'vue'\n\nconst props = withDefaults(defineProps<BCardImageProps>(), {\n  bottom: false,\n  top: false,\n  // BImg props\n  blank: undefined,\n  blankColor: undefined,\n  block: undefined,\n  center: undefined,\n  end: undefined,\n  fluid: undefined,\n  fluidGrow: undefined,\n  height: undefined,\n  lazy: undefined,\n  rounded: undefined,\n  roundedBottom: undefined,\n  roundedEnd: undefined,\n  roundedStart: undefined,\n  roundedTop: undefined,\n  sizes: undefined,\n  src: undefined,\n  srcset: undefined,\n  start: undefined,\n  thumbnail: undefined,\n  width: undefined,\n  // End BImg props\n})\n\nconst baseClass = toRef(() =>\n  props.top\n    ? 'card-img-top'\n    : props.end\n      ? 'card-img-right'\n      : props.bottom\n        ? 'card-img-bottom'\n        : props.start\n          ? 'card-img-left'\n          : 'card-img'\n)\n\nconst computedImgProps = computed(() => omit(props, ['bottom', 'top', 'end', 'start']))\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <!-- eslint-disable-next-line vue/no-v-html -->\n    <div v-if=\"!!html\" v-html=\"html\" />\n    <slot v-else>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {BCardHeadFootProps} from '../../types'\nimport {useColorVariantClasses} from '../../composables'\n\nconst props = withDefaults(defineProps<BCardHeadFootProps>(), {\n  borderVariant: null,\n  html: undefined,\n  tag: 'div',\n  text: undefined,\n  // ColorExtendables props\n  bgVariant: null,\n  textVariant: null,\n  variant: null,\n  // End ColorExtendables props\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst resolvedBackgroundClasses = useColorVariantClasses(props)\n\nconst computedClasses = computed(() => [\n  resolvedBackgroundClasses.value,\n  {\n    [`border-${props.borderVariant}`]: props.borderVariant !== null,\n  },\n])\n</script>\n","<template>\n  <BCardHeadFoot class=\"card-header\" v-bind=\"props\">\n    <slot />\n  </BCardHeadFoot>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BCardHeadFootProps} from '../../types'\nimport BCardHeadFoot from './BCardHeadFoot.vue'\n\nconst props = withDefaults(defineProps<BCardHeadFootProps>(), {\n  borderVariant: undefined,\n  html: undefined,\n  tag: 'div',\n  text: undefined,\n  // ColorExtendables props\n  bgVariant: undefined,\n  textVariant: undefined,\n  variant: undefined,\n  // End ColorExtendables props\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n</script>\n","<template>\n  <component :is=\"tag\" class=\"card-subtitle mb-2\" :class=\"computedClasses\">\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BCardSubtitleProps} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(defineProps<BCardSubtitleProps>(), {\n  tag: 'h6',\n  text: undefined,\n  textVariant: 'body-secondary',\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`text-${props.textVariant}`]: props.textVariant !== null,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" class=\"card-body\" :class=\"computedClasses\">\n    <BCardTitle v-if=\"!!title || hasTitleSlot\" :tag=\"titleTag\">\n      <slot name=\"title\">\n        {{ title }}\n      </slot>\n    </BCardTitle>\n\n    <BCardSubtitle\n      v-if=\"!!subtitle || hasSubtitleSlot\"\n      :tag=\"subtitleTag\"\n      :text-variant=\"subtitleTextVariant\"\n    >\n      <slot name=\"subtitle\">\n        {{ subtitle }}\n      </slot>\n    </BCardSubtitle>\n\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport BCardTitle from './BCardTitle.vue'\nimport {isEmptySlot} from '../../utils'\nimport BCardSubtitle from './BCardSubtitle.vue'\nimport type {BCardBodyProps} from '../../types'\nimport {useColorVariantClasses} from '../../composables'\n\nconst props = withDefaults(defineProps<BCardBodyProps>(), {\n  overlay: false,\n  subtitle: undefined,\n  subtitleTag: 'h4',\n  subtitleTextVariant: undefined,\n  tag: 'div',\n  text: undefined,\n  title: undefined,\n  titleTag: 'h4',\n  // ColorExtendables props\n  bgVariant: null,\n  textVariant: null,\n  variant: null,\n  // End ColorExtendables props\n})\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  subtitle?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  title?: (props: Record<string, never>) => any\n}>()\n\nconst resolvedBackgroundClasses = useColorVariantClasses(props)\n\nconst hasTitleSlot = toRef(() => !isEmptySlot(slots.title))\nconst hasSubtitleSlot = toRef(() => !isEmptySlot(slots.subtitle))\n\nconst computedClasses = computed(() => [\n  resolvedBackgroundClasses.value,\n  {\n    'card-img-overlay': props.overlay,\n  },\n])\n</script>\n","<template>\n  <BCardHeadFoot class=\"card-footer\" v-bind=\"props\">\n    <slot>\n      {{ text }}\n    </slot>\n  </BCardHeadFoot>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BCardHeadFootProps} from '../../types'\nimport BCardHeadFoot from './BCardHeadFoot.vue'\n\nconst props = withDefaults(defineProps<BCardHeadFootProps>(), {\n  borderVariant: undefined,\n  html: undefined,\n  tag: 'div',\n  text: undefined,\n  // ColorExtendables props\n  bgVariant: undefined,\n  textVariant: undefined,\n  variant: undefined,\n  // End ColorExtendables props\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n</script>\n","<template>\n  <component :is=\"tag\" class=\"card\" :class=\"computedClasses\">\n    <ReusableImg.define>\n      <slot name=\"img\">\n        <BCardImg v-if=\"imgSrc\" v-bind=\"imgAttr\" />\n      </slot>\n    </ReusableImg.define>\n\n    <ReusableImg.reuse v-if=\"!props.imgBottom\" />\n    <BCardHeader\n      v-if=\"header || hasHeaderSlot || headerHtml\"\n      :bg-variant=\"headerBgVariant\"\n      :variant=\"headerVariant\"\n      :border-variant=\"headerBorderVariant\"\n      :html=\"headerHtml\"\n      :tag=\"headerTag\"\n      :text-variant=\"headerTextVariant\"\n      :class=\"headerClass\"\n    >\n      <slot name=\"header\">\n        {{ header }}\n      </slot>\n    </BCardHeader>\n    <BCardBody\n      v-if=\"!props.noBody\"\n      :overlay=\"overlay\"\n      :bg-variant=\"bodyBgVariant\"\n      :tag=\"bodyTag\"\n      :text-variant=\"bodyTextVariant\"\n      :subtitle=\"subtitle\"\n      :subtitle-tag=\"subtitleTag\"\n      :subtitle-text-variant=\"subtitleTextVariant\"\n      :title=\"title\"\n      :title-tag=\"titleTag\"\n      :class=\"bodyClass\"\n    >\n      <slot>\n        {{ bodyText }}\n      </slot>\n    </BCardBody>\n    <slot v-else>\n      {{ bodyText }}\n    </slot>\n    <BCardFooter\n      v-if=\"footer || hasFooterSlot || footerHtml\"\n      :bg-variant=\"footerBgVariant\"\n      :border-variant=\"footerBorderVariant\"\n      :variant=\"footerVariant\"\n      :html=\"footerHtml\"\n      :tag=\"footerTag\"\n      :text-variant=\"footerTextVariant\"\n      :class=\"footerClass\"\n    >\n      <slot name=\"footer\">\n        {{ footer }}\n      </slot>\n    </BCardFooter>\n    <ReusableImg.reuse v-if=\"props.imgBottom\" />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BCardProps} from '../../types'\nimport {isEmptySlot} from '../../utils'\nimport {computed, toRef} from 'vue'\nimport {useColorVariantClasses} from '../../composables'\nimport BCardImg from './BCardImg.vue'\nimport BCardHeader from './BCardHeader.vue'\nimport BCardBody from './BCardBody.vue'\nimport BCardFooter from './BCardFooter.vue'\nimport {createReusableTemplate} from '@vueuse/core'\n\nconst props = withDefaults(defineProps<BCardProps>(), {\n  align: undefined,\n  bodyBgVariant: undefined,\n  bodyClass: undefined,\n  bodyTag: 'div',\n  bodyText: '',\n  bodyTextVariant: undefined,\n  borderVariant: null,\n  footer: undefined,\n  footerBgVariant: undefined,\n  footerBorderVariant: undefined,\n  footerClass: undefined,\n  footerHtml: '',\n  footerTag: 'div',\n  footerTextVariant: undefined,\n  footerVariant: null,\n  header: undefined,\n  headerBgVariant: undefined,\n  headerBorderVariant: undefined,\n  headerClass: undefined,\n  headerHtml: '',\n  headerTag: 'div',\n  headerTextVariant: undefined,\n  headerVariant: null,\n  imgAlt: undefined,\n  imgBottom: false,\n  imgEnd: false,\n  imgHeight: undefined,\n  imgSrc: undefined,\n  imgStart: false,\n  imgTop: false,\n  imgWidth: undefined,\n  noBody: false,\n  overlay: false,\n  subtitle: undefined,\n  subtitleTag: 'h6',\n  subtitleTextVariant: 'body-secondary',\n  tag: 'div',\n  title: undefined,\n  titleTag: 'h4',\n  // ColorExtendables props\n  bgVariant: null,\n  textVariant: null,\n  variant: null,\n  // End ColorExtendables props\n})\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  footer?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  header?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  img?: (props: Record<string, never>) => any\n}>()\n\nconst hasHeaderSlot = toRef(() => !isEmptySlot(slots.header))\nconst hasFooterSlot = toRef(() => !isEmptySlot(slots.footer))\n\nconst resolvedBackgroundClasses = useColorVariantClasses(props)\n\nconst computedClasses = computed(() => [\n  resolvedBackgroundClasses.value,\n  {\n    [`text-${props.align}`]: props.align !== undefined,\n    [`border-${props.borderVariant}`]: props.borderVariant !== null,\n    'flex-row': props.imgStart,\n    'flex-row-reverse': props.imgEnd,\n  },\n])\n\nconst imgAttr = computed(() => ({\n  src: props.imgSrc,\n  alt: props.imgAlt,\n  height: props.imgHeight,\n  width: props.imgWidth,\n  bottom: props.imgBottom,\n  end: props.imgEnd,\n  start: props.imgStart,\n  top: props.imgTop,\n}))\n\nconst ReusableImg = createReusableTemplate()\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"cardTypeClass\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BCardGroupProps} from '../../types'\nimport {toRef} from 'vue'\n\nconst props = withDefaults(defineProps<BCardGroupProps>(), {\n  columns: false,\n  deck: false,\n  tag: 'div',\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst cardTypeClass = toRef(() =>\n  props.deck ? 'card-deck' : props.columns ? 'card-columns' : 'card-group'\n)\n</script>\n","<template>\n  <div :id=\"computedId\" ref=\"element\" class=\"carousel slide pointer-event\" :class=\"computedClasses\">\n    <div v-if=\"props.indicators\" class=\"carousel-indicators\">\n      <!-- :data-bs-target=\"`#${computedId}`\" is required since the classes target elems with that attr -->\n      <button\n        v-for=\"(_, i) in slides.length\"\n        :key=\"i\"\n        type=\"button\"\n        data-bs-target=\"\"\n        :class=\"i === modelValue ? 'active' : ''\"\n        :aria-current=\"i === modelValue ? true : undefined\"\n        :aria-label=\"`${indicatorsButtonLabel} ${i}`\"\n        @click=\"goToValue(i)\"\n      />\n    </div>\n\n    <div ref=\"relatedTarget\" class=\"carousel-inner\">\n      <TransitionGroup\n        :enter-from-class=\"enterClasses\"\n        :enter-active-class=\"enterClasses\"\n        :enter-to-class=\"enterClasses\"\n        :leave-from-class=\"leaveClasses\"\n        :leave-active-class=\"leaveClasses\"\n        :leave-to-class=\"leaveClasses\"\n        @before-leave=\"onBeforeLeave\"\n        @after-leave=\"onAfterLeave\"\n        @after-enter=\"onAfterEnter\"\n      >\n        <component\n          :is=\"slide\"\n          v-for=\"(slide, i) in slides\"\n          v-show=\"i === modelValue\"\n          :key=\"i\"\n          :class=\"{active: i === modelValue && isTransitioning === false}\"\n        />\n      </TransitionGroup>\n    </div>\n\n    <template v-if=\"props.controls\">\n      <button class=\"carousel-control-prev\" type=\"button\" @click=\"prev\">\n        <span class=\"carousel-control-prev-icon\" aria-hidden=\"true\" />\n        <span class=\"visually-hidden\">{{ controlsPrevText }}</span>\n      </button>\n      <button class=\"carousel-control-next\" type=\"button\" @click=\"next\">\n        <span class=\"carousel-control-next-icon\" aria-hidden=\"true\" />\n        <span class=\"visually-hidden\">{{ controlsNextText }}</span>\n      </button>\n    </template>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {BvCarouselEvent, carouselInjectionKey, getSlotElements} from '../../utils'\nimport {computed, provide, ref, toRef, watch} from 'vue'\nimport {useId} from '../../composables'\nimport type {BCarouselProps} from '../../types'\nimport {onKeyStroke, useElementHover, useIntervalFn, useSwipe, useToNumber} from '@vueuse/core'\n\nconst props = withDefaults(defineProps<BCarouselProps>(), {\n  background: undefined,\n  controls: false,\n  controlsNextText: 'Next',\n  controlsPrevText: 'Previous',\n  fade: false,\n  id: undefined,\n  imgHeight: undefined,\n  imgWidth: undefined,\n  indicators: false,\n  indicatorsButtonLabel: 'Slide',\n  interval: 5000,\n  keyboard: true,\n  noHoverPause: false,\n  noTouch: false,\n  noWrap: false,\n  // eslint-disable-next-line vue/require-valid-default-prop\n  ride: false,\n  rideReverse: false,\n  touchThreshold: 50,\n})\n\nconst emit = defineEmits<{\n  slide: [value: BvCarouselEvent]\n  slid: [value: BvCarouselEvent]\n}>()\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedId = useId(() => props.id, 'carousel')\n\nconst modelValue = defineModel<number>({default: 0})\n\nconst touchThresholdNumber = useToNumber(() => props.touchThreshold)\nconst intervalNumber = useToNumber(() => props.interval)\n\nconst isTransitioning = ref(false)\nconst rideStarted = ref(false)\nconst direction = ref(true)\nconst relatedTarget = ref<HTMLElement | null>(null)\nconst element = ref<HTMLElement | null>(null)\nconst previousModelValue = ref(modelValue.value)\n\nconst isHovering = useElementHover(element)\n\n// Class carousel-item is a static property\n// If you make it static, the direction can be reversed -- properly (atm it does the carousel-item-${} logic backwards for entering, a weird hack)\n// So all that would be great. However, when you do this, it will break the transition flow. Something about it breaks and I'm not sure why!\n// Try it by removing carousel-item from below and making `!direction.value` => `direction.value` for enter\n// Then reviewing the behavior\nconst enterClasses = toRef(\n  () =>\n    `carousel-item carousel-item-${!direction.value ? 'next' : 'prev'} carousel-item-${\n      !direction.value ? 'start' : 'end'\n    }`\n)\nconst leaveClasses = toRef(\n  () => `carousel-item active carousel-item-${direction.value ? 'start' : 'end'}`\n)\n\nconst {pause, resume} = useIntervalFn(\n  () => {\n    props.rideReverse ? prev() : next()\n  },\n  intervalNumber,\n  {immediate: props.ride === 'carousel'}\n)\n\nconst isRiding = toRef(\n  () => (props.ride === true && rideStarted.value === true) || props.ride === 'carousel'\n)\nconst slides = computed(() => getSlotElements(slots.default, 'BCarouselSlide'))\nconst computedClasses = computed(() => ({'carousel-fade': props.fade}))\n// TODO a general idea of showing only slides that are in bounds\n// const localValue = computed(() =>\n//   props.modelValue >= slides.value.length\n//     ? slides.value.length - 1\n//     : props.modelValue < 0\n//     ? 0\n//     : props.modelValue\n// )\n\nconst buildBvCarouselEvent = (event: 'slid' | 'slide') =>\n  new BvCarouselEvent(event, {\n    componentId: computedId.value,\n    cancelable: false,\n    target: element.value,\n    direction: direction.value ? 'right' : 'left',\n    from: previousModelValue.value,\n    to: modelValue.value,\n    relatedTarget: relatedTarget.value?.children[modelValue.value] ?? null,\n  })\n\nconst goToValue = (value: number): void => {\n  if (isTransitioning.value === true) return\n\n  if (props.ride === true) {\n    rideStarted.value = true\n  }\n  if (isRiding.value === true) {\n    resume()\n  }\n  direction.value = value < modelValue.value ? false : true\n  if (value >= slides.value.length) {\n    if (props.noWrap) return\n    modelValue.value = 0\n    return\n  }\n  if (value < 0) {\n    if (props.noWrap) return\n    modelValue.value = slides.value.length - 1\n    return\n  }\n  previousModelValue.value = modelValue.value\n  modelValue.value = value\n}\n\nconst prev = (): void => {\n  goToValue(modelValue.value - 1)\n}\nconst next = (): void => {\n  goToValue(modelValue.value + 1)\n}\n\nconst onKeydown = (fn: () => void) => {\n  if (props.keyboard === false) return\n  fn()\n}\n\nconst onMouseEnter = () => {\n  if (props.noHoverPause) return\n  pause()\n}\nconst onMouseLeave = () => {\n  if (!isRiding.value) return\n  resume()\n}\n\nconst {lengthX} = useSwipe(element, {\n  passive: true,\n  onSwipeStart() {\n    if (props.noTouch === true) return\n    pause()\n  },\n  onSwipeEnd() {\n    if (props.noTouch === true) return\n    const resumeRiding = () => {\n      if (isRiding.value === false) return\n      resume()\n    }\n    if (lengthX.value >= touchThresholdNumber.value) {\n      next()\n      resumeRiding()\n      return\n    }\n    if (lengthX.value <= -touchThresholdNumber.value) {\n      prev()\n      resumeRiding()\n    }\n  },\n})\n\nconst onBeforeLeave = () => {\n  emit('slide', buildBvCarouselEvent('slide'))\n  isTransitioning.value = true\n}\nconst onAfterLeave = () => {\n  emit('slid', buildBvCarouselEvent('slid'))\n  isTransitioning.value = false\n}\n// carousel-item class is removed from the slide during the transition,\n// as is included within enter classes.\n// The first slide recovers carousel-item class,\nconst onAfterEnter = (el: Readonly<Element>) => {\n  if (modelValue.value !== 0) {\n    el.classList.add('carousel-item')\n  }\n}\n\nonKeyStroke(\n  'ArrowLeft',\n  () => {\n    onKeydown(prev)\n  },\n  {target: element}\n)\nonKeyStroke(\n  'ArrowRight',\n  () => {\n    onKeydown(next)\n  },\n  {target: element}\n)\n\nwatch(\n  () => props.ride,\n  () => {\n    rideStarted.value = false\n  }\n)\n\nwatch(isHovering, (newValue) => {\n  if (newValue) {\n    onMouseEnter()\n    return\n  }\n  onMouseLeave()\n})\n\ndefineExpose({\n  next,\n  pause,\n  prev,\n  resume,\n})\n\nprovide(carouselInjectionKey, {\n  background: toRef(() => props.background),\n  width: toRef(() => props.imgWidth),\n  height: toRef(() => props.imgHeight),\n})\n</script>\n","<template>\n  <div class=\"carousel-item\" :style=\"computedStyle\">\n    <slot name=\"img\">\n      <BImg\n        class=\"d-block w-100\"\n        :alt=\"imgAlt\"\n        :srcset=\"imgSrcset\"\n        :src=\"imgSrc\"\n        :width=\"imgWidth || parentData?.width.value\"\n        :height=\"imgHeight || parentData?.height.value\"\n        :blank=\"imgBlank\"\n        :blank-color=\"imgBlankColor\"\n      />\n    </slot>\n    <component\n      :is=\"contentTag\"\n      v-if=\"hasContent\"\n      class=\"carousel-caption\"\n      :class=\"computedContentClasses\"\n    >\n      <component :is=\"captionTag\" v-if=\"hasCaption\">\n        <slot name=\"caption\">\n          <!-- eslint-disable-next-line vue/no-v-html -->\n          <span v-if=\"captionHtml\" v-html=\"captionHtml\" />\n          <span v-else>{{ caption }}</span>\n        </slot>\n      </component>\n      <component :is=\"textTag\" v-if=\"hasText\">\n        <slot name=\"text\">\n          <!-- eslint-disable-next-line vue/no-v-html -->\n          <span v-if=\"textHtml\" v-html=\"textHtml\" />\n          <span v-else>{{ text }}</span>\n        </slot>\n      </component>\n      <slot />\n    </component>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, type CSSProperties, inject, toRef} from 'vue'\nimport type {BCarouselSlideProps} from '../../types'\nimport {carouselInjectionKey, isEmptySlot} from '../../utils'\nimport BImg from '../BImg.vue'\n\n// TODO interval is unused\n// Need to add https://getbootstrap.com/docs/5.3/components/carousel/#individual-carousel-item-interval\n// Perhaps a provide/inject with next/prev values where the component can call those would work.\n\nconst props = withDefaults(defineProps<BCarouselSlideProps>(), {\n  background: undefined,\n  caption: undefined,\n  captionHtml: undefined,\n  captionTag: 'h3',\n  contentTag: 'div',\n  contentVisibleUp: undefined,\n  id: undefined,\n  imgAlt: undefined,\n  imgBlank: false,\n  imgBlankColor: 'transparent',\n  imgHeight: undefined,\n  imgSrc: undefined,\n  imgSrcset: undefined,\n  imgWidth: undefined,\n  interval: undefined,\n  text: undefined,\n  textHtml: undefined,\n  textTag: 'p',\n})\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  caption?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  img?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  text?: (props: Record<string, never>) => any\n}>()\n\nconst parentData = inject(carouselInjectionKey, null)\n\nconst hasText = toRef(() => props.text || props.textHtml || !isEmptySlot(slots.text))\nconst hasCaption = toRef(() => props.caption || props.captionHtml || !isEmptySlot(slots.caption))\nconst hasContent = toRef(() => hasText.value || hasCaption.value || !isEmptySlot(slots.default))\n\nconst computedStyle = computed<CSSProperties>(() => ({\n  background: `${\n    props.background || parentData?.background.value || 'rgb(171, 171, 171)'\n  } none repeat scroll 0% 0%`,\n}))\n\nconst computedContentClasses = computed(() => ({\n  'd-none': props.contentVisibleUp !== undefined,\n  [`d-${props.contentVisibleUp}-block`]: props.contentVisibleUp !== undefined,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {computed, defineComponent, type PropType, type SlotsType} from 'vue'\nimport type {AlignmentVertical} from '../types'\nimport {getBreakpointProps, getClasses} from '../utils'\n\nconst breakpointCol = getBreakpointProps('', [], {type: [Boolean, String, Number], default: false})\nconst breakpointOffset = getBreakpointProps('offset', [''], {type: [String, Number], default: null})\nconst breakpointOrder = getBreakpointProps('order', [''], {type: [String, Number], default: null})\n\nexport default defineComponent({\n  name: 'BCol',\n  slots: Object as SlotsType<{\n    default?: Record<string, never>\n  }>,\n  props: {\n    col: {type: Boolean, default: false}, // Generic flexbox .col (xs)\n    cols: {type: [String, Number], default: null}, // .col-[1-12]|auto (xs)\n    ...breakpointCol,\n    offset: {type: [String, Number], default: null},\n    ...breakpointOffset,\n    order: {type: [String, Number], default: null},\n    ...breakpointOrder,\n    alignSelf: {type: String as PropType<AlignmentVertical | 'auto'>, default: null},\n    tag: {type: String, default: 'div'},\n  },\n  setup(props) {\n    const properties = [\n      {content: breakpointCol, propPrefix: 'cols', classPrefix: 'col'},\n      {content: breakpointOffset, propPrefix: 'offset'},\n      {content: breakpointOrder, propPrefix: 'order'},\n    ]\n\n    const classList = computed(() =>\n      properties.flatMap((el) => getClasses(props, el.content, el.propPrefix, el.classPrefix))\n    )\n\n    const computedClasses = computed(() => [\n      classList.value,\n      {\n        col: props.col || (!classList.value.some((e) => /^col-/.test(e)) && !props.cols),\n        [`col-${props.cols}`]: !!props.cols,\n        [`offset-${props.offset}`]: !!props.offset,\n        [`order-${props.order}`]: !!props.order,\n        [`align-self-${props.alignSelf}`]: !!props.alignSelf,\n      },\n    ])\n\n    return {\n      computedClasses,\n    }\n  },\n})\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BContainerProps} from '../types'\nimport {computed} from 'vue'\nimport {useToNumber} from '@vueuse/core'\n\nconst props = withDefaults(defineProps<BContainerProps>(), {\n  fluid: false,\n  gutterX: undefined,\n  gutterY: undefined,\n  tag: 'div',\n})\n\nconst gutterXToNumber = useToNumber(() => props.gutterX ?? NaN, {method: 'parseInt'})\nconst gutterYToNumber = useToNumber(() => props.gutterY ?? NaN, {method: 'parseInt'})\n\nconst computedClasses = computed(() => ({\n  container: props.fluid === false,\n  [`container-fluid`]: props.fluid === true,\n  [`container-${props.fluid}`]: typeof props.fluid === 'string',\n  [`gx-${gutterXToNumber.value}`]: !Number.isNaN(gutterXToNumber.value),\n  [`gy-${gutterYToNumber.value}`]: !Number.isNaN(gutterYToNumber.value),\n}))\n</script>\n","<template>\n  <div ref=\"wrapper\" :class=\"computedClasses\" class=\"btn-group\">\n    <BButton\n      :id=\"computedId\"\n      ref=\"splitButton\"\n      :variant=\"splitVariant || variant\"\n      :size=\"size\"\n      :class=\"buttonClasses\"\n      :disabled=\"props.splitDisabled || disabled\"\n      :type=\"splitButtonType\"\n      :aria-label=\"ariaLabel\"\n      :aria-expanded=\"props.split ? undefined : modelValue\"\n      :aria-haspopup=\"props.split ? undefined : 'menu'\"\n      :href=\"props.split ? splitHref : undefined\"\n      :to=\"props.split && splitTo ? splitTo : undefined\"\n      @click=\"onSplitClick\"\n    >\n      <slot name=\"button-content\">\n        {{ text }}\n      </slot>\n    </BButton>\n    <BButton\n      v-if=\"props.split\"\n      ref=\"button\"\n      :variant=\"variant\"\n      :size=\"size\"\n      :disabled=\"disabled\"\n      :class=\"[toggleClass, {show: modelValue}]\"\n      class=\"dropdown-toggle-split dropdown-toggle\"\n      :aria-expanded=\"modelValue\"\n      aria-haspopup=\"menu\"\n      @click=\"onButtonClick\"\n    >\n      <span class=\"visually-hidden\">\n        <slot name=\"toggle-text\">\n          {{ toggleText }}\n        </slot>\n      </span>\n    </BButton>\n    <Teleport :to=\"teleportTo\" :disabled=\"!teleportTo || teleportDisabled\">\n      <ul\n        v-if=\"!props.lazy || modelValue\"\n        v-show=\"props.lazy || modelValue\"\n        ref=\"floating\"\n        :style=\"[floatingStyles, sizeStyles]\"\n        class=\"dropdown-menu overflow-auto\"\n        :class=\"[menuClass, {show: modelValue}]\"\n        :aria-labelledby=\"computedId\"\n        :role=\"role\"\n        @click=\"onClickInside\"\n      >\n        <slot :hide=\"hide\" :show=\"show\" />\n      </ul>\n    </Teleport>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {\n  autoUpdate,\n  type Boundary,\n  flip,\n  type Middleware,\n  offset as offsetMiddleware,\n  type RootBoundary,\n  shift,\n  size as sizeMiddleware,\n  useFloating,\n} from '@floating-ui/vue'\nimport {onClickOutside, onKeyStroke, useToNumber} from '@vueuse/core'\nimport {computed, type CSSProperties, nextTick, provide, ref, toRef, watch} from 'vue'\nimport {useId} from '../../composables'\nimport type {BDropdownProps} from '../../types'\nimport {BvTriggerableEvent, dropdownInjectionKey, resolveFloatingPlacement} from '../../utils'\nimport BButton from '../BButton/BButton.vue'\n\n// TODO add navigation through keyboard events\n// TODO standardize keydown vs keyup events globally\n\nconst props = withDefaults(defineProps<BDropdownProps>(), {\n  ariaLabel: undefined,\n  autoClose: true,\n  boundary: 'clippingAncestors',\n  boundaryPadding: undefined,\n  center: false,\n  teleportTo: undefined,\n  teleportDisabled: false,\n  disabled: false,\n  dropend: false,\n  dropstart: false,\n  dropup: false,\n  end: false,\n  floatingMiddleware: undefined,\n  id: undefined,\n  isNav: false,\n  lazy: false,\n  menuClass: undefined,\n  noCaret: false,\n  noFlip: false,\n  noShift: false,\n  noSize: false,\n  offset: 0,\n  role: 'menu',\n  size: 'md',\n  split: false,\n  splitButtonType: 'button',\n  splitClass: undefined,\n  splitDisabled: undefined,\n  splitHref: undefined,\n  splitTo: undefined,\n  splitVariant: undefined,\n  strategy: 'absolute',\n  text: undefined,\n  toggleClass: undefined,\n  toggleText: 'Toggle dropdown',\n  variant: 'secondary',\n})\n\nconst emit = defineEmits<{\n  'click': [event: MouseEvent]\n  'hidden': []\n  'hide': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'shown': []\n  'toggle': []\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'button-content'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: {hide: () => void; show: () => void}) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'toggle-text'?: (props: Record<string, never>) => any\n}>()\n\nconst computedId = useId(() => props.id, 'dropdown')\n\nconst modelValue = defineModel<boolean>({default: false})\n\nconst computedOffset = toRef(() =>\n  typeof props.offset === 'string' || typeof props.offset === 'number' ? props.offset : NaN\n)\nconst offsetToNumber = useToNumber(computedOffset)\n\nconst floating = ref<HTMLElement | null>(null)\nconst button = ref<HTMLElement | null>(null)\nconst splitButton = ref<HTMLElement | null>(null)\nconst wrapper = ref<HTMLElement | null>(null)\n\nconst boundary = computed<Boundary | undefined>(() =>\n  props.boundary === 'document' || props.boundary === 'viewport' ? undefined : props.boundary\n)\nconst rootBoundary = computed<RootBoundary | undefined>(() =>\n  props.boundary === 'document' || props.boundary === 'viewport' ? props.boundary : undefined\n)\n\nconst referencePlacement = toRef(() => (!props.split ? splitButton.value : button.value))\n\nonKeyStroke(\n  'Escape',\n  () => {\n    modelValue.value = !modelValue.value\n  },\n  {target: referencePlacement}\n)\nonKeyStroke(\n  'Escape',\n  () => {\n    modelValue.value = !modelValue.value\n  },\n  {target: floating}\n)\n\nconst keynav = (e: Readonly<Event>, v: number) => {\n  if (floating.value?.contains((e.target as HTMLElement)?.closest('form'))) return\n  if (/input|select|option|textarea|form/i.test((e.target as HTMLElement)?.tagName)) return\n  e.preventDefault()\n  if (!modelValue.value) {\n    open()\n    nextTick(() => keynav(e, v))\n    return\n  }\n  const list = floating.value?.querySelectorAll('.dropdown-item:not(.disabled):not(:disabled)')\n  if (!list) return\n  if (floating.value?.contains(document.activeElement)) {\n    const active = floating.value.querySelector('.dropdown-item:focus')\n    const index = Array.prototype.indexOf.call(list, active) + v\n    if (index >= 0 && index < list?.length) (list[index] as HTMLElement)?.focus()\n  } else {\n    ;(list[v === -1 ? list.length - 1 : 0] as HTMLElement)?.focus()\n  }\n}\n\nonKeyStroke('ArrowUp', (e) => keynav(e, -1), {target: referencePlacement})\nonKeyStroke('ArrowDown', (e) => keynav(e, 1), {target: referencePlacement})\nonKeyStroke('ArrowUp', (e) => keynav(e, -1), {target: floating})\nonKeyStroke('ArrowDown', (e) => keynav(e, 1), {target: floating})\n\nconst floatingPlacement = computed(() =>\n  resolveFloatingPlacement({\n    top: props.dropup,\n    start: props.dropstart,\n    end: props.dropend,\n    alignCenter: props.center,\n    alignEnd: props.end,\n  })\n)\nconst sizeStyles = ref<CSSProperties>({})\nconst floatingMiddleware = computed<Middleware[]>(() => {\n  if (props.floatingMiddleware !== undefined) {\n    return props.floatingMiddleware\n  }\n  const localOffset =\n    typeof props.offset === 'string' || typeof props.offset === 'number'\n      ? offsetToNumber.value\n      : props.offset\n  const arr: Middleware[] = [offsetMiddleware(localOffset)]\n  if (props.noFlip === false) {\n    arr.push(\n      flip({\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n      })\n    )\n  }\n  if (props.noShift === false) {\n    arr.push(\n      shift({\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n      })\n    )\n  }\n  if (props.noSize === false) {\n    arr.push(\n      sizeMiddleware({\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n        apply({availableWidth, availableHeight}) {\n          sizeStyles.value = {\n            maxHeight: availableHeight && modelValue.value ? `${availableHeight}px` : undefined,\n            maxWidth: availableWidth && modelValue.value ? `${availableWidth}px` : undefined,\n          }\n        },\n      })\n    )\n  }\n  return arr\n})\nconst {update, floatingStyles} = useFloating(referencePlacement, floating, {\n  placement: floatingPlacement,\n  middleware: floatingMiddleware,\n  strategy: toRef(() => props.strategy),\n  whileElementsMounted: autoUpdate,\n})\n\nconst computedClasses = computed(() => ({\n  'dropup': props.dropup,\n  'dropend': props.dropend,\n  'dropstart': props.dropstart,\n  'position-static': props.boundary !== 'clippingAncestors' && !props.isNav,\n}))\n\nconst buttonClasses = computed(() => [\n  props.split ? props.splitClass : props.toggleClass,\n  {\n    'nav-link': props.isNav,\n    'dropdown-toggle': !props.split,\n    'dropdown-toggle-no-caret': props.noCaret && !props.split,\n    'show': props.split ? undefined : modelValue.value,\n  },\n])\n\nconst onButtonClick = () => {\n  toggle()\n}\n\nconst onSplitClick = (event: Readonly<MouseEvent>) => {\n  props.split ? emit('click', event) : onButtonClick()\n}\n\nonClickOutside(\n  floating,\n  () => {\n    if (modelValue.value && (props.autoClose === true || props.autoClose === 'outside')) {\n      toggle()\n    }\n  },\n  {ignore: [button, splitButton]}\n)\nconst onClickInside = () => {\n  if (modelValue.value && (props.autoClose === true || props.autoClose === 'inside')) {\n    toggle()\n  }\n}\n\nconst hide = () => {\n  modelValue.value && toggle()\n}\nconst show = () => {\n  modelValue.value || toggle()\n}\nconst toggle = () => {\n  emit('toggle')\n  const currentModelValue = modelValue.value\n  const e = new BvTriggerableEvent(currentModelValue ? 'hide' : 'show')\n  currentModelValue ? emit('hide', e) : emit('show', e)\n  if (e.defaultPrevented) {\n    currentModelValue ? emit('hide-prevented') : emit('show-prevented')\n    return\n  }\n  modelValue.value = !currentModelValue\n  currentModelValue ? emit('hidden') : emit('shown')\n  wrapper.value?.dispatchEvent(new Event('forceHide'))\n}\n\nwatch(modelValue, () => {\n  update()\n})\n\ndefineExpose({\n  hide,\n  show,\n  toggle,\n})\n\nprovide(dropdownInjectionKey, {\n  id: computedId,\n  show,\n  hide,\n  toggle,\n  visible: toRef(() => modelValue.value),\n  isNav: toRef(() => props.isNav),\n})\n</script>\n","<template>\n  <li role=\"presentation\">\n    <component\n      :is=\"headerTag\"\n      :id=\"headerId\"\n      class=\"dropdown-header\"\n      :class=\"computedClasses\"\n      :role=\"headerRole\"\n    >\n      <slot name=\"header\">\n        {{ header }}\n      </slot>\n    </component>\n    <ul\n      :id=\"id\"\n      role=\"group\"\n      class=\"list-unstyled\"\n      v-bind=\"$attrs\"\n      :aria-describedby=\"ariaDescribedby || headerId\"\n    >\n      <slot />\n    </ul>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BDropdownGroupProps} from '../../types'\nimport {computed, toRef} from 'vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<BDropdownGroupProps>(), {\n  ariaDescribedby: undefined,\n  header: undefined,\n  headerClass: undefined,\n  headerTag: 'header',\n  headerVariant: null,\n  id: undefined,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  header?: (props: Record<string, never>) => any\n}>()\n\nconst headerId = toRef(() => (props.id ? `${props.id}_group_dd_header` : undefined))\nconst headerRole = toRef(() => (props.headerTag === 'header' ? undefined : 'heading'))\n\nconst computedClasses = computed(() => [\n  props.headerClass,\n  {\n    [`text-${props.headerVariant}`]: props.headerVariant !== null,\n  },\n])\n</script>\n","<template>\n  <li role=\"presentation\" :class=\"wrapperClass\" v-bind=\"wrapperAttrs\">\n    <component\n      :is=\"computedTag\"\n      class=\"dropdown-item\"\n      :class=\"computedClasses\"\n      :disabled=\"props.disabled\"\n      :aria-disabled=\"props.disabled ? true : null\"\n      :aria-current=\"props.active ? true : null\"\n      :href=\"computedTag === 'a' ? href : null\"\n      :rel=\"rel\"\n      role=\"menuitem\"\n      :type=\"computedTag === 'button' ? 'button' : null\"\n      :target=\"target\"\n      v-bind=\"{...computedLinkProps, ...attrs}\"\n      @click=\"clicked\"\n    >\n      <slot />\n    </component>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport BLink from '../BLink/BLink.vue'\nimport {computed, inject, toRef, useAttrs} from 'vue'\nimport type {BDropdownItemProps} from '../../types'\nimport {useBLinkHelper} from '../../composables'\nimport {collapseInjectionKey, dropdownInjectionKey, navbarInjectionKey} from '../../utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<BDropdownItemProps>(), {\n  wrapperAttrs: undefined,\n  // Link props\n  linkClass: undefined,\n  variant: null,\n  // All others use defaults\n  active: undefined,\n  activeClass: undefined,\n  append: undefined,\n  disabled: undefined,\n  exactActiveClass: undefined,\n  href: undefined,\n  icon: undefined,\n  opacity: undefined,\n  opacityHover: undefined,\n  rel: undefined,\n  replace: undefined,\n  routerComponentName: undefined,\n  target: undefined,\n  to: undefined,\n  underlineOffset: undefined,\n  underlineOffsetHover: undefined,\n  underlineOpacity: undefined,\n  underlineOpacityHover: undefined,\n  underlineVariant: undefined,\n  // End link props\n})\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst {class: wrapperClass, ...attrs} = useAttrs()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst {computedLink, computedLinkProps} = useBLinkHelper(props)\n\nconst computedClasses = computed(() => [\n  props.linkClass,\n  {\n    active: props.active,\n    disabled: props.disabled,\n    [`text-${props.variant}`]: props.variant !== null,\n  },\n])\n\nconst computedTag = toRef(() => (computedLink.value ? BLink : props.href ? 'a' : 'button'))\n\nconst collapseData = inject(collapseInjectionKey, null)\nconst dropdownData = inject(dropdownInjectionKey, null)\nconst navbarData = inject(navbarInjectionKey, null)\n\n// Pretty sure this emits if computedTag is not button and is disabled\nconst clicked = (e: Readonly<MouseEvent>): void => {\n  emit('click', e)\n  if (navbarData !== null && navbarData?.autoClose?.value === true) {\n    collapseData?.hide?.()\n  }\n  dropdownData?.hide?.()\n}\n</script>\n","<template>\n  <li role=\"presentation\">\n    <button\n      role=\"menu\"\n      type=\"button\"\n      class=\"dropdown-item\"\n      :class=\"computedClasses\"\n      :disabled=\"props.disabled\"\n      @click=\"clicked\"\n    >\n      <slot />\n    </button>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BDropdownItemButtonProps} from '../../types'\nimport {computed} from 'vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<BDropdownItemButtonProps>(), {\n  active: false,\n  activeClass: 'active',\n  buttonClass: undefined,\n  disabled: false,\n  variant: null,\n})\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => [\n  props.buttonClass,\n  {\n    [props.activeClass]: props.active,\n    disabled: props.disabled,\n    [`text-${props.variant}`]: props.variant !== null,\n  },\n])\n\nconst clicked = (e: Readonly<MouseEvent>) => {\n  emit('click', e)\n}\n</script>\n","<template>\n  <form\n    :id=\"id\"\n    ref=\"element\"\n    :novalidate=\"props.novalidate\"\n    :class=\"computedClasses\"\n    @submit.prevent=\"submitted\"\n  >\n    <slot />\n  </form>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BFormProps} from '../../types'\nimport {computed, ref} from 'vue'\n\nconst props = withDefaults(defineProps<BFormProps>(), {\n  floating: false,\n  id: undefined,\n  novalidate: false,\n  validated: false,\n})\n\nconst emit = defineEmits<{\n  submit: [value: Event]\n}>()\n\nconst element = ref<HTMLFormElement | null>(null)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  'form-floating': props.floating,\n  'was-validated': props.validated,\n}))\n\nconst submitted = (e: Readonly<Event>) => {\n  emit('submit', e)\n}\n\ndefineExpose({\n  element,\n})\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"id\"\n    :role=\"role\"\n    :aria-live=\"ariaLive\"\n    :aria-atomic=\"ariaLive ? true : undefined\"\n    :class=\"computedClasses\"\n  >\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport type {BFormFeedbackSharedProps} from '../../types'\n\nconst props = withDefaults(defineProps<BFormFeedbackSharedProps>(), {\n  ariaLive: undefined,\n  forceShow: false,\n  id: undefined,\n  role: undefined,\n  state: null,\n  tag: 'div',\n  text: undefined,\n  tooltip: false,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedShow = toRef(() => props.forceShow === true || props.state === false)\n\nconst computedClasses = computed(() => ({\n  'd-block': computedShow.value,\n  'invalid-feedback': !props.tooltip,\n  'invalid-tooltip': props.tooltip,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" :class=\"computedClasses\">\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {BFormTextProps} from '../../types'\n\nconst props = withDefaults(defineProps<BFormTextProps>(), {\n  id: undefined,\n  inline: false,\n  tag: 'small',\n  text: undefined,\n  textVariant: 'body-secondary',\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`text-${props.textVariant}`]: props.textVariant !== null,\n  'form-text': !props.inline,\n}))\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"id\"\n    :role=\"role\"\n    :aria-live=\"ariaLive\"\n    :aria-atomic=\"ariaLive ? true : undefined\"\n    :class=\"computedClasses\"\n  >\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport type {BFormFeedbackSharedProps} from '../../types'\n\nconst props = withDefaults(defineProps<BFormFeedbackSharedProps>(), {\n  ariaLive: undefined,\n  forceShow: false,\n  id: undefined,\n  role: undefined,\n  state: null,\n  tag: 'div',\n  text: undefined,\n  tooltip: false,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedShow = toRef(() => props.forceShow === true || props.state === true)\n\nconst computedClasses = computed(() => ({\n  'd-block': computedShow.value,\n  'valid-feedback': !props.tooltip,\n  'valid-tooltip': props.tooltip,\n}))\n</script>\n","<script lang=\"ts\">\nimport {\n  defineComponent,\n  h,\n  type PropType,\n  type RendererElement,\n  type SlotsType,\n  Teleport,\n} from 'vue'\n\nexport default defineComponent({\n  name: 'ComponentOrEmpty',\n  slots: Object as SlotsType<{\n    default?: Record<string, never>\n  }>,\n  props: {\n    tag: {\n      type: String,\n      default: 'div',\n    },\n    to: {\n      type: [String, Object] as PropType<string | RendererElement | null | undefined>,\n      default: null,\n    },\n    skip: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup(props, {slots, attrs}) {\n    return () =>\n      props.skip\n        ? slots.default?.()\n        : props.tag === 'Teleport'\n          ? h(Teleport, {to: props.to}, [slots.default?.()])\n          : h(props.tag, {...attrs}, [slots.default?.()])\n  },\n})\n</script>\n","<template>\n  <RenderComponentOrSkip :skip=\"isButtonGroup\" :class=\"computedClasses\">\n    <input\n      :id=\"computedId\"\n      v-bind=\"$attrs\"\n      ref=\"input\"\n      v-model=\"localValue\"\n      :class=\"inputClasses\"\n      type=\"checkbox\"\n      :disabled=\"props.disabled || parentData?.disabled.value\"\n      :required=\"computedRequired || undefined\"\n      :name=\"name || parentData?.name.value\"\n      :form=\"form || parentData?.form.value\"\n      :aria-label=\"ariaLabel\"\n      :aria-labelledby=\"ariaLabelledby\"\n      :aria-required=\"computedRequired || undefined\"\n      :value=\"value\"\n      :true-value=\"value\"\n      :false-value=\"uncheckedValue\"\n      :indeterminate=\"props.indeterminate\"\n    />\n    <label v-if=\"hasDefaultSlot || props.plain === false\" :for=\"computedId\" :class=\"labelClasses\">\n      <slot />\n    </label>\n  </RenderComponentOrSkip>\n</template>\n\n<script setup lang=\"ts\">\nimport {useFocus} from '@vueuse/core'\nimport {computed, inject, ref, toRef} from 'vue'\nimport {getClasses, getInputClasses, getLabelClasses, useId} from '../../composables'\nimport type {BFormCheckboxProps, CheckboxValue} from '../../types'\nimport {checkboxGroupKey, isEmptySlot} from '../../utils'\nimport RenderComponentOrSkip from '../RenderComponentOrSkip.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<BFormCheckboxProps>(), {\n  ariaLabel: undefined,\n  ariaLabelledby: undefined,\n  autofocus: false,\n  button: false,\n  buttonGroup: false,\n  buttonVariant: null,\n  disabled: false,\n  form: undefined,\n  id: undefined,\n  inline: false,\n  name: undefined,\n  plain: false,\n  required: undefined,\n  reverse: false,\n  size: undefined,\n  state: null,\n  switch: false,\n  uncheckedValue: false,\n  value: true,\n})\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = defineModel<CheckboxValue | CheckboxValue[]>({\n  default: undefined,\n})\nconst indeterminate = defineModel<boolean>('indeterminate', {\n  default: false,\n})\n\nconst computedId = useId(() => props.id, 'form-check')\n\nconst parentData = inject(checkboxGroupKey, null)\n\nconst input = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(input, {\n  initialValue: props.autofocus,\n})\n\nconst hasDefaultSlot = toRef(() => !isEmptySlot(slots.default))\n\nconst localValue = computed({\n  get: () => parentData?.modelValue.value ?? modelValue.value,\n  set: (newVal) => {\n    if (newVal === undefined) return\n    // Indeterminate is implicitly cleared when the checked state is changed to any value\n    //  by the user.  We reflect that here by setting our indetermiate model to false\n    //  which will emit the indeterminate event to the parent\n    indeterminate.value = false\n    if (parentData !== null && Array.isArray(newVal)) {\n      // The type cast isn't perfect. Array.isArray detects CheckboxValue.unknown[],\n      // but since it's parentData, it should always be CheckboxValue[]\n      // It doesn't quite work when props.value is an [], but this is more of a Vue issue\n      parentData.modelValue.value = newVal as CheckboxValue[]\n      return\n    }\n    modelValue.value = newVal as CheckboxValue\n  },\n})\n\nconst computedRequired = toRef(\n  () => !!(props.name ?? parentData?.name.value) && (props.required || parentData?.required.value)\n)\n\nconst isButtonGroup = toRef(() => props.buttonGroup || (parentData?.buttons.value ?? false))\n\nconst classesObject = computed(() => ({\n  plain: props.plain || (parentData?.plain.value ?? false),\n  button: props.button || (parentData?.buttons.value ?? false),\n  inline: props.inline || (parentData?.inline.value ?? false),\n  reverse: props.reverse || (parentData?.reverse.value ?? false),\n  switch: props.switch || (parentData?.switch.value ?? false),\n  state: props.state || parentData?.state.value,\n  size: props.size ?? parentData?.size.value ?? 'md', // This is where the true default is made\n  buttonVariant: props.buttonVariant ?? parentData?.buttonVariant.value ?? 'secondary', // This is where the true default is made\n  hasDefaultSlot: hasDefaultSlot.value,\n}))\nconst computedClasses = getClasses(classesObject)\nconst inputClasses = getInputClasses(classesObject)\nconst labelClasses = getLabelClasses(classesObject)\n\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  element: input,\n  focus: () => {\n    focused.value = true\n  },\n})\n</script>\n","<template>\n  <div\n    v-bind=\"computedAttrs\"\n    :id=\"computedId\"\n    ref=\"element\"\n    role=\"group\"\n    :class=\"computedClasses\"\n    class=\"bv-no-focus-ring\"\n    tabindex=\"-1\"\n  >\n    <slot name=\"first\" />\n    <BFormCheckbox v-for=\"item in normalizeOptions\" :key=\"item.self\" v-bind=\"item.props\">\n      <!-- eslint-disable-next-line vue/no-v-html -->\n      <span v-if=\"!!item.html\" v-html=\"item.html\" />\n      <template v-else>\n        {{ item.text }}\n      </template>\n    </BFormCheckbox>\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, provide, ref, toRef} from 'vue'\nimport BFormCheckbox from './BFormCheckbox.vue'\nimport type {BFormCheckboxGroupProps, CheckboxValue} from '../../types'\nimport {getGroupAttr, getGroupClasses, useId} from '../../composables'\nimport {checkboxGroupKey} from '../../utils'\nimport {useFocus} from '@vueuse/core'\n\nconst props = withDefaults(defineProps<BFormCheckboxGroupProps>(), {\n  ariaInvalid: undefined,\n  autofocus: false,\n  buttonVariant: 'secondary',\n  buttons: false,\n  disabled: false,\n  disabledField: 'disabled',\n  form: undefined,\n  htmlField: 'html',\n  id: undefined,\n  name: undefined,\n  options: () => [],\n  plain: false,\n  required: false,\n  reverse: false,\n  size: 'md',\n  stacked: false,\n  state: null,\n  switches: false,\n  textField: 'text',\n  validated: false,\n  valueField: 'value',\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  first?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = defineModel<CheckboxValue[]>({\n  default: () => [],\n})\n\nconst computedId = useId(() => props.id, 'checkbox')\nconst computedName = useId(() => props.name, 'checkbox')\n\nconst element = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(element, {\n  initialValue: props.autofocus,\n})\n\nprovide(checkboxGroupKey, {\n  modelValue,\n  switch: toRef(() => props.switches),\n  buttonVariant: toRef(() => props.buttonVariant),\n  form: toRef(() => props.form),\n  name: computedName,\n  state: toRef(() => props.state),\n  plain: toRef(() => props.plain),\n  size: toRef(() => props.size),\n  inline: toRef(() => !props.stacked),\n  reverse: toRef(() => props.reverse),\n  required: toRef(() => props.required),\n  buttons: toRef(() => props.buttons),\n  disabled: toRef(() => props.disabled),\n})\n\nconst normalizeOptions = computed(() =>\n  props.options.map((el, ind) =>\n    typeof el === 'string' || typeof el === 'number'\n      ? {\n          props: {\n            value: el,\n            disabled: props.disabled,\n          },\n          text: el.toString(),\n          html: undefined,\n          self: Symbol(`checkboxGroupOptionItem${ind}`),\n        }\n      : {\n          props: {\n            value: el[props.valueField] as string | number | undefined,\n            disabled: el[props.disabledField] as boolean | undefined,\n            ...(el.props ? el.props : {}),\n          },\n          text: el[props.textField] as string | undefined,\n          html: el[props.htmlField] as string | undefined,\n          self: Symbol(`checkboxGroupOptionItem${ind}`),\n        }\n  )\n)\n\nconst classesObject = computed(() => ({\n  required: props.required,\n  ariaInvalid: props.ariaInvalid,\n  state: props.state,\n  validated: props.validated,\n  buttons: props.buttons,\n  stacked: props.stacked,\n  size: props.size,\n}))\nconst computedAttrs = getGroupAttr(classesObject)\nconst computedClasses = getGroupClasses(classesObject)\n\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  focus: () => {\n    focused.value = true\n  },\n})\n</script>\n","<template>\n  <DefineTemplate>\n    <label class=\"input-group-text\" :for=\"computedId\">\n      {{ browserText }}\n    </label>\n  </DefineTemplate>\n\n  <label v-if=\"hasLabelSlot || label\" class=\"form-label\" :class=\"labelClass\" :for=\"computedId\">\n    <slot name=\"label\">\n      {{ label }}\n    </slot>\n  </label>\n\n  <div class=\"input-group form-input-file\">\n    <ReusableTemplate v-if=\"placement === 'start'\" />\n    <input\n      :id=\"computedId\"\n      v-bind=\"$attrs\"\n      ref=\"input\"\n      type=\"file\"\n      class=\"form-control\"\n      :class=\"computedClasses\"\n      :form=\"form\"\n      :name=\"name\"\n      :multiple=\"props.multiple\"\n      :disabled=\"props.disabled\"\n      :capture=\"props.capture\"\n      :accept=\"computedAccept || undefined\"\n      :required=\"props.required || undefined\"\n      :aria-label=\"ariaLabel\"\n      :aria-labelledby=\"ariaLabelledby\"\n      :aria-required=\"props.required || undefined\"\n      :directory=\"props.directory\"\n      :webkitdirectory=\"props.directory\"\n      @change=\"onChange\"\n      @drop=\"onDrop\"\n    />\n    <ReusableTemplate v-if=\"placement === 'end'\" />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {createReusableTemplate, useFocus} from '@vueuse/core'\nimport {computed, ref, toRef, watch} from 'vue'\nimport type {BFormFileProps} from '../../types'\nimport {useId, useStateClass} from '../../composables'\nimport {isEmptySlot} from '../../utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  label?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(defineProps<BFormFileProps>(), {\n  ariaLabel: undefined,\n  ariaLabelledby: undefined,\n  accept: '',\n  autofocus: false,\n  browserText: 'Choose',\n  // eslint-disable-next-line vue/require-valid-default-prop\n  capture: false,\n  directory: false,\n  disabled: false,\n  form: undefined,\n  id: undefined,\n  label: '',\n  labelClass: undefined,\n  multiple: false,\n  name: undefined,\n  noDrop: false,\n  noTraverse: false,\n  placement: 'start',\n  required: false,\n  size: undefined,\n  state: null,\n})\n\nconst modelValue = defineModel<File | File[] | null>({\n  default: null,\n})\nconst computedId = useId(() => props.id)\n\n// TODO noTraverse is not implemented yet\n\nconst stateClass = useStateClass(() => props.state)\n\nconst input = ref<HTMLInputElement | null>(null)\n\nconst {focused} = useFocus(input, {initialValue: props.autofocus})\n\nconst hasLabelSlot = toRef(() => !isEmptySlot(slots['label']))\n\nconst computedAccept = toRef(() =>\n  typeof props.accept === 'string' ? props.accept : props.accept.join(',')\n)\n\nconst computedClasses = computed(() => [\n  stateClass.value,\n  {\n    [`form-control-${props.size}`]: props.size !== undefined,\n  },\n])\n\nconst onChange = () => {\n  const value =\n    input.value?.files === null || input.value?.files === undefined ? null : [...input.value.files]\n  modelValue.value = value === null ? null : props.multiple === true ? value : value[0]\n}\n\nconst onDrop = (e: Readonly<Event>) => {\n  if (props.noDrop === true) {\n    e.preventDefault()\n  }\n}\n\n/**\n * Reset the form input\n */\nconst reset = () => {\n  modelValue.value = null\n}\n\nwatch(modelValue, (newValue) => {\n  if (newValue === null && input.value !== null) {\n    input.value.value = ''\n  }\n})\n\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  element: input,\n  focus: () => {\n    focused.value = true\n  },\n  reset,\n})\n\nconst [DefineTemplate, ReusableTemplate] = createReusableTemplate()\n</script>\n\n<style scoped>\n.form-input-file {\n  input[type='file'] {\n    margin-left: -2px !important;\n\n    &::-webkit-file-upload-button {\n      display: none;\n    }\n\n    &::file-selector-button {\n      display: none;\n    }\n  }\n\n  &:hover {\n    label {\n      background-color: #dde0e3;\n      cursor: pointer;\n    }\n  }\n}\n</style>\n","<script lang=\"ts\">\nimport {useAriaInvalid, useId, useStateClass} from '../../composables'\nimport {RX_SPACE_SPLIT} from '../../constants/regex'\nimport {attemptFocus, IS_BROWSER, isVisible, normalizeSlot, suffixPropName} from '../../utils'\nimport {computed, defineComponent, h, nextTick, onMounted, type PropType, ref, watch} from 'vue'\nimport BCol from '../BCol.vue'\nimport BFormInvalidFeedback from '../BForm/BFormInvalidFeedback.vue'\nimport BFormRow from '../BForm/BFormRow.vue'\nimport BFormText from '../BForm/BFormText.vue'\nimport BFormValidFeedback from '../BForm/BFormValidFeedback.vue'\nimport type {AriaInvalid} from '../../types'\n\nconst INPUTS = ['input', 'select', 'textarea']\n// Selector for finding first input in the form group\nconst INPUT_SELECTOR = INPUTS.map((v) => `${v}:not([disabled])`).join()\n\n// A list of interactive elements (tag names) inside `<BFormGroup>`'s legend\nconst LEGEND_INTERACTIVE_ELEMENTS = [...INPUTS, 'a', 'button', 'label']\n\nexport const SLOT_NAME_LABEL = 'label'\nexport const SLOT_NAME_INVALID_FEEDBACK = 'invalid-feedback'\nexport const SLOT_NAME_VALID_FEEDBACK = 'valid-feedback'\nexport const SLOT_NAME_DESCRIPTION = 'description'\nexport const SLOT_NAME_DEFAULT = 'default'\n\nexport default defineComponent({\n  components: {BCol, BFormInvalidFeedback, BFormRow, BFormText, BFormValidFeedback},\n  props: {\n    ariaInvalid: {type: [Boolean, String] as PropType<AriaInvalid>, default: undefined},\n    contentCols: {type: [Boolean, String, Number], default: undefined},\n    contentColsLg: {type: [Boolean, String, Number], default: undefined},\n    contentColsMd: {type: [Boolean, String, Number], default: undefined},\n    contentColsSm: {type: [Boolean, String, Number], default: undefined},\n    contentColsXl: {type: [Boolean, String, Number], default: undefined},\n    description: {type: [String], default: undefined},\n    disabled: {type: Boolean, default: false},\n    feedbackAriaLive: {type: String, default: 'assertive'},\n    id: {type: String, default: undefined},\n    invalidFeedback: {type: String, default: undefined},\n    label: {type: String, default: undefined},\n    labelAlign: {type: [Boolean, String, Number], default: undefined},\n    labelAlignLg: {type: [Boolean, String, Number], default: undefined},\n    labelAlignMd: {type: [Boolean, String, Number], default: undefined},\n    labelAlignSm: {type: [Boolean, String, Number], default: undefined},\n    labelAlignXl: {type: [Boolean, String, Number], default: undefined},\n    labelClass: {type: [Array, Object, String], default: undefined},\n    labelCols: {type: [Boolean, String, Number], default: undefined},\n    labelColsLg: {type: [Boolean, String, Number], default: undefined},\n    labelColsMd: {type: [Boolean, String, Number], default: undefined},\n    labelColsSm: {type: [Boolean, String, Number], default: undefined},\n    labelColsXl: {type: [Boolean, String, Number], default: undefined},\n    labelFor: {type: String, default: undefined},\n    labelSize: {type: String, default: undefined},\n    labelSrOnly: {type: Boolean, default: false},\n    state: {type: Boolean as PropType<boolean | null>, default: null},\n    tooltip: {type: Boolean, default: false},\n    validFeedback: {type: String, default: undefined},\n    validated: {type: Boolean, default: false},\n    floating: {type: Boolean, default: false},\n  },\n  setup(props) {\n    const ariaDescribedby: string | null = null as string | null\n    const breakPoints = ['xs', 'sm', 'md', 'lg', 'xl']\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const getAlignClasses = (props: any, prefix: string) =>\n      breakPoints.reduce((result: string[], breakpoint) => {\n        const suffix = suffixPropName(breakpoint === 'xs' ? '' : breakpoint, `${prefix}Align`)\n        const propValue: string = props[suffix] || null\n        if (propValue) {\n          breakpoint === 'xs'\n            ? result.push(`text-${propValue}`)\n            : result.push(`text-${breakpoint}-${propValue}`)\n        }\n\n        return result\n      }, [])\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const getColProps = (props: any, prefix: string) =>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      breakPoints.reduce((result: any, breakpoint: string) => {\n        const suffix = suffixPropName(breakpoint === 'xs' ? '' : breakpoint, `${prefix}Cols`)\n        let propValue = props[suffix]\n        // Handle case where the prop's value is an empty string,\n        // which represents `true`\n        propValue = propValue === '' ? true : propValue || false\n\n        if (!(typeof propValue === 'boolean') && propValue !== 'auto') {\n          // Convert to column size to number\n          const val = Number.parseInt(propValue)\n          propValue = Number.isNaN(val) ? 0 : val\n          // Ensure column size is greater than `0`\n          propValue = propValue > 0 ? propValue : false\n        }\n\n        // Add the prop to the list of props to give to `</BCol>`\n        // If breakpoint is '' (`${prefix}Cols` is `true`), then we use\n        // the 'col' prop to make equal width at 'xs'\n        if (propValue) {\n          // Extra care is required for xs since it does not have a BCol breakpoint prop\n          // Xs breakpoint is simply 'cols'\n          if (breakpoint === 'xs') {\n            result[typeof propValue === 'boolean' ? 'col' : 'cols'] = propValue\n          } else {\n            result[breakpoint || (typeof propValue === 'boolean' ? 'col' : 'cols')] = propValue\n          }\n        }\n        return result\n      }, {})\n\n    const content = ref<HTMLElement | null>(null)\n\n    // Sets the `aria-describedby` attribute on the input if `labelFor` is set\n    // Optionally accepts a string of Ids to remove as the second parameter\n    // Preserves any `aria-describedby` value(s) user may have on input\n    const updateAriaDescribedby = (newValue: string | null, oldValue: string | null = null) => {\n      if (IS_BROWSER && props.labelFor && content.value !== null) {\n        // We need to escape `labelFor` since it can be user-provided\n        const $input = content.value.querySelector(`#${CSS.escape(props.labelFor)}`)\n        if ($input) {\n          const attr = 'aria-describedby'\n          const newIds = (newValue || '').split(RX_SPACE_SPLIT)\n          const oldIds = (oldValue || '').split(RX_SPACE_SPLIT)\n\n          // Update Id list, preserving any original Ids\n          // and ensuring the Id's are unique\n          const ids = ($input.getAttribute(attr) || '')\n            .split(RX_SPACE_SPLIT)\n            .filter((id) => !oldIds.includes(id))\n            .concat(newIds)\n            .filter((id, index, ids) => ids.indexOf(id) === index)\n            .filter((x) => x)\n            .join(' ')\n            .trim()\n\n          if (ids) {\n            $input.setAttribute(attr, ids)\n          } else {\n            $input.removeAttribute(attr)\n          }\n        }\n      }\n    }\n\n    const contentColProps = computed(() => getColProps(props, 'content'))\n    const labelAlignClasses = computed(() => getAlignClasses(props, 'label'))\n    const labelColProps = computed(() => getColProps(props, 'label'))\n    const isHorizontal = computed(\n      () =>\n        // Determine if the form group will be rendered horizontal\n        // based on the existence of 'content-col' or 'label-col' props\n        Object.keys(contentColProps.value).length > 0 || Object.keys(labelColProps.value).length > 0\n    )\n\n    const stateClass = useStateClass(() => props.state)\n\n    const computedAriaInvalid = useAriaInvalid(\n      () => props.ariaInvalid,\n      () => props.state\n    )\n\n    watch(\n      () => ariaDescribedby,\n      (newValue: string | null, oldValue: string | null) => {\n        if (newValue !== oldValue) {\n          updateAriaDescribedby(newValue, oldValue)\n        }\n      }\n    )\n\n    onMounted(() => {\n      nextTick(() => {\n        // Set `aria-describedby` on the input specified by `labelFor`\n        // We do this in a `$nextTick()` to ensure the children have finished rendering\n        updateAriaDescribedby(ariaDescribedby)\n      })\n    })\n\n    const onLegendClick = (event: Readonly<MouseEvent>) => {\n      // Don't do anything if `labelFor` is set\n      if (props.labelFor || content.value === null) return\n\n      const {target} = event\n      const tagName = target ? (target as HTMLElement).tagName : ''\n\n      // If clicked an interactive element inside legend,\n      // we just let the default happen\n      if (LEGEND_INTERACTIVE_ELEMENTS.indexOf(tagName) !== -1) return\n\n      // If only a single input, focus it, emulating label behaviour\n      const inputs = [...content.value.querySelectorAll(INPUT_SELECTOR)].filter(isVisible)\n      const [inp] = inputs\n      if (inputs.length === 1 && inp instanceof HTMLElement) {\n        attemptFocus(inp)\n      }\n    }\n\n    return {\n      ariaDescribedby,\n      computedAriaInvalid,\n      contentColProps,\n      isHorizontal,\n      labelAlignClasses,\n      labelColProps,\n      onLegendClick,\n      stateClass,\n    }\n  },\n  render() {\n    const props = this.$props\n    const slots = this.$slots\n\n    const id = useId()\n    const isFieldset = !props.labelFor\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let $label: any = null\n    const labelContent = normalizeSlot(SLOT_NAME_LABEL, {}, slots) || props.label\n    const labelId = labelContent ? useId(undefined, '_BV_label_').value : null\n\n    if (labelContent || this.isHorizontal) {\n      const labelTag: 'legend' | 'label' = isFieldset ? 'legend' : 'label'\n      if (props.labelSrOnly) {\n        if (labelContent) {\n          $label = h(\n            labelTag,\n            {\n              class: 'visually-hidden',\n              id: labelId,\n              for: props.labelFor || null,\n            },\n            labelContent\n          )\n        }\n        if (this.isHorizontal) {\n          $label = h(BCol, this.labelColProps, {default: () => $label})\n        } else {\n          $label = h('div', {}, [$label])\n        }\n      } else {\n        const renderProps = {\n          onClick: isFieldset ? this.onLegendClick : null,\n          ...(this.isHorizontal ? this.labelColProps : {}),\n          tag: this.isHorizontal ? labelTag : null,\n          id: labelId,\n          for: props.labelFor || null,\n          tabIndex: isFieldset ? '-1' : null,\n          class: [\n            this.isHorizontal ? 'col-form-label' : 'form-label',\n            {\n              'bv-no-focus-ring': isFieldset,\n              'col-form-label': this.isHorizontal || isFieldset,\n              'pt-0': !this.isHorizontal && isFieldset,\n              'd-block': !this.isHorizontal && !isFieldset,\n              [`col-form-label-${props.labelSize}`]: !!props.labelSize,\n            },\n            this.labelAlignClasses,\n            props.labelClass,\n          ],\n        }\n        if (this.isHorizontal) {\n          $label = h(BCol, renderProps, {default: () => labelContent})\n        } else {\n          $label = h(labelTag, renderProps, labelContent)\n        }\n      }\n    }\n\n    let $invalidFeedback = null\n    const invalidFeedbackContent =\n      normalizeSlot(SLOT_NAME_INVALID_FEEDBACK, {}, slots) || this.invalidFeedback\n    const invalidFeedbackId = invalidFeedbackContent\n      ? useId(undefined, '_BV_feedback_invalid_').value\n      : undefined\n\n    if (invalidFeedbackContent) {\n      $invalidFeedback = h(\n        BFormInvalidFeedback,\n        {\n          ariaLive: props.feedbackAriaLive,\n          id: invalidFeedbackId,\n          state: props.state,\n          tooltip: props.tooltip,\n        },\n        {default: () => invalidFeedbackContent}\n      )\n    }\n\n    let $validFeedback = null\n    const validFeedbackContent =\n      normalizeSlot(SLOT_NAME_VALID_FEEDBACK, {}, slots) || this.validFeedback\n    const validFeedbackId = validFeedbackContent\n      ? useId(undefined, '_BV_feedback_valid_').value\n      : undefined\n\n    if (validFeedbackContent) {\n      $validFeedback = h(\n        BFormValidFeedback,\n        {\n          ariaLive: props.feedbackAriaLive,\n          id: validFeedbackId,\n          state: props.state,\n          tooltip: props.tooltip,\n        },\n        {default: () => validFeedbackContent}\n        // validFeedbackContent\n      )\n    }\n\n    let $description = null\n    const descriptionContent = normalizeSlot(SLOT_NAME_DESCRIPTION, {}, slots) || this.description\n    const descriptionId = descriptionContent\n      ? useId(undefined, '_BV_description_').value\n      : undefined\n    if (descriptionContent) {\n      $description = h(\n        BFormText,\n        {\n          id: descriptionId,\n        },\n        {default: () => descriptionContent}\n      )\n    }\n\n    // Update `ariaDescribedby`\n    // Screen readers will read out any content linked to by `aria-describedby`\n    // even if the content is hidden with `display: none;`, hence we only include\n    // feedback Ids if the form group's state is explicitly valid or invalid\n    const ariaDescribedby = (this.ariaDescribedby =\n      [\n        descriptionId,\n        props.state === false ? invalidFeedbackId : null,\n        props.state === true ? validFeedbackId : null,\n      ]\n        .filter((x) => x)\n        .join(' ') || null)\n\n    const contentBlocks = [\n      normalizeSlot(SLOT_NAME_DEFAULT, {ariaDescribedby, descriptionId, id, labelId}, slots) || '',\n      $invalidFeedback,\n      $validFeedback,\n      $description,\n    ]\n    if (!this.isHorizontal && props.floating) contentBlocks.push($label)\n\n    let $content = h(\n      'div',\n      {\n        ref: 'content',\n        class: [\n          {\n            'form-floating': !this.isHorizontal && props.floating,\n          },\n        ],\n      },\n      contentBlocks\n    )\n    if (this.isHorizontal) {\n      $content = h(BCol, {ref: 'content', ...this.contentColProps}, {default: () => contentBlocks})\n    }\n\n    // Return it wrapped in a form group\n    // Note: Fieldsets do not support adding `row` or `form-row` directly\n    // to them due to browser specific render issues, so we move the `form-row`\n    // to an inner wrapper div when horizontal and using a fieldset\n    const rowProps = {\n      'class': [\n        this.stateClass,\n        {\n          'was-validated': props.validated,\n        },\n      ],\n      'id': useId(() => props.id).value,\n      'disabled': isFieldset ? props.disabled : null,\n      'role': isFieldset ? null : 'group',\n      'aria-invalid': this.computedAriaInvalid,\n      // Only apply `aria-labelledby` if we are a horizontal fieldset\n      // as the legend is no longer a direct child of fieldset\n      'aria-labelledby': isFieldset && this.isHorizontal ? labelId : null,\n    }\n\n    if (this.isHorizontal && !isFieldset) {\n      return h(BFormRow, rowProps, {default: () => [$label, $content]})\n    }\n\n    return h(\n      isFieldset ? 'fieldset' : 'div',\n      rowProps,\n      this.isHorizontal && isFieldset\n        ? [h(BFormRow, null, {default: () => [$label, $content]})]\n        : this.isHorizontal || !props.floating\n          ? [$label, $content]\n          : [$content]\n    )\n  },\n})\n</script>\n","<template>\n  <input\n    :id=\"computedId\"\n    ref=\"input\"\n    :value=\"modelValue\"\n    :class=\"computedClasses\"\n    :name=\"name || undefined\"\n    :form=\"form || undefined\"\n    :type=\"type\"\n    :disabled=\"props.disabled\"\n    :placeholder=\"placeholder\"\n    :required=\"props.required || undefined\"\n    :autocomplete=\"autocomplete || undefined\"\n    :readonly=\"props.readonly || props.plaintext\"\n    :min=\"min\"\n    :max=\"max\"\n    :step=\"step\"\n    :list=\"type !== 'password' ? list : undefined\"\n    :aria-required=\"props.required || undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n    @input=\"onInput($event)\"\n    @change=\"onChange($event)\"\n    @blur=\"onBlur($event)\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, ref} from 'vue'\nimport {useFormInput, useStateClass} from '../../composables'\nimport type {BFormInputProps, Numberish} from '../../types'\n\nconst props = withDefaults(defineProps<BFormInputProps>(), {\n  max: undefined,\n  min: undefined,\n  step: undefined,\n  type: 'text',\n  // CommonInputProps\n  ariaInvalid: undefined,\n  autocomplete: undefined,\n  autofocus: false,\n  debounce: 0,\n  debounceMaxWait: NaN,\n  disabled: false,\n  form: undefined,\n  formatter: undefined,\n  id: undefined,\n  lazy: false,\n  lazyFormatter: false,\n  list: undefined,\n  modelValue: '',\n  name: undefined,\n  number: false,\n  placeholder: undefined,\n  plaintext: false,\n  readonly: false,\n  required: false,\n  size: undefined,\n  state: null,\n  trim: false,\n  // End CommonInputProps\n})\n\nconst emit = defineEmits<{\n  'update:modelValue': [val: Numberish | null]\n}>()\n\nconst {input, computedId, computedAriaInvalid, onInput, onChange, onBlur, focus, blur} =\n  useFormInput(props, emit)\n\nconst stateClass = useStateClass(() => props.state)\n\nconst isHighlighted = ref(false)\n\nconst computedClasses = computed(() => {\n  const isRange = props.type === 'range'\n  const isColor = props.type === 'color'\n  return [\n    stateClass.value,\n    {\n      'form-control-highlighted': isHighlighted.value,\n      'form-range': isRange,\n      'form-control': isColor || (!props.plaintext && !isRange),\n      'form-control-color': isColor,\n      'form-control-plaintext': props.plaintext && !isRange && !isColor,\n      [`form-control-${props.size}`]: !!props.size,\n    },\n  ]\n})\n\ndefineExpose({\n  blur,\n  element: input,\n  focus,\n})\n\n// const highlight = () => {\n//   if (isHighlighted.value === true) return\n//   isHighlighted.value = true\n//   setTimeout(() => {\n//     isHighlighted.value = false\n//   }, 2000)\n// }\n</script>\n","<template>\n  <RenderComponentOrSkip :skip=\"isButtonGroup\" :class=\"computedClasses\">\n    <input\n      :id=\"computedId\"\n      v-bind=\"$attrs\"\n      ref=\"input\"\n      v-model=\"localValue\"\n      :class=\"inputClasses\"\n      type=\"radio\"\n      :disabled=\"props.disabled || parentData?.disabled.value\"\n      :required=\"computedRequired || undefined\"\n      :name=\"name || parentData?.name.value\"\n      :form=\"form || parentData?.form.value\"\n      :aria-label=\"ariaLabel\"\n      :aria-labelledby=\"ariaLabelledby\"\n      :value=\"value\"\n      :aria-required=\"computedRequired || undefined\"\n    />\n    <label v-if=\"hasDefaultSlot || props.plain === false\" :for=\"computedId\" :class=\"labelClasses\">\n      <slot />\n    </label>\n  </RenderComponentOrSkip>\n</template>\n\n<script setup lang=\"ts\">\nimport {useFocus} from '@vueuse/core'\nimport {computed, inject, ref, toRef} from 'vue'\nimport {getClasses, getInputClasses, getLabelClasses, useId} from '../../composables'\nimport type {BFormRadioProps, RadioValue} from '../../types'\nimport {isEmptySlot, radioGroupKey} from '../../utils'\nimport RenderComponentOrSkip from '../RenderComponentOrSkip.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<BFormRadioProps>(), {\n  ariaLabel: undefined,\n  ariaLabelledby: undefined,\n  autofocus: false,\n  button: false,\n  buttonGroup: false,\n  buttonVariant: null,\n  disabled: false,\n  form: undefined,\n  id: undefined,\n  inline: false,\n  name: undefined,\n  plain: false,\n  required: false,\n  reverse: false,\n  size: undefined,\n  state: null,\n  value: true,\n})\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = defineModel<RadioValue | undefined>({\n  default: undefined,\n})\n\nconst computedId = useId(() => props.id, 'form-check')\n\nconst parentData = inject(radioGroupKey, null)\n\nconst input = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(input, {\n  initialValue: props.autofocus,\n})\n\nconst hasDefaultSlot = toRef(() => !isEmptySlot(slots.default))\n\nconst localValue = computed({\n  get: () => parentData?.modelValue.value ?? modelValue.value,\n  set: (newValue) => {\n    if (newValue === undefined) return\n    if (parentData !== null) {\n      parentData.modelValue.value = newValue as RadioValue\n      return\n    }\n    modelValue.value = newValue as RadioValue\n  },\n})\n\nconst computedRequired = toRef(\n  () => !!(props.name ?? parentData?.name.value) && (props.required || parentData?.required.value)\n)\n\nconst isButtonGroup = toRef(() => props.buttonGroup || (parentData?.buttons.value ?? false))\n\nconst classesObject = computed(() => ({\n  plain: props.plain || (parentData?.plain.value ?? false),\n  button: props.button || (parentData?.buttons.value ?? false),\n  inline: props.inline || (parentData?.inline.value ?? false),\n  state: props.state || parentData?.state.value,\n  reverse: props.reverse || (parentData?.reverse.value ?? false),\n  size: props.size ?? parentData?.size.value ?? 'md', // This is where the true default is made\n  buttonVariant: props.buttonVariant ?? parentData?.buttonVariant.value ?? 'secondary', // This is where the true default is made\n  hasDefaultSlot: hasDefaultSlot.value,\n}))\nconst computedClasses = getClasses(classesObject)\nconst inputClasses = getInputClasses(classesObject)\nconst labelClasses = getLabelClasses(classesObject)\n\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  element: input,\n  focus: () => {\n    focused.value = true\n  },\n})\n</script>\n","<template>\n  <div\n    v-bind=\"computedAttrs\"\n    :id=\"computedId\"\n    ref=\"element\"\n    role=\"radiogroup\"\n    :class=\"computedClasses\"\n    class=\"bv-no-focus-ring\"\n    tabindex=\"-1\"\n  >\n    <slot name=\"first\" />\n    <BFormRadio\n      v-for=\"item in normalizeOptions\"\n      :key=\"item.self\"\n      :disabled=\"item.disabled\"\n      :value=\"item.value\"\n    >\n      <!-- eslint-disable-next-line vue/no-v-html -->\n      <span v-if=\"!!item.html\" v-html=\"item.html\" />\n      <template v-else>\n        {{ item.text }}\n      </template>\n    </BFormRadio>\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BFormRadioGroupProps, RadioValue} from '../../types'\nimport {computed, provide, ref, toRef} from 'vue'\nimport {radioGroupKey} from '../../utils'\nimport BFormRadio from './BFormRadio.vue'\nimport {getGroupAttr, getGroupClasses, useId} from '../../composables'\nimport {useFocus} from '@vueuse/core'\n\nconst props = withDefaults(defineProps<BFormRadioGroupProps>(), {\n  ariaInvalid: undefined,\n  autofocus: false,\n  buttonVariant: 'secondary',\n  buttons: false,\n  disabled: false,\n  disabledField: 'disabled',\n  form: undefined,\n  htmlField: 'html',\n  id: undefined,\n  name: undefined,\n  options: () => [],\n  plain: false,\n  required: false,\n  reverse: false,\n  size: 'md',\n  stacked: false,\n  state: null,\n  textField: 'text',\n  validated: false,\n  valueField: 'value',\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  first?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = defineModel<RadioValue | null>({\n  default: null,\n})\n\nconst computedId = useId(() => props.id, 'radio')\nconst computedName = useId(() => props.name, 'checkbox')\n\nconst element = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(element, {\n  initialValue: props.autofocus,\n})\n\nprovide(radioGroupKey, {\n  modelValue,\n  buttonVariant: toRef(() => props.buttonVariant),\n  form: toRef(() => props.form),\n  name: computedName,\n  buttons: toRef(() => props.buttons),\n  state: toRef(() => props.state),\n  plain: toRef(() => props.plain),\n  size: toRef(() => props.size),\n  inline: toRef(() => !props.stacked),\n  reverse: toRef(() => props.reverse),\n  required: toRef(() => props.required),\n  disabled: toRef(() => props.disabled),\n})\n\nconst normalizeOptions = computed(() =>\n  props.options.map((el, ind) =>\n    typeof el === 'string' || typeof el === 'number'\n      ? {\n          value: el,\n          disabled: props.disabled,\n          text: el.toString(),\n          html: undefined,\n          self: Symbol(`radioGroupOptionItem${ind}`),\n        }\n      : {\n          value: el[props.valueField] as string | undefined,\n          disabled: el[props.disabledField] as boolean | undefined,\n          ...(el.props ? el.props : {}),\n          text: el[props.textField] as string | undefined,\n          html: el[props.htmlField] as string | undefined,\n          self: Symbol(`radioGroupOptionItem${ind}`),\n        }\n  )\n)\n\nconst classesObject = computed(() => ({\n  required: props.required,\n  ariaInvalid: props.ariaInvalid,\n  state: props.state,\n  validated: props.validated,\n  buttons: props.buttons,\n  stacked: props.stacked,\n  size: props.size,\n}))\nconst computedAttrs = getGroupAttr(classesObject)\nconst computedClasses = getGroupClasses(classesObject)\n\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  focus: () => {\n    focused.value = true\n  },\n})\n</script>\n","<template>\n  <option :value=\"value\" :disabled=\"props.disabled\">\n    <slot />\n  </option>\n</template>\n\n<script setup lang=\"ts\" generic=\"T\">\nimport type {BFormSelectOptionProps} from '../../types'\n\nconst props = withDefaults(defineProps<BFormSelectOptionProps<T>>(), {\n  disabled: false,\n  value: undefined,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n</script>\n","<template>\n  <optgroup :label=\"label\">\n    <slot name=\"first\" />\n    <BFormSelectOption\n      v-for=\"(option, index) in normalizedOptsWrapper\"\n      :key=\"index\"\n      :disabled=\"option.disabled\"\n      :value=\"option.value\"\n      v-bind=\"$attrs\"\n    >\n      <!-- eslint-disable-next-line vue/no-v-html -->\n      <span v-if=\"!!option.html\" v-html=\"option.html\" />\n      <template v-else>\n        {{ option.text }}\n      </template>\n    </BFormSelectOption>\n    <slot />\n  </optgroup>\n</template>\n\n<script setup lang=\"ts\" generic=\"T\">\nimport BFormSelectOption from './BFormSelectOption.vue'\nimport {useFormSelect} from '../../composables'\nimport type {BFormSelectOptionGroupProps, SelectOption} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(defineProps<BFormSelectOptionGroupProps>(), {\n  disabledField: 'disabled',\n  htmlField: 'html',\n  label: undefined,\n  options: () => [],\n  textField: 'text',\n  valueField: 'value',\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  first?: (props: Record<string, never>) => any\n}>()\n\nconst {normalizedOptions} = useFormSelect(() => props.options, props)\n\nconst normalizedOptsWrapper = computed(() => normalizedOptions.value as SelectOption<T>[])\n</script>\n","<template>\n  <select\n    :id=\"computedId\"\n    ref=\"input\"\n    v-model=\"localValue\"\n    :class=\"computedClasses\"\n    :name=\"name\"\n    :form=\"form || undefined\"\n    :multiple=\"props.multiple || undefined\"\n    :size=\"computedSelectSize\"\n    :disabled=\"props.disabled\"\n    :required=\"props.required || undefined\"\n    :aria-required=\"props.required || undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n  >\n    <slot name=\"first\" />\n    <template v-for=\"(option, index) in normalizedOptsWrapper\" :key=\"index\">\n      <BFormSelectOptionGroup\n        v-if=\"isComplex(option)\"\n        :label=\"option.label\"\n        :options=\"option.options\"\n        :value-field=\"valueField\"\n        :text-field=\"textField\"\n        :html-field=\"htmlField\"\n        :disabled-field=\"disabledField\"\n      />\n      <BFormSelectOption v-else :value=\"option.value\" :disabled=\"option.disabled\">\n        <!-- eslint-disable-next-line vue/no-v-html -->\n        <span v-if=\"!!option.html\" v-html=\"option.html\" />\n        <template v-else>\n          {{ option.text }}\n        </template>\n      </BFormSelectOption>\n    </template>\n    <slot />\n  </select>\n</template>\n\n<script setup lang=\"ts\" generic=\"T\">\nimport type {BFormSelectProps, ComplexSelectOptionRaw, SelectOption} from '../../types'\nimport {computed, ref, toRef} from 'vue'\nimport BFormSelectOption from './BFormSelectOption.vue'\nimport BFormSelectOptionGroup from './BFormSelectOptionGroup.vue'\nimport {useAriaInvalid, useFormSelect, useId, useStateClass} from '../../composables'\nimport {useFocus, useToNumber} from '@vueuse/core'\n\nconst props = withDefaults(defineProps<BFormSelectProps>(), {\n  ariaInvalid: undefined,\n  autofocus: false,\n  disabled: false,\n  disabledField: 'disabled',\n  form: undefined,\n  htmlField: 'html',\n  id: undefined,\n  labelField: 'label',\n  multiple: false,\n  name: undefined,\n  // eslint-disable-next-line vue/require-valid-default-prop\n  options: () => [],\n  optionsField: 'options',\n  plain: false,\n  required: false,\n  selectSize: 0,\n  size: 'md',\n  state: null,\n  textField: 'text',\n  valueField: 'value',\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  first?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = defineModel<T>({\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default: '' as any,\n})\n\nconst computedId = useId(() => props.id, 'input')\n\nconst selectSizeNumber = useToNumber(() => props.selectSize)\n\nconst stateClass = useStateClass(() => props.state)\n\nconst input = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(input, {\n  initialValue: props.autofocus,\n})\n\nconst computedClasses = computed(() => [\n  stateClass.value,\n  {\n    'form-control': props.plain,\n    [`form-control-${props.size}`]: props.size !== 'md' && props.plain,\n    'form-select': !props.plain,\n    [`form-select-${props.size}`]: props.size !== 'md' && !props.plain,\n  },\n])\n\nconst computedSelectSize = toRef(() =>\n  selectSizeNumber.value || props.plain ? selectSizeNumber.value : undefined\n)\n\nconst computedAriaInvalid = useAriaInvalid(\n  () => props.ariaInvalid,\n  () => props.state\n)\n\nconst {normalizedOptions, isComplex} = useFormSelect(() => props.options, props)\n\nconst normalizedOptsWrapper = computed(\n  () => normalizedOptions.value as readonly (ComplexSelectOptionRaw<T> | SelectOption<T>)[]\n)\n\nconst localValue = computed({\n  get: () => modelValue.value,\n  set: (newValue) => {\n    modelValue.value = newValue\n  },\n})\n\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  element: input,\n  focus: () => {\n    focused.value = true\n  },\n})\n</script>\n","export const CODE_BACKSPACE = 'Backspace'\nexport const CODE_BREAK = 19\nexport const CODE_DELETE = 46\nexport const CODE_DOWN = 'ArrowDown'\nexport const CODE_END = 'End'\nexport const CODE_ENTER = 13\nexport const CODE_ESC = 27\nexport const CODE_HOME = 'Home'\nexport const CODE_LEFT = 37\nexport const CODE_PAGEDOWN = 'PageDown'\nexport const CODE_PAGEUP = 'PageUp'\nexport const CODE_RIGHT = 39\nexport const CODE_SPACE = 32\nexport const CODE_UP = 'ArrowUp'\n","<template>\n  <div\n    ref=\"element\"\n    class=\"b-form-spinbutton form-control\"\n    :class=\"computedClasses\"\n    role=\"group\"\n    :lang=\"computedLocale\"\n    :tabindex=\"props.disabled ? undefined : '-1'\"\n    :title=\"ariaLabel\"\n    @click=\"focused = true\"\n  >\n    <!-- eslint-disable-next-line prettier/prettier -->\n    <!-- prettier-ignore -->\n    <slot :name=\"(buttons.top.slot.name as 'increment' | 'decrement')\" :has-focus=\"focused\">\n      <button\n        v-bind=\"buttons.top.button\"\n        @mousedown=\"buttons.top.handler\"\n        @touchstart=\"buttons.top.handler\"\n      >\n        <svg v-bind=\"buttons.top.svg\">\n          <path v-bind=\"buttons.top.path\" />\n        </svg>\n      </button>\n    </slot>\n    <input\n      v-if=\"name && !props.disabled\"\n      key=\"hidden\"\n      type=\"hidden\"\n      :name=\"name\"\n      :form=\"form\"\n      :value=\"valueAsFixed\"\n    />\n    <output\n      :id=\"computedId\"\n      key=\"output\"\n      class=\"flex-grow-1\"\n      :class=\"computedSpinClasses\"\n      :dir=\"isRtl ?? false ? 'rtl' : 'ltr'\"\n      :tabindex=\"props.disabled ? undefined : '0'\"\n      role=\"spinbutton\"\n      aria-live=\"off\"\n      :aria-label=\"ariaLabel || undefined\"\n      :aria-invalid=\"\n        props.state === false || (!modelValue !== null && props.required) ? true : undefined\n      \"\n      :aria-required=\"props.required ? true : undefined\"\n      :aria-valuemin=\"computedMin\"\n      :aria-valuemax=\"computedMax\"\n      :aria-valuenow=\"modelValue !== null ? modelValue : undefined\"\n      :aria-valuetext=\"modelValue !== null ? computedFormatter(modelValue) : undefined\"\n    >\n      <bdi>\n        {{ (modelValue !== null ? computedFormatter(modelValue) : placeholder) || '' }}\n      </bdi>\n    </output>\n    <!-- eslint-disable-next-line prettier/prettier -->\n    <!-- prettier-ignore -->\n    <slot :name=\"(buttons.bottom.slot.name as 'increment' | 'decrement')\" :has-focus=\"focused\">\n      <button\n        v-bind=\"buttons.bottom.button\"\n        @mousedown=\"buttons.bottom.handler\"\n        @touchstart=\"buttons.bottom.handler\"\n      >\n        <svg v-bind=\"buttons.bottom.svg\">\n          <path v-bind=\"buttons.bottom.path\" />\n        </svg>\n      </button>\n    </slot>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, ref, toRef} from 'vue'\nimport type {BFormSpinbuttonProps, ButtonType} from '../../types'\nimport {eventOnOff} from '../../utils/event'\nimport {\n  CODE_DOWN,\n  CODE_END,\n  CODE_HOME,\n  CODE_PAGEDOWN,\n  CODE_PAGEUP,\n  CODE_UP,\n} from '../../constants/codes'\nimport {onKeyStroke, useFocus, useToNumber} from '@vueuse/core'\nimport {useId, useRtl} from '../../composables'\n\nconst KEY_CODES = [CODE_UP, CODE_DOWN, CODE_HOME, CODE_END, CODE_PAGEUP, CODE_PAGEDOWN]\n\nconst props = withDefaults(defineProps<BFormSpinbuttonProps>(), {\n  ariaControls: undefined,\n  ariaLabel: undefined,\n  disabled: false,\n  form: undefined,\n  formatterFn: undefined,\n  id: undefined,\n  inline: false,\n  labelDecrement: 'Decrement',\n  labelIncrement: 'Increment',\n  locale: undefined,\n  max: defaultValues.max,\n  min: defaultValues.min,\n  name: undefined,\n  placeholder: undefined,\n  readonly: false,\n  repeatDelay: defaultValues.repeatDelay,\n  repeatInterval: defaultValues.repeatInterval,\n  repeatStepMultiplier: defaultValues.repeatMultiplier,\n  repeatThreshold: defaultValues.repeatThreshold,\n  required: false,\n  size: undefined,\n  state: null,\n  step: defaultValues.step,\n  vertical: false,\n  wrap: false,\n})\n\nconst emit = defineEmits<{\n  change: [value: number | null]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  decrement?: (props: {hasFocus: boolean}) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  increment?: (props: {hasFocus: boolean}) => any\n}>()\n\nconst modelValue = defineModel<number | null>({\n  default: null,\n})\n\n// TODO focus system\nconst element = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(element)\n\nconst computedId = useId(() => props.id, 'spinbutton')\n\nconst computedClasses = computed(() => ({\n  'disabled': props.disabled,\n  'readonly': props.readonly,\n  'focus': focused.value,\n  'd-inline-flex': props.inline || props.vertical,\n  'd-flex': !props.inline && !props.vertical,\n  'align-items-stretch': !props.vertical,\n  'flex-column': props.vertical,\n  [`form-control-${props.size}`]: props.size !== undefined,\n}))\n\nconst computedSpinClasses = computed(() => ({\n  'd-flex': props.vertical,\n  'align-self-center': !props.vertical,\n  'align-items-center': props.vertical,\n  'border-top': props.vertical,\n  'border-bottom': props.vertical,\n  'border-start': !props.vertical,\n  'border-end': !props.vertical,\n}))\n\n//non reactive properties\nlet $_autoDelayTimer: ReturnType<typeof setTimeout> | undefined\nlet $_autoRepeatTimer: ReturnType<typeof setTimeout> | undefined\nlet $_keyIsDown = false\n\n// const computedInline = computed(() => props.inline && !props.vertical)\n\n// const computedReadonly = computed(() => props.readonly && !props.disabled)\n\nconst stepNumber = useToNumber(() => props.step)\nconst computedStep = toRef(() =>\n  Number.isNaN(stepNumber.value) ? defaultValues.step : stepNumber.value\n)\n\nconst minNumber = useToNumber(() => props.min)\nconst computedMin = toRef(() =>\n  Number.isNaN(minNumber.value) ? defaultValues.min : minNumber.value\n)\n\nconst maxNumber = useToNumber(() => props.max)\nconst computedMax = toRef(() => {\n  const step = computedStep.value\n  const min = computedMin.value\n  return Math.floor((maxNumber.value - min) / step) * step + min\n})\n\nconst repeatDelayNumber = useToNumber(() => props.repeatDelay, {\n  nanToZero: true,\n  method: 'parseInt',\n})\nconst computedDelay = toRef(() =>\n  repeatDelayNumber.value > 0 ? repeatDelayNumber.value : defaultValues.repeatDelay\n)\n\nconst repeatIntervalNumber = useToNumber(() => props.repeatInterval, {\n  nanToZero: true,\n  method: 'parseInt',\n})\nconst computedInterval = toRef(() =>\n  repeatIntervalNumber.value > 0 ? repeatIntervalNumber.value : defaultValues.repeatInterval\n)\n\nconst repeatThresholdNumber = useToNumber(() => props.repeatThreshold, {\n  nanToZero: true,\n  method: 'parseInt',\n})\nconst computedThreshold = toRef(() =>\n  Math.max(\n    Number.isNaN(repeatThresholdNumber.value)\n      ? defaultValues.repeatThreshold\n      : repeatThresholdNumber.value,\n    1\n  )\n)\n\nconst repeatStepMultiplierNumber = useToNumber(() => props.repeatStepMultiplier, {\n  nanToZero: true,\n  method: 'parseInt',\n})\nconst computedStepMultiplier = toRef(() =>\n  Math.max(\n    Number.isNaN(repeatStepMultiplierNumber.value)\n      ? defaultValues.repeatMultiplier\n      : repeatStepMultiplierNumber.value,\n    1\n  )\n)\n\nconst computedPrecision = toRef(() => {\n  const step = computedStep.value\n  return Math.floor(step) === step ? 0 : (step.toString().split('.')[1] || '').length\n})\n\nconst computedMultiplier = toRef(() => Math.pow(10, computedPrecision.value || 0))\n\nconst valueAsFixed = toRef(() =>\n  modelValue.value === null ? '' : modelValue.value.toFixed(computedPrecision.value)\n)\n\nconst {isRtl, locale: globalLocale} = useRtl()\n\nconst computedLocale = computed(() => {\n  const loc = (props.locale ?? globalLocale?.value) || 'locale'\n  const locales = [loc]\n  const nf = new Intl.NumberFormat(locales)\n  return nf.resolvedOptions().locale\n})\n\nconst defaultFormatter = () =>\n  new Intl.NumberFormat(computedLocale.value, {\n    style: 'decimal',\n    useGrouping: false,\n    minimumIntegerDigits: 1,\n    minimumFractionDigits: computedPrecision.value,\n    maximumFractionDigits: computedPrecision.value,\n    notation: 'standard',\n  }).format\n\nconst computedFormatter = toRef(() => props.formatterFn ?? defaultFormatter())\n\nconst stepValue = (direction: number) => {\n  // Sets a new incremented or decremented value, supporting optional wrapping\n  // Direction is either +1 or -1 (or a multiple thereof)\n  let {value} = modelValue\n  if (!props.disabled && value !== null) {\n    const step = computedStep.value * direction\n    const min = computedMin.value\n    const max = computedMax.value\n    const multiplier = computedMultiplier.value\n    const {wrap} = props\n    // We ensure that the value steps like a native input\n    value = Math.round((value - min) / step) * step + min + step\n    // We ensure that precision is maintained (decimals)\n    value = Math.round(value * multiplier) / multiplier\n    // Handle if wrapping is enabled\n    modelValue.value = value > max ? (wrap ? min : max) : value < min ? (wrap ? max : min) : value\n  }\n}\n\nconst stepUp = (multiplier = 1) => {\n  if (modelValue.value === null) {\n    modelValue.value = computedMin.value\n    return\n  }\n  stepValue(+1 * multiplier)\n}\n\nconst stepDown = (multiplier = 1) => {\n  if (modelValue.value === null) {\n    modelValue.value = props.wrap ? computedMax.value : computedMin.value\n    return\n  }\n  stepValue(-1 * multiplier)\n}\n\nconst stopEvent = (event: Readonly<Event>) => {\n  event.preventDefault()\n  event.stopImmediatePropagation()\n}\n\nonKeyStroke(\n  KEY_CODES,\n  (event) => {\n    const {code, altKey, ctrlKey, metaKey} = event\n\n    if (props.disabled || props.readonly || altKey || ctrlKey || metaKey) return\n\n    // https://w3c.github.io/aria-practices/#spinbutton\n    stopEvent(event)\n    if ($_keyIsDown) {\n      // Keypress is already in progress\n      return\n    }\n\n    resetTimers()\n    if ([CODE_UP, CODE_DOWN].includes(code)) {\n      // The following use the custom auto-repeat handling\n\n      $_keyIsDown = true\n      if (code === CODE_UP) {\n        handleStepRepeat(event, stepUp)\n        return\n      }\n      if (code === CODE_DOWN) {\n        handleStepRepeat(event, stepDown)\n      }\n      return\n    }\n    // These use native OS key repeating\n    if (code === CODE_PAGEUP) {\n      stepUp(computedStepMultiplier.value)\n      return\n    }\n    if (code === CODE_PAGEDOWN) {\n      stepDown(computedStepMultiplier.value)\n      return\n    }\n    if (code === CODE_HOME) {\n      modelValue.value = computedMin.value\n      return\n    }\n    if (code === CODE_END) {\n      modelValue.value = computedMax.value\n    }\n  },\n  {target: element, eventName: 'keydown'}\n)\n\nonKeyStroke(\n  KEY_CODES,\n  (event: Readonly<KeyboardEvent>) => {\n    // Emit a change event when the keyup happens\n\n    const {altKey, ctrlKey, metaKey} = event\n\n    if (props.disabled || props.readonly || altKey || ctrlKey || metaKey) return\n\n    stopEvent(event)\n    resetTimers()\n    $_keyIsDown = false\n    emit('change', modelValue.value)\n  },\n  {target: element, eventName: 'keyup'}\n)\n\n// takes in a mount or Keyboard Event\nconst handleStepRepeat = (event: Readonly<Event>, stepper: (step: number) => void) => {\n  const {type} = event || {}\n\n  if (!props.disabled && !props.readonly) {\n    if (isMouseEvent(event)) {\n      // We only respond to left (main === 0) button clicks\n      if (type === 'mousedown' && event.button) return\n    }\n    resetTimers()\n    // Step the counter initially\n    stepper(1)\n    const threshold = computedThreshold.value\n    const multiplier = computedStepMultiplier.value\n    const delay = computedDelay.value\n    const interval = computedInterval.value\n\n    // Initiate the delay/repeat interval\n    $_autoDelayTimer = setTimeout(() => {\n      let count = 0\n      $_autoRepeatTimer = setInterval(() => {\n        // After N initial repeats, we increase the incrementing step amount\n        // We do this to minimize screen reader announcements of the value\n        // (values are announced every change, which can be chatty for SR users)\n        // And to make it easer to select a value when the range is large\n        stepper(count < threshold ? 1 : multiplier)\n        count++\n      }, interval)\n    }, delay)\n  }\n}\n\nconst isMouseEvent = (evt: Readonly<Event>): evt is MouseEvent =>\n  evt.type === 'mouseup' || evt.type === 'mousedown'\n\nconst onMouseup: EventListener = (event: Readonly<Event>) => {\n  // `<body>` listener, only enabled when mousedown starts\n\n  if (isMouseEvent(event)) {\n    if (event.type === 'mouseup' && event.button) {\n      // Ignore non left button (main === 0) mouse button click\n      return\n    }\n  }\n\n  stopEvent(event)\n  resetTimers()\n  setMouseup(false)\n  // Trigger the change event\n  emit('change', modelValue.value)\n}\n\nconst setMouseup = (on: boolean) => {\n  // Enable or disabled the body mouseup/touchend handlers\n  // Use try/catch to handle case when called server side\n  try {\n    eventOnOff(on, [document.body, 'mouseup', onMouseup, false])\n    eventOnOff(on, [document.body, 'touchend', onMouseup, false])\n  } catch {\n    /* empty */\n  }\n}\nconst resetTimers = () => {\n  clearTimeout($_autoDelayTimer)\n  clearInterval($_autoRepeatTimer)\n  $_autoDelayTimer = undefined\n  $_autoRepeatTimer = undefined\n}\n\nconst buttons = computed(() => {\n  const incrementSvgAttrs = {\n    svg: {\n      xmlns: 'http://www.w3.org/2000/svg',\n      width: '16',\n      height: '16',\n      fill: 'currentColor',\n      class: 'bi bi-plus',\n      viewBox: '0 0 16 16',\n    },\n    path: {\n      d: 'M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z',\n    },\n  } as const\n\n  const decrementSvgAttrs = {\n    svg: {\n      xmlns: 'http://www.w3.org/2000/svg',\n      width: '16',\n      height: '16',\n      fill: 'currentColor',\n      class: 'bi bi-dash',\n      viewBox: '0 0 16 16',\n    },\n    path: {d: 'M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z'},\n  } as const\n\n  const sharedButtonAttrs = {\n    'class': [{'py-0': !props.vertical}, 'btn', 'btn-sm', 'border-0', 'rounded-0'],\n    'tabindex': '-1',\n    'type': 'button' as ButtonType,\n    'disabled': props.disabled || props.readonly,\n    'aria-disabled': props.disabled || props.readonly ? true : undefined,\n    'aria-controls': computedId.value,\n  }\n\n  const sharedSvgAttrs = {\n    'aria-hidden': true,\n    'scale': focused.value ? 1.5 : 1.25,\n  }\n\n  const handler = (event: Readonly<Event>, stepper: (multiplier?: number) => void) => {\n    if (!props.disabled && !props.readonly) {\n      stopEvent(event)\n      setMouseup(true)\n      // Since we `preventDefault()`, we must manually focus the button\n      // Though it's likely captured from the element click focus\n      focused.value = true\n      handleStepRepeat(event, stepper)\n    }\n  }\n\n  const incrementAttrs = {\n    button: {\n      ...sharedButtonAttrs,\n      'aria-label': props.labelIncrement || undefined,\n      'aria-keyshortcuts': 'ArrowUp',\n    },\n    svg: {\n      ...sharedSvgAttrs,\n      ...incrementSvgAttrs.svg,\n    },\n    path: {\n      ...incrementSvgAttrs.path,\n    },\n    slot: {\n      name: 'increment',\n    },\n    handler: (e: Event) => handler(e, stepUp),\n  }\n\n  const decrementAttrs = {\n    button: {\n      ...sharedButtonAttrs,\n      'aria-label': props.labelDecrement || undefined,\n      'aria-keyshortcuts': 'ArrowDown',\n    },\n    svg: {\n      ...sharedSvgAttrs,\n      ...decrementSvgAttrs.svg,\n    },\n    path: {\n      ...decrementSvgAttrs.path,\n    },\n    slot: {\n      name: 'decrement',\n    },\n    handler: (e: Readonly<Event>) => handler(e, stepDown),\n  }\n\n  return {\n    top: {\n      ...(props.vertical ? incrementAttrs : decrementAttrs),\n    },\n    bottom: {\n      ...(!props.vertical ? incrementAttrs : decrementAttrs),\n    },\n  }\n})\n</script>\n\n<script lang=\"ts\">\nconst defaultValues = {\n  min: 1,\n  max: 100,\n  step: 1,\n  repeatDelay: 500,\n  repeatInterval: 100,\n  repeatThreshold: 10,\n  repeatMultiplier: 4,\n} as const\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"computedId\"\n    :title=\"tagText\"\n    class=\"badge b-form-tag d-inline-flex align-items-center mw-100\"\n    :class=\"computedClasses\"\n    :aria-labelledby=\"taglabelId\"\n  >\n    <span :id=\"taglabelId\" class=\"b-form-tag-content flex-grow-1 text-truncate\">\n      <slot>{{ tagText }}</slot>\n    </span>\n    <BCloseButton\n      v-if=\"!props.disabled && !props.noRemove\"\n      aria-keyshortcuts=\"Delete\"\n      :aria-label=\"removeLabel\"\n      class=\"b-form-tag-remove\"\n      :aria-describedby=\"taglabelId\"\n      :aria-controls=\"id\"\n      @click=\"emit('remove', tagText)\"\n    />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport {useId} from '../../composables'\nimport type {BFormTagProps} from '../../types'\nimport BCloseButton from '../BButton/BCloseButton.vue'\n\nconst props = withDefaults(defineProps<BFormTagProps>(), {\n  disabled: false,\n  id: undefined,\n  noRemove: false,\n  pill: false,\n  removeLabel: 'Remove tag',\n  tag: 'span',\n  title: undefined,\n  variant: 'secondary',\n})\n\nconst emit = defineEmits<{\n  remove: [value: string]\n}>()\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedId = useId(() => props.id)\n\nconst tagText = computed(\n  () => ((slots.default?.({})[0].children ?? '').toString() || props.title) ?? ''\n)\nconst taglabelId = toRef(() => `${computedId.value}taglabel__`)\n\nconst computedClasses = computed(() => ({\n  [`text-bg-${props.variant}`]: props.variant !== null,\n  'rounded-pill': props.pill,\n  'disabled': props.disabled,\n}))\n</script>\n","<template>\n  <div\n    :id=\"computedId\"\n    class=\"b-form-tags form-control h-auto\"\n    :class=\"computedClasses\"\n    role=\"group\"\n    tabindex=\"-1\"\n    @focusin=\"onFocusin\"\n    @focusout=\"emit('focusout', $event)\"\n  >\n    <output\n      :id=\"`${computedId}selected_tags__`\"\n      class=\"visually-hidden\"\n      :for=\"_inputId\"\n      :aria-live=\"focused ? 'polite' : 'off'\"\n      aria-atomic=\"true\"\n      aria-relevant=\"additions text\"\n      >{{ tags.join(', ') }}</output\n    >\n    <div\n      :id=\"`${computedId}removed_tags__`\"\n      role=\"status\"\n      :aria-live=\"focused ? 'assertive' : 'off'\"\n      aria-atomic=\"true\"\n      class=\"visually-hidden\"\n    >\n      ({{ tagRemovedLabel }}) {{ lastRemovedTag }}\n    </div>\n\n    <slot v-bind=\"slotAttrs\">\n      <ul\n        :id=\"`${computedId}tag_list__`\"\n        class=\"b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center\"\n      >\n        <template v-for=\"(tag, index) in tags\" :key=\"index\">\n          <slot\n            name=\"tag\"\n            :tag=\"tag\"\n            :tag-class=\"tagClass\"\n            :tag-variant=\"tagVariant\"\n            :tag-pills=\"props.tagPills\"\n            :remove-tag=\"removeTag\"\n          >\n            <BFormTag\n              :key=\"tag\"\n              :class=\"tagClass\"\n              tag=\"li\"\n              :variant=\"tagVariant\"\n              :pill=\"tagPills\"\n              @remove=\"removeTag\"\n              >{{ tag }}</BFormTag\n            >\n          </slot>\n        </template>\n        <li\n          role=\"none\"\n          aria-live=\"off\"\n          class=\"b-from-tags-field flex-grow-1\"\n          :aria-controls=\"`${computedId}tag_list__`\"\n        >\n          <div role=\"group\" class=\"d-flex\">\n            <input\n              :id=\"_inputId\"\n              ref=\"input\"\n              :disabled=\"props.disabled\"\n              :value=\"inputValue\"\n              :type=\"inputType\"\n              :placeholder=\"placeholder\"\n              class=\"b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0\"\n              style=\"outline: currentcolor none 0px; min-width: 5rem\"\n              v-bind=\"inputAttrs\"\n              :form=\"form\"\n              :required=\"props.required || undefined\"\n              :aria-required=\"props.required || undefined\"\n              @input=\"onInput\"\n              @change=\"onChange\"\n              @focus=\"onFocus\"\n              @blur=\"onBlur\"\n            />\n            <button\n              v-if=\"disableAddButton\"\n              type=\"button\"\n              class=\"btn b-form-tags-button py-0\"\n              :class=\"[\n                inputClass,\n                {\n                  [`btn-${addButtonVariant}`]: addButtonVariant !== null,\n                  'disabled invisible': inputValue.length === 0,\n                },\n              ]\"\n              style=\"font-size: 90%\"\n              :disabled=\"props.disabled || inputValue.length === 0 || isLimitReached\"\n              @click=\"addTag(inputValue)\"\n            >\n              <slot name=\"add-button-text\">{{ addButtonText }}</slot>\n            </button>\n          </div>\n        </li>\n      </ul>\n      <div aria-live=\"polite\" aria-atomic=\"true\">\n        <div v-if=\"isInvalid\" class=\"d-block invalid-feedback\">\n          {{ invalidTagText }}: {{ inputValue }}\n        </div>\n        <small v-if=\"isDuplicate\" class=\"form-text text-body-secondary\"\n          >{{ duplicateTagText }}: {{ inputValue }}</small\n        >\n        <small v-if=\"tags.length === limit\" class=\"form-text text-body-secondary\">\n          {{ limitTagsText }}</small\n        >\n      </div>\n    </slot>\n    <template v-if=\"name\">\n      <input v-for=\"(tag, index) in tags\" :key=\"index\" type=\"hidden\" :name=\"name\" :value=\"tag\" />\n    </template>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {onKeyStroke, syncRef, useFocus, useToNumber} from '@vueuse/core'\nimport {computed, ref, toRef} from 'vue'\nimport {useId, useStateClass} from '../../composables'\nimport type {BFormTagsProps, ClassValue, ColorVariant} from '../../types'\nimport {escapeRegExpChars} from '../../utils'\nimport BFormTag from './BFormTag.vue'\n\nconst props = withDefaults(defineProps<BFormTagsProps>(), {\n  addButtonText: 'Add',\n  addButtonVariant: 'outline-secondary',\n  addOnChange: false,\n  autofocus: false,\n  disabled: false,\n  duplicateTagText: 'Duplicate tag(s)',\n  form: undefined,\n  inputAttrs: undefined,\n  inputClass: undefined,\n  inputId: undefined,\n  inputType: 'text',\n  invalidTagText: 'Invalid tag(s)',\n  limit: undefined,\n  limitTagsText: 'Tag limit reached',\n  name: undefined,\n  noAddOnEnter: false,\n  noOuterFocus: false,\n  noTagRemove: false,\n  placeholder: 'Add tag...',\n  removeOnDelete: false,\n  required: false,\n  separator: undefined,\n  size: 'md',\n  state: null,\n  tagClass: undefined,\n  tagPills: false,\n  tagRemoveLabel: undefined,\n  tagRemovedLabel: 'Tag removed',\n  tagValidator: () => true,\n  tagVariant: 'secondary',\n})\n\nconst emit = defineEmits<{\n  'blur': [value: FocusEvent]\n  'focus': [value: FocusEvent]\n  'focusin': [value: FocusEvent]\n  'focusout': [value: FocusEvent]\n  'tag-state': [...args: string[][]]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'add-button-text'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: typeof slotAttrs.value) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'tag'?: (props: {\n    tag: string\n    tagClass: ClassValue\n    tagVariant: ColorVariant | null\n    tagPills: boolean\n    removeTag: (tag?: string) => void\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n}>()\n\nconst modelValue = defineModel<string[]>({\n  default: () => [],\n})\n\nconst computedId = useId()\n\nconst limitNumber = useToNumber(() => props.limit ?? NaN)\n\nconst stateClass = useStateClass(() => props.state)\n\nconst input = ref<HTMLInputElement | null>(null)\n\nconst {focused} = useFocus(input, {\n  initialValue: props.autofocus,\n})\n\nconst _inputId = toRef(() => props.inputId || `${computedId.value}input__`)\nconst tags = ref<string[]>([...modelValue.value])\nconst inputValue = ref<string>('')\nconst shouldRemoveOnDelete = ref<boolean>(modelValue.value.length > 0)\nconst lastRemovedTag = ref<string>('')\nconst validTags = ref<string[]>([])\nconst invalidTags = ref<string[]>([])\nconst duplicateTags = ref<string[]>([])\n\nsyncRef(modelValue, tags, {\n  direction: 'ltr',\n  transform: {\n    ltr: (v) => [...v],\n  },\n})\n\nconst computedClasses = computed(() => [\n  stateClass.value,\n  {\n    [`form-control-${props.size}`]: props.size !== 'md',\n    disabled: props.disabled,\n    focus: focused.value,\n  },\n])\n\nconst isDuplicate = computed(() => tags.value.includes(inputValue.value))\nconst isInvalid = computed(() =>\n  inputValue.value === '' ? false : !props.tagValidator(inputValue.value)\n)\nconst isLimitReached = toRef(() => tags.value.length === limitNumber.value)\nconst disableAddButton = toRef(() => !isInvalid.value && !isDuplicate.value)\n\nconst slotAttrs = computed(() => ({\n  addButtonText: props.addButtonText,\n  addButtonVariant: props.addButtonVariant,\n  addTag,\n  disableAddButton: disableAddButton.value,\n  disabled: props.disabled,\n  duplicateTagText: props.duplicateTagText,\n  duplicateTags: duplicateTags.value,\n  form: props.form,\n  inputAttrs: {\n    ...props.inputAttrs,\n    disabled: props.disabled,\n    form: props.form,\n    id: _inputId,\n    value: inputValue,\n  },\n  inputHandlers: {\n    input: onInput,\n    keydown: onKeydown,\n    change: onChange,\n  },\n  inputId: _inputId,\n  inputType: props.inputType,\n  invalidTagText: props.invalidTagText,\n  invalidTags: invalidTags.value,\n  isDuplicate: isDuplicate.value,\n  isInvalid: isInvalid.value,\n  isLimitReached: isLimitReached.value,\n  limitTagsText: props.limitTagsText,\n  limit: limitNumber.value,\n  noTagRemove: props.noTagRemove,\n  placeholder: props.placeholder,\n  removeTag,\n  required: props.required,\n  separator: props.separator,\n  size: props.size,\n  state: props.state,\n  tagClass: props.tagClass,\n  tagPills: props.tagPills,\n  tagRemoveLabel: props.tagRemoveLabel,\n  tagVariant: props.tagVariant,\n  tags: tags.value,\n}))\n\nconst onFocusin = (e: Readonly<FocusEvent>): void => {\n  if (props.disabled) {\n    const target = e.target as HTMLDivElement\n    target.blur()\n    return\n  }\n\n  emit('focusin', e)\n}\n\nconst onFocus = (e: Readonly<FocusEvent>): void => {\n  if (props.disabled || props.noOuterFocus) {\n    return\n  }\n\n  focused.value = true\n  emit('focus', e)\n}\n\nconst onBlur = (e: Readonly<FocusEvent>): void => {\n  focused.value = false\n  emit('blur', e)\n}\n\nconst onInput = (e: Readonly<Event> | string): void => {\n  const value = typeof e === 'string' ? e : (e.target as HTMLInputElement).value\n\n  shouldRemoveOnDelete.value = false\n\n  if (props.separator?.includes(value.charAt(0)) && value.length > 0) {\n    if (input.value) {\n      input.value.value = ''\n    }\n    return\n  }\n\n  inputValue.value = value\n\n  if (props.separator?.includes(value.charAt(value.length - 1))) {\n    addTag(value.slice(0, value.length - 1))\n    return\n  }\n\n  validTags.value = props.tagValidator(value) && !isDuplicate.value ? [value] : []\n  invalidTags.value = props.tagValidator(value) ? [] : [value]\n  duplicateTags.value = isDuplicate.value ? [value] : []\n\n  emit('tag-state', validTags.value, invalidTags.value, duplicateTags.value)\n}\n\nconst onChange = (e: Readonly<Event>): void => {\n  if (props.addOnChange) {\n    onInput(e)\n\n    if (!isDuplicate.value) {\n      addTag(inputValue.value)\n    }\n  }\n}\n\nconst onKeydown = (e: Readonly<KeyboardEvent>): void => {\n  if (e.key === 'Enter' && !props.noAddOnEnter) {\n    addTag(inputValue.value)\n    return\n  }\n\n  if (\n    (e.key === 'Backspace' || e.key === 'Delete') &&\n    props.removeOnDelete &&\n    inputValue.value === '' &&\n    shouldRemoveOnDelete.value &&\n    tags.value.length > 0\n  ) {\n    removeTag(tags.value[tags.value.length - 1])\n  } else {\n    shouldRemoveOnDelete.value = true\n  }\n}\n\nonKeyStroke(onKeydown, {target: input})\n\nconst separator = computed(() => {\n  if (!props.separator) {\n    return\n  }\n\n  return typeof props.separator === 'string' ? props.separator : props.separator.join('')\n})\n\nconst separatorRegExp = computed(() => {\n  if (!separator.value) {\n    return\n  }\n\n  return new RegExp(`[${escapeRegExpChars(separator.value)}]+`)\n})\n\nconst addTag = (tag?: string): void => {\n  tag = (tag ?? inputValue.value).trim()\n\n  const newTags = separatorRegExp.value\n    ? tag.split(separatorRegExp.value).map((t) => t.trim())\n    : [tag]\n  const validTags: string[] = []\n\n  for (const newTag of newTags) {\n    if (newTag === '' || isDuplicate.value || !props.tagValidator(newTag)) {\n      continue\n    }\n\n    if (limitNumber.value && isLimitReached.value) {\n      break\n    }\n\n    validTags.push(newTag)\n  }\n\n  const newValue = [...modelValue.value, ...validTags]\n  inputValue.value = ''\n  shouldRemoveOnDelete.value = true\n  modelValue.value = newValue\n  focused.value = true\n}\n\nconst removeTag = (tag?: string): void => {\n  const tagIndex = tags.value.indexOf(tag?.toString() ?? '')\n  if (tagIndex === -1) return\n  lastRemovedTag.value = tags.value.splice(tagIndex, 1).toString() // TODO this seems strange, if index === -1 you'll remove the last el\n  modelValue.value = tags.value\n}\n\n// TODO these focus/blur events aren't quite in line with use useFormInput implementation. Perhaps we should bring them together?\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  element: input,\n  focus: () => {\n    focused.value = true\n  },\n})\n</script>\n","<template>\n  <textarea\n    :id=\"computedId\"\n    ref=\"input\"\n    :class=\"computedClasses\"\n    :name=\"name || undefined\"\n    :form=\"form || undefined\"\n    :value=\"modelValue ?? undefined\"\n    :disabled=\"props.disabled\"\n    :placeholder=\"placeholder\"\n    :required=\"props.required || undefined\"\n    :autocomplete=\"autocomplete || undefined\"\n    :readonly=\"props.readonly || props.plaintext\"\n    :aria-required=\"required || undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n    :rows=\"rows\"\n    :style=\"computedStyles\"\n    :wrap=\"wrap || undefined\"\n    @input=\"onInput($event)\"\n    @change=\"onChange($event)\"\n    @blur=\"onBlur($event)\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport type {BFormTextareaProps, Numberish} from '../../types'\nimport {computed, type CSSProperties} from 'vue'\nimport {useFormInput, useStateClass} from '../../composables'\n\nconst props = withDefaults(defineProps<BFormTextareaProps>(), {\n  // CommonInputProps\n  ariaInvalid: undefined,\n  autocomplete: undefined,\n  autofocus: false,\n  debounce: 0,\n  debounceMaxWait: NaN,\n  disabled: false,\n  form: undefined,\n  formatter: undefined,\n  id: undefined,\n  lazy: false,\n  lazyFormatter: false,\n  list: undefined,\n  modelValue: '',\n  name: undefined,\n  number: false,\n  placeholder: undefined,\n  plaintext: false,\n  readonly: false,\n  required: false,\n  size: undefined,\n  state: null,\n  trim: false,\n  // End CommonInputProps\n  noResize: false,\n  rows: 2,\n  wrap: 'soft',\n})\n\nconst emit = defineEmits<{\n  'update:modelValue': [val: Numberish | null]\n}>()\n\nconst {input, computedId, computedAriaInvalid, onInput, onChange, onBlur, focus, blur} =\n  useFormInput(props, emit)\n\nconst stateClass = useStateClass(() => props.state)\n\nconst computedClasses = computed(() => [\n  stateClass.value,\n  props.plaintext ? 'form-control-plaintext' : 'form-control',\n  {\n    [`form-control-${props.size}`]: !!props.size,\n  },\n])\n\nconst computedStyles = computed<CSSProperties>(() => ({\n  resize: props.noResize ? 'none' : undefined,\n}))\n\ndefineExpose({\n  blur,\n  element: input,\n  focus,\n})\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" class=\"input-group\" :class=\"computedClasses\" role=\"group\">\n    <slot name=\"prepend\">\n      <span v-if=\"hasPrepend\" class=\"input-group-text\">\n        <!-- eslint-disable-next-line vue/no-v-html -->\n        <span v-if=\"!!prependHtml\" v-html=\"prependHtml\" />\n        <span v-else>{{ prepend }}</span>\n      </span>\n    </slot>\n    <slot />\n    <slot name=\"append\">\n      <span v-if=\"hasAppend\" class=\"input-group-text\">\n        <!-- eslint-disable-next-line vue/no-v-html -->\n        <span v-if=\"!!appendHtml\" v-html=\"appendHtml\" />\n        <span v-else>{{ append }}</span>\n      </span>\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BInputGroupProps} from '../../types'\nimport {computed, toRef} from 'vue'\n\nconst props = withDefaults(defineProps<BInputGroupProps>(), {\n  append: undefined,\n  appendHtml: undefined,\n  id: undefined,\n  prepend: undefined,\n  prependHtml: undefined,\n  size: 'md',\n  tag: 'div',\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  append?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  prepend?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`input-group-${props.size}`]: props.size !== 'md',\n}))\nconst hasAppend = toRef(() => !!props.append || !!props.appendHtml)\nconst hasPrepend = toRef(() => !!props.prepend || !!props.prependHtml)\n</script>\n","<template>\n  <BInputGroupText v-if=\"props.isText\">\n    <slot />\n  </BInputGroupText>\n  <slot v-else />\n</template>\n\n<script setup lang=\"ts\">\nimport type {BInputGroupAddonProps} from '../../types'\nimport BInputGroupText from './BInputGroupText.vue'\n\nconst props = withDefaults(defineProps<BInputGroupAddonProps>(), {\n  isText: false,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"list-group\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, provide, toRef} from 'vue'\nimport {listGroupInjectionKey} from '../../utils'\nimport type {BListGroupProps} from '../../types'\n\nconst props = withDefaults(defineProps<BListGroupProps>(), {\n  flush: false,\n  horizontal: false,\n  numbered: false,\n  tag: 'div',\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => {\n  const horizontal = props.flush ? false : props.horizontal\n  return {\n    'list-group-flush': props.flush,\n    'list-group-horizontal': horizontal === true,\n    [`list-group-horizontal-${horizontal}`]: typeof horizontal === 'string',\n    'list-group-numbered': props.numbered,\n  }\n})\nconst computedTag = toRef(() => (props.numbered === true ? 'ol' : props.tag))\n\nprovide(listGroupInjectionKey, {\n  numbered: toRef(() => props.numbered),\n})\n</script>\n","<template>\n  <component\n    :is=\"tagComputed\"\n    class=\"list-group-item\"\n    :class=\"computedClasses\"\n    :aria-current=\"props.active ? true : undefined\"\n    :aria-disabled=\"props.disabled ? true : undefined\"\n    :target=\"isLink ? target : undefined\"\n    :href=\"!props.button ? href : undefined\"\n    :to=\"!props.button ? to : undefined\"\n    v-bind=\"computedAttrs\"\n  >\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, inject, toRef, useAttrs} from 'vue'\nimport type {BListGroupItemProps} from '../../types'\nimport {useBLinkHelper} from '../../composables'\nimport BLink from '../BLink/BLink.vue'\nimport {listGroupInjectionKey} from '../../utils'\n\nconst props = withDefaults(defineProps<BListGroupItemProps>(), {\n  action: false,\n  button: false,\n  tag: 'div',\n  // Link props\n  active: false, // Why is this active: false?\n  // All others use defaults\n  activeClass: undefined,\n  append: undefined,\n  disabled: undefined,\n  exactActiveClass: undefined,\n  href: undefined,\n  icon: undefined,\n  opacity: undefined,\n  opacityHover: undefined,\n  rel: undefined,\n  replace: undefined,\n  routerComponentName: undefined,\n  target: undefined,\n  to: undefined,\n  underlineOffset: undefined,\n  underlineOffsetHover: undefined,\n  underlineOpacity: undefined,\n  underlineOpacityHover: undefined,\n  underlineVariant: undefined,\n  variant: undefined,\n  // End link props\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst attrs = useAttrs()\n\nconst parentData = inject(listGroupInjectionKey, null)\n\nconst {computedLink} = useBLinkHelper(props)\n\nconst isLink = toRef(() => !props.button && computedLink.value)\nconst tagComputed = toRef(() =>\n  parentData?.numbered.value ? 'li' : props.button ? 'button' : !isLink.value ? props.tag : BLink\n)\n\nconst isAction = computed(\n  () =>\n    props.action ||\n    isLink.value ||\n    props.button ||\n    ['a', 'router-link', 'button', 'b-link'].includes(props.tag)\n)\n\nconst computedClasses = computed(() => ({\n  [`list-group-item-${props.variant}`]: props.variant !== null && props.variant !== undefined,\n  'list-group-item-action': isAction.value,\n  'active': props.active,\n  'disabled': props.disabled,\n}))\n\nconst computedAttrs = computed(() => {\n  const localAttrs = {} as {type?: string; disabled?: boolean}\n  if (props.button) {\n    if (!attrs || !attrs.type) {\n      // Add a type for button is one not provided in passed attributes\n      localAttrs.type = 'button'\n    }\n    if (props.disabled) {\n      // Set disabled attribute if button and disabled\n      localAttrs.disabled = true\n    }\n  }\n  return localAttrs\n})\n</script>\n","<template>\n  <Teleport :to=\"teleportTo\" :disabled=\"props.teleportDisabled\">\n    <!-- This wrapper div is used for specific targetting by the user -->\n    <!-- Even though it serves no direct purpose itself -->\n    <div id=\"__BVID__modal-container\">\n      <!-- TODO the animation when entering doesn't work. -->\n      <!-- I tried to use <Transition appear> to have the animation work, but it didn't -->\n      <component\n        :is=\"modal.value.component\"\n        v-for=\"(modal, index) in modals\"\n        :key=\"index\"\n        v-model=\"modal.value.props._modelValue\"\n        v-bind=\"pluckModalItem(modal.value.props)\"\n        :teleport-disabled=\"true\"\n        @hide=\"\n          (e: BvTriggerableEvent) => {\n            // These following are confirm rules, otherwise we always resolve true\n            if (modal.value.props._isConfirm === true) {\n              if (e.trigger === 'ok') {\n                modal.value.props._promise.resolve(true)\n                return\n              }\n              if (e.trigger === 'cancel') {\n                modal.value.props._promise.resolve(false)\n                return\n              }\n              modal.value.props._promise.resolve(null)\n            }\n            modal.value.props._promise.resolve(true)\n          }\n        \"\n        @hidden=\"remove?.(modal.value.props._self)\"\n      />\n    </div>\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport {BvTriggerableEvent, omit} from '../../utils'\nimport {useModalController} from '../../composables'\nimport type {BModalOrchestratorProps} from '../../types'\n\nconst props = withDefaults(defineProps<BModalOrchestratorProps>(), {\n  teleportDisabled: false,\n  teleportTo: 'body',\n})\n\nconst {modals, remove, show, confirm} = useModalController()\n\nconst pluckModalItem = (\n  payload: Readonly<Exclude<typeof modals, undefined>['value'][number]['value']['props']>\n) => omit(payload, ['_promise', '_self', '_isConfirm', '_modelValue'])\n\ndefineExpose({\n  modals,\n  show,\n  confirm,\n})\n</script>\n","<template>\n  <component :is=\"tag\" class=\"nav\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BNavProps} from '../../types'\nimport {useAlignment} from '../../composables'\nimport {computed} from 'vue'\n\nconst props = withDefaults(defineProps<BNavProps>(), {\n  align: undefined,\n  cardHeader: false,\n  fill: false,\n  justified: false,\n  pills: false,\n  small: false,\n  tabs: false,\n  tag: 'ul',\n  underline: false,\n  vertical: false,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst alignment = useAlignment(() => props.align)\n\nconst computedClasses = computed(() => ({\n  'nav-tabs': props.tabs,\n  'nav-pills': props.pills && !props.tabs,\n  'card-header-tabs': !props.vertical && props.cardHeader && props.tabs,\n  'card-header-pills': !props.vertical && props.cardHeader && props.pills && !props.tabs,\n  'flex-column': props.vertical,\n  'nav-fill': !props.vertical && props.fill,\n  'nav-justified': !props.vertical && props.justified,\n  [alignment.value]: !props.vertical && props.align !== undefined,\n  'small': props.small,\n  'nav-underline': props.underline,\n}))\n</script>\n","<template>\n  <li class=\"d-flex flex-row align-items-center flex-wrap\">\n    <BForm\n      v-bind=\"$attrs\"\n      :id=\"id\"\n      :floating=\"floating\"\n      :role=\"role\"\n      :novalidate=\"novalidate\"\n      :validated=\"validated\"\n      class=\"d-flex\"\n      @submit.prevent=\"submitted\"\n    >\n      <slot />\n    </BForm>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BNavFormProps} from '../../types'\nimport BForm from '../BForm/BForm.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nwithDefaults(defineProps<BNavFormProps>(), {\n  role: undefined,\n  // BForm props\n  floating: undefined,\n  id: undefined,\n  novalidate: undefined,\n  validated: undefined,\n  // End BForm props\n})\n\nconst emit = defineEmits<{\n  submit: [value: Event]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst submitted = (e: Readonly<Event>) => {\n  emit('submit', e)\n}\n</script>\n","<template>\n  <li class=\"nav-item\">\n    <BLink\n      class=\"nav-link\"\n      :class=\"linkClass\"\n      :tabindex=\"props.disabled ? -1 : undefined\"\n      :aria-disabled=\"props.disabled ? true : undefined\"\n      v-bind=\"{...computedLinkProps, ...linkAttrs}\"\n      @click=\"emit('click', $event)\"\n    >\n      <slot />\n    </BLink>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport BLink from '../BLink/BLink.vue'\nimport type {BNavItemProps} from '../../types'\nimport {pick} from '../../utils'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(defineProps<BNavItemProps>(), {\n  // Link props\n  active: undefined,\n  activeClass: undefined,\n  append: undefined,\n  disabled: undefined,\n  exactActiveClass: undefined,\n  href: undefined,\n  icon: undefined,\n  linkAttrs: undefined,\n  linkClass: undefined,\n  opacity: undefined,\n  opacityHover: undefined,\n  rel: undefined,\n  replace: undefined,\n  routerComponentName: undefined,\n  target: undefined,\n  to: undefined,\n  underlineOffset: undefined,\n  underlineOffsetHover: undefined,\n  underlineOpacity: undefined,\n  underlineOpacityHover: undefined,\n  underlineVariant: undefined,\n  variant: undefined,\n  // End link props\n})\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst computedLinkProps = computed(() =>\n  pick(props, [\n    'active',\n    'activeClass',\n    'append',\n    'disabled',\n    'href',\n    'icon',\n    'opacity',\n    'opacityHover',\n    'rel',\n    'replace',\n    'routerComponentName',\n    'target',\n    'to',\n    'underlineOffset',\n    'underlineOffsetHover',\n    'underlineOpacity',\n    'underlineOpacityHover',\n    'underlineVariant',\n    'variant',\n  ])\n)\ncomputedLinkProps.value.activeClass\n</script>\n","<template>\n  <li class=\"nav-item dropdown\">\n    <BDropdown\n      ref=\"dropdown\"\n      v-bind=\"props\"\n      v-model=\"modelValue\"\n      is-nav\n      @show=\"emit('show', $event)\"\n      @shown=\"emit('shown')\"\n      @hide=\"emit('hide', $event)\"\n      @hidden=\"emit('hidden')\"\n      @hide-prevented=\"emit('hide-prevented')\"\n      @show-prevented=\"emit('show-prevented')\"\n      @click=\"emit('click', $event)\"\n      @toggle=\"emit('toggle')\"\n    >\n      <template #button-content>\n        <slot name=\"button-content\" />\n      </template>\n      <template #toggle-text>\n        <slot name=\"toggle-text\" />\n      </template>\n      <template #default>\n        <slot :hide=\"hide\" :show=\"show\" />\n      </template>\n    </BDropdown>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport {ref} from 'vue'\nimport {BvTriggerableEvent} from '../../utils'\nimport BDropdown from '../BDropdown/BDropdown.vue'\nimport type {BDropdownProps} from '../../types'\n\nconst props = withDefaults(defineProps<BDropdownProps>(), {\n  ariaLabel: undefined,\n  autoClose: true,\n  block: false,\n  boundary: 'clippingAncestors',\n  boundaryPadding: undefined,\n  center: false,\n  teleportTo: undefined,\n  teleportDisabled: false,\n  disabled: false,\n  dropend: false,\n  dropstart: false,\n  dropup: false,\n  end: false,\n  floatingMiddleware: undefined,\n  id: undefined,\n  isNav: true,\n  lazy: false,\n  menuClass: undefined,\n  noCaret: false,\n  noFlip: false,\n  noShift: false,\n  noSize: false,\n  offset: 0,\n  role: 'menu',\n  size: 'md',\n  split: false,\n  splitButtonType: 'button',\n  splitClass: undefined,\n  splitDisabled: undefined,\n  splitHref: undefined,\n  splitTo: undefined,\n  splitVariant: undefined,\n  strategy: 'absolute',\n  text: undefined,\n  toggleClass: undefined,\n  toggleText: 'Toggle dropdown',\n  variant: 'link',\n})\n\nconst emit = defineEmits<{\n  'click': [event: MouseEvent]\n  'hidden': []\n  'hide': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'shown': []\n  'toggle': []\n}>()\n\nconst modelValue = defineModel<boolean>({default: false})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'button-content'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: {hide: () => void; show: () => void}) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'toggle-text'?: (props: Record<string, never>) => any\n}>()\nconst dropdown = ref<InstanceType<typeof BDropdown> | null>(null)\n\nconst hide = () => {\n  dropdown.value?.hide()\n}\nconst show = () => {\n  dropdown.value?.show()\n}\nconst toggle = () => {\n  dropdown.value?.toggle()\n}\n\ndefineExpose({\n  hide,\n  show,\n  toggle,\n})\n</script>\n","<template>\n  <component :is=\"tag\" class=\"navbar\" :class=\"computedClasses\" :role=\"computedRole\">\n    <div v-if=\"container !== false\" :class=\"containerClass\">\n      <slot />\n    </div>\n    <slot v-else />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, provide, toRef} from 'vue'\nimport type {BNavbarProps} from '../../types'\nimport {useContainerClasses} from '../../composables'\nimport {navbarInjectionKey} from '../../utils'\n\nconst props = withDefaults(defineProps<BNavbarProps>(), {\n  autoClose: true,\n  container: 'fluid',\n  fixed: undefined,\n  print: false,\n  sticky: undefined,\n  tag: 'nav',\n  toggleable: false,\n  variant: null,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedRole = toRef(() => (props.tag === 'nav' ? undefined : 'navigation'))\n\nconst containerClass = useContainerClasses(() => props.container)\n\nconst computedClasses = computed(() => ({\n  'd-print': props.print,\n  [`sticky-${props.sticky}`]: props.sticky !== undefined,\n  [`bg-${props.variant}`]: props.variant !== null,\n  [`fixed-${props.fixed}`]: props.fixed !== undefined,\n  'navbar-expand': props.toggleable === false,\n  [`navbar-expand-${props.toggleable}`]: typeof props.toggleable === 'string',\n}))\n\nprovide(navbarInjectionKey, {\n  tag: toRef(() => props.tag),\n  autoClose: toRef(() => props.autoClose),\n})\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"navbar-brand\" v-bind=\"computedLinkProps\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {toRef} from 'vue'\nimport BLink from '../BLink/BLink.vue'\nimport type {BNavbarBrandProps} from '../../types'\nimport {useBLinkHelper} from '../../composables'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(defineProps<BNavbarBrandProps>(), {\n  tag: 'div',\n  // Link props\n  active: undefined,\n  activeClass: undefined,\n  append: undefined,\n  disabled: undefined,\n  exactActiveClass: undefined,\n  href: undefined,\n  icon: undefined,\n  opacity: undefined,\n  opacityHover: undefined,\n  rel: undefined,\n  replace: undefined,\n  routerComponentName: undefined,\n  target: undefined,\n  to: undefined,\n  underlineOffset: undefined,\n  underlineOffsetHover: undefined,\n  underlineOpacity: undefined,\n  underlineOpacityHover: undefined,\n  underlineVariant: undefined,\n  variant: undefined,\n  // End link props\n})\n\nconst {computedLink, computedLinkProps} = useBLinkHelper(props, [\n  'active',\n  'activeClass',\n  'append',\n  'disabled',\n  'href',\n  'rel',\n  'replace',\n  'routerComponentName',\n  'target',\n  'to',\n  'variant',\n  'opacity',\n  'opacityHover',\n  'underlineVariant',\n  'underlineOffset',\n  'underlineOffsetHover',\n  'underlineOpacity',\n  'underlineOpacityHover',\n  'icon',\n])\n\nconst computedTag = toRef(() => (computedLink.value ? BLink : props.tag))\n</script>\n","<template>\n  <ul class=\"navbar-nav\" :class=\"computedClasses\">\n    <slot />\n  </ul>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BNavbarNavProps} from '../../types'\nimport {computed} from 'vue'\nimport {useAlignment} from '../../composables'\n\nconst props = withDefaults(defineProps<BNavbarNavProps>(), {\n  align: undefined,\n  fill: false,\n  justified: false,\n  small: false,\n  tag: 'ul',\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst alignment = useAlignment(() => props.align)\n\nconst computedClasses = computed(() => ({\n  'nav-fill': props.fill,\n  'nav-justified': props.justified,\n  [alignment.value]: props.align !== undefined,\n  'small': props.small,\n}))\n</script>\n","import type {Directive, DirectiveBinding} from 'vue'\n\nconst setTheme = (el: Readonly<HTMLElement>, value: string): void =>\n  el.setAttribute('data-bs-theme', value)\nexport default {\n  mounted(el, binding: DirectiveBinding): void {\n    setTheme(el, binding.value)\n  },\n  updated(el, binding: DirectiveBinding): void {\n    setTheme(el, binding.value)\n  },\n} satisfies Directive<HTMLElement>\n","import {RX_HASH, RX_HASH_ID, RX_SPACE_SPLIT} from '../constants/regex'\nimport type {Directive, DirectiveBinding} from 'vue'\n\nconst getTargets = (\n  binding: DirectiveBinding<string | readonly string[] | undefined>,\n  el: Readonly<HTMLElement>\n) => {\n  const {modifiers, arg, value} = binding\n  // Any modifiers are considered target Ids\n  const targets = Object.keys(modifiers || {})\n\n  // If value is a string, split out individual targets (if space delimited)\n  const localValue = typeof value === 'string' ? value.split(RX_SPACE_SPLIT) : value\n\n  // Support target Id as link href (`href=\"#id\"`)\n  if (el.tagName.toLowerCase() === 'a') {\n    const href = el.getAttribute('href') || ''\n    if (RX_HASH_ID.test(href)) {\n      targets.push(href.replace(RX_HASH, ''))\n    }\n  }\n\n  // Add Id from `arg` (if provided), and support value\n  // as a single string Id or an array of string Ids\n  // If `value` is not an array or string, then it gets filtered out\n  Array.prototype.concat\n    .apply([], [arg, localValue])\n    .forEach((t) => typeof t === 'string' && targets.push(t))\n\n  // Return only unique and truthy target Ids\n  return targets.filter((t, index, arr) => t && arr.indexOf(t) === index)\n}\n\nconst toggle = (targetIds: readonly string[], el: Readonly<HTMLElement>) => {\n  targetIds.forEach((targetId) => {\n    const target = document.getElementById(targetId)\n\n    if (target !== null) {\n      target.dispatchEvent(new Event('bv-toggle'))\n    }\n  })\n  setTimeout(() => checkVisibility(targetIds, el), 50)\n}\n\nconst checkVisibility = (targetIds: readonly string[], el: Readonly<HTMLElement>) => {\n  let visible = false\n  targetIds.forEach((targetId) => {\n    const target = document.getElementById(targetId)\n\n    if (target?.classList.contains('show')) {\n      visible = true\n    }\n    if (target?.classList.contains('closing')) {\n      visible = false\n    }\n  })\n  el.setAttribute('aria-expanded', visible ? 'true' : 'false')\n  el.classList.remove(visible ? 'collapsed' : 'not-collapsed')\n  el.classList.add(visible ? 'not-collapsed' : 'collapsed')\n}\n\nconst handleUpdate = (\n  el: WithToggle,\n  binding: DirectiveBinding<string | readonly string[] | undefined>\n) => {\n  // Determine targets\n  const targets = getTargets(binding, el)\n  if (targets.length === 0) return\n\n  // Set up click handler\n  if (el.__toggle) {\n    el.removeEventListener('click', el.__toggle)\n  }\n  el.__toggle = () => toggle(targets, el)\n  el.addEventListener('click', el.__toggle)\n\n  // Update attributes\n  el.setAttribute('aria-controls', targets.join(' '))\n  checkVisibility(targets, el)\n}\n\nexport interface WithToggle extends HTMLElement {\n  __toggle: () => void\n}\n\nexport default {\n  mounted: handleUpdate,\n  updated: handleUpdate,\n  unmounted(el: WithToggle): void {\n    el.removeEventListener('click', el.__toggle)\n    el.removeAttribute('aria-controls')\n    el.removeAttribute('aria-expanded')\n  },\n} satisfies Directive<WithToggle>\n","import {type Directive} from 'vue'\nimport {\n  bind,\n  type ElementWithPopper,\n  resolveActiveStatus,\n  resolveContent,\n  resolveDirectiveProps,\n  unbind,\n} from '../utils/floatingUi'\n\nexport default {\n  mounted(el, binding) {\n    const isActive = resolveActiveStatus(binding.value)\n    if (!isActive) return\n\n    const text = resolveContent(binding.value, el)\n\n    if (!text.content && !text.title) return\n    bind(el, binding, {\n      ...resolveDirectiveProps(binding, el),\n      ...text,\n    })\n  },\n  updated(el, binding) {\n    const isActive = resolveActiveStatus(binding.value)\n    if (!isActive) return\n\n    const text = resolveContent(binding.value, el)\n\n    if (!text.content && !text.title) return\n\n    unbind(el)\n    bind(el, binding, {\n      ...resolveDirectiveProps(binding, el),\n      ...text,\n    })\n  },\n  beforeUnmount(el) {\n    unbind(el)\n  },\n} satisfies Directive<ElementWithPopper>\n","import {type Directive, type DirectiveBinding} from 'vue'\nimport {useScrollspy} from '../composables'\nimport {omit} from '../utils'\n\nexport interface ElementWithScrollspy extends HTMLElement {\n  $__scrollspy?: ReturnType<typeof useScrollspy>\n}\n\nconst bind = (el: ElementWithScrollspy, binding: Readonly<DirectiveBinding>) => {\n  if (el.$__scrollspy) el.$__scrollspy.cleanup()\n  const {arg, value} = binding\n  const isObject = typeof value === 'object' && value !== null\n  const content = arg\n    ? arg\n    : typeof value === 'string'\n      ? value\n      : isObject\n        ? value.content || value.element\n        : null\n  el.$__scrollspy = useScrollspy(content, el, isObject ? omit(value, ['content', 'element']) : {})\n}\n\nexport default {\n  mounted: bind,\n  updated: bind,\n  beforeUnmount(el) {\n    if (el.$__scrollspy) el.$__scrollspy.cleanup()\n  },\n} satisfies Directive<ElementWithScrollspy>\n","import {type Directive} from 'vue'\nimport {\n  bind,\n  type ElementWithPopper,\n  resolveActiveStatus,\n  resolveContent,\n  resolveDirectiveProps,\n  unbind,\n} from '../utils/floatingUi'\n\nexport default {\n  mounted(el, binding) {\n    const isActive = resolveActiveStatus(binding.value)\n    if (!isActive) return\n\n    const text = resolveContent(binding.value, el)\n\n    if (!text.content && !text.title) return\n\n    bind(el, binding, {\n      noninteractive: true,\n      ...resolveDirectiveProps(binding, el),\n      title: text.title ?? text.content ?? '',\n      tooltip: isActive,\n    })\n  },\n  updated(el, binding) {\n    const isActive = resolveActiveStatus(binding.value)\n    if (!isActive) return\n\n    const text = resolveContent(binding.value, el)\n\n    if (!text.content && !text.title) return\n    unbind(el)\n\n    bind(el, binding, {\n      noninteractive: true,\n      ...resolveDirectiveProps(binding, el),\n      title: text.title ?? text.content ?? '',\n      tooltip: isActive,\n    })\n  },\n  beforeUnmount(el) {\n    unbind(el)\n  },\n} satisfies Directive<ElementWithPopper>\n","<template>\n  <button\n    v-b-toggle=\"!props.disabled ? target : undefined\"\n    class=\"navbar-toggler\"\n    type=\"button\"\n    :class=\"computedClasses\"\n    :disabled=\"props.disabled\"\n    :aria-label=\"label\"\n    @click=\"onClick\"\n  >\n    <slot>\n      <span class=\"navbar-toggler-icon\" />\n    </slot>\n  </button>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BNavbarToggleProps} from '../../types'\nimport {vBToggle} from '../../directives'\nimport {computed} from 'vue'\n\nconst props = withDefaults(defineProps<BNavbarToggleProps>(), {\n  label: 'Toggle navigation',\n  disabled: false,\n  target: undefined,\n})\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\ndefineSlots<{\n  // TODO this scoped slot is {expanded: boolean}\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  disabled: props.disabled,\n}))\n\nconst onClick = (e: Readonly<MouseEvent>): void => {\n  if (!props.disabled) {\n    emit('click', e)\n  }\n}\n</script>\n","<template>\n  <Teleport :to=\"teleportTo\" :disabled=\"props.teleportDisabled\">\n    <BTransition\n      :no-fade=\"true\"\n      :trans-props=\"{\n        enterToClass: 'showing',\n        enterFromClass: '',\n        leaveToClass: 'hiding show',\n        leaveFromClass: 'show',\n      }\"\n      @before-enter=\"OnBeforeEnter\"\n      @after-enter=\"OnAfterEnter\"\n      @leave=\"onLeave\"\n      @after-leave=\"OnAfterLeave\"\n    >\n      <div\n        v-show=\"modelValue\"\n        :id=\"computedId\"\n        ref=\"element\"\n        aria-modal=\"true\"\n        role=\"dialog\"\n        :class=\"computedClasses\"\n        tabindex=\"-1\"\n        :aria-labelledby=\"`${computedId}-offcanvas-label`\"\n        data-bs-backdrop=\"false\"\n        v-bind=\"$attrs\"\n      >\n        <template v-if=\"lazyShowing\">\n          <div v-if=\"!props.noHeader\" class=\"offcanvas-header\" :class=\"headerClass\">\n            <slot name=\"header\" v-bind=\"sharedSlots\">\n              <h5 :id=\"`${computedId}-offcanvas-label`\" class=\"offcanvas-title\">\n                <slot name=\"title\" v-bind=\"sharedSlots\">\n                  {{ title }}\n                </slot>\n              </h5>\n              <template v-if=\"!props.noHeaderClose\">\n                <BButton v-if=\"hasHeaderCloseSlot\" v-bind=\"headerCloseAttrs\" @click=\"hide('close')\">\n                  <slot name=\"header-close\" />\n                </BButton>\n                <BCloseButton\n                  v-else\n                  :aria-label=\"headerCloseLabel\"\n                  v-bind=\"headerCloseAttrs\"\n                  @click=\"hide('close')\"\n                />\n              </template>\n            </slot>\n          </div>\n          <div class=\"offcanvas-body\" :class=\"bodyClass\" v-bind=\"bodyAttrs\">\n            <slot v-bind=\"sharedSlots\" />\n          </div>\n          <div v-if=\"hasFooterSlot\" :class=\"footerClass\">\n            <slot name=\"footer\" v-bind=\"sharedSlots\" />\n          </div>\n        </template>\n      </div>\n    </BTransition>\n    <slot name=\"backdrop\">\n      <BOverlay\n        :blur=\"backdropBlur\"\n        :variant=\"backdropVariant\"\n        :show=\"showBackdrop\"\n        fixed\n        no-wrap\n        no-spinner\n        @click=\"hide('backdrop')\"\n      />\n    </slot>\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport {onKeyStroke, useEventListener, useFocus} from '@vueuse/core'\nimport {computed, nextTick, ref, toRef} from 'vue'\nimport {useId, useSafeScrollLock} from '../../composables'\nimport type {BOffcanvasProps} from '../../types'\nimport {BvTriggerableEvent, isEmptySlot} from '../../utils'\nimport BButton from '../BButton/BButton.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BOverlay from '../BOverlay/BOverlay.vue'\nimport BTransition from '../BTransition/BTransition.vue'\n\n// TODO once the responsive stuff may be implemented correctly,\n// What needs to occur is a fixing of the \"body scrolling\".\n// If the offcanvas is on the screen on a large screen, body scrolling is not disabled\n// Even though the modelValue is true\n// When it's a small screen and close, it works, as normal,\n// But then when it opens up on a small screen, it must disable again\n// This is implemented on Layout.vue, but is not officially supported.\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<BOffcanvasProps>(), {\n  backdrop: true,\n  backdropBlur: undefined,\n  backdropVariant: 'dark',\n  bodyAttrs: undefined,\n  bodyClass: undefined,\n  bodyScrolling: false,\n  footerClass: undefined,\n  headerClass: undefined,\n  headerCloseClass: undefined,\n  headerCloseLabel: 'Close',\n  headerCloseVariant: 'secondary',\n  id: undefined,\n  lazy: false,\n  noCloseOnBackdrop: false,\n  noCloseOnEsc: false,\n  noFocus: false,\n  noHeader: false,\n  noHeaderClose: false,\n  placement: 'start',\n  shadow: false,\n  teleportDisabled: false,\n  teleportTo: 'body',\n  title: undefined,\n})\n\nconst emit = defineEmits<{\n  'close': [value: BvTriggerableEvent]\n  'esc': [value: BvTriggerableEvent]\n  'hidden': [value: BvTriggerableEvent]\n  'hide': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'shown': [value: BvTriggerableEvent]\n}>()\n\ntype SharedSlotsData = {\n  visible: boolean\n  placement: 'top' | 'bottom' | 'start' | 'end'\n  hide: (trigger?: string) => void\n}\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'backdrop'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'footer'?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'header'?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'header-close'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'title'?: (props: SharedSlotsData) => any\n}>()\n\nconst modelValue = defineModel<boolean>({\n  default: false,\n})\n\nconst computedId = useId(() => props.id, 'offcanvas')\nuseSafeScrollLock(modelValue, () => props.bodyScrolling)\n\nconst element = ref<HTMLElement | null>(null)\n\nonKeyStroke(\n  'Escape',\n  () => {\n    hide('esc')\n  },\n  {target: element}\n)\n\nconst {focused} = useFocus(element, {\n  initialValue: modelValue.value && props.noFocus === false,\n})\n\nconst isActive = ref(modelValue.value)\nconst lazyLoadCompleted = ref(false)\n\nconst showBackdrop = toRef(() => props.backdrop === true && modelValue.value === true)\n\nconst lazyShowing = toRef(\n  () =>\n    props.lazy === false ||\n    (props.lazy === true && lazyLoadCompleted.value === true) ||\n    (props.lazy === true && modelValue.value === true)\n)\n\nconst hasHeaderCloseSlot = toRef(() => !isEmptySlot(slots['header-close']))\nconst headerCloseClasses = computed(() => [\n  {'text-reset': !hasHeaderCloseSlot.value},\n  props.headerCloseClass,\n])\nconst headerCloseAttrs = computed(() => ({\n  variant: hasHeaderCloseSlot.value ? props.headerCloseVariant : undefined,\n  class: headerCloseClasses.value,\n}))\n\nconst hasFooterSlot = toRef(() => !isEmptySlot(slots.footer))\nconst computedClasses = computed(() => [\n  // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,\n  'offcanvas', // Remove when above check is fixed\n  `offcanvas-${props.placement}`,\n  {\n    show: modelValue.value && isActive.value === true,\n    [`shadow-${props.shadow}`]: !!props.shadow,\n  },\n])\n\nconst sharedSlots = computed<SharedSlotsData>(() => ({\n  visible: modelValue.value,\n  placement: props.placement,\n  hide,\n}))\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Partial<BvTriggerableEvent> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nconst hide = (trigger = '') => {\n  if (\n    (trigger === 'backdrop' && props.noCloseOnBackdrop) ||\n    (trigger === 'esc' && props.noCloseOnEsc)\n  ) {\n    emit('hide-prevented')\n    return\n  }\n\n  const event = buildTriggerableEvent('hide', {cancelable: trigger !== '', trigger})\n\n  if (trigger === 'close') {\n    emit(trigger, event)\n  }\n  if (trigger === 'esc') {\n    emit(trigger, event)\n  }\n  emit('hide', event)\n\n  if (event.defaultPrevented) {\n    emit('hide-prevented')\n    return\n  }\n\n  modelValue.value = false\n}\n\nconst show = () => {\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    modelValue.value = false\n    emit('show-prevented')\n    return\n  }\n  modelValue.value = true\n}\n\nconst focus = () => {\n  nextTick(() => {\n    if (props.noFocus === false) {\n      focused.value = true\n    }\n  })\n}\n\nconst OnBeforeEnter = () => show()\nconst OnAfterEnter = () => {\n  isActive.value = true\n  focus()\n  emit('shown', buildTriggerableEvent('shown'))\n  if (props.lazy === true) lazyLoadCompleted.value = true\n}\nconst onLeave = () => {\n  isActive.value = false\n}\nconst OnAfterLeave = () => {\n  emit('hidden', buildTriggerableEvent('hidden'))\n  if (props.lazy === true) lazyLoadCompleted.value = false\n}\nuseEventListener(element, 'bv-toggle', () => {\n  modelValue.value ? hide() : show()\n})\n\ndefineExpose({\n  hide,\n  show,\n})\n</script>\n","<template>\n  <ul\n    class=\"pagination\"\n    :class=\"computedWrapperClasses\"\n    role=\"menubar\"\n    :aria-disabled=\"props.disabled\"\n    :aria-label=\"ariaLabel || undefined\"\n  >\n    <ReusableButton.define v-slot=\"{button, li, text, clickHandler}\">\n      <li v-bind=\"li\">\n        <component v-bind=\"button\" :is=\"button.is\" @click=\"clickHandler\">\n          <slot\n            :name=\"text.name\"\n            :disabled=\"text.disabled\"\n            :page=\"text.page\"\n            :index=\"text.index\"\n            :active=\"text.active\"\n            :content=\"text.value\"\n          >\n            {{ text.value }}\n          </slot>\n        </component>\n      </li>\n    </ReusableButton.define>\n\n    <ReusableEllipsis.define>\n      <li v-bind=\"ellipsisProps.li\">\n        <span v-bind=\"ellipsisProps.span\">\n          <slot name=\"ellipsis-text\">\n            {{ ellipsisText || '...' }}\n          </slot>\n        </span>\n      </li>\n    </ReusableEllipsis.define>\n\n    <template v-for=\"button in buttons\" :key=\"`page-${button.number}`\">\n      <ReusableButton.reuse v-if=\"button === FIRST_BUTTON\" v-bind=\"firstButtonProps\" />\n      <ReusableButton.reuse v-else-if=\"button === PREV_BUTTON\" v-bind=\"prevButtonProps\" />\n      <ReusableButton.reuse v-else-if=\"button === NEXT_BUTTON\" v-bind=\"nextButtonProps\" />\n      <ReusableButton.reuse v-else-if=\"button === LAST_BUTTON\" v-bind=\"lastButtonProps\" />\n      <ReusableEllipsis.reuse v-else-if=\"button === ELLIPSIS_BUTTON\" />\n      <ReusableButton.reuse v-else v-bind=\"getPageButtonProps(button!)\" />\n    </template>\n  </ul>\n</template>\n\n<script setup lang=\"ts\">\nimport {BvEvent} from '../../utils'\nimport {computed, toRef, watch} from 'vue'\nimport type {BPaginationProps, ClassValue} from '../../types'\nimport {useAlignment} from '../../composables'\nimport {createReusableTemplate, useToNumber} from '@vueuse/core'\n\n// Threshold of limit size when we start/stop showing ellipsis\nconst ELLIPSIS_THRESHOLD = 3\n\nconst FIRST_BUTTON = -1\nconst PREV_BUTTON = -2\nconst NEXT_BUTTON = -3\nconst LAST_BUTTON = -4\nconst ELLIPSIS_BUTTON = -5\n\nconst props = withDefaults(defineProps<BPaginationProps>(), {\n  align: 'start',\n  ariaControls: undefined,\n  ariaLabel: 'Pagination',\n  disabled: false,\n  ellipsisClass: undefined,\n  ellipsisText: '\\u2026',\n  firstClass: undefined,\n  firstNumber: false,\n  firstText: '\\u00AB',\n  hideEllipsis: false,\n  hideGotoEndButtons: false,\n  labelFirstPage: 'Go to first page',\n  labelLastPage: 'Go to last page',\n  labelNextPage: 'Go to next page',\n  labelPage: 'Go to page',\n  labelPrevPage: 'Go to previous page',\n  lastClass: undefined,\n  lastNumber: false,\n  lastText: '\\u00BB',\n  limit: 5,\n  nextClass: undefined,\n  nextText: '\\u203A',\n  pageClass: undefined,\n  perPage: DEFAULT_PER_PAGE,\n  pills: false,\n  prevClass: undefined,\n  prevText: '\\u2039',\n  size: undefined,\n  totalRows: DEFAULT_TOTAL_ROWS,\n})\n\nconst emit = defineEmits<{\n  'page-click': [event: BvEvent, pageNumber: number]\n}>()\n\nconst modelValue = defineModel<number>({default: 1})\n\nconst limitNumber = useToNumber(() => props.limit, {nanToZero: true, method: 'parseInt'})\nconst perPageNumber = useToNumber(() => props.perPage, {nanToZero: true, method: 'parseInt'})\nconst totalRowsNumber = useToNumber(() => props.totalRows, {nanToZero: true, method: 'parseInt'})\nconst modelValueNumber = useToNumber(modelValue, {nanToZero: true, method: 'parseInt'})\n\nconst perPageSanitized = toRef(() => Math.max(perPageNumber.value || DEFAULT_PER_PAGE, 1))\nconst totalRowsSanitized = toRef(() => Math.max(totalRowsNumber.value || DEFAULT_TOTAL_ROWS, 0))\n// Use Active to on page-item to denote active tab\nconst numberOfPages = toRef(() => Math.ceil(totalRowsSanitized.value / perPageSanitized.value))\nconst computedFill = toRef(() => props.align === 'fill')\n// This doesn't use the computedFill util because TS cannot infer that it would never be 'fill'\nconst justifyAlign = toRef(() => (props.align === 'fill' ? 'start' : props.align))\n\nconst alignment = useAlignment(justifyAlign)\n\nconst isActivePage = (pageNumber: number) => pageNumber === modelValueNumber.value\nconst getTabIndex = (num: number) => (props.disabled ? null : isActivePage(num) ? '0' : '-1')\n\nconst checkDisabled = (num: number) =>\n  props.disabled ||\n  isActivePage(num) ||\n  modelValueNumber.value < 1 ||\n  // Check if the number is out of bounds\n  num < 1 ||\n  num > numberOfPages.value\n\nconst firstDisabled = computed(() => checkDisabled(1))\nconst prevDisabled = computed(() => checkDisabled(modelValueNumber.value - 1))\nconst lastDisabled = computed(() => checkDisabled(numberOfPages.value))\nconst nextDisabled = computed(() => checkDisabled(modelValueNumber.value + 1))\n\nconst getBaseButtonProps = ({\n  page,\n  classVal,\n  dis,\n  slotName,\n  textValue,\n  tabIndex,\n  label,\n  position,\n  isActive,\n  role,\n  hidden,\n}: {\n  page: number\n  dis: boolean\n  classVal: ClassValue\n  slotName: string\n  textValue?: string\n  tabIndex?: string\n  label?: string\n  position?: number\n  isActive?: boolean\n  role?: string\n  hidden?: boolean\n}) => ({\n  li: {\n    'class': [\n      'page-item',\n      {\n        'active': isActive,\n        'disabled': dis,\n        'flex-fill': computedFill.value,\n        'd-flex': computedFill.value && !dis,\n      },\n      classVal,\n    ],\n    role,\n    'aria-hidden': hidden,\n  },\n  button: {\n    'is': dis ? 'span' : 'button',\n    'class': ['page-link', {'flex-grow-1': !dis && computedFill.value}],\n    'aria-label': label,\n    'aria-controls': props.ariaControls || undefined,\n    'aria-disabled': dis ? true : undefined,\n    'aria-posinset': position,\n    'aria-setsize': position ? numberOfPages.value : undefined,\n    'role': 'menuitem',\n    'type': dis ? undefined : 'button',\n    'tabindex': dis ? undefined : tabIndex,\n  },\n  text: {\n    name: slotName,\n    active: isActive,\n    value: textValue ?? page,\n    page,\n    disabled: dis,\n    index: page - 1,\n    content: textValue ? undefined : page,\n  },\n  clickHandler: (e: Readonly<MouseEvent>) => pageClick(e, page),\n})\n\nconst getButtonProps = ({\n  page,\n  classVal,\n  dis,\n  slotName,\n  textValue,\n  label,\n}: {\n  page: number\n  dis: boolean\n  classVal: ClassValue\n  slotName: string\n  textValue?: string\n  label: string\n}) => getBaseButtonProps({page, classVal, dis, slotName, textValue, label, tabIndex: '-1'})\n\nconst getPageButtonProps = (page: number) =>\n  getBaseButtonProps({\n    page,\n    dis: props.disabled,\n    classVal: props.pageClass,\n    slotName: 'page',\n    label: props.labelPage ? `${props.labelPage} ${page}` : undefined,\n    tabIndex: getTabIndex(page) ?? undefined,\n    position: page,\n    isActive: isActivePage(page),\n  })\n\nconst firstButtonProps = computed(() =>\n  getButtonProps({\n    page: 1,\n    dis: firstDisabled.value,\n    classVal: props.firstClass,\n    slotName: 'first-text',\n    textValue: props.firstText,\n    label: props.labelFirstPage,\n  })\n)\nconst prevButtonProps = computed(() =>\n  getButtonProps({\n    page: Math.max(modelValueNumber.value - 1, 1),\n    dis: prevDisabled.value,\n    classVal: props.prevClass,\n    slotName: 'prev-text',\n    textValue: props.prevText,\n    label: props.labelPrevPage,\n  })\n)\nconst nextButtonProps = computed(() =>\n  getButtonProps({\n    page: Math.min(modelValueNumber.value + 1, numberOfPages.value),\n    dis: nextDisabled.value,\n    classVal: props.nextClass,\n    slotName: 'next-text',\n    textValue: props.nextText,\n    label: props.labelNextPage,\n  })\n)\nconst lastButtonProps = computed(() =>\n  getButtonProps({\n    page: numberOfPages.value,\n    dis: lastDisabled.value,\n    classVal: props.lastClass,\n    slotName: 'last-text',\n    textValue: props.lastText,\n    label: props.labelLastPage,\n  })\n)\n\nconst ReusableButton = createReusableTemplate<ReturnType<typeof getButtonProps>>()\nconst ReusableEllipsis = createReusableTemplate()\n\nconst ellipsisProps = computed(() => ({\n  li: {\n    class: [\n      'page-item',\n      'disabled',\n      'bv-d-xs-down-none',\n      computedFill.value ? 'flex-fill' : '',\n      props.ellipsisClass,\n    ],\n    role: 'separator',\n  },\n  span: {\n    class: ['page-link'],\n  },\n}))\n\nconst computedWrapperClasses = computed(() => [\n  alignment.value,\n  {\n    [`pagination-${props.size}`]: props.size !== undefined,\n    'b-pagination-pills': props.pills,\n  },\n])\n\nconst pagination = computed(() => ({\n  pageSize: perPageSanitized.value,\n  totalRows: totalRowsNumber.value,\n  numberOfPages: numberOfPages.value,\n}))\n\nconst pageClick = (event: Readonly<MouseEvent>, pageNumber: number) => {\n  if (pageNumber === modelValueNumber.value) return\n\n  const clickEvent = new BvEvent('page-click', {\n    cancelable: true,\n    target: event.target,\n  })\n  emit('page-click', clickEvent, pageNumber)\n\n  if (clickEvent.defaultPrevented) return\n\n  modelValue.value = pageNumber\n\n  //    nextTick(() => {\n  //  if (isVisible(target) && un_element.contains(target)) {\n  //  attemptFocus(target)\n  //} else {\n  //this.focusCurrent()\n  //}\n  // })\n}\n\nwatch(modelValueNumber, (newValue) => {\n  const sanitizeCurrentPage = (value: number, numberOfPages: number) => {\n    const page = value || 1\n    return page > numberOfPages ? numberOfPages : page < 1 ? 1 : page\n  }\n  const calculatedValue = sanitizeCurrentPage(newValue, numberOfPages.value)\n  if (calculatedValue === modelValue.value) return\n  modelValue.value = calculatedValue\n})\n\nwatch(pagination, (oldValue, newValue) => {\n  if (newValue.pageSize !== oldValue.pageSize && newValue.totalRows === oldValue.totalRows) {\n    // If the page size changes, reset to page 1\n    modelValue.value = 1\n  } else if (\n    newValue.numberOfPages !== oldValue.numberOfPages &&\n    modelValueNumber.value > newValue.numberOfPages\n  ) {\n    // If `numberOfPages` changes and is less than\n    // the `currentPage` number, reset to page 1\n    modelValue.value = 1\n  }\n})\n\nconst buttons = computed(() => {\n  // The idea here is to create an array of all the buttons on the page control.\n  // This was we can keep the invariants in one place and the template code just\n  // iterates over the array.\n\n  const pages = numberOfPages.value\n  const {value} = modelValueNumber\n  const limit = limitNumber.value\n  const firstPage = props.firstNumber ? 1 : 0\n  const lastPage = props.lastNumber ? 1 : 0\n  const hideEllipsis = props.hideEllipsis || limit <= ELLIPSIS_THRESHOLD\n  const hideEndButtons = props.hideGotoEndButtons ? 1 : 0\n\n  // The first case is when all of the page buttons fit on the control, this is\n  //  the simplest case and the only one that will create an array smaller than\n  //  Limit + 4 - hideEndButtons *2 (the [first, last,] prev, next buttons)\n\n  if (pages < limit + firstPage + lastPage) {\n    return [\n      !firstPage && !hideEndButtons ? FIRST_BUTTON : null,\n      PREV_BUTTON,\n      ...Array.from({length: pages}, (_, index) => index + 1),\n      NEXT_BUTTON,\n      !lastPage && !hideEndButtons ? LAST_BUTTON : null,\n    ].filter((x) => x !== null)\n  }\n\n  // All of the remaining cases result in an array that is exactly limit + 4 - hideEndButtons * 2 in length, so create\n  //  the array upfront and set up the beginning and end buttons, then fill the rest for each case\n\n  const buttons = Array.from({length: limit + 4 - hideEndButtons * 2})\n  if (!hideEndButtons) {\n    if (!firstPage) {\n      buttons[0] = FIRST_BUTTON\n      buttons[1] = PREV_BUTTON\n    } else {\n      buttons[0] = PREV_BUTTON\n      buttons[1] = 1\n    }\n\n    if (!lastPage) {\n      buttons[buttons.length - 1] = LAST_BUTTON\n      buttons[buttons.length - 2] = NEXT_BUTTON\n    } else {\n      buttons[buttons.length - 1] = NEXT_BUTTON\n      buttons[buttons.length - 2] = pages\n    }\n  } else {\n    buttons[0] = PREV_BUTTON\n    buttons[buttons.length - 1] = NEXT_BUTTON\n  }\n\n  // The next case is where the buttons page buttons start at the begginning, with\n  //  no ellipsis at the beginning, but one at the end\n\n  const halfLimit = Math.floor(limit / 2)\n  if (value <= halfLimit + firstPage) {\n    for (let index = 1; index <= limit; index++) {\n      buttons[index + 1 - hideEndButtons] = index + firstPage\n    }\n\n    if (!hideEllipsis) {\n      buttons[buttons.length - 3] = ELLIPSIS_BUTTON\n    }\n  }\n\n  // And then we have the case where the page buttons go up to the end, with no\n  //  ellipsis at the end, but one at the beginning\n\n  if (value > pages - halfLimit - lastPage) {\n    const start = pages - (limit - 1) - lastPage\n    for (let index = 0; index < limit; index++) {\n      buttons[index + 2 - hideEndButtons] = start + index\n    }\n\n    if (!hideEllipsis) {\n      buttons[2] = ELLIPSIS_BUTTON\n    }\n  }\n\n  // Finally we have the case where we have ellipsis at both ends\n  if (!buttons[2]) {\n    // Is there a more elegant way to ceck that we're in the final case?\n    const start = value - Math.floor(limit / 2)\n    for (let index = 0; index < limit; index++) {\n      buttons[index + 2 - hideEndButtons] = start + index\n    }\n\n    if (!hideEllipsis) {\n      buttons[2] = ELLIPSIS_BUTTON\n      buttons[buttons.length - 3] = ELLIPSIS_BUTTON\n    }\n  }\n\n  // Enable sanity check for debugging purposes\n  // for (let i = 0; i < buttons.length; i++) {\n  //   if (!buttons[i]) {\n  //     console.log(\n  //       `Failed: button == ${i}, limit=${limit}, pages=${pages}, firstPage=${firstPage}, lastPage=${lastPage}, value=${value}`\n  //     )\n  //   }\n  // }\n\n  return buttons as number[]\n})\n</script>\n\n<script lang=\"ts\">\nconst DEFAULT_PER_PAGE = 20\nconst DEFAULT_TOTAL_ROWS = 0\n</script>\n","<template>\n  <component :is=\"wrapperTag\" :class=\"wrapperClasses\">\n    <component\n      v-bind=\"$attrs\"\n      :is=\"tag\"\n      class=\"placeholder\"\n      :class=\"computedClasses\"\n      :style=\"computedStyle\"\n    />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, type CSSProperties, toRef} from 'vue'\nimport type {BPlaceholderProps} from '../../types'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<BPlaceholderProps>(), {\n  animation: undefined,\n  cols: 12,\n  size: 'md',\n  tag: 'span',\n  variant: null,\n  width: undefined,\n  wrapperTag: 'span',\n})\n\nconst widthString = toRef(() =>\n  props.width === undefined\n    ? undefined\n    : typeof props.width === 'number'\n      ? props.width.toString()\n      : props.width.replace('%', '')\n)\n\nconst colsString = toRef(() =>\n  props.cols === undefined\n    ? undefined\n    : typeof props.cols === 'number'\n      ? props.cols.toString()\n      : props.cols\n)\n\nconst computedClasses = computed(() => ({\n  [`col-${colsString.value}`]: colsString.value !== undefined && widthString.value === undefined,\n  [`bg-${props.variant}`]: props.variant !== null,\n  [`placeholder-${props.size}`]: props.size !== 'md',\n}))\n\nconst wrapperClasses = computed(() => ({\n  [`placeholder-${props.animation}`]: props.animation !== undefined,\n}))\n\nconst computedStyle = computed<CSSProperties>(() => ({\n  width: widthString.value === undefined ? undefined : `${widthString.value}%`,\n}))\n</script>\n","<template>\n  <BPlaceholder\n    class=\"btn disabled\"\n    :class=\"computedClasses\"\n    :animation=\"animation\"\n    :width=\"width\"\n    :cols=\"cols\"\n    :tag=\"tag\"\n    :style=\"{'cursor': 'wait', 'pointer-events': 'auto'}\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport BPlaceholder from './BPlaceholder.vue'\nimport type {BPlaceholderButtonProps} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(defineProps<BPlaceholderButtonProps>(), {\n  animation: undefined,\n  cols: undefined,\n  tag: 'div',\n  variant: 'primary',\n  width: undefined,\n})\n\nconst computedClasses = computed(() => ({\n  [`btn-${props.variant}`]: props.variant !== null,\n}))\n</script>\n","<template>\n  <BCard :img-bottom=\"imgBottom\">\n    <template v-if=\"!props.noImg\" #img>\n      <slot name=\"img\">\n        <BCardImg\n          :blank=\"!imgSrc ? true : false\"\n          :blank-color=\"imgBlankColor\"\n          :height=\"!imgSrc ? imgHeight : undefined\"\n          :src=\"imgSrc\"\n          :top=\"!imgBottom\"\n          :bottom=\"imgBottom\"\n          :style=\"{cursor: 'wait'}\"\n        />\n      </slot>\n    </template>\n\n    <template v-if=\"!props.noHeader\" #header>\n      <slot name=\"header\">\n        <BPlaceholder\n          :width=\"headerWidth\"\n          :variant=\"headerVariant\"\n          :animation=\"headerAnimation\"\n          :size=\"headerSize\"\n        />\n      </slot>\n    </template>\n    <slot>\n      <BPlaceholder cols=\"7\" v-bind=\"defaultAttrs\" />\n      <BPlaceholder cols=\"4\" v-bind=\"defaultAttrs\" />\n      <BPlaceholder cols=\"4\" v-bind=\"defaultAttrs\" />\n      <BPlaceholder cols=\"6\" v-bind=\"defaultAttrs\" />\n      <BPlaceholder cols=\"8\" v-bind=\"defaultAttrs\" />\n    </slot>\n    <template v-if=\"!props.noFooter\" #footer>\n      <slot name=\"footer\">\n        <component\n          :is=\"footerComponent\"\n          :width=\"footerWidth\"\n          :animation=\"footerAnimation\"\n          :size=\"props.noButton ? footerSize : undefined\"\n          :variant=\"footerVariant\"\n        />\n      </slot>\n    </template>\n  </BCard>\n</template>\n\n<script setup lang=\"ts\">\nimport BCard from '../BCard/BCard.vue'\nimport BCardImg from '../BCard/BCardImg.vue'\nimport BPlaceholder from './BPlaceholder.vue'\nimport BPlaceholderButton from './BPlaceholderButton.vue'\nimport type {BPlaceholderCardProps} from '../../types'\nimport {computed, toRef} from 'vue'\n\nconst props = withDefaults(defineProps<BPlaceholderCardProps>(), {\n  animation: undefined,\n  footerAnimation: undefined,\n  footerSize: 'md',\n  footerVariant: undefined,\n  footerWidth: 100,\n  headerAnimation: undefined,\n  headerSize: 'md',\n  headerVariant: undefined,\n  headerWidth: 100,\n  imgBlankColor: '#868e96',\n  imgBottom: false,\n  imgHeight: 100,\n  imgSrc: undefined,\n  noButton: false,\n  noFooter: false,\n  noHeader: false,\n  noImg: false,\n  size: 'md',\n  variant: undefined,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  footer?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  header?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  img?: (props: Record<string, never>) => any\n}>()\n\nconst defaultAttrs = computed(() => ({\n  animation: props.animation,\n  size: props.size,\n  variant: props.variant,\n}))\n\nconst footerComponent = toRef(() => (!props.noButton ? BPlaceholderButton : BPlaceholder))\n</script>\n","<template>\n  <!-- tables definitions are shared. Can't use createReusableTemplate cause it becomes a non-root node -->\n  <div v-if=\"isResponsive\" :class=\"responsiveClasses\" :style=\"responsiveStyles\">\n    <table v-bind=\"tableAttrs\">\n      <slot />\n    </table>\n  </div>\n  <table v-else v-bind=\"tableAttrs\">\n    <slot />\n  </table>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, type StyleValue} from 'vue'\nimport type {BTableSimpleProps} from '../../types'\nimport {useNumberishToStyle} from '../../composables'\n\nconst defaultStickyHeaderHeight = '300px'\n\n// TODO alphabetize the lists for tables\n// TODO all table things do not declare their props\n// TODO some props are not used. ex id, fixed, etc\n// TODO Attrs fallthrough will attach to either responsive or table, but you can't assign attrs to table if it is responsive. So we will need an attrs & class\nconst props = withDefaults(defineProps<BTableSimpleProps>(), {\n  borderVariant: null,\n  tableClass: undefined,\n  variant: null,\n  bordered: false,\n  borderless: false,\n  captionTop: false,\n  dark: false,\n  hover: false,\n  id: undefined,\n  noBorderCollapse: false,\n  outlined: false,\n  fixed: false,\n  responsive: false,\n  stacked: false,\n  striped: false,\n  stripedColumns: false,\n  small: false,\n  stickyHeader: false,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => [\n  props.tableClass,\n  'table',\n  'b-table',\n  {\n    'table-bordered': props.bordered,\n    'table-borderless': props.borderless,\n    [`border-${props.borderVariant}`]: props.borderVariant !== null,\n    'caption-top': props.captionTop,\n    'table-dark': props.dark,\n    'table-hover': props.hover,\n    'b-table-stacked': props.stacked === true,\n    [`b-table-stacked-${props.stacked}`]: typeof props.stacked === 'string',\n    'table-striped': props.striped,\n    'table-sm': props.small,\n    [`table-${props.variant}`]: props.variant !== null,\n    'table-striped-columns': props.stripedColumns,\n  },\n])\nconst tableAttrs = computed(() => ({\n  id: props.id,\n  class: computedClasses.value,\n}))\n\nconst computedSticky = useNumberishToStyle(\n  computed(\n    () => (props.stickyHeader === true ? defaultStickyHeaderHeight : props.stickyHeader) || NaN\n  )\n)\nconst stickyIsValid = computed(() => props.stickyHeader !== false)\n\nconst isResponsive = computed(() => props.responsive !== false || stickyIsValid.value)\nconst responsiveStyles = computed<StyleValue | undefined>(() =>\n  stickyIsValid.value ? {maxHeight: computedSticky.value} : undefined\n)\nconst responsiveClasses = computed(() => ({\n  'table-responsive': props.responsive === true,\n  [`table-responsive-${props.responsive}`]: typeof props.responsive === 'string',\n  'b-table-sticky-header': stickyIsValid.value,\n}))\n</script>\n","<template>\n  <BTableSimple>\n    <slot v-if=\"!props.hideHeader\" name=\"thead\">\n      <thead>\n        <tr>\n          <th v-for=\"(_, i) in computedHeaderColumnsLength\" :key=\"i\">\n            <BPlaceholder\n              :size=\"headerSize\"\n              :variant=\"headerVariant\"\n              :animation=\"headerAnimation\"\n              :width=\"headerCellWidth\"\n            />\n          </th>\n        </tr>\n      </thead>\n    </slot>\n    <slot>\n      <tbody>\n        <tr v-for=\"(_, j) in rowsNumber\" :key=\"j\">\n          <td v-for=\"(__, k) in columnsNumber\" :key=\"k\">\n            <BPlaceholder\n              :size=\"size\"\n              :variant=\"variant\"\n              :animation=\"animation\"\n              :width=\"cellWidth\"\n            />\n          </td>\n        </tr>\n      </tbody>\n    </slot>\n    <slot v-if=\"props.showFooter\" name=\"tfoot\">\n      <tfoot>\n        <tr>\n          <th v-for=\"(_, l) in computedFooterColumnsLength\" :key=\"l\">\n            <BPlaceholder\n              :size=\"footerSize\"\n              :variant=\"footerVariant\"\n              :animation=\"footerAnimation\"\n              :width=\"footerCellWidth\"\n            />\n          </th>\n        </tr>\n      </tfoot>\n    </slot>\n  </BTableSimple>\n</template>\n\n<script setup lang=\"ts\">\nimport {toRef} from 'vue'\nimport type {BPlaceholderTableProps} from '../../types'\nimport BTableSimple from '../BTable/BTableSimple.vue'\nimport BPlaceholder from './BPlaceholder.vue'\nimport {useToNumber} from '@vueuse/core'\n\nconst props = withDefaults(defineProps<BPlaceholderTableProps>(), {\n  animation: undefined,\n  cellWidth: 100,\n  columns: 5,\n  footerAnimation: undefined,\n  footerCellWidth: 100,\n  footerColumns: undefined,\n  footerSize: 'md',\n  footerVariant: undefined,\n  headerAnimation: undefined,\n  headerCellWidth: 100,\n  headerColumns: undefined,\n  headerSize: 'md',\n  headerVariant: undefined,\n  hideHeader: false,\n  rows: 3,\n  showFooter: false,\n  size: 'md',\n  variant: undefined,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tfoot?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  thead?: (props: Record<string, never>) => any\n}>()\n\nconst columnsToNumber = useToNumber(() => props.columns)\nconst rowsToNumber = useToNumber(() => props.rows)\nconst computedHeaderColumns = toRef(() => props.headerColumns ?? NaN)\nconst computedFooterColumns = toRef(() => props.footerColumns ?? NaN)\nconst headerColumnsNumber = useToNumber(computedHeaderColumns)\nconst footerColumnsNumber = useToNumber(computedFooterColumns)\n\nconst columnsNumber = toRef(() => columnsToNumber.value || 5)\nconst rowsNumber = toRef(() => rowsToNumber.value || 3)\n\nconst computedHeaderColumnsLength = toRef(() =>\n  props.headerColumns === undefined ? columnsNumber.value : headerColumnsNumber.value\n)\nconst computedFooterColumnsLength = toRef(() =>\n  props.footerColumns === undefined ? columnsNumber.value : footerColumnsNumber.value\n)\n</script>\n","<template>\n  <slot v-if=\"props.loading\" name=\"loading\" />\n  <slot v-else />\n</template>\n\n<script setup lang=\"ts\">\nimport type {BPlaceholderWrapperProps} from '../../types'\n\nconst props = withDefaults(defineProps<BPlaceholderWrapperProps>(), {\n  loading: false,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  loading?: (props: Record<string, never>) => any\n}>()\n</script>\n","<template>\n  <component :is=\"tag\" class=\"row\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {computed, defineComponent, type PropType, type SlotsType} from 'vue'\nimport {getBreakpointProps, getClasses} from '../utils'\nimport type {AlignmentContent, AlignmentJustifyContent, AlignmentVertical} from '../types'\nimport {useAlignment} from '../composables'\n\nconst rowColsProps = getBreakpointProps('cols', [''], {type: [String, Number], default: null})\n\nexport default defineComponent({\n  name: 'BRow',\n  slots: Object as SlotsType<{\n    default?: Record<string, never>\n  }>,\n  props: {\n    tag: {type: String, default: 'div'},\n    gutterX: {type: String, default: null},\n    gutterY: {type: String, default: null},\n    noGutters: {type: Boolean, default: false},\n    alignV: {type: String as PropType<AlignmentVertical>, default: null},\n    alignH: {type: String as PropType<AlignmentJustifyContent>, default: null},\n    alignContent: {type: String as PropType<AlignmentContent>, default: null},\n    ...rowColsProps,\n  },\n  setup(props) {\n    const alignment = useAlignment(() => props.alignH)\n\n    const rowColsClasses = computed(() => getClasses(props, rowColsProps, 'cols', 'row-cols'))\n\n    const computedClasses = computed(() => [\n      rowColsClasses.value,\n      {\n        [`gx-${props.gutterX}`]: props.gutterX !== null,\n        [`gy-${props.gutterY}`]: props.gutterY !== null,\n        'g-0': props.noGutters,\n        [`align-items-${props.alignV}`]: props.alignV !== null,\n        [alignment.value]: props.alignH !== null,\n        [`align-content-${props.alignContent}`]: props.alignContent !== null,\n      },\n    ])\n\n    return {\n      computedClasses,\n    }\n  },\n})\n</script>\n","import type {ClassValue, ColorVariant, LiteralUnion, MaybePromise} from '.'\nimport type {StyleValue} from 'vue'\n\nexport type TableItem<T = Record<string, unknown>> = T & {\n  _rowVariant?: ColorVariant | null\n  _cellVariants?: Partial<Record<keyof T, ColorVariant>>\n  _showDetails?: boolean\n}\n\nexport const isTableItem = (value: unknown): value is TableItem =>\n  typeof value === 'object' && value !== null\n\n// undefined means no sorting\nexport type BTableSortByOrder = 'desc' | 'asc' | undefined\n\nexport type BTableSortBy = {\n  order: BTableSortByOrder\n  key: string\n  comparer?: (a: string, b: string) => number\n}\n\nexport type BTableProviderContext = {\n  sortBy: BTableSortBy[] | undefined\n  filter: string | undefined\n  currentPage: number\n  perPage: number\n}\n\nexport type BTableProvider<T> = (\n  context: Readonly<BTableProviderContext>\n) => MaybePromise<T[] | undefined>\n\nexport type TableFieldFormatter<T> = (value: unknown, key: string, item: T) => string\n\nexport type TableFieldAttribute<T> =\n  | Record<string, unknown>\n  | ((value: unknown, key: string, item: T) => Record<string, unknown>)\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type TableField<T = any> = {\n  key: LiteralUnion<keyof T>\n  label?: string\n  headerTitle?: string\n  headerAbbr?: string\n  class?: ClassValue\n  formatter?: TableFieldFormatter<T>\n  sortable?: boolean\n  sortKey?: string\n  sortDirection?: string\n  sortByFormatted?: boolean | TableFieldFormatter<T>\n  filterByFormatted?: boolean\n  tdClass?: ClassValue\n  thClass?: ClassValue\n  thStyle?: StyleValue\n  variant?: ColorVariant | null\n  tdAttr?: TableFieldAttribute<T>\n  thAttr?: TableFieldAttribute<T>\n  isRowHeader?: boolean\n  stickyColumn?: boolean\n}\n\nexport type TableFieldRaw<T = unknown> = T extends object\n  ? LiteralUnion<keyof T> | TableField<T>\n  : string | TableField\n\nexport const isTableField = <T>(value: unknown): value is TableField<T> =>\n  typeof value === 'object' && value !== null && 'key' in value\n\nexport const isTableFieldRaw = <T>(value: unknown): value is TableFieldRaw<T> =>\n  typeof value === 'string' || isTableField(value)\n\nexport type NoProviderTypes = 'paging' | 'sorting' | 'filtering'\n","<template>\n  <tbody :class=\"computedClasses\">\n    <slot />\n  </tbody>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BTbodyProps} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(defineProps<BTbodyProps>(), {\n  variant: null,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`thead-${props.variant}`]: props.variant !== null,\n}))\n</script>\n","<template>\n  <td\n    :scope=\"scope\"\n    :class=\"computedClasses\"\n    :colspan=\"colspan\"\n    :rowspan=\"rowspan\"\n    :data-label=\"stackedHeading\"\n  >\n    <div v-if=\"stackedHeading\">\n      <slot />\n    </div>\n    <slot v-else />\n  </td>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BTdProps} from '../../types'\nimport {computed, toRef} from 'vue'\n\nconst props = withDefaults(defineProps<BTdProps>(), {\n  colspan: undefined,\n  rowspan: undefined,\n  stackedHeading: undefined,\n  stickyColumn: false,\n  variant: null,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n  'b-table-sticky-column': props.stickyColumn,\n  'table-b-table-default': props.stickyColumn && props.variant === null,\n}))\n\nconst scope = toRef(() => (props.colspan ? 'colspan' : props.rowspan ? 'rowspan' : 'col'))\n</script>\n","<template>\n  <tfoot :class=\"computedClasses\">\n    <slot />\n  </tfoot>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BTfootProps} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(defineProps<BTfootProps>(), {\n  variant: null,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n}))\n</script>\n","<template>\n  <th\n    :scope=\"scope\"\n    :class=\"computedClasses\"\n    :colspan=\"colspan\"\n    :rowspan=\"rowspan\"\n    :data-label=\"stackedHeading\"\n  >\n    <div v-if=\"stackedHeading !== undefined\">\n      <slot />\n    </div>\n    <slot v-else />\n  </th>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BThProps} from '../../types'\nimport {computed, toRef} from 'vue'\n\nconst props = withDefaults(defineProps<BThProps>(), {\n  colspan: undefined,\n  rowspan: undefined,\n  stackedHeading: undefined,\n  stickyColumn: false,\n  variant: null,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n  'b-table-sticky-column': props.stickyColumn,\n  'table-b-table-default': props.stickyColumn && props.variant === null,\n}))\n\nconst scope = toRef(() => (props.colspan ? 'colspan' : props.rowspan ? 'rowspan' : 'col'))\n</script>\n","<template>\n  <thead :class=\"computedClasses\">\n    <slot />\n  </thead>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BTheadProps} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(defineProps<BTheadProps>(), {\n  variant: null,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n}))\n</script>\n","<template>\n  <tr :class=\"computedClasses\">\n    <slot />\n  </tr>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BTrProps} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(defineProps<BTrProps>(), {\n  variant: null,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n}))\n</script>\n","<template>\n  <BTableSimple\n    :id=\"id\"\n    :bordered=\"bordered\"\n    :borderless=\"borderless\"\n    :border-variant=\"borderVariant\"\n    :caption-top=\"captionTop\"\n    :dark=\"dark\"\n    :fixed=\"fixed\"\n    :hover=\"hover\"\n    :no-border-collapse=\"noBorderCollapse\"\n    :outlined=\"outlined\"\n    :responsive=\"responsive\"\n    :small=\"small\"\n    :stacked=\"props.stacked\"\n    :sticky-header=\"stickyHeader\"\n    :striped=\"striped\"\n    :table-class=\"computedTableClasses\"\n    :variant=\"variant\"\n    :striped-columns=\"stripedColumns\"\n  >\n    <BThead v-show=\"showComputedHeaders\" :variant=\"headVariant\" :class=\"theadClass\">\n      <slot v-if=\"$slots['thead-top']\" name=\"thead-top\" />\n      <BTr :variant=\"headRowVariant\" :class=\"theadTrClass\">\n        <BTh\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          scope=\"col\"\n          :class=\"getFieldColumnClasses(field)\"\n          :title=\"field.headerTitle\"\n          :variant=\"field.variant\"\n          :abbr=\"field.headerAbbr\"\n          :style=\"field.thStyle\"\n          v-bind=\"field.thAttr\"\n          @click=\"headerClicked(field, $event)\"\n        >\n          <slot\n            :name=\"$slots[`head(${String(field.key)})`] ? `head(${String(field.key)})` : 'head()'\"\n            :label=\"field.label\"\n            :column=\"field.key\"\n            :field=\"field\"\n            :is-foot=\"false\"\n          >\n            {{ getTableFieldHeadLabel(field) }}\n          </slot>\n        </BTh>\n      </BTr>\n      <BTr v-if=\"$slots['thead-sub']\">\n        <BTd\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          scope=\"col\"\n          :variant=\"field.variant\"\n          :class=\"[field.class, field.thClass]\"\n        >\n          <slot name=\"thead-sub\" :items=\"computedFields\" v-bind=\"field\">\n            {{ field.label }}\n          </slot>\n        </BTd>\n      </BTr>\n    </BThead>\n    <BTbody :class=\"tbodyClass\">\n      <slot\n        name=\"custom-body\"\n        :fields=\"computedFields\"\n        :items=\"items\"\n        :columns=\"computedFields.length\"\n      >\n        <BTr v-if=\"!props.stacked && $slots['top-row']\">\n          <slot name=\"top-row\" />\n        </BTr>\n\n        <template v-for=\"(item, itemIndex) in items\" :key=\"itemIndex\">\n          <BTr\n            :class=\"getRowClasses(item, 'row')\"\n            :variant=\"isTableItem(item) ? item._rowVariant : undefined\"\n            @click=\"!filterEvent($event) && emit('row-clicked', item, itemIndex, $event)\"\n            @dblclick=\"!filterEvent($event) && emit('row-dbl-clicked', item, itemIndex, $event)\"\n            @mouseenter=\"!filterEvent($event) && emit('row-hovered', item, itemIndex, $event)\"\n            @mouseleave=\"!filterEvent($event) && emit('row-unhovered', item, itemIndex, $event)\"\n          >\n            <BTd\n              v-for=\"field in computedFields\"\n              :key=\"field.key\"\n              :variant=\"\n                (isTableItem(item) ? item._cellVariants?.[field.key as string] : false)\n                  ? null\n                  : field.variant\n              \"\n              :class=\"getFieldRowClasses(field, item)\"\n              v-bind=\"itemAttributes(item, String(field.key), field.tdAttr)\"\n            >\n              <label v-if=\"props.stacked && props.labelStacked\" class=\"b-table-stacked-label\">\n                {{ getTableFieldHeadLabel(field) }}\n              </label>\n              <slot\n                :name=\"\n                  $slots[`cell(${String(field.key)})`] ? `cell(${String(field.key)})` : 'cell()'\n                \"\n                :value=\"get(item, String(field.key))\"\n                :index=\"itemIndex\"\n                :item=\"item\"\n                :field=\"field\"\n                :items=\"items\"\n                :toggle-details=\"\n                  () => {\n                    toggleRowDetails(item)\n                  }\n                \"\n                :details-showing=\"isTableItem(item) ? detailsMap.get(item) ?? false : false\"\n              >\n                <template v-if=\"!$slots[`cell(${String(field.key)})`] && !$slots['cell()']\">\n                  {{ formatItem(item, String(field.key), field.formatter) }}\n                </template>\n              </slot>\n            </BTd>\n          </BTr>\n\n          <template\n            v-if=\"isTableItem(item) && detailsMap.get(item) === true && $slots['row-details']\"\n          >\n            <BTr aria-hidden=\"true\" role=\"presentation\" class=\"d-none\" />\n            <BTr :class=\"getRowClasses(item, 'row-details')\" :variant=\"item._rowVariant\">\n              <BTd :colspan=\"computedFieldsTotal\">\n                <slot\n                  name=\"row-details\"\n                  :item=\"item\"\n                  :toggle-details=\"\n                    () => {\n                      toggleRowDetails(item)\n                    }\n                  \"\n                  :fields=\"fields\"\n                  :index=\"itemIndex\"\n                />\n              </BTd>\n            </BTr>\n          </template>\n        </template>\n        <BTr v-if=\"props.showEmpty && items.length === 0\" class=\"b-table-empty-slot\">\n          <BTd :colspan=\"computedFieldsTotal\">\n            <slot name=\"empty\" :items=\"items\">\n              {{ emptyText }}\n            </slot>\n          </BTd>\n        </BTr>\n        <BTr v-if=\"!props.stacked && $slots['bottom-row']\">\n          <slot name=\"bottom-row\" />\n        </BTr>\n      </slot>\n    </BTbody>\n    <BTfoot v-if=\"props.footClone\" :variant=\"footVariant\" :class=\"tfootClass\">\n      <BTr :variant=\"footRowVariant\" :class=\"tfootTrClass\">\n        <BTh\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          scope=\"col\"\n          :class=\"getFieldColumnClasses(field)\"\n          :title=\"field.headerTitle\"\n          :abbr=\"field.headerAbbr\"\n          :style=\"field.thStyle\"\n          :variant=\"field.variant\"\n          v-bind=\"field.thAttr\"\n          @click=\"headerClicked(field, $event, true)\"\n        >\n          <div class=\"d-inline-flex flex-nowrap align-items-center gap-1\">\n            <div>\n              <slot\n                :name=\"\n                  $slots[`foot(${String(field.key)})`] ? `foot(${String(field.key)})` : 'foot()'\n                \"\n                :label=\"field.label\"\n                :column=\"field.key\"\n                :field=\"field\"\n                :is-foot=\"true\"\n              >\n                {{ getTableFieldHeadLabel(field) }}\n              </slot>\n            </div>\n          </div>\n        </BTh>\n      </BTr>\n    </BTfoot>\n    <BTfoot v-else-if=\"$slots['custom-foot']\">\n      <slot\n        name=\"custom-foot\"\n        :fields=\"computedFields\"\n        :items=\"items\"\n        :columns=\"computedFields.length\"\n      />\n    </BTfoot>\n    <caption v-if=\"$slots['table-caption'] || caption\">\n      <slot name=\"table-caption\">\n        {{ caption }}\n      </slot>\n    </caption>\n  </BTableSimple>\n</template>\n\n<script setup lang=\"ts\" generic=\"T\">\nimport {computed, ref, toRef, watch} from 'vue'\nimport type {BTableLiteProps, TableField, TableFieldAttribute, TableItem} from '../../types'\nimport {isTableField, isTableItem} from '../../types/TableTypes'\nimport {filterEvent, formatItem, get, getTableFieldHeadLabel, startCase} from '../../utils'\nimport BTableSimple from './BTableSimple.vue'\nimport BTbody from './BTbody.vue'\nimport BTd from './BTd.vue'\nimport BTfoot from './BTfoot.vue'\nimport BTh from './BTh.vue'\nimport BThead from './BThead.vue'\nimport BTr from './BTr.vue'\n\nconst props = withDefaults(defineProps<BTableLiteProps<T>>(), {\n  caption: undefined,\n  align: undefined,\n  fields: () => [],\n  footClone: false,\n  items: () => [],\n  labelStacked: false,\n  showEmpty: false,\n  emptyText: 'There are no records to show',\n  emptyFilteredText: 'There are no records matching your request', // TODO not implemented\n  fieldColumnClass: undefined,\n  tbodyTrClass: undefined,\n  captionHtml: undefined,\n  detailsTdClass: undefined,\n  headVariant: undefined,\n  headRowVariant: undefined,\n  footRowVariant: undefined,\n  footVariant: undefined,\n  modelValue: undefined,\n  primaryKey: undefined,\n  tbodyClass: undefined,\n  tbodyTrAttr: undefined,\n  tfootClass: undefined,\n  tfootTrClass: undefined,\n  theadClass: undefined,\n  theadTrClass: undefined,\n  // BTableSimpleProps props\n  borderVariant: undefined,\n  tableClass: undefined,\n  variant: undefined,\n  bordered: undefined,\n  borderless: undefined,\n  captionTop: undefined,\n  dark: undefined,\n  hover: undefined,\n  id: undefined,\n  noBorderCollapse: undefined,\n  outlined: undefined,\n  fixed: undefined,\n  responsive: undefined,\n  stacked: undefined,\n  striped: undefined,\n  stripedColumns: undefined,\n  small: undefined,\n  stickyHeader: undefined,\n  // End BTableSimpleProps props\n})\n\nconst emit = defineEmits<{\n  'head-clicked': [key: string, field: TableField<T>, event: MouseEvent, isFooter: boolean]\n  'row-clicked': [item: T, index: number, event: MouseEvent]\n  'row-dbl-clicked': [item: T, index: number, event: MouseEvent]\n  'row-hovered': [item: T, index: number, event: MouseEvent]\n  'row-unhovered': [item: T, index: number, event: MouseEvent]\n}>()\n\nconst generateDetailsItem = (item: TableItem): [object, boolean | undefined] => [\n  item,\n  item._showDetails,\n]\nconst detailsMap = ref(\n  new WeakMap(\n    props.items.reduce(\n      (acc, el) => {\n        if (isTableItem(el)) {\n          acc.push(generateDetailsItem(el))\n        }\n        return acc\n      },\n      [] as [object, boolean | undefined][]\n    )\n  )\n)\nwatch(\n  () => props.items,\n  (items) => {\n    items.forEach((item) => {\n      if (!isTableItem(item)) return\n      const detailsItem = generateDetailsItem(item)\n      detailsMap.value.set(detailsItem[0], detailsItem[1])\n    })\n  },\n  {deep: true}\n)\n\nconst computedTableClasses = computed(() => [\n  props.tableClass,\n  {\n    [`align-${props.align}`]: props.align !== undefined,\n  },\n])\n\nconst computedFields = computed<(TableField & {_noHeader?: true})[]>(() => {\n  if (!props.fields.length && props.items.length) {\n    const [firstItem] = props.items\n    if (isTableItem(firstItem) || Array.isArray(firstItem)) {\n      return Object.keys(firstItem).map((k) => {\n        const label = startCase(k)\n        return {\n          key: k,\n          label,\n          tdAttr: props.stacked === true ? {'data-label': label} : undefined,\n        }\n      })\n    }\n    // The items are primitives, so we just return a single empty field\n    // No header will be shown, as we don't know what to show\n    return [{key: '', _noHeader: true}]\n  }\n\n  return props.fields.map((f) => {\n    if (isTableField(f)) {\n      return {\n        ...(f as TableField),\n        tdAttr:\n          props.stacked === true\n            ? {'data-label': startCase(f.key as string), ...f.tdAttr}\n            : f.tdAttr,\n      }\n    }\n    const label = startCase(f as string)\n    return {\n      key: f as string,\n      label,\n      tdAttr: props.stacked === true ? {'data-label': label} : undefined,\n    }\n  })\n})\nconst computedFieldsTotal = toRef(() => computedFields.value.length)\nconst showComputedHeaders = computed(() => {\n  // We only hide the header if all fields have _noHeader set to true. Which would be our doing\n  // This usually happens under a circumstance of displaying an array of primitives\n  // Under any other circumstance, I'm not sure how this would apply\n  if (computedFields.value.length > 0 && computedFields.value.every((el) => el._noHeader === true))\n    return false\n  return true\n})\n\nconst itemAttributes = (item: T, fieldKey: string, attr?: TableFieldAttribute<unknown>) => {\n  const val = get(item, fieldKey)\n  return attr && typeof attr === 'function' ? attr(val, fieldKey, item) : attr\n}\n\nconst headerClicked = (field: TableField<T>, event: Readonly<MouseEvent>, isFooter = false) => {\n  emit('head-clicked', field.key as string, field, event, isFooter)\n}\n\nconst toggleRowDetails = (tr: T) => {\n  if (isTableItem(tr)) {\n    const prevValue = detailsMap.value.get(tr)\n    detailsMap.value.set(tr, !prevValue)\n  }\n}\n\nconst getFieldColumnClasses = (field: TableField) => [\n  field.class,\n  field.thClass,\n  {\n    'b-table-sticky-column': field.stickyColumn,\n  },\n  props.fieldColumnClass\n    ? typeof props.fieldColumnClass === 'function'\n      ? props.fieldColumnClass(field)\n      : props.fieldColumnClass\n    : null,\n]\n\nconst getFieldRowClasses = (field: Readonly<TableField>, tr: T) => [\n  field.class,\n  field.tdClass,\n  (isTableItem(tr) ? tr._cellVariants?.[field.key as string] : false)\n    ? `table-${(tr as TableItem)._cellVariants?.[field.key as string]}`\n    : null,\n  {\n    'b-table-sticky-column': field.stickyColumn,\n  },\n]\n\nconst getRowClasses = (item: T, type: 'row-details' | 'row') =>\n  props.tbodyTrClass\n    ? typeof props.tbodyTrClass === 'function'\n      ? props.tbodyTrClass(item, type)\n      : props.tbodyTrClass\n    : null\n</script>\n","<template>\n  <BTableLite\n    v-bind=\"props\"\n    :aria-busy=\"busyModel\"\n    :items=\"computedDisplayItems\"\n    :fields=\"computedFields\"\n    :table-class=\"tableClasses\"\n    :tbody-tr-class=\"getRowClasses\"\n    :field-column-class=\"getFieldColumnClasses\"\n    @head-clicked=\"onFieldHeadClick\"\n    @row-dbl-clicked=\"\n      (row, index, e) => {\n        emit('row-dbl-clicked', row, index, e)\n      }\n    \"\n    @row-clicked=\"onRowClick\"\n    @row-hovered=\"\n      (row, index, e) => {\n        emit('row-hovered', row, index, e)\n      }\n    \"\n    @row-unhovered=\"\n      (row, index, e) => {\n        emit('row-unhovered', row, index, e)\n      }\n    \"\n  >\n    <template v-for=\"(_, name) in $slots\" #[name]=\"slotData\">\n      <slot :name=\"name\" v-bind=\"slotData\" />\n    </template>\n    <template #head()=\"scope\">\n      {{ getTableFieldHeadLabel(scope.field) }}\n      <template v-if=\"isSortable && !!scope.field.sortable && props.noSortableIcon === false\">\n        <slot\n          v-if=\"sortByModel?.find((el) => el.key === scope.field.key)?.order === 'asc'\"\n          v-bind=\"{...scope}\"\n          :name=\"\n            $slots[`sortAsc(${String(scope.field.key)})`]\n              ? `sortAsc(${String(scope.field.key)})`\n              : 'sortAsc()'\n          \"\n        >\n          <svg\n            xmlns=\"http://www.w3.org/2000/svg\"\n            width=\"24\"\n            height=\"24\"\n            fill=\"currentColor\"\n            class=\"bi bi-arrow-up-short\"\n            viewBox=\"0 0 16 16\"\n            aria-hidden\n          >\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z\"\n            />\n          </svg>\n        </slot>\n        <slot\n          v-else-if=\"sortByModel?.find((el) => el.key === scope.field.key)?.order === 'desc'\"\n          v-bind=\"{...scope}\"\n          :name=\"\n            $slots[`sortDesc(${String(scope.field.key)})`]\n              ? `sortDesc(${String(scope.field.key)})`\n              : 'sortDesc()'\n          \"\n        >\n          <svg\n            xmlns=\"http://www.w3.org/2000/svg\"\n            width=\"24\"\n            height=\"24\"\n            fill=\"currentColor\"\n            class=\"bi bi-arrow-down-short\"\n            viewBox=\"0 0 16 16\"\n            aria-hidden\n          >\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z\"\n            />\n          </svg>\n        </slot>\n        <slot\n          v-else\n          v-bind=\"{...scope}\"\n          :name=\"\n            $slots[`sortDefault(${String(scope.field.key)})`]\n              ? `sortDefault(${String(scope.field.key)})`\n              : 'sortDefault()'\n          \"\n        >\n          <svg\n            :style=\"{opacity: 0.4}\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            width=\"24\"\n            height=\"24\"\n            fill=\"currentColor\"\n            class=\"bi bi-arrow-up-short\"\n            viewBox=\"0 0 16 16\"\n            aria-hidden\n          >\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z\"\n            />\n          </svg>\n        </slot>\n      </template>\n    </template>\n    <template #custom-body=\"scope\">\n      <BTr v-if=\"busyModel\" class=\"b-table-busy-slot\" :class=\"getBusyRowClasses\">\n        <BTd :colspan=\"scope.fields.length\">\n          <slot name=\"table-busy\">\n            <BOverlay show>\n              <template #overlay>\n                <div class=\"d-flex align-items-center gap-2 mt-5\">\n                  <BSpinner />\n                  <strong>{{ busyLoadingText }}</strong>\n                </div>\n              </template>\n            </BOverlay>\n          </slot>\n        </BTd>\n      </BTr>\n    </template>\n  </BTableLite>\n</template>\n\n<script setup lang=\"ts\" generic=\"T\">\nimport {useToNumber} from '@vueuse/core'\nimport {computed, onMounted, type Ref, ref, toRef, watch} from 'vue'\nimport type {\n  BTableProps,\n  BTableSortBy,\n  BTableSortByOrder,\n  NoProviderTypes,\n  TableField,\n  TableFieldRaw,\n  TableItem,\n} from '../../types'\nimport {formatItem, get, getTableFieldHeadLabel, set} from '../../utils'\nimport BOverlay from '../BOverlay/BOverlay.vue'\nimport BSpinner from '../BSpinner.vue'\nimport BTableLite from './BTableLite.vue'\nimport BTd from './BTd.vue'\nimport BTr from './BTr.vue'\nimport {isTableField, isTableItem} from '../../types/TableTypes'\n\nconst props = withDefaults(defineProps<BTableProps<T>>(), {\n  noSortableIcon: false,\n  perPage: Number.POSITIVE_INFINITY,\n  filter: undefined,\n  mustSort: false,\n  filterable: undefined,\n  provider: undefined,\n  noProvider: undefined,\n  noProviderPaging: false,\n  noProviderSorting: false,\n  multisort: false,\n  noProviderFiltering: false,\n  noLocalSorting: false,\n  noSelectOnClick: false,\n  selectable: false,\n  stickySelect: false,\n  selectHead: true,\n  selectMode: 'multi',\n  selectionVariant: 'primary',\n  busyLoadingText: 'Loading...',\n  currentPage: 1,\n  // BTableLite props\n  items: () => [],\n  fields: () => [],\n  // All others use defaults\n  caption: undefined,\n  align: undefined,\n  footClone: undefined,\n  labelStacked: undefined,\n  showEmpty: undefined,\n  emptyText: undefined,\n  emptyFilteredText: undefined,\n  fieldColumnClass: undefined,\n  tbodyTrClass: undefined,\n  captionHtml: undefined,\n  detailsTdClass: undefined,\n  headVariant: undefined,\n  headRowVariant: undefined,\n  footRowVariant: undefined,\n  footVariant: undefined,\n  modelValue: undefined,\n  primaryKey: undefined,\n  tbodyClass: undefined,\n  tbodyTrAttr: undefined,\n  tfootClass: undefined,\n  tfootTrClass: undefined,\n  theadClass: undefined,\n  theadTrClass: undefined,\n  // End BTableLite props\n  // BTableSimple props\n  borderVariant: undefined,\n  variant: undefined,\n  bordered: undefined,\n  borderless: undefined,\n  captionTop: undefined,\n  dark: undefined,\n  hover: undefined,\n  id: undefined,\n  noBorderCollapse: undefined,\n  outlined: undefined,\n  fixed: undefined,\n  responsive: undefined,\n  stacked: undefined,\n  striped: undefined,\n  stripedColumns: undefined,\n  small: undefined,\n  stickyHeader: undefined,\n  // End BTableSimple props\n})\n\nconst emit = defineEmits<{\n  'filtered': [value: T[]]\n  'head-clicked': [key: string, field: TableField<T>, event: MouseEvent, isFooter: boolean]\n  'row-clicked': [item: T, index: number, event: MouseEvent]\n  'row-dbl-clicked': [item: T, index: number, event: MouseEvent]\n  'row-hovered': [item: T, index: number, event: MouseEvent]\n  'row-unhovered': [item: T, index: number, event: MouseEvent]\n  'row-selected': [value: T]\n  'row-unselected': [value: T]\n  'selection': [value: T[]]\n  'sorted': [value: BTableSortBy]\n  'change': [value: T[]]\n}>()\n\nconst sortByModel = defineModel<BTableSortBy[] | undefined>('sortBy', {\n  default: undefined,\n})\nconst busyModel = defineModel<boolean>('busy', {\n  default: false,\n})\nconst selectedItemsModel = defineModel<T[]>('selectedItems', {\n  default: () => [],\n})\n\nconst selectedItemsToSet = computed({\n  get: () => new Set([...selectedItemsModel.value]),\n  set: (val) => {\n    selectedItemsModel.value = [...val]\n  },\n})\n/**\n * This is to avoid the issue of directly mutating the array structure and to properly trigger the computed setter.\n * The utils also conveniently emit the proper events after\n */\nconst selectedItemsSetUtilities = {\n  add: (item: T) => {\n    const value = new Set(selectedItemsToSet.value)\n    value.add(item)\n    selectedItemsToSet.value = value\n    emit('row-selected', item)\n  },\n  clear: () => {\n    selectedItemsToSet.value.forEach((item) => {\n      selectedItemsSetUtilities.delete(item)\n    })\n  },\n  delete: (item: T) => {\n    const value = new Set(selectedItemsToSet.value)\n    value.delete(item)\n    selectedItemsToSet.value = value\n    emit('row-unselected', item)\n  },\n  set: (items: T[]) => {\n    selectedItemsToSet.value = new Set(items)\n    selectedItemsToSet.value.forEach((item) => {\n      emit('row-unselected', item)\n    })\n  },\n  /* TODO\n  This has method and the delete method suffer from an error when using a non-reactive source as the items prop\n  ```ts\n  const items = [{first_name: 'Geneva', last_name: 'Wilson', age: 89},{first_name: 'Jami', last_name: 'Carney', age: 38}]\n  ```\n  For some reason, the reference of the object gets lost. However, when you use an actual ref(), it works just fine\n  Getting the reference properly will fix all outstanding issues\n  */\n  has: (item: T) => {\n    if (!props.primaryKey) return selectedItemsToSet.value.has(item)\n\n    // Resolver for when we are using primary keys\n    const pkey: string = props.primaryKey\n    for (const selected of selectedItemsToSet.value) {\n      const selectedKey = get(selected, pkey)\n      const itemKey = get(item, pkey)\n\n      if (!!selectedKey && !!itemKey && selectedKey === itemKey) return true\n    }\n    return false\n  },\n} as const\n\n/**\n * Only stores data that is fetched when using the provider\n */\nconst internalItems: Ref<T[]> = ref([])\n\nconst perPageNumber = useToNumber(() => props.perPage, {method: 'parseInt'})\nconst currentPageNumber = useToNumber(() => props.currentPage, {method: 'parseInt'})\n\nconst isFilterableTable = toRef(() => !!props.filter)\nconst usesProvider = toRef(() => props.provider !== undefined)\nconst isSelecting = toRef(() => selectedItemsToSet.value.size > 0)\n\nconst isSortable = computed(\n  () =>\n    sortByModel.value !== undefined ||\n    props.fields.some(\n      (field) => typeof field === 'object' && field !== null && field.sortable === true\n    )\n)\n\nconst computedFields = computed<TableFieldRaw<T>[]>(() =>\n  props.fields.map((el) => {\n    if (!(typeof el === 'object' && el !== null)) return el\n\n    const value = sortByModel.value?.find((sb) => el.key === sb.key)\n    const sortValue =\n      isSortable.value === false\n        ? undefined\n        : value === undefined\n          ? 'none'\n          : value.order === 'desc'\n            ? 'descending'\n            : 'ascending'\n    return {\n      ...el,\n      thAttr: {\n        'aria-sort': sortValue,\n        ...el.thAttr,\n      },\n    }\n  })\n)\n\nconst tableClasses = computed(() => ({\n  'b-table-busy': busyModel.value,\n  'b-table-selectable': props.selectable,\n  'user-select-none': props.selectable && isSelecting.value,\n}))\n// All three of these are similar, even though the two following are not computeds\nconst getBusyRowClasses = computed(() => [\n  props.tbodyTrClass\n    ? typeof props.tbodyTrClass === 'function'\n      ? props.tbodyTrClass(null, 'table-busy')\n      : props.tbodyTrClass\n    : null,\n])\nconst getFieldColumnClasses = (field: TableField) => [\n  {\n    'b-table-sortable-column': isSortable.value && field.sortable,\n  },\n]\n// TODO this class has issues if the table has a variant already applied\n// Also the row should technically have aria-selected . Both things could probably just use a function with tbodyTrAttrs\n// But functional tbodyTrAttrs are not supported yet\n// Also the stuff for resolving functions could probably be made a util\nconst getRowClasses = (item: T, type: string) => [\n  {\n    [`selected table-${props.selectionVariant}`]:\n      props.selectable && item && selectedItemsSetUtilities.has(item),\n  },\n  props.tbodyTrClass\n    ? typeof props.tbodyTrClass === 'function'\n      ? props.tbodyTrClass(item, type)\n      : props.tbodyTrClass\n    : null,\n]\n\nconst computedItems = computed<T[]>(() => {\n  const sortItems = (items: T[]) => {\n    // \"undefined\" values are set by us, we do this so we dont wipe out the comparer\n    const sortByItems = sortByModel.value?.filter((el) => !!el.order)\n\n    if (!sortByItems || sortByItems.length === 0) return items\n\n    // Multi-sort\n    return [...items].sort((a, b) => {\n      for (let i = 0; i < (sortByItems.length ?? 0); i++) {\n        const sortOption = sortByItems[i]\n        const realVal = (ob: T): string => {\n          if (!isTableItem(ob)) return String(ob)\n\n          const sortField = computedFields.value.find((el) => {\n            if (isTableField(el)) return el.key === sortOption.key\n\n            return false\n          })\n          const val = get(ob, sortOption.key as keyof TableItem)\n          if (isTableField(sortField) && !!sortField.sortByFormatted) {\n            const formatter =\n              typeof sortField.sortByFormatted === 'function'\n                ? sortField.sortByFormatted\n                : sortField.formatter\n            if (formatter) {\n              return formatItem(ob, String(sortField.key), formatter) as string\n            }\n          }\n          return typeof val === 'object' && val !== null\n            ? JSON.stringify(val)\n            : val?.toString() ?? ''\n        }\n\n        const aValue = realVal(a)\n        const bValue = realVal(b)\n        const comparison = sortOption.comparer\n          ? sortOption.comparer(aValue, bValue)\n          : aValue.localeCompare(bValue, undefined, {numeric: true})\n\n        if (comparison !== 0) {\n          return sortOption.order === 'asc' ? comparison : -comparison\n        }\n      }\n      return 0 // items are equal\n    })\n  }\n\n  const filterItems = (items: T[]) =>\n    items.filter((item) =>\n      isTableItem(item)\n        ? Object.entries(item).some(([key, val]) => {\n            if (\n              val === null ||\n              val === undefined ||\n              key[0] === '_' ||\n              (!props.filterable?.includes(key) && !!props.filterable?.length)\n            )\n              return false\n            const itemValue: string =\n              typeof val === 'object' ? JSON.stringify(Object.values(val)) : val.toString()\n            return itemValue.toLowerCase().includes(props.filter?.toLowerCase() ?? '')\n          })\n        : true\n    )\n\n  let mappedItems = usesProvider.value ? internalItems.value : (props.items as T[])\n  mappedItems = mappedItems.map((item) => {\n    if (\n      typeof item === 'object' &&\n      item !== null &&\n      Object.keys(item).some((key) => key.includes('.'))\n    ) {\n      // We use any here because the TS doesn't isn't certain that \"item\" is the same type as our newItem.\n      // But we've determined that it's an object, so we can ignore it since they will always be the same \"object\"\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let newItem: any = {}\n      for (const key in item) {\n        if (key.includes('.')) {\n          newItem = set(newItem, key, item[key])\n        } else {\n          newItem[key] = item[key]\n        }\n      }\n      return newItem\n      // return\n    }\n    return item\n  })\n\n  if (\n    (isFilterableTable.value === true && !usesProvider.value) ||\n    (isFilterableTable.value === true && usesProvider.value && props.noProviderFiltering)\n  ) {\n    mappedItems = filterItems(mappedItems)\n  }\n\n  if (\n    (isSortable.value === true && !usesProvider.value && !props.noLocalSorting) ||\n    (isSortable.value === true && usesProvider.value && props.noProviderSorting)\n  ) {\n    mappedItems = sortItems(mappedItems)\n  }\n\n  return mappedItems\n})\n\nconst computedDisplayItems = computed<T[]>(() => {\n  if (Number.isNaN(perPageNumber.value) || (usesProvider.value && !props.noProviderPaging)) {\n    return computedItems.value\n  }\n\n  return computedItems.value.slice(\n    (currentPageNumber.value - 1) * (perPageNumber.value || Number.POSITIVE_INFINITY),\n    currentPageNumber.value * (perPageNumber.value || Number.POSITIVE_INFINITY)\n  )\n})\n\nwatch(computedDisplayItems, (v) => {\n  emit('change', v)\n})\n\nconst handleRowSelection = (\n  row: T,\n  index: number,\n  shiftClicked = false,\n  ctrlClicked = false,\n  metaClicked = false\n) => {\n  if (!props.selectable) return\n\n  if (props.selectMode === 'single' || props.selectMode === 'multi') {\n    // Do nothing when these items are held\n    if (shiftClicked || ctrlClicked) return\n    // Delete if item is in\n    if (selectedItemsSetUtilities.has(row)) {\n      selectedItemsSetUtilities.delete(row)\n    } else {\n      if (props.selectMode === 'single') {\n        selectedItemsSetUtilities.set([row])\n      } else {\n        selectedItemsSetUtilities.add(row)\n      }\n    }\n  } else {\n    if (ctrlClicked || metaClicked) {\n      // Delete if in the object\n      if (selectedItemsSetUtilities.has(row)) {\n        selectedItemsSetUtilities.delete(row)\n        // Otherwise add. Functions similarly to 'multi' at this point\n      } else {\n        selectedItemsSetUtilities.add(row)\n      }\n      // This is where range is different, due to the difference in shift\n    } else if (shiftClicked) {\n      const lastSelectedItem = [...selectedItemsToSet.value].pop()\n      const lastSelectedIndex = props.items.findIndex((i) => i === lastSelectedItem)\n      const selectStartIndex = Math.min(lastSelectedIndex, index)\n      const selectEndIndex = Math.max(lastSelectedIndex, index)\n      const items = props.items.slice(selectStartIndex, selectEndIndex + 1)\n      selectedItemsSetUtilities.set(items)\n      // If nothing is being held, then we just behave like it's single mode\n    } else {\n      selectedItemsSetUtilities.set([row])\n    }\n  }\n  // Notify\n  notifySelectionEvent()\n}\n\nconst onRowClick = (row: T, index: number, e: MouseEvent) => {\n  if (props.noSelectOnClick === false) {\n    handleRowSelection(row, index, e.shiftKey, e.ctrlKey, e.metaKey)\n  }\n  emit('row-clicked', row, index, e)\n}\n\nconst handleFieldSorting = (field: TableField<T>) => {\n  if (!isSortable.value) return\n\n  const fieldKey = typeof field === 'object' && field !== null ? field.key : field\n  const fieldSortable = typeof field === 'object' && field !== null ? field.sortable : false\n\n  // TODO implement rules for noSortReset\n\n  if (!(isSortable.value === true && fieldSortable === true)) return\n\n  const resolveOrder = (val: BTableSortByOrder): BTableSortByOrder | undefined => {\n    if (val === 'asc') return 'desc'\n    if (val === undefined) return 'asc'\n    if (\n      props.mustSort === true ||\n      (Array.isArray(props.mustSort) && props.mustSort.includes(fieldKey as string))\n    )\n      return 'asc'\n    return undefined\n  }\n\n  const index = sortByModel.value?.findIndex((el) => el.key === fieldKey) ?? -1\n  const originalValue = sortByModel.value?.[index]\n  const updatedValue: BTableSortBy =\n    // If value is new, we default to ascending\n    // Otherwise we make a temp copy of the value\n    index === -1 || !originalValue ? {key: fieldKey as string, order: 'asc'} : {...originalValue}\n\n  /**\n   * @returns the updated value to emit for sorted\n   */\n  const handleMultiSort = (): BTableSortBy => {\n    let val = updatedValue\n    if (index === -1) {\n      sortByModel.value = [...(sortByModel.value ?? []), updatedValue]\n    } else {\n      const order = resolveOrder(updatedValue.order)\n      val = {...updatedValue, order}\n      sortByModel.value = order\n        ? sortByModel.value?.map((el) => (el.key === val.key ? val : el))\n        : sortByModel.value?.filter((el) => el.key !== val.key)\n    }\n    return val\n  }\n\n  /**\n   * @returns the updated value to emit for sorted\n   */\n  const handleSingleSort = (): BTableSortBy => {\n    const val = {\n      ...updatedValue,\n      order: index === -1 ? updatedValue.order : resolveOrder(updatedValue.order),\n    }\n    sortByModel.value = [val]\n    return val\n  }\n\n  // Then emit the returned updated value\n  emit('sorted', props.multisort === true ? handleMultiSort() : handleSingleSort())\n}\n\nconst onFieldHeadClick = (\n  fieldKey: string,\n  field: TableField<T>,\n  event: Readonly<MouseEvent>,\n  isFooter = false\n) => {\n  emit('head-clicked', fieldKey, field, event, isFooter)\n  handleFieldSorting(field)\n}\n\nconst callItemsProvider = async () => {\n  if (!usesProvider.value || props.provider === undefined || busyModel.value) return\n  busyModel.value = true\n  const response = props.provider({\n    currentPage: currentPageNumber.value,\n    filter: props.filter,\n    sortBy: sortByModel.value,\n    perPage: perPageNumber.value,\n  })\n  try {\n    const items = response instanceof Promise ? await response : response\n\n    if (items === undefined) return\n    internalItems.value = items\n  } finally {\n    // Potential race condition could occur if the user explicitly sets the busy value to a different value while the response promise is executing\n    // which would have been the users choice.\n    // eslint-disable-next-line require-atomic-updates\n    busyModel.value = false\n  }\n}\n\nconst notifySelectionEvent = () => {\n  if (!props.selectable) return\n  emit('selection', [...selectedItemsToSet.value])\n}\n\nconst providerPropsWatch = async (prop: string, val: unknown, oldVal: unknown) => {\n  if (val === oldVal) return\n\n  //stop provide when paging\n  const inNoProvider = (key: NoProviderTypes) => props.noProvider?.includes(key) === true\n  const noProvideWhenPaging =\n    (prop === 'currentPage' || prop === 'perPage') &&\n    (inNoProvider('paging') || props.noProviderPaging === true)\n  const noProvideWhenFiltering =\n    prop === 'filter' && (inNoProvider('filtering') || props.noProviderFiltering === true)\n  const noProvideWhenSorting =\n    (prop === 'sortBy' || prop === 'sortDesc') &&\n    (inNoProvider('sorting') || props.noProviderSorting === true)\n\n  if (noProvideWhenPaging || noProvideWhenFiltering || noProvideWhenSorting) return\n\n  if (usesProvider.value === true) {\n    await callItemsProvider()\n  }\n\n  if (!(prop === 'currentPage' || prop === 'perPage')) {\n    emit('filtered', [...computedItems.value])\n  }\n}\n\nwatch(\n  () => props.filter,\n  (filter, oldFilter) => {\n    providerPropsWatch('filter', filter, oldFilter)\n\n    if (filter === oldFilter || usesProvider.value) return\n    if (!filter) {\n      emit('filtered', [...computedItems.value])\n    }\n  }\n)\nwatch(currentPageNumber, (val, oldVal) => {\n  providerPropsWatch('currentPage', val, oldVal)\n})\nwatch(perPageNumber, (val, oldVal) => {\n  providerPropsWatch('perPage', val, oldVal)\n})\nwatch(\n  sortByModel,\n  (val, oldVal) => {\n    providerPropsWatch('sortBy', val, oldVal)\n  },\n  {deep: true}\n)\n\nwatch(\n  () => props.provider,\n  (newValue) => {\n    // Reset the internal values if the provider stops getting used\n    if (newValue === undefined) {\n      internalItems.value = []\n      return\n    }\n    // Otherwise we should refresh the table on such a change\n    callItemsProvider()\n  }\n)\n\nonMounted(callItemsProvider)\n\ndefineExpose({\n  // The row selection methods are really for compat. Users should probably use the v-model though\n  clearSelected: () => {\n    if (!props.selectable) return\n    selectedItemsSetUtilities.clear()\n    notifySelectionEvent()\n  },\n  refresh: callItemsProvider,\n  selectAllRows: () => {\n    if (!props.selectable) return\n    const unselectableItems = selectedItemsToSet.value.size > 0 ? [...selectedItemsToSet.value] : []\n    selectedItemsToSet.value = new Set([...computedItems.value])\n    selectedItemsToSet.value.forEach((item) => {\n      if (unselectableItems.includes(item)) return\n      emit('row-selected', item)\n    })\n    notifySelectionEvent()\n  },\n  selectRow: (index: number) => {\n    if (!props.selectable) return\n    const item = computedItems.value[index]\n    if (!item || selectedItemsSetUtilities.has(item)) return\n    selectedItemsSetUtilities.add(item)\n    notifySelectionEvent()\n  },\n  unselectRow: (index: number) => {\n    if (!props.selectable) return\n    const item = computedItems.value[index]\n    if (!item || !selectedItemsSetUtilities.has(item)) return\n    selectedItemsSetUtilities.delete(item)\n    notifySelectionEvent()\n  },\n})\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"computedId\"\n    ref=\"el\"\n    class=\"tab-pane\"\n    :class=\"computedClasses\"\n    role=\"tabpanel\"\n    :aria-labelledby=\"buttonId\"\n    v-bind=\"attrs\"\n  >\n    <slot v-if=\"showSlot\" />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, inject, onMounted, onUnmounted, ref, toRef, useAttrs, watch} from 'vue'\nimport {useId} from '../../composables'\nimport type {BTabProps, TabType} from '../../types'\nimport {tabsInjectionKey} from '../../utils'\n\nconst props = withDefaults(defineProps<BTabProps>(), {\n  buttonId: undefined,\n  disabled: false,\n  id: undefined,\n  lazy: undefined,\n  lazyOnce: undefined,\n  noBody: false,\n  tag: 'div',\n  title: undefined,\n  titleItemClass: undefined,\n  titleLinkAttrs: undefined,\n  titleLinkClass: undefined,\n})\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  title?: (props: Record<string, never>) => any\n}>()\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst activeModel = defineModel<boolean>('active', {\n  default: false,\n})\n\nconst parentData = inject(tabsInjectionKey, null)\nconst computedId = useId(() => props.id, 'tabpane')\nconst buttonId = useId(() => props.buttonId, 'tab')\n\nconst lazyRenderCompleted = ref(false)\nconst el = ref<HTMLElement | null>(null)\n\nconst {onClick, ...attrs} = useAttrs()\n\nconst tab = computed(\n  () =>\n    ({\n      id: computedId.value,\n      buttonId: buttonId.value,\n      disabled: props.disabled,\n      title: props.title,\n      titleComponent: slots.title,\n      titleItemClass: props.titleItemClass,\n      titleLinkAttrs: props.titleLinkAttrs,\n      titleLinkClass: props.titleLinkClass,\n      onClick,\n      el: el.value,\n    }) as TabType\n)\n\nonMounted(() => {\n  if (!parentData) return\n  parentData.registerTab(tab)\n  if (props.active) {\n    parentData.activateTab(computedId.value)\n  }\n})\n\nonUnmounted(() => {\n  if (!parentData) return\n  parentData.unregisterTab(computedId.value)\n})\n\nconst isActive = toRef(() => parentData?.activeId.value === computedId.value)\nconst show = ref(isActive.value)\n\nconst computedLazy = toRef(() => !!(parentData?.lazy.value || (props.lazyOnce ?? props.lazy)))\nconst computedLazyOnce = toRef(() => props.lazyOnce !== undefined)\n\nconst computedActive = toRef(() => isActive.value && !props.disabled)\nconst showSlot = toRef(\n  () =>\n    computedActive.value ||\n    !computedLazy.value ||\n    (computedLazy.value && computedLazyOnce.value && lazyRenderCompleted.value)\n)\n\nwatch(isActive, (active) => {\n  if (active) {\n    activeModel.value = true\n    setTimeout(() => {\n      show.value = true\n    }, 0)\n    return\n  }\n  show.value = false\n  activeModel.value = false\n})\nwatch(\n  () => props.active,\n  (active) => {\n    if (!parentData) return\n    if (!active) {\n      if (isActive.value) {\n        parentData.activateTab(undefined)\n      }\n      return\n    }\n    parentData.activateTab(computedId.value)\n  }\n)\n\nconst computedClasses = computed(() => [\n  {\n    'active': isActive.value,\n    'show': show.value,\n    'card-body': parentData?.card.value && props.noBody === false,\n    'fade': !parentData?.noFade.value,\n  },\n  show.value ? parentData?.activeTabClass : parentData?.inactiveTabClass,\n  parentData?.tabClass,\n])\n\nwatch(showSlot, (shown) => {\n  if (shown && !lazyRenderCompleted.value) lazyRenderCompleted.value = true\n})\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" class=\"tabs\" :class=\"computedClasses\">\n    <ReusableEmptyTab.define>\n      <div class=\"tab-content\" :class=\"contentClass\">\n        <slot />\n        <div\n          v-if=\"showEmpty\"\n          key=\"bv-empty-tab\"\n          class=\"tab-pane active\"\n          :class=\"{'card-body': props.card}\"\n        >\n          <slot name=\"empty\" />\n        </div>\n      </div>\n    </ReusableEmptyTab.define>\n\n    <ReusableEmptyTab.reuse v-if=\"props.end\" />\n    <div :class=\"[navWrapperClass, {'card-header': props.card, 'ms-auto': vertical && props.end}]\">\n      <ul\n        class=\"nav\"\n        :class=\"[navTabsClasses, navClass]\"\n        role=\"tablist\"\n        :aria-orientation=\"vertical ? 'vertical' : 'horizontal'\"\n      >\n        <slot name=\"tabs-start\" />\n        <li\n          v-for=\"(tab, idx) in tabs\"\n          :key=\"tab.id\"\n          class=\"nav-item\"\n          :class=\"tab.titleItemClass\"\n          role=\"presentation\"\n        >\n          <button\n            :id=\"tab.buttonId\"\n            class=\"nav-link\"\n            :class=\"tab.navItemClasses\"\n            role=\"tab\"\n            :aria-controls=\"tab.id\"\n            :aria-selected=\"tab.active\"\n            v-bind=\"tab.titleLinkAttrs\"\n            @keydown.left.stop.prevent=\"keynav(-1)\"\n            @keydown.right.stop.prevent=\"keynav(1)\"\n            @keydown.page-up.stop.prevent=\"keynav(-999)\"\n            @keydown.page-down.stop.prevent=\"keynav(999)\"\n            @click.stop.prevent=\"(e) => handleClick(e, idx)\"\n          >\n            <component :is=\"tab.titleComponent\" v-if=\"tab.titleComponent\" />\n            <template v-else>\n              {{ tab.title }}\n            </template>\n          </button>\n        </li>\n        <slot name=\"tabs-end\" />\n      </ul>\n    </div>\n    <ReusableEmptyTab.reuse v-if=\"!props.end\" />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, nextTick, provide, type Ref, ref, toRef, unref, watch} from 'vue'\nimport {BvEvent, tabsInjectionKey} from '../../utils'\nimport {useAlignment} from '../../composables'\nimport type {BTabsProps, TabType} from '../../types'\nimport {createReusableTemplate} from '@vueuse/core'\n// TODO this component needs a desperate refactoring to use provide/inject and not the complicated slot manipulation logic it's doing now\n\nconst props = withDefaults(defineProps<BTabsProps>(), {\n  activeNavItemClass: undefined,\n  activeTabClass: undefined,\n  align: undefined,\n  card: false,\n  contentClass: undefined,\n  end: false,\n  fill: false,\n  id: undefined,\n  inactiveNavItemClass: undefined,\n  inactiveTabClass: undefined,\n  justified: false,\n  lazy: false,\n  navClass: undefined,\n  navItemClass: undefined,\n  navWrapperClass: undefined,\n  noFade: false,\n  // noKeyNav: false,\n  noNavStyle: false,\n  pills: false,\n  small: false,\n  tag: 'div',\n  tabClass: undefined,\n  vertical: false,\n})\n\nconst emit = defineEmits<{\n  'activate-tab': [v1: number, v2: number, v3: BvEvent]\n  'click': [] // TODO click event is never used\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'empty'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'tabs-end'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'tabs-start'?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = defineModel<number>({\n  default: -1,\n})\nconst activeId = defineModel<string | undefined>('activeId', {\n  default: undefined,\n})\n\nconst ReusableEmptyTab = createReusableTemplate()\n\nconst tabsInternal = ref<Ref<TabType>[]>([])\n\nconst tabs = computed(() =>\n  tabsInternal.value.map((_tab) => {\n    const tab = unref(_tab)\n    const active = tab.id === activeId.value\n\n    return {\n      ...tab,\n      active,\n      navItemClasses: [\n        {\n          active,\n          disabled: tab.disabled,\n        },\n        active ? props.activeNavItemClass : props.inactiveNavItemClass,\n        props.navItemClass,\n        tab.titleLinkClass,\n      ],\n    }\n  })\n)\n\nconst showEmpty = toRef(() => !(tabs?.value && tabs.value.length > 0))\n\nconst computedClasses = computed(() => ({\n  'd-flex': props.vertical,\n  'align-items-start': props.vertical,\n}))\n\nconst alignment = useAlignment(() => props.align)\n\nconst navTabsClasses = computed(() => ({\n  'nav-pills': props.pills,\n  'flex-column me-3': props.vertical,\n  [alignment.value]: props.align !== undefined,\n  'nav-fill': props.fill,\n  'card-header-tabs': props.card,\n  'nav-justified': props.justified,\n  'nav-tabs': !props.noNavStyle && !props.pills,\n  'small': props.small,\n}))\n\nconst activateTab = (index: number): void => {\n  if (index !== undefined) {\n    const id = tabs.value[index]?.id\n    if (\n      index > -1 &&\n      index < tabs.value.length &&\n      !tabs.value[index].disabled &&\n      (modelValue.value < 0 || activeId.value !== id || modelValue.value !== index)\n    ) {\n      const tabEvent = new BvEvent('activate-tab', {cancelable: true})\n      emit('activate-tab', index, modelValue.value, tabEvent)\n      if (!tabEvent.defaultPrevented) {\n        if (activeId.value !== id) activeId.value = id\n        if (modelValue.value !== index) modelValue.value = index\n      }\n    }\n  }\n}\n\nconst handleClick = (event: Readonly<MouseEvent>, index: number) => {\n  activateTab(index)\n  if (\n    index >= 0 &&\n    !tabs.value[index].disabled &&\n    tabs.value[index]?.onClick &&\n    typeof tabs.value[index].onClick === 'function'\n  ) {\n    tabs.value[index].onClick?.(event)\n  }\n}\n\nconst keynav = (direction: number) => {\n  if (tabs.value.length <= 0) return\n  modelValue.value = nextIndex(modelValue.value + direction, direction)\n  document.getElementById(tabs.value[modelValue.value]?.buttonId)?.focus()\n}\n\nconst nextIndex = (start: number, direction: number) => {\n  let index = start\n  let minIdx = -1\n  let maxIdx = -1\n\n  for (let i = 0; i < tabs.value.length; i++) {\n    if (!tabs.value[i].disabled) {\n      if (minIdx === -1) minIdx = i\n      maxIdx = i\n    }\n  }\n\n  while (index >= minIdx && index <= maxIdx && tabs.value[index].disabled) {\n    index += direction\n  }\n\n  if (index < minIdx) index = minIdx\n  if (index > maxIdx) index = maxIdx\n\n  return index\n}\n\nwatch(modelValue, (newValue, oldValue) => {\n  if (newValue === oldValue) return\n  if (tabs.value.length <= 0) {\n    return\n  }\n\n  const index = nextIndex(newValue, newValue > oldValue ? 1 : -1)\n  nextTick(() => {\n    activateTab(index)\n  })\n})\n\nwatch(activeId, (newValue, oldValue) => {\n  const index = tabs.value.findIndex((t) => t.id === newValue)\n  if (newValue === oldValue) return\n  if (tabs.value.length <= 0) {\n    return\n  }\n  if (index === -1) {\n    activateTab(nextIndex(0, 1))\n    return\n  }\n  activateTab(index)\n})\n\nconst registerTab = (tab: Ref<TabType>) => {\n  if (!tabsInternal.value.find((t) => t.value.id === tab.value.id)) {\n    tabsInternal.value.push(tab)\n  } else {\n    tabsInternal.value[tabsInternal.value.findIndex((t) => t.value.id === tab.value.id)] = tab\n  }\n  tabsInternal.value.sort((a, b) => {\n    if (!Node || !a.value.el || !b.value.el) return 0\n    const position = a.value.el.compareDocumentPosition(b.value.el)\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING) return -1\n    if (position & Node.DOCUMENT_POSITION_PRECEDING) return 1\n    return 0\n  })\n}\nconst unregisterTab = (id: string) => {\n  tabsInternal.value = tabsInternal.value.filter((t) => t.value.id !== id)\n}\n\nwatch(\n  tabsInternal,\n  () => {\n    findActive()\n  },\n  {deep: true}\n)\n\nconst findActive = () => {\n  if (tabs.value.length === 0) {\n    modelValue.value = -1\n    activeId.value = undefined\n    return\n  }\n  if (modelValue.value >= 0 && !activeId.value) {\n    activeId.value = tabs.value[modelValue.value]?.id\n  }\n  if (tabs.value.find((t) => t.id === activeId.value)) {\n    activateTab(tabs.value.findIndex((t) => t.id === activeId.value))\n    return\n  }\n  activateTab(tabs.value.map((tab) => !tab.disabled).indexOf(true))\n}\n\nprovide(tabsInjectionKey, {\n  lazy: toRef(() => props.lazy),\n  card: toRef(() => props.card),\n  noFade: toRef(() => props.noFade),\n  activeTabClass: toRef(() => props.activeTabClass),\n  inactiveTabClass: toRef(() => props.inactiveTabClass),\n  tabClass: toRef(() => props.tabClass),\n  registerTab,\n  unregisterTab,\n  activeId,\n  activateTab: (id) => {\n    const idx = tabs.value.findIndex((t) => t.id === id)\n    if (id === undefined || idx === -1) {\n      activateTab(nextIndex(0, 1))\n      return\n    }\n    activateTab(idx)\n  },\n})\n</script>\n","<template>\n  <Teleport :to=\"teleportTo\" :disabled=\"props.teleportDisabled\">\n    <!-- This wrapper div is used for specific targetting by the user -->\n    <!-- Even though it serves no direct purpose itself -->\n    <div id=\"__BVID__toaster-container\">\n      <div\n        v-for=\"(value, key) in toastPositions\"\n        :key=\"key\"\n        :class=\"value\"\n        class=\"toast-container position-fixed p-3\"\n      >\n        <TransitionGroup name=\"b-list\">\n          <component\n            :is=\"toast.value.component\"\n            v-for=\"toast in toasts?.filter((el) => el.value.props.pos === key)\"\n            :key=\"toast.value.props._self\"\n            v-bind=\"pluckToastItem(toast.value.props)\"\n            v-model=\"toast.value.props._modelValue\"\n            :trans-props=\"{...toast.value.props.transProps, appear: true}\"\n            @hide.prevent=\"remove?.(toast.value.props._self)\"\n          />\n        </TransitionGroup>\n      </div>\n    </div>\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport {watch} from 'vue'\nimport {useToast} from '../../composables'\nimport {omit} from '../../utils'\nimport type {BToastOrchestratorProps} from '../../types'\n\nconst props = withDefaults(defineProps<BToastOrchestratorProps>(), {\n  teleportDisabled: false,\n  teleportTo: 'body',\n  appendToast: false,\n})\n\nconst toastPositions = {\n  'top-left': 'top-0 start-0',\n  'top-center': 'top-0 start-50 translate-middle-x',\n  'top-right': 'top-0 end-0',\n  'middle-left': 'top-50 start-0 translate-middle-y',\n  'middle-center': 'top-50 start-50 translate-middle',\n  'middle-right': 'top-50 end-0 translate-middle-y',\n  'bottom-left': 'bottom-0 start-0',\n  'bottom-center': 'bottom-0 start-50 translate-middle-x',\n  'bottom-right': 'bottom-0 end-0',\n} as const\n\nconst {remove, toasts, show, _setIsAppend} = useToast()\n\nwatch(\n  () => props.appendToast,\n  (value) => {\n    _setIsAppend?.(value)\n  },\n  {immediate: true}\n)\n\nconst pluckToastItem = (\n  payload: Readonly<Exclude<typeof toasts, undefined>['value'][number]['value']['props']>\n) => omit(payload, ['_modelValue', '_self', 'pos'])\n\ndefineExpose({\n  remove,\n  show,\n  toasts,\n})\n</script>\n\n<style lang=\"scss\">\n/*\nIf you remove the last element in the list, the animation goes farther to the right then normal.\nI don't know why\nI kind of like it though, and even if I didn't, I don't know how to get rid of it.\nGetting the transitions to work here was basically all trial and error.\nI think it's because it's \"moving\", but I don't know where it's moving to\n*/\n.b-list-move,\n.b-list-enter-active,\n.b-list-leave-active {\n  transition: all 0.5s cubic-bezier(0.55, 0, 0.1, 1);\n}\n.b-list-enter-from,\n.b-list-leave-to {\n  opacity: 0; // TODO this should be the responsibility of the child\n}\n.b-list-leave-active {\n  position: fixed;\n}\n</style>\n","<template>\n  <BPopover ref=\"popover\" v-bind=\"computedProps\" v-model=\"modelValue\" tooltip>\n    <template v-for=\"(_, name) in $slots\" #[name]=\"slotData\">\n      <slot :name=\"name\" v-bind=\"slotData\" />\n    </template>\n  </BPopover>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, ref} from 'vue'\nimport BPopover from './BPopover.vue'\nimport type {BPopoverProps, BTooltipProps} from '../types'\n\nconst props = withDefaults(defineProps<BTooltipProps>(), {\n  click: undefined,\n  teleportDisabled: undefined,\n  teleportTo: undefined,\n  content: undefined,\n  customClass: undefined,\n  delay: undefined,\n  floatingMiddleware: undefined,\n  hide: undefined,\n  html: undefined,\n  id: undefined,\n  inline: undefined,\n  interactive: undefined,\n  manual: undefined,\n  noAutoClose: undefined,\n  noFade: undefined,\n  noFlip: undefined,\n  noHide: undefined,\n  noShift: undefined,\n  noninteractive: undefined,\n  offset: undefined,\n  placement: undefined,\n  realtime: undefined,\n  reference: undefined,\n  strategy: undefined,\n  target: undefined,\n  title: undefined,\n  variant: undefined,\n})\n\nconst modelValue = defineModel<boolean | undefined>({default: undefined})\n\nconst computedProps = computed<BPopoverProps>(() => {\n  const {interactive, noninteractive, ...rest} = props\n  return {noninteractive: noninteractive !== undefined ? noninteractive : !interactive, ...rest}\n})\n\nconst popover = ref<null | InstanceType<typeof BPopover>>(null)\n\ndefineExpose({\n  hide: popover.value?.hide,\n  show: popover.value?.show,\n  toggle: popover.value?.toggle,\n})\n</script>\n","import type {Plugin} from 'vue'\nimport type {BootstrapVueOptions, ComponentType, DirectiveType} from './types'\nimport toastPlugin from './plugins/toastPlugin'\nimport breadcrumbPlugin from './plugins/breadcrumbPlugin'\nimport idPlugin from './plugins/idPlugin'\nimport modalControllerPlugin from './plugins/modalControllerPlugin'\nimport modalManagerPlugin from './plugins/modalManagerPlugin'\nimport rtlPlugin from './plugins/rtlPlugin'\n\nimport './styles/styles.scss'\n\nimport * as Components from './components'\nimport * as Directives from './directives'\nimport parseActiveImports from './utils/parseActiveImports'\n\ndeclare module '@vue/runtime-core' {\n  export interface GlobalComponents {\n    BFormFile: typeof Components.BFormFile\n    BAccordion: typeof Components.BAccordion\n    BAccordionItem: typeof Components.BAccordionItem\n    BAlert: typeof Components.BAlert\n    BAvatar: typeof Components.BAvatar\n    BAvatarGroup: typeof Components.BAvatarGroup\n    BBadge: typeof Components.BBadge\n    BBreadcrumb: typeof Components.BBreadcrumb\n    BBreadcrumbItem: typeof Components.BBreadcrumbItem\n    BButton: typeof Components.BButton\n    BButtonGroup: typeof Components.BButtonGroup\n    BButtonToolbar: typeof Components.BButtonToolbar\n    BCard: typeof Components.BCard\n    BCardBody: typeof Components.BCardBody\n    BCardFooter: typeof Components.BCardFooter\n    BCardGroup: typeof Components.BCardGroup\n    BCardHeader: typeof Components.BCardHeader\n    BCardImg: typeof Components.BCardImg\n    BCardSubtitle: typeof Components.BCardSubtitle\n    BCardText: typeof Components.BCardText\n    BCardTitle: typeof Components.BCardTitle\n    BCarousel: typeof Components.BCarousel\n    BCarouselSlide: typeof Components.BCarouselSlide\n    BCloseButton: typeof Components.BCloseButton\n    BCol: typeof Components.BCol\n    BCollapse: typeof Components.BCollapse\n    BContainer: typeof Components.BContainer\n    BDropdown: typeof Components.BDropdown\n    BDropdownDivider: typeof Components.BDropdownDivider\n    BDropdownForm: typeof Components.BDropdownForm\n    BDropdownGroup: typeof Components.BDropdownGroup\n    BDropdownHeader: typeof Components.BDropdownHeader\n    BDropdownItem: typeof Components.BDropdownItem\n    BDropdownItemButton: typeof Components.BDropdownItemButton\n    BDropdownText: typeof Components.BDropdownText\n    BForm: typeof Components.BForm\n    BFormCheckbox: typeof Components.BFormCheckbox\n    BFormCheckboxGroup: typeof Components.BFormCheckboxGroup\n    BFormFloatingLabel: typeof Components.BFormFloatingLabel\n    BFormGroup: typeof Components.BFormGroup\n    BFormInput: typeof Components.BFormInput\n    BFormInvalidFeedback: typeof Components.BFormInvalidFeedback\n    BFormRadio: typeof Components.BFormRadio\n    BFormRadioGroup: typeof Components.BFormRadioGroup\n    BFormRow: typeof Components.BFormRow\n    BFormSelect: typeof Components.BFormSelect\n    BFormSelectOption: typeof Components.BFormSelectOption\n    BFormSelectOptionGroup: typeof Components.BFormSelectOptionGroup\n    BFormText: typeof Components.BFormText\n    BFormTextarea: typeof Components.BFormTextarea\n    BFormTag: typeof Components.BFormTag\n    BFormTags: typeof Components.BFormTags\n    BFormSpinbutton: typeof Components.BFormSpinbutton\n    BFormValidFeedback: typeof Components.BFormValidFeedback\n    BImg: typeof Components.BImg\n    BInputGroup: typeof Components.BInputGroup\n    BInputGroupAddon: typeof Components.BInputGroupAddon\n    BInputGroupAppend: typeof Components.BInputGroupAppend\n    BInputGroupPrepend: typeof Components.BInputGroupPrepend\n    BInputGroupText: typeof Components.BInputGroupText\n    BLink: typeof Components.BLink\n    BListGroup: typeof Components.BListGroup\n    BListGroupItem: typeof Components.BListGroupItem\n    BModal: typeof Components.BModal\n    BModalOrchestrator: typeof Components.BModalOrchestrator\n    BNav: typeof Components.BNav\n    BNavForm: typeof Components.BNavForm\n    BNavText: typeof Components.BNavText\n    BNavbar: typeof Components.BNavbar\n    BNavbarBrand: typeof Components.BNavbarBrand\n    BNavbarNav: typeof Components.BNavbarNav\n    BNavbarToggle: typeof Components.BNavbarToggle\n    BNavItem: typeof Components.BNavItem\n    BNavItemDropdown: typeof Components.BNavItemDropdown\n    BOffcanvas: typeof Components.BOffcanvas\n    BOverlay: typeof Components.BOverlay\n    BPagination: typeof Components.BPagination\n    BPlaceholder: typeof Components.BPlaceholder\n    BPlaceholderButton: typeof Components.BPlaceholderButton\n    BPlaceholderCard: typeof Components.BPlaceholderCard\n    BPlaceholderTable: typeof Components.BPlaceholderTable\n    BPlaceholderWrapper: typeof Components.BPlaceholderWrapper\n    BPopover: typeof Components.BPopover\n    BProgress: typeof Components.BProgress\n    BProgressBar: typeof Components.BProgressBar\n    BRow: typeof Components.BRow\n    BSpinner: typeof Components.BSpinner\n    BTab: typeof Components.BTab\n    BTable: typeof Components.BTable\n    BTableSimple: typeof Components.BTableSimple\n    BTbody: typeof Components.BTbody\n    BTd: typeof Components.BTd\n    BTfoot: typeof Components.BTfoot\n    BTh: typeof Components.BTh\n    BThead: typeof Components.BThead\n    BTr: typeof Components.BTr\n    BToast: typeof Components.BToast\n    BToastOrchestrator: typeof Components.BToastOrchestrator\n    BTooltip: typeof Components.BTooltip\n    BTabs: typeof Components.BTabs\n    BTransition: typeof Components.BTransition\n  }\n}\n\n// Main app plugin\nexport const createBootstrap = ({\n  components = false,\n  directives = false,\n  plugins = {},\n}: BootstrapVueOptions = {}): Plugin => ({\n  install(app) {\n    const selectedComponents = typeof components === 'boolean' ? {all: components} : components\n\n    const componentKeys = Object.keys(Components) as unknown as ComponentType[]\n    parseActiveImports(selectedComponents, componentKeys).forEach((name) => {\n      const component = Components[name]\n      app.component(name, component)\n    })\n\n    const selectedDirectives = typeof directives === 'boolean' ? {all: directives} : directives\n\n    const directiveKeys = Object.keys(Directives) as unknown as DirectiveType[]\n    const sliceName = (str: string) => (str.toLowerCase().startsWith('v') ? str.slice(1) : str)\n    parseActiveImports(selectedDirectives, directiveKeys).forEach((name) => {\n      const parsedName = sliceName(name)\n      const directive = Directives[name]\n      app.directive(parsedName, directive)\n    })\n\n    if (plugins?.breadcrumb ?? true === true) {\n      app.use(breadcrumbPlugin)\n    }\n    if ((plugins?.id ?? true === true) || typeof plugins.id === 'object') {\n      app.use(idPlugin, plugins)\n    }\n    if (plugins?.modalController ?? true === true) {\n      app.use(modalControllerPlugin)\n    }\n    if (plugins?.modalManager ?? true === true) {\n      app.use(modalManagerPlugin)\n    }\n    if ((plugins?.rtl ?? true === true) || typeof plugins.rtl === 'object') {\n      app.use(rtlPlugin, plugins)\n    }\n    if (plugins?.toast ?? true === true) {\n      app.use(toastPlugin)\n    }\n  },\n})\n\nexport * from './components'\nexport * as Components from './components'\nexport * from './directives'\nexport * as Directives from './directives'\nexport * from './composables/exports'\nexport * as Composables from './composables/exports'\nexport * from './utils/exports'\nexport * as Utils from './utils/exports'\nexport * from './types/exports'\nexport * as Types from './types/exports'\n\nexport default createBootstrap\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}