var $n = Object.defineProperty;
var Tn = (t, e, l) => e in t ? $n(t, e, { enumerable: !0, configurable: !0, writable: !0, value: l }) : t[e] = l;
var ze = (t, e, l) => (Tn(t, typeof e != "symbol" ? e + "" : e, l), l);
import { computed as w, toValue as Se, unref as O, ref as x, shallowRef as bt, watch as ue, getCurrentScope as Ml, onScopeDispose as xl, shallowReadonly as kt, isRef as Sn, toRef as k, readonly as We, customRef as _n, onMounted as Xe, nextTick as Ve, getCurrentInstance as gt, reactive as nl, defineComponent as H, watchEffect as Rt, mergeModels as pe, useModel as he, onBeforeUnmount as Fa, openBlock as b, createElementBlock as _, Fragment as de, createElementVNode as J, renderSlot as T, createBlock as I, Teleport as ht, mergeProps as K, normalizeClass as D, normalizeStyle as Ee, createTextVNode as ne, toDisplayString as Y, createCommentVNode as ae, render as Dl, h as Ne, inject as _e, onActivated as Vn, Transition as An, withCtx as E, useAttrs as Mt, resolveDynamicComponent as re, provide as at, createVNode as ve, useSlots as Le, normalizeProps as ge, guardReactiveProps as we, withDirectives as ut, vShow as xt, renderList as Ce, TransitionGroup as jl, withModifiers as ft, vModelCheckbox as On, vModelRadio as Nn, vModelSelect as In, createSlots as La, onUnmounted as Pn, withKeys as Wt } from "vue";
const Dt = (t) => w(() => {
  const e = Se(t);
  return e ? `justify-content-${e}` : "";
}), ua = (t, e) => w(() => {
  const l = Se(t), a = Se(e);
  return l === !0 ? "true" : typeof l == "string" ? l : a === !1 ? "true" : l === !1 ? "false" : void 0;
});
class nt {
  constructor(e, l = {}) {
    ze(this, "cancelable", !0);
    ze(this, "componentId", null);
    ze(this, "_defaultPrevented", !1);
    ze(this, "eventType", "");
    ze(this, "nativeEvent", null);
    ze(this, "_preventDefault");
    ze(this, "relatedTarget", null);
    ze(this, "target", null);
    if (!e)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, nt.Defaults, l, { eventType: e }), this._preventDefault = function() {
      this.cancelable && (this.defaultPrevented = !0);
    };
  }
  // Readable by everyone,
  // But only overwritten by inherrited constructors
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  set defaultPrevented(e) {
    this._defaultPrevented = e;
  }
  // I think this is right
  // We want to be able to have it callable to everyone,
  // But only overwritten by inherrited constructors
  get preventDefault() {
    return this._preventDefault;
  }
  // This may not be correct, because it doesn't get correct type inferences in children
  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue
  set preventDefault(e) {
    this._preventDefault = e;
  }
  static get Defaults() {
    return {
      cancelable: !0,
      componentId: null,
      eventType: "",
      nativeEvent: null,
      relatedTarget: null,
      target: null
    };
  }
}
class Bt extends nt {
  constructor(l, a = {}) {
    super(l, a);
    ze(this, "trigger", null);
    Object.assign(this, nt.Defaults, a, { eventType: l });
  }
  static get Defaults() {
    return {
      ...super.Defaults,
      trigger: null
    };
  }
}
class ql extends nt {
  constructor(l, a) {
    super(l, a);
    ze(this, "from");
    ze(this, "to");
    ze(this, "direction");
    Object.assign(this, nt.Defaults, a, { eventType: l });
    const { from: o, direction: r, to: s } = a;
    this.from = o, this.to = s, this.direction = r;
  }
  static get Defaults() {
    return {
      ...super.Defaults
    };
  }
}
const En = (t, e = {}) => {
  const l = (o = []) => {
    const { activeElement: r } = document;
    return r && !o.some((s) => s === r) ? r : null;
  }, a = (o) => o === l();
  try {
    t.focus(e);
  } catch (o) {
    console.error(o);
  }
  return a(t);
}, Ae = (t) => ((t == null ? void 0 : t()) ?? []).length === 0, Fn = (t) => {
  if (t.getAttribute("display") === "none")
    return !1;
  const e = t.getBoundingClientRect();
  return !!(e && e.height > 0 && e.width > 0);
}, wa = (t) => {
  const e = window.getComputedStyle(t), l = e.transitionDelay.split(",")[0] || "", a = e.transitionDuration.split(",")[0] || "", o = Number(l.slice(0, -1)) * 1e3, r = Number(a.slice(0, -1)) * 1e3;
  return o + r;
}, za = typeof window < "u" && typeof document < "u" && typeof navigator < "u", Ln = (t) => (() => {
  let l = !1;
  if (za)
    try {
      const a = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          l = !0;
        }
      };
      WINDOW.addEventListener("test", a, a), WINDOW.removeEventListener("test", a, a);
    } catch {
      l = !1;
    }
  return l;
})() ? typeof t == "object" ? t : { capture: !!t || !1 } : typeof t == "object" ? t.capture : t, zn = (t, e, l, a) => {
  t && t.addEventListener && t.addEventListener(e, l, Ln(a));
}, Hn = (t, e, l, a) => {
  t && t.removeEventListener && t.removeEventListener(e, l, a);
}, sl = (t, e) => {
  (t ? zn : Hn)(...e);
}, Rn = ["TD", "TH", "TR"], Mn = [
  "a",
  "a *",
  // Include content inside links
  "button",
  "button *",
  // Include content inside buttons
  "input:not(.disabled):not([disabled])",
  "select:not(.disabled):not([disabled])",
  "textarea:not(.disabled):not([disabled])",
  '[role="link"]',
  '[role="link"] *',
  '[role="button"]',
  '[role="button"] *',
  "[tabindex]:not(.disabled):not([disabled])"
].join(","), Gt = (t) => {
  if (!t || !t.target)
    return !1;
  const e = t.target;
  if ("disabled" in e && e.disabled || Rn.indexOf(e.tagName) !== -1)
    return !1;
  if (e.closest(".dropdown-menu"))
    return !0;
  const l = e.tagName === "LABEL" ? e : e.closest("label");
  if (l) {
    const a = l.getAttribute("for"), o = a ? document.getElementById(a) : l.querySelector("input, select, textarea");
    if (o && !o.disabled)
      return !0;
  }
  return e.matches(Mn);
}, Wl = ["top", "right", "bottom", "left"], rl = ["start", "end"], il = /* @__PURE__ */ Wl.reduce((t, e) => t.concat(e, e + "-" + rl[0], e + "-" + rl[1]), []), tt = Math.min, Ie = Math.max, ea = Math.round, Ut = Math.floor, pt = (t) => ({
  x: t,
  y: t
}), xn = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Dn = {
  start: "end",
  end: "start"
};
function Ca(t, e, l) {
  return Ie(t, tt(e, l));
}
function dt(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Ue(t) {
  return t.split("-")[0];
}
function Qe(t) {
  return t.split("-")[1];
}
function Gl(t) {
  return t === "x" ? "y" : "x";
}
function Ha(t) {
  return t === "y" ? "height" : "width";
}
function Nt(t) {
  return ["top", "bottom"].includes(Ue(t)) ? "y" : "x";
}
function Ra(t) {
  return Gl(Nt(t));
}
function Ul(t, e, l) {
  l === void 0 && (l = !1);
  const a = Qe(t), o = Ra(t), r = Ha(o);
  let s = o === "x" ? a === (l ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return e.reference[r] > e.floating[r] && (s = aa(s)), [s, aa(s)];
}
function jn(t) {
  const e = aa(t);
  return [ta(t), e, ta(e)];
}
function ta(t) {
  return t.replace(/start|end/g, (e) => Dn[e]);
}
function qn(t, e, l) {
  const a = ["left", "right"], o = ["right", "left"], r = ["top", "bottom"], s = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return l ? e ? o : a : e ? a : o;
    case "left":
    case "right":
      return e ? r : s;
    default:
      return [];
  }
}
function Wn(t, e, l, a) {
  const o = Qe(t);
  let r = qn(Ue(t), l === "start", a);
  return o && (r = r.map((s) => s + "-" + o), e && (r = r.concat(r.map(ta)))), r;
}
function aa(t) {
  return t.replace(/left|right|bottom|top/g, (e) => xn[e]);
}
function Gn(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function Ma(t) {
  return typeof t != "number" ? Gn(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function Vt(t) {
  return {
    ...t,
    top: t.y,
    left: t.x,
    right: t.x + t.width,
    bottom: t.y + t.height
  };
}
function ul(t, e, l) {
  let {
    reference: a,
    floating: o
  } = t;
  const r = Nt(e), s = Ra(e), n = Ha(s), i = Ue(e), u = r === "y", d = a.x + a.width / 2 - o.width / 2, p = a.y + a.height / 2 - o.height / 2, f = a[n] / 2 - o[n] / 2;
  let m;
  switch (i) {
    case "top":
      m = {
        x: d,
        y: a.y - o.height
      };
      break;
    case "bottom":
      m = {
        x: d,
        y: a.y + a.height
      };
      break;
    case "right":
      m = {
        x: a.x + a.width,
        y: p
      };
      break;
    case "left":
      m = {
        x: a.x - o.width,
        y: p
      };
      break;
    default:
      m = {
        x: a.x,
        y: a.y
      };
  }
  switch (Qe(e)) {
    case "start":
      m[s] -= f * (l && u ? -1 : 1);
      break;
    case "end":
      m[s] += f * (l && u ? -1 : 1);
      break;
  }
  return m;
}
const Un = async (t, e, l) => {
  const {
    placement: a = "bottom",
    strategy: o = "absolute",
    middleware: r = [],
    platform: s
  } = l, n = r.filter(Boolean), i = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let u = await s.getElementRects({
    reference: t,
    floating: e,
    strategy: o
  }), {
    x: d,
    y: p
  } = ul(u, a, i), f = a, m = {}, y = 0;
  for (let h = 0; h < n.length; h++) {
    const {
      name: c,
      fn: g
    } = n[h], {
      x: v,
      y: $,
      data: B,
      reset: C
    } = await g({
      x: d,
      y: p,
      initialPlacement: a,
      placement: f,
      strategy: o,
      middlewareData: m,
      rects: u,
      platform: s,
      elements: {
        reference: t,
        floating: e
      }
    });
    d = v ?? d, p = $ ?? p, m = {
      ...m,
      [c]: {
        ...m[c],
        ...B
      }
    }, C && y <= 50 && (y++, typeof C == "object" && (C.placement && (f = C.placement), C.rects && (u = C.rects === !0 ? await s.getElementRects({
      reference: t,
      floating: e,
      strategy: o
    }) : C.rects), {
      x: d,
      y: p
    } = ul(u, f, i)), h = -1);
  }
  return {
    x: d,
    y: p,
    placement: f,
    strategy: o,
    middlewareData: m
  };
};
async function At(t, e) {
  var l;
  e === void 0 && (e = {});
  const {
    x: a,
    y: o,
    platform: r,
    rects: s,
    elements: n,
    strategy: i
  } = t, {
    boundary: u = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: p = "floating",
    altBoundary: f = !1,
    padding: m = 0
  } = dt(e, t), y = Ma(m), c = n[f ? p === "floating" ? "reference" : "floating" : p], g = Vt(await r.getClippingRect({
    element: (l = await (r.isElement == null ? void 0 : r.isElement(c))) == null || l ? c : c.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(n.floating)),
    boundary: u,
    rootBoundary: d,
    strategy: i
  })), v = p === "floating" ? {
    ...s.floating,
    x: a,
    y: o
  } : s.reference, $ = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(n.floating)), B = await (r.isElement == null ? void 0 : r.isElement($)) ? await (r.getScale == null ? void 0 : r.getScale($)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, C = Vt(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: n,
    rect: v,
    offsetParent: $,
    strategy: i
  }) : v);
  return {
    top: (g.top - C.top + y.top) / B.y,
    bottom: (C.bottom - g.bottom + y.bottom) / B.y,
    left: (g.left - C.left + y.left) / B.x,
    right: (C.right - g.right + y.right) / B.x
  };
}
const Kn = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: l,
      y: a,
      placement: o,
      rects: r,
      platform: s,
      elements: n,
      middlewareData: i
    } = e, {
      element: u,
      padding: d = 0
    } = dt(t, e) || {};
    if (u == null)
      return {};
    const p = Ma(d), f = {
      x: l,
      y: a
    }, m = Ra(o), y = Ha(m), h = await s.getDimensions(u), c = m === "y", g = c ? "top" : "left", v = c ? "bottom" : "right", $ = c ? "clientHeight" : "clientWidth", B = r.reference[y] + r.reference[m] - f[m] - r.floating[y], C = f[m] - r.reference[m], V = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u));
    let L = V ? V[$] : 0;
    (!L || !await (s.isElement == null ? void 0 : s.isElement(V))) && (L = n.floating[$] || r.floating[y]);
    const Q = B / 2 - C / 2, W = L / 2 - h[y] / 2 - 1, F = tt(p[g], W), Z = tt(p[v], W), R = F, le = L - h[y] - Z, N = L / 2 - h[y] / 2 + Q, S = Ca(R, N, le), P = !i.arrow && Qe(o) != null && N !== S && r.reference[y] / 2 - (N < R ? F : Z) - h[y] / 2 < 0, M = P ? N < R ? N - R : N - le : 0;
    return {
      [m]: f[m] + M,
      data: {
        [m]: S,
        centerOffset: N - S - M,
        ...P && {
          alignmentOffset: M
        }
      },
      reset: P
    };
  }
});
function Xn(t, e, l) {
  return (t ? [...l.filter((o) => Qe(o) === t), ...l.filter((o) => Qe(o) !== t)] : l.filter((o) => Ue(o) === o)).filter((o) => t ? Qe(o) === t || (e ? ta(o) !== o : !1) : !0);
}
const Yn = function(t) {
  return t === void 0 && (t = {}), {
    name: "autoPlacement",
    options: t,
    async fn(e) {
      var l, a, o;
      const {
        rects: r,
        middlewareData: s,
        placement: n,
        platform: i,
        elements: u
      } = e, {
        crossAxis: d = !1,
        alignment: p,
        allowedPlacements: f = il,
        autoAlignment: m = !0,
        ...y
      } = dt(t, e), h = p !== void 0 || f === il ? Xn(p || null, m, f) : f, c = await At(e, y), g = ((l = s.autoPlacement) == null ? void 0 : l.index) || 0, v = h[g];
      if (v == null)
        return {};
      const $ = Ul(v, r, await (i.isRTL == null ? void 0 : i.isRTL(u.floating)));
      if (n !== v)
        return {
          reset: {
            placement: h[0]
          }
        };
      const B = [c[Ue(v)], c[$[0]], c[$[1]]], C = [...((a = s.autoPlacement) == null ? void 0 : a.overflows) || [], {
        placement: v,
        overflows: B
      }], V = h[g + 1];
      if (V)
        return {
          data: {
            index: g + 1,
            overflows: C
          },
          reset: {
            placement: V
          }
        };
      const L = C.map((F) => {
        const Z = Qe(F.placement);
        return [F.placement, Z && d ? (
          // Check along the mainAxis and main crossAxis side.
          F.overflows.slice(0, 2).reduce((R, le) => R + le, 0)
        ) : (
          // Check only the mainAxis.
          F.overflows[0]
        ), F.overflows];
      }).sort((F, Z) => F[1] - Z[1]), W = ((o = L.filter((F) => F[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        Qe(F[0]) ? 2 : 3
      ).every((Z) => Z <= 0))[0]) == null ? void 0 : o[0]) || L[0][0];
      return W !== n ? {
        data: {
          index: g + 1,
          overflows: C
        },
        reset: {
          placement: W
        }
      } : {};
    }
  };
}, Zn = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var l, a;
      const {
        placement: o,
        middlewareData: r,
        rects: s,
        initialPlacement: n,
        platform: i,
        elements: u
      } = e, {
        mainAxis: d = !0,
        crossAxis: p = !0,
        fallbackPlacements: f,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: y = "none",
        flipAlignment: h = !0,
        ...c
      } = dt(t, e);
      if ((l = r.arrow) != null && l.alignmentOffset)
        return {};
      const g = Ue(o), v = Ue(n) === n, $ = await (i.isRTL == null ? void 0 : i.isRTL(u.floating)), B = f || (v || !h ? [aa(n)] : jn(n));
      !f && y !== "none" && B.push(...Wn(n, h, y, $));
      const C = [n, ...B], V = await At(e, c), L = [];
      let Q = ((a = r.flip) == null ? void 0 : a.overflows) || [];
      if (d && L.push(V[g]), p) {
        const R = Ul(o, s, $);
        L.push(V[R[0]], V[R[1]]);
      }
      if (Q = [...Q, {
        placement: o,
        overflows: L
      }], !L.every((R) => R <= 0)) {
        var W, F;
        const R = (((W = r.flip) == null ? void 0 : W.index) || 0) + 1, le = C[R];
        if (le)
          return {
            data: {
              index: R,
              overflows: Q
            },
            reset: {
              placement: le
            }
          };
        let N = (F = Q.filter((S) => S.overflows[0] <= 0).sort((S, P) => S.overflows[1] - P.overflows[1])[0]) == null ? void 0 : F.placement;
        if (!N)
          switch (m) {
            case "bestFit": {
              var Z;
              const S = (Z = Q.map((P) => [P.placement, P.overflows.filter((M) => M > 0).reduce((M, j) => M + j, 0)]).sort((P, M) => P[1] - M[1])[0]) == null ? void 0 : Z[0];
              S && (N = S);
              break;
            }
            case "initialPlacement":
              N = n;
              break;
          }
        if (o !== N)
          return {
            reset: {
              placement: N
            }
          };
      }
      return {};
    }
  };
};
function dl(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function cl(t) {
  return Wl.some((e) => t[e] >= 0);
}
const Jn = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: l
      } = e, {
        strategy: a = "referenceHidden",
        ...o
      } = dt(t, e);
      switch (a) {
        case "referenceHidden": {
          const r = await At(e, {
            ...o,
            elementContext: "reference"
          }), s = dl(r, l.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: cl(s)
            }
          };
        }
        case "escaped": {
          const r = await At(e, {
            ...o,
            altBoundary: !0
          }), s = dl(r, l.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: cl(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
function Kl(t) {
  const e = tt(...t.map((r) => r.left)), l = tt(...t.map((r) => r.top)), a = Ie(...t.map((r) => r.right)), o = Ie(...t.map((r) => r.bottom));
  return {
    x: e,
    y: l,
    width: a - e,
    height: o - l
  };
}
function Qn(t) {
  const e = t.slice().sort((o, r) => o.y - r.y), l = [];
  let a = null;
  for (let o = 0; o < e.length; o++) {
    const r = e[o];
    !a || r.y - a.y > a.height / 2 ? l.push([r]) : l[l.length - 1].push(r), a = r;
  }
  return l.map((o) => Vt(Kl(o)));
}
const es = function(t) {
  return t === void 0 && (t = {}), {
    name: "inline",
    options: t,
    async fn(e) {
      const {
        placement: l,
        elements: a,
        rects: o,
        platform: r,
        strategy: s
      } = e, {
        padding: n = 2,
        x: i,
        y: u
      } = dt(t, e), d = Array.from(await (r.getClientRects == null ? void 0 : r.getClientRects(a.reference)) || []), p = Qn(d), f = Vt(Kl(d)), m = Ma(n);
      function y() {
        if (p.length === 2 && p[0].left > p[1].right && i != null && u != null)
          return p.find((c) => i > c.left - m.left && i < c.right + m.right && u > c.top - m.top && u < c.bottom + m.bottom) || f;
        if (p.length >= 2) {
          if (Nt(l) === "y") {
            const F = p[0], Z = p[p.length - 1], R = Ue(l) === "top", le = F.top, N = Z.bottom, S = R ? F.left : Z.left, P = R ? F.right : Z.right, M = P - S, j = N - le;
            return {
              top: le,
              bottom: N,
              left: S,
              right: P,
              width: M,
              height: j,
              x: S,
              y: le
            };
          }
          const c = Ue(l) === "left", g = Ie(...p.map((F) => F.right)), v = tt(...p.map((F) => F.left)), $ = p.filter((F) => c ? F.left === v : F.right === g), B = $[0].top, C = $[$.length - 1].bottom, V = v, L = g, Q = L - V, W = C - B;
          return {
            top: B,
            bottom: C,
            left: V,
            right: L,
            width: Q,
            height: W,
            x: V,
            y: B
          };
        }
        return f;
      }
      const h = await r.getElementRects({
        reference: {
          getBoundingClientRect: y
        },
        floating: a.floating,
        strategy: s
      });
      return o.reference.x !== h.reference.x || o.reference.y !== h.reference.y || o.reference.width !== h.reference.width || o.reference.height !== h.reference.height ? {
        reset: {
          rects: h
        }
      } : {};
    }
  };
};
async function ts(t, e) {
  const {
    placement: l,
    platform: a,
    elements: o
  } = t, r = await (a.isRTL == null ? void 0 : a.isRTL(o.floating)), s = Ue(l), n = Qe(l), i = Nt(l) === "y", u = ["left", "top"].includes(s) ? -1 : 1, d = r && i ? -1 : 1, p = dt(e, t);
  let {
    mainAxis: f,
    crossAxis: m,
    alignmentAxis: y
  } = typeof p == "number" ? {
    mainAxis: p,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...p
  };
  return n && typeof y == "number" && (m = n === "end" ? y * -1 : y), i ? {
    x: m * d,
    y: f * u
  } : {
    x: f * u,
    y: m * d
  };
}
const Xl = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var l, a;
      const {
        x: o,
        y: r,
        placement: s,
        middlewareData: n
      } = e, i = await ts(e, t);
      return s === ((l = n.offset) == null ? void 0 : l.placement) && (a = n.arrow) != null && a.alignmentOffset ? {} : {
        x: o + i.x,
        y: r + i.y,
        data: {
          ...i,
          placement: s
        }
      };
    }
  };
}, as = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: l,
        y: a,
        placement: o
      } = e, {
        mainAxis: r = !0,
        crossAxis: s = !1,
        limiter: n = {
          fn: (c) => {
            let {
              x: g,
              y: v
            } = c;
            return {
              x: g,
              y: v
            };
          }
        },
        ...i
      } = dt(t, e), u = {
        x: l,
        y: a
      }, d = await At(e, i), p = Nt(Ue(o)), f = Gl(p);
      let m = u[f], y = u[p];
      if (r) {
        const c = f === "y" ? "top" : "left", g = f === "y" ? "bottom" : "right", v = m + d[c], $ = m - d[g];
        m = Ca(v, m, $);
      }
      if (s) {
        const c = p === "y" ? "top" : "left", g = p === "y" ? "bottom" : "right", v = y + d[c], $ = y - d[g];
        y = Ca(v, y, $);
      }
      const h = n.fn({
        ...e,
        [f]: m,
        [p]: y
      });
      return {
        ...h,
        data: {
          x: h.x - l,
          y: h.y - a
        }
      };
    }
  };
}, ls = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      const {
        placement: l,
        rects: a,
        platform: o,
        elements: r
      } = e, {
        apply: s = () => {
        },
        ...n
      } = dt(t, e), i = await At(e, n), u = Ue(l), d = Qe(l), p = Nt(l) === "y", {
        width: f,
        height: m
      } = a.floating;
      let y, h;
      u === "top" || u === "bottom" ? (y = u, h = d === (await (o.isRTL == null ? void 0 : o.isRTL(r.floating)) ? "start" : "end") ? "left" : "right") : (h = u, y = d === "end" ? "top" : "bottom");
      const c = m - i[y], g = f - i[h], v = !e.middlewareData.shift;
      let $ = c, B = g;
      if (p) {
        const V = f - i.left - i.right;
        B = d || v ? tt(g, V) : V;
      } else {
        const V = m - i.top - i.bottom;
        $ = d || v ? tt(c, V) : V;
      }
      if (v && !d) {
        const V = Ie(i.left, 0), L = Ie(i.right, 0), Q = Ie(i.top, 0), W = Ie(i.bottom, 0);
        p ? B = f - 2 * (V !== 0 || L !== 0 ? V + L : Ie(i.left, i.right)) : $ = m - 2 * (Q !== 0 || W !== 0 ? Q + W : Ie(i.top, i.bottom));
      }
      await s({
        ...e,
        availableWidth: B,
        availableHeight: $
      });
      const C = await o.getDimensions(r.floating);
      return f !== C.width || m !== C.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function st(t) {
  return xa(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function xe(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function ct(t) {
  var e;
  return (e = (xa(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function xa(t) {
  return t instanceof Node || t instanceof xe(t).Node;
}
function rt(t) {
  return t instanceof Element || t instanceof xe(t).Element;
}
function lt(t) {
  return t instanceof HTMLElement || t instanceof xe(t).HTMLElement;
}
function fl(t) {
  return typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof xe(t).ShadowRoot;
}
function jt(t) {
  const {
    overflow: e,
    overflowX: l,
    overflowY: a,
    display: o
  } = Ke(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + a + l) && !["inline", "contents"].includes(o);
}
function os(t) {
  return ["table", "td", "th"].includes(st(t));
}
function Da(t) {
  const e = ja(), l = Ke(t);
  return l.transform !== "none" || l.perspective !== "none" || (l.containerType ? l.containerType !== "normal" : !1) || !e && (l.backdropFilter ? l.backdropFilter !== "none" : !1) || !e && (l.filter ? l.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((a) => (l.willChange || "").includes(a)) || ["paint", "layout", "strict", "content"].some((a) => (l.contain || "").includes(a));
}
function ns(t) {
  let e = Ot(t);
  for (; lt(e) && !da(e); ) {
    if (Da(e))
      return e;
    e = Ot(e);
  }
  return null;
}
function ja() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function da(t) {
  return ["html", "body", "#document"].includes(st(t));
}
function Ke(t) {
  return xe(t).getComputedStyle(t);
}
function ca(t) {
  return rt(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.pageXOffset,
    scrollTop: t.pageYOffset
  };
}
function Ot(t) {
  if (st(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    fl(t) && t.host || // Fallback.
    ct(t)
  );
  return fl(e) ? e.host : e;
}
function Yl(t) {
  const e = Ot(t);
  return da(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : lt(e) && jt(e) ? e : Yl(e);
}
function Lt(t, e, l) {
  var a;
  e === void 0 && (e = []), l === void 0 && (l = !0);
  const o = Yl(t), r = o === ((a = t.ownerDocument) == null ? void 0 : a.body), s = xe(o);
  return r ? e.concat(s, s.visualViewport || [], jt(o) ? o : [], s.frameElement && l ? Lt(s.frameElement) : []) : e.concat(o, Lt(o, [], l));
}
function Zl(t) {
  const e = Ke(t);
  let l = parseFloat(e.width) || 0, a = parseFloat(e.height) || 0;
  const o = lt(t), r = o ? t.offsetWidth : l, s = o ? t.offsetHeight : a, n = ea(l) !== r || ea(a) !== s;
  return n && (l = r, a = s), {
    width: l,
    height: a,
    $: n
  };
}
function qa(t) {
  return rt(t) ? t : t.contextElement;
}
function _t(t) {
  const e = qa(t);
  if (!lt(e))
    return pt(1);
  const l = e.getBoundingClientRect(), {
    width: a,
    height: o,
    $: r
  } = Zl(e);
  let s = (r ? ea(l.width) : l.width) / a, n = (r ? ea(l.height) : l.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!n || !Number.isFinite(n)) && (n = 1), {
    x: s,
    y: n
  };
}
const ss = /* @__PURE__ */ pt(0);
function Jl(t) {
  const e = xe(t);
  return !ja() || !e.visualViewport ? ss : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function rs(t, e, l) {
  return e === void 0 && (e = !1), !l || e && l !== xe(t) ? !1 : e;
}
function yt(t, e, l, a) {
  e === void 0 && (e = !1), l === void 0 && (l = !1);
  const o = t.getBoundingClientRect(), r = qa(t);
  let s = pt(1);
  e && (a ? rt(a) && (s = _t(a)) : s = _t(t));
  const n = rs(r, l, a) ? Jl(r) : pt(0);
  let i = (o.left + n.x) / s.x, u = (o.top + n.y) / s.y, d = o.width / s.x, p = o.height / s.y;
  if (r) {
    const f = xe(r), m = a && rt(a) ? xe(a) : a;
    let y = f, h = y.frameElement;
    for (; h && a && m !== y; ) {
      const c = _t(h), g = h.getBoundingClientRect(), v = Ke(h), $ = g.left + (h.clientLeft + parseFloat(v.paddingLeft)) * c.x, B = g.top + (h.clientTop + parseFloat(v.paddingTop)) * c.y;
      i *= c.x, u *= c.y, d *= c.x, p *= c.y, i += $, u += B, y = xe(h), h = y.frameElement;
    }
  }
  return Vt({
    width: d,
    height: p,
    x: i,
    y: u
  });
}
const is = [":popover-open", ":modal"];
function Ql(t) {
  return is.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
function us(t) {
  let {
    elements: e,
    rect: l,
    offsetParent: a,
    strategy: o
  } = t;
  const r = o === "fixed", s = ct(a), n = e ? Ql(e.floating) : !1;
  if (a === s || n && r)
    return l;
  let i = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = pt(1);
  const d = pt(0), p = lt(a);
  if ((p || !p && !r) && ((st(a) !== "body" || jt(s)) && (i = ca(a)), lt(a))) {
    const f = yt(a);
    u = _t(a), d.x = f.x + a.clientLeft, d.y = f.y + a.clientTop;
  }
  return {
    width: l.width * u.x,
    height: l.height * u.y,
    x: l.x * u.x - i.scrollLeft * u.x + d.x,
    y: l.y * u.y - i.scrollTop * u.y + d.y
  };
}
function ds(t) {
  return Array.from(t.getClientRects());
}
function eo(t) {
  return yt(ct(t)).left + ca(t).scrollLeft;
}
function cs(t) {
  const e = ct(t), l = ca(t), a = t.ownerDocument.body, o = Ie(e.scrollWidth, e.clientWidth, a.scrollWidth, a.clientWidth), r = Ie(e.scrollHeight, e.clientHeight, a.scrollHeight, a.clientHeight);
  let s = -l.scrollLeft + eo(t);
  const n = -l.scrollTop;
  return Ke(a).direction === "rtl" && (s += Ie(e.clientWidth, a.clientWidth) - o), {
    width: o,
    height: r,
    x: s,
    y: n
  };
}
function fs(t, e) {
  const l = xe(t), a = ct(t), o = l.visualViewport;
  let r = a.clientWidth, s = a.clientHeight, n = 0, i = 0;
  if (o) {
    r = o.width, s = o.height;
    const u = ja();
    (!u || u && e === "fixed") && (n = o.offsetLeft, i = o.offsetTop);
  }
  return {
    width: r,
    height: s,
    x: n,
    y: i
  };
}
function vs(t, e) {
  const l = yt(t, !0, e === "fixed"), a = l.top + t.clientTop, o = l.left + t.clientLeft, r = lt(t) ? _t(t) : pt(1), s = t.clientWidth * r.x, n = t.clientHeight * r.y, i = o * r.x, u = a * r.y;
  return {
    width: s,
    height: n,
    x: i,
    y: u
  };
}
function vl(t, e, l) {
  let a;
  if (e === "viewport")
    a = fs(t, l);
  else if (e === "document")
    a = cs(ct(t));
  else if (rt(e))
    a = vs(e, l);
  else {
    const o = Jl(t);
    a = {
      ...e,
      x: e.x - o.x,
      y: e.y - o.y
    };
  }
  return Vt(a);
}
function to(t, e) {
  const l = Ot(t);
  return l === e || !rt(l) || da(l) ? !1 : Ke(l).position === "fixed" || to(l, e);
}
function ps(t, e) {
  const l = e.get(t);
  if (l)
    return l;
  let a = Lt(t, [], !1).filter((n) => rt(n) && st(n) !== "body"), o = null;
  const r = Ke(t).position === "fixed";
  let s = r ? Ot(t) : t;
  for (; rt(s) && !da(s); ) {
    const n = Ke(s), i = Da(s);
    !i && n.position === "fixed" && (o = null), (r ? !i && !o : !i && n.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || jt(s) && !i && to(t, s)) ? a = a.filter((d) => d !== s) : o = n, s = Ot(s);
  }
  return e.set(t, a), a;
}
function ms(t) {
  let {
    element: e,
    boundary: l,
    rootBoundary: a,
    strategy: o
  } = t;
  const s = [...l === "clippingAncestors" ? ps(e, this._c) : [].concat(l), a], n = s[0], i = s.reduce((u, d) => {
    const p = vl(e, d, o);
    return u.top = Ie(p.top, u.top), u.right = tt(p.right, u.right), u.bottom = tt(p.bottom, u.bottom), u.left = Ie(p.left, u.left), u;
  }, vl(e, n, o));
  return {
    width: i.right - i.left,
    height: i.bottom - i.top,
    x: i.left,
    y: i.top
  };
}
function bs(t) {
  const {
    width: e,
    height: l
  } = Zl(t);
  return {
    width: e,
    height: l
  };
}
function ys(t, e, l) {
  const a = lt(e), o = ct(e), r = l === "fixed", s = yt(t, !0, r, e);
  let n = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const i = pt(0);
  if (a || !a && !r)
    if ((st(e) !== "body" || jt(o)) && (n = ca(e)), a) {
      const p = yt(e, !0, r, e);
      i.x = p.x + e.clientLeft, i.y = p.y + e.clientTop;
    } else
      o && (i.x = eo(o));
  const u = s.left + n.scrollLeft - i.x, d = s.top + n.scrollTop - i.y;
  return {
    x: u,
    y: d,
    width: s.width,
    height: s.height
  };
}
function pl(t, e) {
  return !lt(t) || Ke(t).position === "fixed" ? null : e ? e(t) : t.offsetParent;
}
function ao(t, e) {
  const l = xe(t);
  if (!lt(t) || Ql(t))
    return l;
  let a = pl(t, e);
  for (; a && os(a) && Ke(a).position === "static"; )
    a = pl(a, e);
  return a && (st(a) === "html" || st(a) === "body" && Ke(a).position === "static" && !Da(a)) ? l : a || ns(t) || l;
}
const gs = async function(t) {
  const e = this.getOffsetParent || ao, l = this.getDimensions;
  return {
    reference: ys(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await l(t.floating)
    }
  };
};
function hs(t) {
  return Ke(t).direction === "rtl";
}
const Bs = {
  convertOffsetParentRelativeRectToViewportRelativeRect: us,
  getDocumentElement: ct,
  getClippingRect: ms,
  getOffsetParent: ao,
  getElementRects: gs,
  getClientRects: ds,
  getDimensions: bs,
  getScale: _t,
  isElement: rt,
  isRTL: hs
};
function ws(t, e) {
  let l = null, a;
  const o = ct(t);
  function r() {
    var n;
    clearTimeout(a), (n = l) == null || n.disconnect(), l = null;
  }
  function s(n, i) {
    n === void 0 && (n = !1), i === void 0 && (i = 1), r();
    const {
      left: u,
      top: d,
      width: p,
      height: f
    } = t.getBoundingClientRect();
    if (n || e(), !p || !f)
      return;
    const m = Ut(d), y = Ut(o.clientWidth - (u + p)), h = Ut(o.clientHeight - (d + f)), c = Ut(u), v = {
      rootMargin: -m + "px " + -y + "px " + -h + "px " + -c + "px",
      threshold: Ie(0, tt(1, i)) || 1
    };
    let $ = !0;
    function B(C) {
      const V = C[0].intersectionRatio;
      if (V !== i) {
        if (!$)
          return s();
        V ? s(!1, V) : a = setTimeout(() => {
          s(!1, 1e-7);
        }, 100);
      }
      $ = !1;
    }
    try {
      l = new IntersectionObserver(B, {
        ...v,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      l = new IntersectionObserver(B, v);
    }
    l.observe(t);
  }
  return s(!0), r;
}
function lo(t, e, l, a) {
  a === void 0 && (a = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: r = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: n = typeof IntersectionObserver == "function",
    animationFrame: i = !1
  } = a, u = qa(t), d = o || r ? [...u ? Lt(u) : [], ...Lt(e)] : [];
  d.forEach((g) => {
    o && g.addEventListener("scroll", l, {
      passive: !0
    }), r && g.addEventListener("resize", l);
  });
  const p = u && n ? ws(u, l) : null;
  let f = -1, m = null;
  s && (m = new ResizeObserver((g) => {
    let [v] = g;
    v && v.target === u && m && (m.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var $;
      ($ = m) == null || $.observe(e);
    })), l();
  }), u && !i && m.observe(u), m.observe(e));
  let y, h = i ? yt(t) : null;
  i && c();
  function c() {
    const g = yt(t);
    h && (g.x !== h.x || g.y !== h.y || g.width !== h.width || g.height !== h.height) && l(), h = g, y = requestAnimationFrame(c);
  }
  return l(), () => {
    var g;
    d.forEach((v) => {
      o && v.removeEventListener("scroll", l), r && v.removeEventListener("resize", l);
    }), p == null || p(), (g = m) == null || g.disconnect(), m = null, i && cancelAnimationFrame(y);
  };
}
const Cs = Yn, oo = as, no = Zn, so = ls, ks = Jn, $s = Kn, Ts = es, Ss = (t, e, l) => {
  const a = /* @__PURE__ */ new Map(), o = {
    platform: Bs,
    ...l
  }, r = {
    ...o.platform,
    _c: a
  };
  return Un(t, e, {
    ...o,
    platform: r
  });
};
function _s(t) {
  return t != null && typeof t == "object" && "$el" in t;
}
function ka(t) {
  if (_s(t)) {
    const e = t.$el;
    return xa(e) && st(e) === "#comment" ? null : e;
  }
  return t;
}
function Vs(t) {
  return {
    name: "arrow",
    options: t,
    fn(e) {
      const l = ka(O(t.element));
      return l == null ? {} : $s({
        element: l,
        padding: t.padding
      }).fn(e);
    }
  };
}
function ro(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function ml(t, e) {
  const l = ro(t);
  return Math.round(e * l) / l;
}
function io(t, e, l) {
  l === void 0 && (l = {});
  const a = l.whileElementsMounted, o = w(() => {
    var L;
    return (L = O(l.open)) != null ? L : !0;
  }), r = w(() => O(l.middleware)), s = w(() => {
    var L;
    return (L = O(l.placement)) != null ? L : "bottom";
  }), n = w(() => {
    var L;
    return (L = O(l.strategy)) != null ? L : "absolute";
  }), i = w(() => {
    var L;
    return (L = O(l.transform)) != null ? L : !0;
  }), u = w(() => ka(t.value)), d = w(() => ka(e.value)), p = x(0), f = x(0), m = x(n.value), y = x(s.value), h = bt({}), c = x(!1), g = w(() => {
    const L = {
      position: m.value,
      left: "0",
      top: "0"
    };
    if (!d.value)
      return L;
    const Q = ml(d.value, p.value), W = ml(d.value, f.value);
    return i.value ? {
      ...L,
      transform: "translate(" + Q + "px, " + W + "px)",
      ...ro(d.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: m.value,
      left: Q + "px",
      top: W + "px"
    };
  });
  let v;
  function $() {
    u.value == null || d.value == null || Ss(u.value, d.value, {
      middleware: r.value,
      placement: s.value,
      strategy: n.value
    }).then((L) => {
      p.value = L.x, f.value = L.y, m.value = L.strategy, y.value = L.placement, h.value = L.middlewareData, c.value = !0;
    });
  }
  function B() {
    typeof v == "function" && (v(), v = void 0);
  }
  function C() {
    if (B(), a === void 0) {
      $();
      return;
    }
    if (u.value != null && d.value != null) {
      v = a(u.value, d.value, $);
      return;
    }
  }
  function V() {
    o.value || (c.value = !1);
  }
  return ue([r, s, n], $, {
    flush: "sync"
  }), ue([u, d], C, {
    flush: "sync"
  }), ue(o, V, {
    flush: "sync"
  }), Ml() && xl(B), {
    x: kt(p),
    y: kt(f),
    strategy: kt(m),
    placement: kt(y),
    middlewareData: kt(h),
    isPositioned: kt(c),
    floatingStyles: g,
    update: $
  };
}
const As = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), Os = /^aria-[\w-]*$/i, Ns = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Is = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, Ps = (t, e) => {
  const l = t.nodeName.toLowerCase();
  return e.includes(l) ? As.has(l) ? !!(Ns.test(t.nodeValue || "") || Is.test(t.nodeValue || "")) : !0 : e.filter((a) => a instanceof RegExp).some((a) => a.test(l));
}, $t = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", Os],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
}, Tt = (t, e, l) => {
  if (!t.length)
    return t;
  if (l && typeof l == "function")
    return l(t);
  const o = new window.DOMParser().parseFromString(t, "text/html"), r = o.body.querySelectorAll("*");
  for (const s of r) {
    const n = s.nodeName.toLowerCase();
    if (!Object.keys(e).includes(n)) {
      s.remove();
      continue;
    }
    const i = s.attributes, u = [...e["*"] || [], ...e[n] || []];
    for (const d of i)
      Ps(d, u) || s.removeAttribute(d.nodeName);
  }
  return o.body.innerHTML;
};
function it(t) {
  return Ml() ? (xl(t), !0) : !1;
}
function Es(t, e) {
  if (typeof Symbol < "u") {
    const l = { ...t };
    return Object.defineProperty(l, Symbol.iterator, {
      enumerable: !1,
      value() {
        let a = 0;
        return {
          next: () => ({
            value: e[a++],
            done: a > e.length
          })
        };
      }
    }), l;
  } else
    return Object.assign([...e], t);
}
function Fe(t) {
  return typeof t == "function" ? t() : O(t);
}
const la = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const Fs = (t) => typeof t < "u", uo = (t) => t != null, Ls = Object.prototype.toString, zs = (t) => Ls.call(t) === "[object Object]", Ge = () => {
}, $a = /* @__PURE__ */ Hs();
function Hs() {
  var t, e;
  return la && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function co(t, e) {
  function l(...a) {
    return new Promise((o, r) => {
      Promise.resolve(t(() => e.apply(this, a), { fn: e, thisArg: this, args: a })).then(o).catch(r);
    });
  }
  return l;
}
const fo = (t) => t();
function Rs(t, e = {}) {
  let l, a, o = Ge;
  const r = (n) => {
    clearTimeout(n), o(), o = Ge;
  };
  return (n) => {
    const i = Fe(t), u = Fe(e.maxWait);
    return l && r(l), i <= 0 || u !== void 0 && u <= 0 ? (a && (r(a), a = null), Promise.resolve(n())) : new Promise((d, p) => {
      o = e.rejectOnCancel ? p : d, u && !a && (a = setTimeout(() => {
        l && r(l), a = null, d(n());
      }, u)), l = setTimeout(() => {
        a && r(a), a = null, d(n());
      }, i);
    });
  };
}
function Ms(t = fo) {
  const e = x(!0);
  function l() {
    e.value = !1;
  }
  function a() {
    e.value = !0;
  }
  const o = (...r) => {
    e.value && t(...r);
  };
  return { isActive: We(e), pause: l, resume: a, eventFilter: o };
}
function xs(t) {
  const e = /* @__PURE__ */ Object.create(null);
  return (l) => e[l] || (e[l] = t(l));
}
const Ds = /-(\w)/g, js = xs((t) => t.replace(Ds, (e, l) => l ? l.toUpperCase() : ""));
function qs(t) {
  return t || gt();
}
function vo(...t) {
  if (t.length !== 1)
    return k(...t);
  const e = t[0];
  return typeof e == "function" ? We(_n(() => ({ get: e, set: Ge }))) : x(e);
}
function Ws(t, e = 200, l = {}) {
  return co(
    Rs(e, l),
    t
  );
}
function Gs(t, e, l = {}) {
  const {
    eventFilter: a = fo,
    ...o
  } = l;
  return ue(
    t,
    co(
      a,
      e
    ),
    o
  );
}
function Ta(t, e, l = {}) {
  const {
    eventFilter: a,
    ...o
  } = l, { eventFilter: r, pause: s, resume: n, isActive: i } = Ms(a);
  return { stop: Gs(
    t,
    e,
    {
      ...o,
      eventFilter: r
    }
  ), pause: s, resume: n, isActive: i };
}
function Sa(t, e, ...[l]) {
  const {
    flush: a = "sync",
    deep: o = !1,
    immediate: r = !0,
    direction: s = "both",
    transform: n = {}
  } = l || {}, i = [], u = "ltr" in n && n.ltr || ((f) => f), d = "rtl" in n && n.rtl || ((f) => f);
  return (s === "both" || s === "ltr") && i.push(Ta(
    t,
    (f) => {
      i.forEach((m) => m.pause()), e.value = u(f), i.forEach((m) => m.resume());
    },
    { flush: a, deep: o, immediate: r }
  )), (s === "both" || s === "rtl") && i.push(Ta(
    e,
    (f) => {
      i.forEach((m) => m.pause()), t.value = d(f), i.forEach((m) => m.resume());
    },
    { flush: a, deep: o, immediate: r }
  )), () => {
    i.forEach((f) => f.stop());
  };
}
function po(t, e = !0, l) {
  qs() ? Xe(t, l) : e ? t() : Ve(t);
}
function mo(t, e = 1e3, l = {}) {
  const {
    immediate: a = !0,
    immediateCallback: o = !1
  } = l;
  let r = null;
  const s = x(!1);
  function n() {
    r && (clearInterval(r), r = null);
  }
  function i() {
    s.value = !1, n();
  }
  function u() {
    const d = Fe(e);
    d <= 0 || (s.value = !0, o && t(), n(), r = setInterval(t, d));
  }
  if (a && la && u(), Sn(e) || typeof e == "function") {
    const d = ue(e, () => {
      s.value && la && u();
    });
    it(d);
  }
  return it(i), {
    isActive: s,
    pause: i,
    resume: u
  };
}
function be(t, e = {}) {
  const {
    method: l = "parseFloat",
    radix: a,
    nanToZero: o
  } = e;
  return w(() => {
    let r = Fe(t);
    return typeof r == "string" && (r = Number[l](r, a)), o && Number.isNaN(r) && (r = 0), r;
  });
}
function zt(t = {}) {
  const {
    inheritAttrs: e = !0
  } = t, l = bt(), a = /* @__PURE__ */ H({
    setup(r, { slots: s }) {
      return () => {
        l.value = s.default;
      };
    }
  }), o = /* @__PURE__ */ H({
    inheritAttrs: e,
    setup(r, { attrs: s, slots: n }) {
      return () => {
        var i;
        if (!l.value && process.env.NODE_ENV !== "production")
          throw new Error("[VueUse] Failed to find the definition of reusable template");
        const u = (i = l.value) == null ? void 0 : i.call(l, { ...Us(s), $slots: n });
        return e && (u == null ? void 0 : u.length) === 1 ? u[0] : u;
      };
    }
  });
  return Es(
    { define: a, reuse: o },
    [a, o]
  );
}
function Us(t) {
  const e = {};
  for (const l in t)
    e[js(l)] = t[l];
  return e;
}
function Me(t) {
  var e;
  const l = Fe(t);
  return (e = l == null ? void 0 : l.$el) != null ? e : l;
}
const De = la ? window : void 0;
function ke(...t) {
  let e, l, a, o;
  if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([l, a, o] = t, e = De) : [e, l, a, o] = t, !e)
    return Ge;
  Array.isArray(l) || (l = [l]), Array.isArray(a) || (a = [a]);
  const r = [], s = () => {
    r.forEach((d) => d()), r.length = 0;
  }, n = (d, p, f, m) => (d.addEventListener(p, f, m), () => d.removeEventListener(p, f, m)), i = ue(
    () => [Me(e), Fe(o)],
    ([d, p]) => {
      if (s(), !d)
        return;
      const f = zs(p) ? { ...p } : p;
      r.push(
        ...l.flatMap((m) => a.map((y) => n(d, m, y, f)))
      );
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    i(), s();
  };
  return it(u), u;
}
let bl = !1;
function bo(t, e, l = {}) {
  const { window: a = De, ignore: o = [], capture: r = !0, detectIframe: s = !1 } = l;
  if (!a)
    return Ge;
  $a && !bl && (bl = !0, Array.from(a.document.body.children).forEach((f) => f.addEventListener("click", Ge)), a.document.documentElement.addEventListener("click", Ge));
  let n = !0;
  const i = (f) => o.some((m) => {
    if (typeof m == "string")
      return Array.from(a.document.querySelectorAll(m)).some((y) => y === f.target || f.composedPath().includes(y));
    {
      const y = Me(m);
      return y && (f.target === y || f.composedPath().includes(y));
    }
  }), d = [
    ke(a, "click", (f) => {
      const m = Me(t);
      if (!(!m || m === f.target || f.composedPath().includes(m))) {
        if (f.detail === 0 && (n = !i(f)), !n) {
          n = !0;
          return;
        }
        e(f);
      }
    }, { passive: !0, capture: r }),
    ke(a, "pointerdown", (f) => {
      const m = Me(t);
      n = !i(f) && !!(m && !f.composedPath().includes(m));
    }, { passive: !0 }),
    s && ke(a, "blur", (f) => {
      setTimeout(() => {
        var m;
        const y = Me(t);
        ((m = a.document.activeElement) == null ? void 0 : m.tagName) === "IFRAME" && !(y != null && y.contains(a.document.activeElement)) && e(f);
      }, 0);
    })
  ].filter(Boolean);
  return () => d.forEach((f) => f());
}
function Ks(t) {
  return typeof t == "function" ? t : typeof t == "string" ? (e) => e.key === t : Array.isArray(t) ? (e) => t.includes(e.key) : () => !0;
}
function Re(...t) {
  let e, l, a = {};
  t.length === 3 ? (e = t[0], l = t[1], a = t[2]) : t.length === 2 ? typeof t[1] == "object" ? (e = !0, l = t[0], a = t[1]) : (e = t[0], l = t[1]) : (e = !0, l = t[0]);
  const {
    target: o = De,
    eventName: r = "keydown",
    passive: s = !1,
    dedupe: n = !1
  } = a, i = Ks(e);
  return ke(o, r, (d) => {
    d.repeat && Fe(n) || i(d) && l(d);
  }, s);
}
function Xs() {
  const t = x(!1), e = gt();
  return e && Xe(() => {
    t.value = !0;
  }, e), t;
}
function Wa(t) {
  const e = Xs();
  return w(() => (e.value, !!t()));
}
function Ys(t, e = {}) {
  const { window: l = De } = e, a = Wa(() => l && "matchMedia" in l && typeof l.matchMedia == "function");
  let o;
  const r = x(!1), s = (u) => {
    r.value = u.matches;
  }, n = () => {
    o && ("removeEventListener" in o ? o.removeEventListener("change", s) : o.removeListener(s));
  }, i = Rt(() => {
    a.value && (n(), o = l.matchMedia(Fe(t)), "addEventListener" in o ? o.addEventListener("change", s) : o.addListener(s), r.value = o.matches);
  });
  return it(() => {
    i(), n(), o = void 0;
  }), r;
}
function Zs(t) {
  return JSON.parse(JSON.stringify(t));
}
const Kt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Xt = "__vueuse_ssr_handlers__", Js = /* @__PURE__ */ Qs();
function Qs() {
  return Xt in Kt || (Kt[Xt] = Kt[Xt] || {}), Kt[Xt];
}
function Ga(t, e) {
  return Js[t] || e;
}
function er(t) {
  return t == null ? "any" : t instanceof Set ? "set" : t instanceof Map ? "map" : t instanceof Date ? "date" : typeof t == "boolean" ? "boolean" : typeof t == "string" ? "string" : typeof t == "object" ? "object" : Number.isNaN(t) ? "any" : "number";
}
const tr = {
  boolean: {
    read: (t) => t === "true",
    write: (t) => String(t)
  },
  object: {
    read: (t) => JSON.parse(t),
    write: (t) => JSON.stringify(t)
  },
  number: {
    read: (t) => Number.parseFloat(t),
    write: (t) => String(t)
  },
  any: {
    read: (t) => t,
    write: (t) => String(t)
  },
  string: {
    read: (t) => t,
    write: (t) => String(t)
  },
  map: {
    read: (t) => new Map(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t.entries()))
  },
  set: {
    read: (t) => new Set(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t))
  },
  date: {
    read: (t) => new Date(t),
    write: (t) => t.toISOString()
  }
}, yl = "vueuse-storage";
function ar(t, e, l, a = {}) {
  var o;
  const {
    flush: r = "pre",
    deep: s = !0,
    listenToStorageChanges: n = !0,
    writeDefaults: i = !0,
    mergeDefaults: u = !1,
    shallow: d,
    window: p = De,
    eventFilter: f,
    onError: m = (F) => {
      console.error(F);
    },
    initOnMounted: y
  } = a, h = (d ? bt : x)(typeof e == "function" ? e() : e);
  if (!l)
    try {
      l = Ga("getDefaultStorage", () => {
        var F;
        return (F = De) == null ? void 0 : F.localStorage;
      })();
    } catch (F) {
      m(F);
    }
  if (!l)
    return h;
  const c = Fe(e), g = er(c), v = (o = a.serializer) != null ? o : tr[g], { pause: $, resume: B } = Ta(
    h,
    () => V(h.value),
    { flush: r, deep: s, eventFilter: f }
  );
  p && n && po(() => {
    ke(p, "storage", Q), ke(p, yl, W), y && Q();
  }), y || Q();
  function C(F, Z) {
    p && p.dispatchEvent(new CustomEvent(yl, {
      detail: {
        key: t,
        oldValue: F,
        newValue: Z,
        storageArea: l
      }
    }));
  }
  function V(F) {
    try {
      const Z = l.getItem(t);
      if (F == null)
        C(Z, null), l.removeItem(t);
      else {
        const R = v.write(F);
        Z !== R && (l.setItem(t, R), C(Z, R));
      }
    } catch (Z) {
      m(Z);
    }
  }
  function L(F) {
    const Z = F ? F.newValue : l.getItem(t);
    if (Z == null)
      return i && c != null && l.setItem(t, v.write(c)), c;
    if (!F && u) {
      const R = v.read(Z);
      return typeof u == "function" ? u(R, c) : g === "object" && !Array.isArray(R) ? { ...c, ...R } : R;
    } else
      return typeof Z != "string" ? Z : v.read(Z);
  }
  function Q(F) {
    if (!(F && F.storageArea !== l)) {
      if (F && F.key == null) {
        h.value = c;
        return;
      }
      if (!(F && F.key !== t)) {
        $();
        try {
          (F == null ? void 0 : F.newValue) !== v.write(h.value) && (h.value = L(F));
        } catch (Z) {
          m(Z);
        } finally {
          F ? Ve(B) : B();
        }
      }
    }
  }
  function W(F) {
    Q(F.detail);
  }
  return h;
}
function lr(t) {
  return Ys("(prefers-color-scheme: dark)", t);
}
function or(t = {}) {
  const {
    selector: e = "html",
    attribute: l = "class",
    initialValue: a = "auto",
    window: o = De,
    storage: r,
    storageKey: s = "vueuse-color-scheme",
    listenToStorageChanges: n = !0,
    storageRef: i,
    emitAuto: u,
    disableTransition: d = !0
  } = t, p = {
    auto: "",
    light: "light",
    dark: "dark",
    ...t.modes || {}
  }, f = lr({ window: o }), m = w(() => f.value ? "dark" : "light"), y = i || (s == null ? vo(a) : ar(s, a, r, { window: o, listenToStorageChanges: n })), h = w(() => y.value === "auto" ? m.value : y.value), c = Ga(
    "updateHTMLAttrs",
    (B, C, V) => {
      const L = typeof B == "string" ? o == null ? void 0 : o.document.querySelector(B) : Me(B);
      if (!L)
        return;
      let Q;
      if (d && (Q = o.document.createElement("style"), Q.appendChild(document.createTextNode("*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), o.document.head.appendChild(Q)), C === "class") {
        const W = V.split(/\s/g);
        Object.values(p).flatMap((F) => (F || "").split(/\s/g)).filter(Boolean).forEach((F) => {
          W.includes(F) ? L.classList.add(F) : L.classList.remove(F);
        });
      } else
        L.setAttribute(C, V);
      d && (o.getComputedStyle(Q).opacity, document.head.removeChild(Q));
    }
  );
  function g(B) {
    var C;
    c(e, l, (C = p[B]) != null ? C : B);
  }
  function v(B) {
    t.onChanged ? t.onChanged(B, g) : g(B);
  }
  ue(h, v, { flush: "post", immediate: !0 }), po(() => v(h.value));
  const $ = w({
    get() {
      return u ? y.value : h.value;
    },
    set(B) {
      y.value = B;
    }
  });
  try {
    return Object.assign($, { store: y, system: m, state: h });
  } catch {
    return $;
  }
}
function nr(t, e, l = {}) {
  const { window: a = De, ...o } = l;
  let r;
  const s = Wa(() => a && "MutationObserver" in a), n = () => {
    r && (r.disconnect(), r = void 0);
  }, i = w(() => {
    const f = Fe(t), m = (Array.isArray(f) ? f : [f]).map(Me).filter(uo);
    return new Set(m);
  }), u = ue(
    () => i.value,
    (f) => {
      n(), s.value && a && f.size && (r = new MutationObserver(e), f.forEach((m) => r.observe(m, o)));
    },
    { immediate: !0, flush: "post" }
  ), d = () => r == null ? void 0 : r.takeRecords(), p = () => {
    n(), u();
  };
  return it(p), {
    isSupported: s,
    stop: p,
    takeRecords: d
  };
}
function Ua(t, e = {}) {
  const {
    delayEnter: l = 0,
    delayLeave: a = 0,
    window: o = De
  } = e, r = x(!1);
  let s;
  const n = (i) => {
    const u = i ? l : a;
    s && (clearTimeout(s), s = void 0), u ? s = setTimeout(() => r.value = i, u) : r.value = i;
  };
  return o && (ke(t, "mouseenter", () => n(!0), { passive: !0 }), ke(t, "mouseleave", () => n(!1), { passive: !0 })), r;
}
function sr(t, e, l = {}) {
  const {
    root: a,
    rootMargin: o = "0px",
    threshold: r = 0.1,
    window: s = De,
    immediate: n = !0
  } = l, i = Wa(() => s && "IntersectionObserver" in s), u = w(() => {
    const y = Fe(t);
    return (Array.isArray(y) ? y : [y]).map(Me).filter(uo);
  });
  let d = Ge;
  const p = x(n), f = i.value ? ue(
    () => [u.value, Me(a), p.value],
    ([y, h]) => {
      if (d(), !p.value || !y.length)
        return;
      const c = new IntersectionObserver(
        e,
        {
          root: Me(h),
          rootMargin: o,
          threshold: r
        }
      );
      y.forEach((g) => g && c.observe(g)), d = () => {
        c.disconnect(), d = Ge;
      };
    },
    { immediate: n, flush: "post" }
  ) : Ge, m = () => {
    d(), f(), p.value = !1;
  };
  return it(m), {
    isSupported: i,
    isActive: p,
    pause() {
      d(), p.value = !1;
    },
    resume() {
      p.value = !0;
    },
    stop: m
  };
}
function Pe(t, e = {}) {
  const { initialValue: l = !1, focusVisible: a = !1 } = e, o = x(!1), r = w(() => Me(t));
  ke(r, "focus", (n) => {
    var i, u;
    (!a || (u = (i = n.target).matches) != null && u.call(i, ":focus-visible")) && (o.value = !0);
  }), ke(r, "blur", () => o.value = !1);
  const s = w({
    get: () => o.value,
    set(n) {
      var i, u;
      !n && o.value ? (i = r.value) == null || i.blur() : n && !o.value && ((u = r.value) == null || u.focus());
    }
  });
  return ue(
    r,
    () => {
      s.value = l;
    },
    { immediate: !0, flush: "post" }
  ), { focused: s };
}
function ba(t) {
  return typeof Window < "u" && t instanceof Window ? t.document.documentElement : typeof Document < "u" && t instanceof Document ? t.documentElement : t;
}
const rr = {
  page: (t) => [t.pageX, t.pageY],
  client: (t) => [t.clientX, t.clientY],
  screen: (t) => [t.screenX, t.screenY],
  movement: (t) => t instanceof Touch ? null : [t.movementX, t.movementY]
};
function ir(t = {}) {
  const {
    type: e = "page",
    touch: l = !0,
    resetOnTouchEnds: a = !1,
    initialValue: o = { x: 0, y: 0 },
    window: r = De,
    target: s = r,
    scroll: n = !0,
    eventFilter: i
  } = t;
  let u = null;
  const d = x(o.x), p = x(o.y), f = x(null), m = typeof e == "function" ? e : rr[e], y = (C) => {
    const V = m(C);
    u = C, V && ([d.value, p.value] = V, f.value = "mouse");
  }, h = (C) => {
    if (C.touches.length > 0) {
      const V = m(C.touches[0]);
      V && ([d.value, p.value] = V, f.value = "touch");
    }
  }, c = () => {
    if (!u || !r)
      return;
    const C = m(u);
    u instanceof MouseEvent && C && (d.value = C[0] + r.scrollX, p.value = C[1] + r.scrollY);
  }, g = () => {
    d.value = o.x, p.value = o.y;
  }, v = i ? (C) => i(() => y(C), {}) : (C) => y(C), $ = i ? (C) => i(() => h(C), {}) : (C) => h(C), B = i ? () => i(() => c(), {}) : () => c();
  if (s) {
    const C = { passive: !0 };
    ke(s, ["mousemove", "dragover"], v, C), l && e !== "movement" && (ke(s, ["touchstart", "touchmove"], $, C), a && ke(s, "touchend", g, C)), n && e === "page" && ke(r, "scroll", B, { passive: !0 });
  }
  return {
    x: d,
    y: p,
    sourceType: f
  };
}
function gl(t, e = {}) {
  const {
    handleOutside: l = !0,
    window: a = De
  } = e, o = e.type || "page", { x: r, y: s, sourceType: n } = ir(e), i = x(t ?? (a == null ? void 0 : a.document.body)), u = x(0), d = x(0), p = x(0), f = x(0), m = x(0), y = x(0), h = x(!0);
  let c = () => {
  };
  return a && (c = ue(
    [i, r, s],
    () => {
      const g = Me(i);
      if (!g)
        return;
      const {
        left: v,
        top: $,
        width: B,
        height: C
      } = g.getBoundingClientRect();
      p.value = v + (o === "page" ? a.pageXOffset : 0), f.value = $ + (o === "page" ? a.pageYOffset : 0), m.value = C, y.value = B;
      const V = r.value - p.value, L = s.value - f.value;
      h.value = B === 0 || C === 0 || V < 0 || L < 0 || V > B || L > C, (l || !h.value) && (u.value = V, d.value = L);
    },
    { immediate: !0 }
  ), ke(document, "mouseleave", () => {
    h.value = !0;
  })), {
    x: r,
    y: s,
    sourceType: n,
    elementX: u,
    elementY: d,
    elementPositionX: p,
    elementPositionY: f,
    elementHeight: m,
    elementWidth: y,
    isOutside: h,
    stop: c
  };
}
function yo(t) {
  const e = window.getComputedStyle(t);
  if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && t.clientWidth < t.scrollWidth || e.overflowY === "auto" && t.clientHeight < t.scrollHeight)
    return !0;
  {
    const l = t.parentNode;
    return !l || l.tagName === "BODY" ? !1 : yo(l);
  }
}
function ur(t) {
  const e = t || window.event, l = e.target;
  return yo(l) ? !1 : e.touches.length > 1 ? !0 : (e.preventDefault && e.preventDefault(), !1);
}
const Yt = /* @__PURE__ */ new WeakMap();
function dr(t, e = !1) {
  const l = x(e);
  let a = null;
  ue(vo(t), (s) => {
    const n = ba(Fe(s));
    if (n) {
      const i = n;
      Yt.get(i) || Yt.set(i, i.style.overflow), l.value && (i.style.overflow = "hidden");
    }
  }, {
    immediate: !0
  });
  const o = () => {
    const s = ba(Fe(t));
    !s || l.value || ($a && (a = ke(
      s,
      "touchmove",
      (n) => {
        ur(n);
      },
      { passive: !1 }
    )), s.style.overflow = "hidden", l.value = !0);
  }, r = () => {
    var s;
    const n = ba(Fe(t));
    !n || !l.value || ($a && (a == null || a()), n.style.overflow = (s = Yt.get(n)) != null ? s : "", Yt.delete(n), l.value = !1);
  };
  return it(r), w({
    get() {
      return l.value;
    },
    set(s) {
      s ? o() : r();
    }
  });
}
function cr(t, e = {}) {
  const {
    threshold: l = 50,
    onSwipe: a,
    onSwipeEnd: o,
    onSwipeStart: r,
    passive: s = !0,
    window: n = De
  } = e, i = nl({ x: 0, y: 0 }), u = nl({ x: 0, y: 0 }), d = w(() => i.x - u.x), p = w(() => i.y - u.y), { max: f, abs: m } = Math, y = w(() => f(m(d.value), m(p.value)) >= l), h = x(!1), c = w(() => y.value ? m(d.value) > m(p.value) ? d.value > 0 ? "left" : "right" : p.value > 0 ? "up" : "down" : "none"), g = (W) => [W.touches[0].clientX, W.touches[0].clientY], v = (W, F) => {
    i.x = W, i.y = F;
  }, $ = (W, F) => {
    u.x = W, u.y = F;
  };
  let B;
  const C = fr(n == null ? void 0 : n.document);
  s ? B = C ? { passive: !0 } : { capture: !1 } : B = C ? { passive: !1, capture: !0 } : { capture: !0 };
  const V = (W) => {
    h.value && (o == null || o(W, c.value)), h.value = !1;
  }, L = [
    ke(t, "touchstart", (W) => {
      if (W.touches.length !== 1)
        return;
      B.capture && !B.passive && W.preventDefault();
      const [F, Z] = g(W);
      v(F, Z), $(F, Z), r == null || r(W);
    }, B),
    ke(t, "touchmove", (W) => {
      if (W.touches.length !== 1)
        return;
      const [F, Z] = g(W);
      $(F, Z), !h.value && y.value && (h.value = !0), h.value && (a == null || a(W));
    }, B),
    ke(t, ["touchend", "touchcancel"], V, B)
  ];
  return {
    isPassiveEventSupported: C,
    isSwiping: h,
    direction: c,
    coordsStart: i,
    coordsEnd: u,
    lengthX: d,
    lengthY: p,
    stop: () => L.forEach((W) => W())
  };
}
function fr(t) {
  if (!t)
    return !1;
  let e = !1;
  const l = {
    get passive() {
      return e = !0, !1;
    }
  };
  return t.addEventListener("x", Ge, l), t.removeEventListener("x", Ge), e;
}
function vr(t, e, l, a = {}) {
  var o, r, s;
  const {
    clone: n = !1,
    passive: i = !1,
    eventName: u,
    deep: d = !1,
    defaultValue: p,
    shouldEmit: f
  } = a, m = gt(), y = l || (m == null ? void 0 : m.emit) || ((o = m == null ? void 0 : m.$emit) == null ? void 0 : o.bind(m)) || ((s = (r = m == null ? void 0 : m.proxy) == null ? void 0 : r.$emit) == null ? void 0 : s.bind(m == null ? void 0 : m.proxy));
  let h = u;
  e || (e = "modelValue"), h = h || `update:${e.toString()}`;
  const c = ($) => n ? typeof n == "function" ? n($) : Zs($) : $, g = () => Fs(t[e]) ? c(t[e]) : p, v = ($) => {
    f ? f($) && y(h, $) : y(h, $);
  };
  if (i) {
    const $ = g(), B = x($);
    let C = !1;
    return ue(
      () => t[e],
      (V) => {
        C || (C = !0, B.value = c(V), Ve(() => C = !1));
      }
    ), ue(
      B,
      (V) => {
        !C && (V !== t[e] || d) && v(V);
      },
      { deep: d }
    ), B;
  } else
    return w({
      get() {
        return g();
      },
      set($) {
        v($);
      }
    });
}
const pr = ["id"], mr = ["id"], br = ["innerHTML"], yr = ["innerHTML"], Ka = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BPopover",
  props: /* @__PURE__ */ pe({
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    click: { type: Boolean, default: !1 },
    content: { default: void 0 },
    customClass: { default: "" },
    delay: { default: () => ({ show: 100, hide: 300 }) },
    floatingMiddleware: { default: void 0 },
    hide: { type: Boolean, default: void 0 },
    html: { type: Boolean, default: !1 },
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    manual: { type: Boolean, default: !1 },
    modelValue: { type: Boolean },
    noAutoClose: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    noFlip: { type: Boolean, default: !1 },
    noHide: { type: Boolean, default: !1 },
    noShift: { type: Boolean, default: !1 },
    noSize: { type: Boolean, default: !1 },
    noninteractive: { type: Boolean, default: !1 },
    offset: { default: null },
    placement: { default: "top" },
    persistent: { type: Boolean, default: !1 },
    realtime: { type: Boolean, default: !1 },
    reference: { default: null },
    strategy: { default: "absolute" },
    target: { default: null },
    title: { default: void 0 },
    tooltip: { type: Boolean, default: !1 },
    variant: { default: null },
    teleportDisabled: { default: !1 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = he(t, "modelValue"), s = x(r.value), n = x(r.value);
    Rt(() => {
      r.value = s.value;
    }), ue(r, (q) => {
      q !== s.value && (q ? A() : X(new Event("update:modelValue")));
    });
    const i = Be(() => a.id, "popover"), u = x(!1), d = x(null), p = x(null), f = x(null), m = x(null), y = x(null), h = w(
      () => a.title ? Tt(a.title, $t) : ""
    ), c = w(
      () => a.content ? Tt(a.content, $t) : ""
    ), g = k(() => a.placement.startsWith("auto")), v = be(() => a.offset ?? NaN), $ = w(
      () => a.boundary === "document" || a.boundary === "viewport" ? void 0 : a.boundary
    ), B = w(
      () => a.boundary === "document" || a.boundary === "viewport" ? a.boundary : void 0
    ), C = x({}), V = w(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const q = a.offset !== null ? v.value : a.tooltip ? 6 : 8, se = [Xl(q)];
      return a.noFlip === !1 && !g.value && se.push(
        no({
          boundary: $.value,
          rootBoundary: B.value,
          padding: a.boundaryPadding
        })
      ), g.value && se.push(
        Cs({
          alignment: a.placement.split("-")[1] || void 0,
          boundary: $.value,
          rootBoundary: B.value,
          padding: a.boundaryPadding
        })
      ), a.noShift === !1 && se.push(
        oo({
          boundary: $.value,
          rootBoundary: B.value,
          padding: a.boundaryPadding
        })
      ), a.noHide === !1 && se.push(
        ks({
          boundary: $.value,
          rootBoundary: B.value,
          padding: a.boundaryPadding
        })
      ), a.inline === !0 && se.push(Ts()), se.push(Vs({ element: f, padding: 10 })), a.noSize === !1 && se.push(
        so({
          boundary: $.value,
          rootBoundary: B.value,
          padding: a.boundaryPadding,
          apply({ availableWidth: me, availableHeight: te }) {
            C.value = {
              maxHeight: te ? `${te}px` : void 0,
              maxWidth: me ? `${me}px` : void 0
            };
          }
        })
      ), se;
    }), L = k(
      () => g.value ? void 0 : a.placement
    ), { floatingStyles: Q, middlewareData: W, placement: F, update: Z } = io(p, d, {
      placement: L,
      middleware: V,
      strategy: k(() => a.strategy),
      whileElementsMounted: (...q) => lo(...q, { animationFrame: a.realtime })
    }), R = x({ position: "absolute" });
    ue(W, () => {
      var q;
      if (a.noHide === !1 && ((q = W.value.hide) != null && q.referenceHidden ? u.value = !0 : u.value = !1), W.value.arrow) {
        const { x: se, y: me } = W.value.arrow;
        R.value = {
          position: "absolute",
          top: me ? `${me}px` : "",
          left: se ? `${se}px` : ""
        };
      }
    });
    const le = w(() => {
      const q = a.tooltip ? "tooltip" : "popover";
      return [
        q,
        `b-${q}`,
        {
          [`b-${q}-${a.variant}`]: a.variant !== null,
          show: s.value && !u.value,
          "pe-none": !s.value,
          fade: !a.noFade,
          "d-none": !s.value && a.noFade,
          [`${a.customClass}`]: a.customClass !== void 0,
          [`bs-${q}-${hr(F.value)}`]: F.value !== void 0
        }
      ];
    }), { isOutside: N } = gl(d), { isOutside: S } = gl(m), P = (q) => {
      const se = q ?? new Event("click");
      s.value ? X(se) : A();
    }, M = (q, se = {}) => new Bt(q, {
      cancelable: !1,
      target: d.value || null,
      relatedTarget: null,
      trigger: null,
      ...se,
      componentId: i.value
    });
    let j;
    const A = () => {
      const q = M("show", { cancelable: !0 });
      if (o("show", q), q.defaultPrevented) {
        o("show-prevented");
        return;
      }
      n.value = !0, Ve(() => {
        var se;
        Z(), j = setTimeout(
          () => {
            Z(), s.value = !0, Ve(() => {
              o("shown", M("shown"));
            });
          },
          typeof a.delay == "number" ? a.delay : ((se = a.delay) == null ? void 0 : se.show) || 0
        );
      });
    }, X = (q) => {
      var te;
      const se = M("hide", { cancelable: !0 });
      if (o("hide", se), se.defaultPrevented) {
        o("hide-prevented");
        return;
      }
      j && (clearTimeout(j), j = void 0);
      const me = typeof a.delay == "number" ? a.delay : ((te = a.delay) == null ? void 0 : te.hide) || 0;
      setTimeout(() => {
        var ye, ee;
        (q == null ? void 0 : q.type) === "click" || (q == null ? void 0 : q.type) === "forceHide" || (q == null ? void 0 : q.type) === "update:modelValue" && a.manual || !a.noninteractive && N.value && S.value && !((ye = d.value) != null && ye.contains(document == null ? void 0 : document.activeElement)) && !((ee = m.value) != null && ee.contains(document == null ? void 0 : document.activeElement)) || a.noninteractive && S.value ? (s.value = !1, Ve(() => {
          setTimeout(
            () => {
              n.value = !1;
            },
            d.value ? wa(d.value) : 150
          ), o("hidden", M("hidden"));
        })) : setTimeout(
          () => {
            X(q);
          },
          me < 50 ? 50 : me
        );
      }, me);
    };
    e({
      hide: X,
      show: A,
      toggle: P
    });
    const G = () => {
      var q;
      if (a.target) {
        const se = mt(a.target);
        se ? m.value = se : console.warn("Target element not found", a.target);
      } else
        m.value = (q = y.value) == null ? void 0 : q.nextElementSibling;
      if (a.reference) {
        const se = mt(a.reference);
        se ? p.value = se : console.warn("Reference element not found", a.reference);
      } else
        p.value = m.value;
      if (!(!m.value || a.manual) && za) {
        if (m.value.addEventListener("forceHide", X), a.click) {
          m.value.addEventListener("click", P);
          return;
        }
        m.value.addEventListener("pointerenter", A), m.value.addEventListener("pointerleave", X), m.value.addEventListener("focus", A), m.value.addEventListener("blur", X);
      }
    }, ie = () => {
      m.value && (m.value.removeEventListener("forceHide", X), m.value.removeEventListener("click", P), m.value.removeEventListener("pointerenter", A), m.value.removeEventListener("pointerleave", X), m.value.removeEventListener("focus", A), m.value.removeEventListener("blur", X));
    };
    return bo(
      d,
      () => {
        s.value && a.click && !a.noAutoClose && !a.manual && X(new Event("clickOutside"));
      },
      { ignore: [m] }
    ), ue([() => a.click, () => a.target, () => a.reference], () => {
      ie(), G();
    }), Xe(G), Fa(ie), (q, se) => (b(), _(de, null, [
      J("span", {
        id: O(i) + "_placeholder",
        ref_key: "placeholder",
        ref: y
      }, null, 8, pr),
      T(q.$slots, "target", {
        show: A,
        hide: X,
        toggle: P,
        showState: s.value
      }),
      (b(), I(ht, {
        to: q.teleportTo,
        disabled: !q.teleportTo || q.teleportDisabled
      }, [
        n.value || a.persistent ? (b(), _("div", K({
          key: 0,
          id: O(i)
        }, q.$attrs, {
          ref_key: "element",
          ref: d,
          class: le.value,
          role: "tooltip",
          tabindex: "-1",
          style: O(Q)
        }), [
          J("div", {
            ref_key: "arrow",
            ref: f,
            class: D(`${a.tooltip ? "tooltip" : "popover"}-arrow`),
            style: Ee(R.value),
            "data-popper-arrow": ""
          }, null, 6),
          J("div", {
            class: "overflow-auto",
            style: Ee(C.value)
          }, [
            q.title || q.$slots.title ? (b(), _(de, { key: 0 }, [
              a.html ? (b(), _("div", {
                key: 1,
                class: D(["position-sticky top-0", a.tooltip ? "tooltip-inner" : "popover-header"]),
                innerHTML: h.value
              }, null, 10, br)) : (b(), _("div", {
                key: 0,
                class: D(["position-sticky top-0", a.tooltip ? "tooltip-inner" : "popover-header"])
              }, [
                T(q.$slots, "title", {}, () => [
                  ne(Y(q.title), 1)
                ])
              ], 2))
            ], 64)) : ae("", !0),
            a.tooltip && !q.$slots.title && !q.title || !a.tooltip ? (b(), _(de, { key: 1 }, [
              a.html ? (b(), _("div", {
                key: 1,
                class: D(a.tooltip ? "tooltip-inner" : "popover-body"),
                innerHTML: c.value
              }, null, 10, yr)) : (b(), _("div", {
                key: 0,
                class: D(a.tooltip ? "tooltip-inner" : "popover-body")
              }, [
                T(q.$slots, "default", {}, () => [
                  ne(Y(q.content), 1)
                ])
              ], 2))
            ], 64)) : ae("", !0)
          ], 4)
        ], 16, mr)) : ae("", !0)
      ], 8, ["to", "disabled"]))
    ], 64));
  }
}), gr = ({
  top: t,
  end: e,
  start: l,
  alignCenter: a,
  alignEnd: o
}) => {
  const r = t ? "top" : l ? "left" : e ? "right" : "bottom", s = o ? "end" : a ? null : "start";
  return `${r}${s ? `-${s}` : ""}`;
}, hr = (t) => {
  const [e] = t.split("-");
  switch (e) {
    case "left":
      return "start";
    case "right":
      return "end";
    default:
      return e;
  }
}, Ht = (t) => typeof t != "object" || t.active !== !1, oa = (t, e) => {
  if (!Ht(t))
    return {};
  const a = typeof t > "u" || typeof t == "object" && !t.title && !t.content, o = e.getAttribute("title") || e.getAttribute("data-original-title");
  return a ? o ? (e.removeAttribute("title"), e.setAttribute("data-original-title", o), {
    content: Tt(o, $t)
  }) : {} : typeof t == "string" ? {
    content: Tt(t, $t)
  } : {
    title: t != null && t.title ? Tt(t == null ? void 0 : t.title, $t) : void 0,
    content: t != null && t.content ? Tt(t == null ? void 0 : t.content, $t) : void 0
  };
}, na = (t, e) => ({
  target: e,
  modelValue: t.modifiers.show,
  inline: t.modifiers.inline,
  click: t.modifiers.click,
  realtime: t.modifiers.realtime,
  persistent: t.modifiers.persistent,
  placement: t.modifiers.left ? "left" : t.modifiers.right ? "right" : t.modifiers.bottom ? "bottom" : t.modifiers.top ? "top" : void 0,
  html: !0,
  ...typeof t.value == "object" ? t.value : {},
  ...t.modifiers.interactive ? { noninteractive: !1 } : {},
  title: null,
  content: null
}), sa = (t, e, l) => {
  var o;
  const a = document.createElement("span");
  e.modifiers.body ? document.body.appendChild(a) : e.modifiers.child ? t.appendChild(a) : (o = t.parentNode) == null || o.insertBefore(a, t.nextSibling), Dl(Ne(Ka, l), a), t.$__element = a;
}, ra = (t) => {
  const e = t.$__element;
  e && Dl(null, e), setTimeout(() => {
    e == null || e.remove();
  }, 0), delete t.$__element;
}, go = (t, e, l) => {
  const a = qe(t, e);
  return l && typeof l == "function" ? l(a, e, t) : a;
}, fa = (t, e, l) => e.concat(["sm", "md", "lg", "xl", "xxl"]).reduce((a, o) => (a[t ? `${t}${o.charAt(0).toUpperCase() + o.slice(1)}` : o] = l, a), {}), ho = (t, e, l, a = l) => Object.keys(e).reduce((o, r) => (t[r] && o.push(
  [a, r.replace(l, ""), t[r]].filter((s) => s && typeof s != "boolean").join("-").toLowerCase()
), o), []), mt = (t) => {
  if (t)
    return typeof t == "string" ? typeof document > "u" ? void 0 : document.getElementById(t) ?? document.querySelector(t) ?? void 0 : t.$el ?? t;
}, Br = (t, e) => ((t == null ? void 0 : t()) ?? []).reduce((l, a) => (typeof a.type == "symbol" ? l = l.concat(a.children) : l.push(a), l), []).filter((l) => {
  var a;
  return ((a = l.type) == null ? void 0 : a.__name) === e;
}), Bo = /_/g, wo = /([a-z])([A-Z])/g, wr = /^[0-9]*\.?[0-9]+$/, Cr = /(\s|^)(\w)/g, kr = /(\s|^)(\w)/, Zt = /\s+/, $r = /^#/, Tr = /^#[A-Za-z]+[\w\-:.]*$/, Sr = /[-/\\^$*+?.()|[\]{}]/g, _r = /[\s\uFEFF\xA0]+/g, ya = (t) => t.replace(Bo, " ").replace(wo, (e, l, a) => `${l} ${a}`).replace(kr, (e, l, a) => l + a.toUpperCase()), hl = (t) => t.replace(Bo, " ").replace(wo, (e, l, a) => `${l} ${a}`).replace(Cr, (e, l, a) => l + a.toUpperCase()), Vr = (t) => {
  const e = t.trim();
  return e.charAt(0).toUpperCase() + e.slice(1);
}, Ar = (t) => t.replace(Sr, "\\$&"), Or = (t) => Ar(t).replace(_r, "\\s"), Jt = (t) => typeof t == "string" ? hl(t) : t.label !== void 0 ? t.label : typeof t.key == "string" ? hl(t.key) : t.key, Nr = (t) => !!(t.href || t.to), Co = Symbol("carousel"), ko = Symbol("tabs"), $o = Symbol("progress"), To = Symbol("listGroup"), So = Symbol("avatarGroup"), _o = Symbol("accordion"), Vo = Symbol("checkboxGroup"), Ao = Symbol("radioGroup"), Xa = Symbol("collapse"), Oo = Symbol("collapse"), Ya = Symbol("navbar"), No = Symbol("toastPlugin"), Io = Symbol("rtlPlugin"), Po = Symbol("breadcrumbPlugin"), Eo = Symbol("modalControllerPlugin"), Fo = Symbol("modalManagerPlugin"), Lo = Symbol("idPluginKey"), Et = (t, e = {}, l = {}) => {
  const a = [t];
  let o;
  for (let r = 0; r < a.length && !o; r++) {
    const s = a[r];
    o = l[s];
  }
  return o && typeof o == "function" ? o(e) : o;
}, va = (t, e) => Object.keys(t).filter((l) => !e.map((a) => a.toString()).includes(l)).reduce((l, a) => ({ ...l, [a]: t[a] }), {}), Za = (t, e) => [...e].reduce(
  (l, a) => (l[a] = t[a], l),
  {}
), qe = (t, e, l) => {
  const a = e.split(/[.[\]]/g);
  let o = t;
  for (const r of a) {
    if (o === null || o === void 0)
      return l;
    r.trim() !== "" && (o = o[r]);
  }
  return o === void 0 ? l : o;
}, Ir = (t, e, l) => {
  const a = (i) => {
    if (((p) => p == null || typeof p != "object" && typeof p != "function")(i))
      return i;
    if (typeof i == "function")
      return i.bind({});
    const d = new i.constructor();
    return Object.getOwnPropertyNames(i).forEach((p) => {
      d[p] = i[p];
    }), d;
  }, o = (i, u) => {
    const d = u === void 0 ? 0 : u;
    if (i == null)
      return d;
    const p = Number.parseInt(i);
    return Number.isNaN(p) ? d : p;
  };
  if (!t)
    return {};
  if (!e || l === void 0)
    return t;
  const r = e.split(/[.[\]]/g).filter((i) => !!i.trim()), s = (i) => {
    if (r.length > 1) {
      const u = r.shift(), d = o(r[0], null) !== null;
      i[u] = i[u] === void 0 ? d ? [] : {} : i[u], s(i[u]);
    } else
      i[r[0]] = l;
  }, n = a(t);
  return s(n), n;
}, Bl = (t, e) => {
  const { all: l, ...a } = t, o = {};
  l && e.forEach((s) => {
    o[s] = l;
  });
  const r = { ...o, ...a };
  return Object.entries(r).filter(([s, n]) => !!n && e.includes(s)).map(([s]) => s);
}, wl = (t, e) => e + (t ? Vr(t) : ""), wt = (t, e) => {
  const l = k(e), a = k(t), o = k(() => Nr(a.value)), r = w(
    () => o.value ? Za(
      a.value,
      l.value ?? [
        "active",
        "activeClass",
        "append",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover"
      ]
    ) : {}
  );
  return { computedLink: o, computedLinkProps: r };
}, zo = () => ({ ..._e(Po) }), Pr = (t = {}) => {
  const e = t.persist ?? !1, l = "data-bs-theme", a = "body";
  return or({
    attribute: l,
    selector: a,
    storageKey: e === !0 ? `bv-color-${t.attribute ?? l}-${t.selector ?? a}` : null,
    ...t
  });
}, et = (t) => w(() => {
  let e = Se(t);
  return e = {
    ...e,
    variant: e.variant ?? null,
    bgVariant: e.bgVariant ?? null,
    textVariant: e.textVariant ?? null
  }, {
    [`text-bg-${e.variant}`]: e.variant !== null,
    [`text-${e.textVariant}`]: e.textVariant !== null && e.variant === null,
    [`bg-${e.bgVariant}`]: e.bgVariant !== null && e.variant === null
  };
}), Er = (t) => w(() => {
  const e = Se(t);
  return {
    container: e === !0,
    [`container-${e}`]: typeof e == "string"
  };
}), Ho = (t, e = x(1e3), l = {}) => {
  const a = We(k(t)), o = We(k(e)), r = x(!1), s = x(0), n = k(() => Math.ceil(a.value / o.value)), i = k(
    () => p.value || r.value ? Math.round(a.value - s.value * o.value) : 0
  ), { pause: u, resume: d, isActive: p } = mo(
    () => {
      s.value = s.value + 1;
    },
    e,
    l
  ), f = () => {
    r.value = !1, s.value = 0, d();
  }, m = () => {
    r.value = !1, s.value = n.value;
  };
  Rt(() => {
    s.value > n.value && (s.value = n.value), s.value === n.value && u();
  }), ue([o, a], () => {
    m(), f();
  });
  const y = () => {
    p.value !== !1 && (r.value = !0, u());
  }, h = () => {
    s.value !== n.value && (r.value = !1, d());
  };
  return {
    isActive: We(p),
    isPaused: We(r),
    restart: f,
    stop: m,
    pause: y,
    resume: h,
    value: i
  };
}, Ct = (t) => w(() => {
  const e = Se(t);
  return e === !0 ? "is-valid" : e === !1 ? "is-invalid" : null;
}), Ro = (t) => w(() => {
  const e = Se(t);
  return {
    "form-check": e.plain === !1 && e.button === !1 && e.hasDefaultSlot,
    "form-check-reverse": e.reverse === !0,
    "form-check-inline": e.inline === !0,
    "form-switch": e.switch === !0,
    [`form-control-${e.size}`]: e.size !== void 0 && e.size !== "md" && e.button === !1
  };
}), Mo = (t) => {
  const e = k(t), l = Ct(() => e.value.state ?? null);
  return w(() => [
    l.value,
    {
      "form-check-input": e.value.plain === !1 && e.value.button === !1,
      "btn-check": e.value.button === !0
    }
  ]);
}, xo = (t) => w(() => {
  const e = Se(t);
  return {
    "form-check-label": e.plain === !1 && e.button === !1,
    btn: e.button === !0,
    [`btn-${e.buttonVariant}`]: e.button === !0 && e.buttonVariant !== void 0 && e.buttonVariant !== null,
    [`btn-${e.size}`]: e.button && e.size && e.size !== "md"
  };
}), Do = (t) => {
  const e = k(t), l = ua(
    () => e.value.ariaInvalid,
    () => e.value.state
  );
  return w(() => ({
    "aria-invalid": l.value,
    "aria-required": e.value.required === !0 ? !0 : void 0
  }));
}, jo = (t) => w(() => {
  const e = Se(t);
  return {
    "was-validated": e.validated === !0,
    "btn-group": e.buttons === !0 && e.stacked === !1,
    "btn-group-vertical": e.stacked === !0 && e.buttons === !0,
    [`btn-group-${e.size}`]: e.size !== void 0
  };
}), Be = (t, e) => w(() => Se(t) || Fr(e)), Fr = (t = "") => `__BVID__${_e(Lo, () => Math.random().toString().slice(2, 8))()}___BV_${t}__`, qo = (t, e) => {
  const l = x(null), a = vr(t, "modelValue", e, { passive: !0 }), o = Be(() => t.id, "input"), r = be(() => t.debounce ?? 0), s = be(() => t.debounceMaxWait ?? NaN), n = Ws(
    (v) => {
      a.value = v;
    },
    () => t.lazy === !0 ? 0 : r.value,
    { maxWait: () => t.lazy === !0 ? NaN : s.value }
  ), i = (v, $ = !1) => {
    t.lazy === !0 && $ === !1 || n(v);
  }, { focused: u } = Pe(l, {
    initialValue: t.autofocus
  }), d = (v, $, B = !1) => t.formatter !== void 0 && (!t.lazyFormatter || B) ? t.formatter(v, $) : v, p = (v) => t.trim ? v.trim() : t.number ? Number.parseFloat(v) : v;
  Xe(() => {
    var v;
    l.value && (l.value.value = ((v = a.value) == null ? void 0 : v.toString()) ?? "");
  }), Vn(() => {
    Ve(() => {
      t.autofocus && (u.value = !0);
    });
  });
  const f = ua(
    () => t.ariaInvalid,
    () => t.state
  );
  return {
    input: l,
    computedId: o,
    computedAriaInvalid: f,
    onInput: (v) => {
      const { value: $ } = v.target, B = d($, v);
      if (v.defaultPrevented) {
        v.preventDefault();
        return;
      }
      const C = p(B);
      i(C);
    },
    onChange: (v) => {
      const { value: $ } = v.target, B = d($, v);
      if (v.defaultPrevented) {
        v.preventDefault();
        return;
      }
      const C = p(B);
      a.value !== C && i(B, !0);
    },
    onBlur: (v) => {
      if (!t.lazy && !t.lazyFormatter)
        return;
      const { value: $ } = v.target, B = d($, v, !0), C = p(B);
      a.value !== C && i(B, !0);
    },
    focus: () => {
      t.disabled || (u.value = !0);
    },
    blur: () => {
      t.disabled || (u.value = !1);
    }
  };
}, Wo = (t, e) => {
  const l = (s) => typeof s == "object" && s !== null && "label" in s, a = (s) => {
    if (typeof s == "string")
      return { value: s, text: s };
    if (typeof s == "number")
      return { value: s, text: `${s}` };
    if (s instanceof Date)
      return { value: s, text: s.toLocaleString() };
    const n = qe(s, e.valueField), i = qe(s, e.textField), u = qe(s, e.htmlField), d = qe(s, e.disabledField), p = e.optionsField ? qe(s, e.optionsField) : void 0;
    return p !== void 0 ? {
      label: qe(s, e.labelField) || i,
      options: p
    } : {
      value: n,
      text: i,
      html: u,
      disabled: d
    };
  }, o = (s) => s.map((n) => a(n));
  return { normalizedOptions: w(() => o(Se(t))), isComplex: l };
}, ga = "modal-open", Ja = () => {
  const t = _e(Fo), e = (a) => {
    t == null || t.removeStack(a), t == null || t.removeRegistry(a);
  }, l = Ga("updateHTMLAttrs", (a, o, r) => {
    const s = typeof a == "string" ? window == null ? void 0 : window.document.querySelector(a) : Me(a);
    s && (o === "class" ? s.classList.toggle(ga, r === ga) : s.setAttribute(o, r));
  });
  return it(() => {
    l("body", "class", "");
  }), ue(
    () => t == null ? void 0 : t.countStack.value,
    (a) => {
      a !== void 0 && l("body", "class", a > 0 ? ga : "");
    }
  ), {
    ...t,
    dispose: e
  };
}, Lr = (t) => {
  const { pushRegistry: e, pushStack: l, removeStack: a, stack: o, dispose: r, countStack: s } = Ja(), n = gt();
  if (!n || n.type.__name !== "BModal")
    throw new Error("useModalManager must only use in BModal component");
  return e == null || e(n), it(() => {
    r(n);
  }), ue(
    t,
    (i, u) => {
      i ? l == null || l(n) : u && !i && (a == null || a(n));
    },
    { immediate: !0 }
  ), {
    activePosition: w(
      () => o == null ? void 0 : o.value.findIndex((i) => {
        var u, d;
        return ((u = i.exposed) == null ? void 0 : u.id) === ((d = n.exposed) == null ? void 0 : d.id);
      })
    ),
    activeModalCount: s
  };
}, zr = (t = void 0) => {
  const { registry: e } = Ja(), l = gt(), a = (s) => s.parent ? s.parent.type.__name === "BModal" ? s.parent : a(s.parent) : null, o = w(() => {
    const s = Se(t);
    return s ? (e == null ? void 0 : e.value.find((n) => {
      var i;
      return ((i = n.exposed) == null ? void 0 : i.id.value) === s;
    })) || null : l ? a(l) : null;
  }), r = k(() => {
    var s;
    return (s = o.value) == null ? void 0 : s.proxy;
  });
  return {
    show() {
      var s, n;
      (n = (s = o.value) == null ? void 0 : s.exposed) == null || n.show();
    },
    hide(s = "") {
      var n, i;
      (i = (n = o.value) == null ? void 0 : n.exposed) == null || i.hide(s);
    },
    modal: r
  };
}, Go = () => {
  const { lastStack: t, stack: e } = Ja();
  return {
    ..._e(Eo),
    hide: (r = "") => {
      var s;
      t != null && t.value && ((s = t == null ? void 0 : t.value.exposed) == null || s.hide(r));
    },
    hideAll: (r = "") => {
      e == null || e.value.forEach((s) => {
        var n;
        (n = s.exposed) == null || n.hide(r);
      });
    }
    // Todo: Supports listening events globally in the future
  };
}, ia = (t, e = "px") => w(() => {
  const l = Se(t), a = Se(e);
  return wr.test(String(l)) ? `${Number(l)}${a}` : l;
}), Qa = (t) => {
  const e = (l, a) => {
    const o = a === null ? "" : `${a}-`;
    return l === "circle" ? `${o}rounded-circle` : l === "pill" ? `${o}rounded-pill` : typeof l == "number" || l === "0" || l === "1" || l === "2" || l === "3" || l === "4" || l === "5" ? `${o}rounded-${l}` : l === "none" ? `${o}rounded-0` : l === "sm" ? `${o}rounded-1` : l === "lg" ? `${o}rounded-5` : `${o}rounded`;
  };
  return w(() => {
    const l = Se(t);
    return {
      [`${e(l.rounded, null)}`]: !!l.rounded,
      [`${e(l.roundedTop, "top")}`]: !!l.roundedTop,
      [`${e(l.roundedBottom, "bottom")}`]: !!l.roundedBottom,
      [`${e(l.roundedStart, "start")}`]: !!l.roundedStart,
      [`${e(l.roundedEnd, "end")}`]: !!l.roundedEnd
    };
  });
}, Hr = () => {
  const t = _e(Io);
  return Xe(() => {
    ue(
      [() => t == null ? void 0 : t.isRtl.value, () => t == null ? void 0 : t.locale.value],
      ([e, l]) => {
        const a = document.documentElement;
        a.setAttribute("dir", e ?? !1 ? "rtl" : "ltr"), a.setAttribute("lang", l ?? "");
      },
      { immediate: !0 }
    );
  }), { ...t };
}, Uo = (t, e) => {
  const l = We(k(t)), a = We(k(e)), o = k(() => !a.value);
  Xe(() => {
    const r = dr(
      document.body,
      l.value && o.value
    );
    ue([l, o], ([s, n]) => {
      r.value = s && n;
    });
  });
}, Ko = (t, e, l = {}) => {
  const a = k(t), o = k(e), r = x(mt(a.value)), s = x(mt(o.value));
  ue([a, o], () => {
    v();
  });
  const {
    contentQuery: n = ":scope > [id]",
    targetQuery: i = "[href]",
    manual: u = !1,
    root: d,
    rootMargin: p = "0px 0px -25%",
    threshold: f = [0.1, 0.5, 1],
    watchChanges: m = !0
  } = l, y = x(null), h = x([]), c = x([]);
  gt() ? Xe(() => {
    Sa(a, r, {
      transform: {
        ltr: (F) => mt(F)
      },
      direction: "ltr",
      immediate: !0
    }), Sa(o, s, {
      transform: {
        ltr: (F) => mt(F)
      },
      direction: "ltr",
      immediate: !0
    }), v();
  }) : Ve(() => {
    v();
  });
  const v = () => {
    c.value = r.value ? Array.from(r.value.querySelectorAll(n)) : [], h.value = c.value.map((F) => ({
      id: F.id,
      el: F,
      visible: !1,
      text: F.textContent
    }));
  };
  let $ = !0, B = 0;
  const C = w(
    () => r.value && getComputedStyle(r.value).overflowY === "visible" ? null : r.value
  ), V = sr(
    c,
    (F) => {
      var le, N, S, P;
      const Z = (le = C.value || (document == null ? void 0 : document.documentElement)) == null ? void 0 : le.scrollTop;
      $ = Z > B, B = Z, F.forEach((M) => {
        if (M.isIntersecting) {
          h.value.forEach((j) => {
            j.el === M.target && (j.visible = !0);
          });
          return;
        }
        h.value.forEach((j) => {
          j.el === M.target && (j.visible = !1);
        });
      });
      let R = null;
      $ ? R = ((N = [...h.value].reverse().find((M) => M.visible)) == null ? void 0 : N.id) || null : R = ((S = h.value.find((M) => M.visible)) == null ? void 0 : S.id) || null, R !== null && (y.value = R), y.value || (y.value = ((P = h.value[0]) == null ? void 0 : P.id) || null);
    },
    {
      root: d ? mt(d) : C,
      rootMargin: p,
      threshold: f
    }
  );
  ue(y, (F) => {
    var N;
    if (u)
      return;
    const Z = (N = s.value) == null ? void 0 : N.querySelectorAll(i);
    if (Z === void 0)
      return;
    let R = !1, le = null;
    Z.forEach((S) => {
      var M, j, A, X, G, ie, q, se, me, te, ye;
      const P = S.closest(".dropdown");
      if ((M = S.getAttribute("href")) != null && M.includes(`#${F}`)) {
        le = S, S.classList.add("active"), P && ((j = P == null ? void 0 : P.querySelector(".dropdown-toggle")) == null || j.classList.add("active"), R = !0);
        let ee = (A = S.closest(".nav")) == null ? void 0 : A.previousSibling;
        for (; (X = ee == null ? void 0 : ee.classList) != null && X.contains("nav-item"); )
          R = !0, (G = ee.querySelector(".nav-link")) == null || G.classList.add("active"), ee = (ie = ee.closest(".nav")) == null ? void 0 : ie.previousSibling;
      } else if (S.classList.remove("active"), P && !R && ((q = P == null ? void 0 : P.querySelector(".dropdown-toggle")) == null || q.classList.remove("active")), !R) {
        let ee = (se = S.closest(".nav")) == null ? void 0 : se.previousSibling;
        for (; (me = ee == null ? void 0 : ee.classList) != null && me.contains("nav-item"); )
          R = !0, ee.querySelector(".nav-link") !== le && ((te = ee.querySelector(".nav-link")) == null || te.classList.remove("active")), ee = (ye = ee.closest(".nav")) == null ? void 0 : ye.previousSibling;
      }
    });
  });
  const L = m ? nr(
    r,
    () => {
      v();
    },
    {
      childList: !0
    }
  ) : { stop: () => {
  } }, Q = (F, Z = !1) => {
    var N, S;
    F.preventDefault();
    const R = (S = (N = F.target) == null ? void 0 : N.getAttribute) == null ? void 0 : S.call(N, "href"), le = R ? document == null ? void 0 : document.querySelector(R) : null;
    le && r.value && (r.value.scrollTo ? r.value.scrollTo({ top: le.offsetTop, behavior: Z ? "smooth" : "auto" }) : r.value.scrollTop = le.offsetTop);
  }, W = () => {
    V.stop(), L.stop();
  };
  return {
    current: We(y),
    list: h,
    content: r,
    target: s,
    scrollIntoView: Q,
    updateList: v,
    cleanup: W
  };
}, Xo = () => ({ ..._e(No) }), It = /* @__PURE__ */ H({
  __name: "BTransition",
  props: {
    appear: { type: Boolean, default: !1 },
    mode: { default: void 0 },
    noFade: { type: Boolean, default: !1 },
    transProps: { default: void 0 }
  },
  emits: ["after-appear", "after-enter", "after-leave", "appear", "before-appear", "before-enter", "before-leave", "enter", "appear-cancelled", "enter-cancelled", "leave", "leave-cancelled"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = w(() => {
      const s = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: ""
      }, n = {
        ...s,
        enterActiveClass: "fade showing",
        leaveActiveClass: "fade showing"
      };
      return l.noFade ? s : n;
    }), r = w(() => ({ mode: l.mode, css: !0, ...o.value }));
    return (s, n) => (b(), I(An, K({ ...r.value, ...s.transProps }, {
      appear: l.appear,
      onAfterAppear: n[0] || (n[0] = (i) => a("after-appear", i)),
      onAfterEnter: n[1] || (n[1] = (i) => a("after-enter", i)),
      onAfterLeave: n[2] || (n[2] = (i) => a("after-leave", i)),
      onAppear: n[3] || (n[3] = (i) => a("appear", i)),
      onBeforeAppear: n[4] || (n[4] = (i) => a("before-appear", i)),
      onBeforeEnter: n[5] || (n[5] = (i) => a("before-enter", i)),
      onBeforeLeave: n[6] || (n[6] = (i) => a("before-leave", i)),
      onEnter: n[7] || (n[7] = (i) => a("enter", i)),
      onAppearCancelled: n[8] || (n[8] = (i) => a("appear-cancelled", i)),
      onEnterCancelled: n[9] || (n[9] = (i) => a("enter-cancelled", i)),
      onLeave: n[10] || (n[10] = (i) => a("leave", i)),
      onLeaveCancelled: n[11] || (n[11] = (i) => a("leave-cancelled", i))
    }), {
      default: E(() => [
        T(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["appear"]));
  }
}), Rr = ["type", "disabled", "aria-label"], Pt = /* @__PURE__ */ H({
  __name: "BCloseButton",
  props: {
    ariaLabel: { default: "Close" },
    disabled: { type: Boolean, default: !1 },
    type: { default: "button" }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const l = t, a = e;
    return (o, r) => (b(), _("button", {
      type: o.type,
      class: "btn-close",
      disabled: l.disabled,
      "aria-label": o.ariaLabel,
      onClick: r[0] || (r[0] = (s) => a("click", s))
    }, null, 8, Rr));
  }
}), Cl = "active", ot = /* @__PURE__ */ H({
  __name: "BLink",
  props: {
    active: { type: Boolean, default: void 0 },
    activeClass: { default: "router-link-active" },
    append: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    exactActiveClass: { default: "router-link-exact-active" },
    href: { default: void 0 },
    icon: { type: Boolean, default: !1 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: !1 },
    routerComponentName: { default: "router-link" },
    routerTag: { default: "a" },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: null },
    variant: { default: null }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = Mt(), r = _e(Xa, null), s = _e(Ya, null), n = gt(), i = w(() => {
      const y = l.routerComponentName.split("-").map((c) => c.charAt(0).toUpperCase() + c.slice(1)).join("");
      return !((n == null ? void 0 : n.appContext.app.component(y)) !== void 0) || l.disabled || !l.to ? "a" : l.routerComponentName;
    }), u = w(() => {
      const y = "#";
      if (l.href)
        return l.href;
      if (typeof l.to == "string")
        return l.to || y;
      const { to: h } = l;
      if (h !== void 0 && "path" in h) {
        const c = h.path || "", g = h.query ? `?${Object.keys(h.query).map(($) => {
          var B;
          return `${$}=${(B = h.query) == null ? void 0 : B[$]}`;
        }).join("=")}` : "", v = !h.hash || h.hash.charAt(0) === "#" ? h.hash || "" : `#${h.hash}`;
        return `${c}${g}${v}` || y;
      }
      return y;
    }), d = w(() => ({
      [`link-${l.variant}`]: l.variant !== null,
      [`link-opacity-${l.opacity}`]: l.opacity !== void 0,
      [`link-opacity-${l.opacityHover}-hover`]: l.opacityHover !== void 0,
      [`link-underline-${l.underlineVariant}`]: l.underlineVariant !== null,
      [`link-offset-${l.underlineOffset}`]: l.underlineOffset !== void 0,
      [`link-offset-${l.underlineOffsetHover}-hover`]: l.underlineOffsetHover !== void 0,
      [`link-underline-opacity-${l.underlineOpacity}`]: l.underlineOpacity !== void 0,
      [`link-underline-opacity-${l.underlineOpacityHover}-hover`]: l.underlineOpacityHover !== void 0,
      "icon-link": l.icon === !0
    })), p = w(() => ({
      class: d.value,
      to: l.to,
      href: u.value,
      target: l.target,
      rel: l.target === "_blank" ? l.rel ?? "noopener" : void 0,
      tabindex: l.disabled ? "-1" : typeof o.tabindex > "u" ? null : o.tabindex,
      "aria-disabled": l.disabled ? !0 : null
    })), f = w(() => ({
      [Cl]: l.active,
      disabled: l.disabled
    })), m = (y) => {
      var h, c, g;
      if (l.disabled) {
        y.preventDefault(), y.stopImmediatePropagation();
        return;
      }
      (((h = r == null ? void 0 : r.isNav) == null ? void 0 : h.value) === !0 && s === null || s !== null && ((c = s.autoClose) == null ? void 0 : c.value) === !0) && ((g = r == null ? void 0 : r.hide) == null || g.call(r)), a("click", y);
    };
    return (y, h) => i.value === "router-link" ? (b(), I(re(i.value), K({ key: 0 }, p.value, { custom: "" }), {
      default: E(({ href: c, navigate: g, isActive: v, isExactActive: $ }) => [
        (b(), I(re(y.routerTag), K({
          href: c,
          class: {
            [Cl]: l.active,
            [y.activeClass]: v,
            [y.exactActiveClass]: $
          }
        }, y.$attrs, {
          onClick: (B) => {
            g(B), m(B);
          }
        }), {
          default: E(() => [
            T(y.$slots, "default")
          ]),
          _: 2
        }, 1040, ["href", "class", "onClick"]))
      ]),
      _: 3
    }, 16)) : (b(), I(re(i.value), K({
      key: 1,
      class: f.value
    }, p.value, { onClick: m }), {
      default: E(() => [
        T(y.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Mr = ["aria-valuenow", "aria-valuemax"], Yo = /* @__PURE__ */ H({
  __name: "BProgressBar",
  props: {
    animated: { type: Boolean, default: !1 },
    label: { default: void 0 },
    labelHtml: { default: void 0 },
    max: { default: void 0 },
    precision: { default: 0 },
    showProgress: { type: Boolean, default: !1 },
    showValue: { type: Boolean, default: !1 },
    striped: { type: Boolean, default: !1 },
    value: { default: 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const e = t, l = _e($o, null), a = et(e), o = w(() => [
      a.value,
      {
        "progress-bar-animated": e.animated || (l == null ? void 0 : l.animated.value),
        "progress-bar-striped": e.striped || (l == null ? void 0 : l.striped.value) || e.animated || (l == null ? void 0 : l.animated.value)
      }
    ]), r = be(() => e.precision), s = be(() => e.value), n = be(() => e.max ?? NaN), i = be(() => (l == null ? void 0 : l.max.value) ?? NaN), u = w(
      () => e.labelHtml !== void 0 ? e.labelHtml : e.showValue || l != null && l.showValue.value ? s.value.toFixed(r.value) : e.showProgress || l != null && l.showProgress.value ? (s.value * 100 / (n.value || 100)).toFixed(r.value) : e.label !== void 0 ? e.label : ""
    ), d = w(
      () => i.value ? `${s.value * 100 / i.value}%` : n.value ? `${s.value * 100 / n.value}%` : typeof e.value == "string" ? e.value : `${e.value}%`
    );
    return (p, f) => (b(), _("div", {
      class: D(["progress-bar", o.value]),
      role: "progressbar",
      "aria-valuenow": p.value,
      "aria-valuemin": "0",
      "aria-valuemax": p.max,
      style: Ee({ width: d.value })
    }, [
      T(p.$slots, "default", {}, () => [
        ne(Y(u.value), 1)
      ])
    ], 14, Mr));
  }
}), Zo = /* @__PURE__ */ H({
  __name: "BProgress",
  props: {
    height: { default: void 0 },
    animated: { type: Boolean, default: void 0 },
    max: { default: 100 },
    precision: { default: void 0 },
    showProgress: { type: Boolean, default: void 0 },
    showValue: { type: Boolean, default: void 0 },
    striped: { type: Boolean, default: void 0 },
    value: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(t) {
    const e = t;
    return at($o, {
      animated: k(() => e.animated),
      max: k(() => e.max),
      showProgress: k(() => e.showProgress),
      showValue: k(() => e.showValue),
      striped: k(() => e.striped)
    }), (l, a) => (b(), _("div", {
      class: "progress",
      style: Ee({ height: l.height })
    }, [
      T(l.$slots, "default", {}, () => [
        ve(Yo, {
          animated: l.animated,
          max: l.max,
          precision: l.precision,
          "show-progress": l.showProgress,
          "show-value": l.showValue,
          striped: l.striped,
          value: l.value,
          variant: l.variant,
          "text-variant": l.textVariant,
          "bg-variant": l.bgVariant
        }, null, 8, ["animated", "max", "precision", "show-progress", "show-value", "striped", "value", "variant", "text-variant", "bg-variant"])
      ])
    ], 4));
  }
}), xr = ["id", "role", "aria-live", "aria-atomic"], Dr = { class: "me-auto" }, Jo = /* @__PURE__ */ H({
  __name: "BToast",
  props: /* @__PURE__ */ pe({
    body: { default: void 0 },
    bodyClass: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "div" },
    id: { default: void 0 },
    interval: { default: 1e3 },
    isStatus: { type: Boolean, default: !1 },
    modelValue: { type: [Boolean, Number] },
    noCloseButton: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    noHoverPause: { type: Boolean, default: !1 },
    progressProps: { default: void 0 },
    showOnPause: { type: Boolean, default: !0 },
    solid: { type: Boolean, default: !1 },
    title: { default: void 0 },
    toastClass: { default: void 0 },
    transProps: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: null },
    textVariant: { default: null },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 }
  }, {
    modelValue: { type: [Boolean, Number], default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["close", "close-countdown", "hide", "hidden", "show", "shown", "show-prevented", "hide-prevented"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = x(null), s = Ua(r), n = he(t, "modelValue"), { computedLink: i, computedLinkProps: u } = wt(a), d = be(() => a.interval), p = et(a), f = k(() => typeof n.value == "boolean" ? 0 : n.value), {
      isActive: m,
      pause: y,
      restart: h,
      resume: c,
      stop: g,
      isPaused: v,
      value: $
    } = Ho(f, d, {
      immediate: typeof n.value == "number"
    });
    Rt(() => {
      o("close-countdown", $.value);
    });
    const B = k(() => i.value ? ot : "div"), C = k(
      () => typeof n.value == "boolean" ? n.value : m.value || a.showOnPause && v.value
    ), V = w(() => [
      p.value,
      {
        show: C.value
      }
    ]), L = () => {
      a.noHoverPause || y();
    };
    ue(s, (N) => {
      if (N) {
        L();
        return;
      }
      c();
    });
    const Q = (N, S = {}) => new Bt(N, {
      cancelable: !1,
      target: r.value || null,
      relatedTarget: null,
      trigger: null,
      ...S,
      componentId: a.id
    }), W = () => {
      const N = Q("show", { cancelable: !0 });
      if (o("show", N), N.defaultPrevented) {
        n.value && (n.value = !1), o("show-prevented");
        return;
      }
      n.value || (n.value = !0);
    }, F = (N = "") => {
      const S = Q("hide", { cancelable: N !== "", trigger: N });
      if (o("hide", S), N === "close" && o("close", S), S.defaultPrevented) {
        o("hide-prevented"), n.value || (n.value = !0);
        return;
      }
      typeof n.value == "boolean" ? n.value = !1 : (n.value = 0, g());
    }, Z = () => {
      W();
    }, R = () => {
      o("shown", Q("shown"));
    }, le = () => {
      o("hidden", Q("hidden"));
    };
    return ue(m, (N) => {
      N === !1 && v.value === !1 && n.value && F();
    }), Fa(g), e({
      pause: y,
      restart: h,
      resume: c,
      stop: g
    }), (N, S) => (b(), I(It, K({
      "no-fade": a.noFade
    }, N.transProps, {
      onBeforeEnter: Z,
      onAfterEnter: R,
      onAfterLeave: le
    }), {
      default: E(() => [
        C.value ? (b(), _("div", {
          key: 0,
          id: N.id,
          ref_key: "element",
          ref: r,
          class: D(["toast", [N.toastClass, V.value]]),
          tabindex: "0",
          role: C.value ? a.isStatus ? "status" : "alert" : void 0,
          "aria-live": C.value ? a.isStatus ? "polite" : "assertive" : void 0,
          "aria-atomic": C.value ? !0 : void 0
        }, [
          N.$slots.title || N.title ? (b(), I(re(N.headerTag), {
            key: 0,
            class: "toast-header"
          }, {
            default: E(() => [
              T(N.$slots, "title", { hide: F }, () => [
                J("strong", Dr, Y(N.title), 1)
              ]),
              a.noCloseButton ? ae("", !0) : (b(), I(Pt, {
                key: 0,
                onClick: S[0] || (S[0] = (P) => F("close"))
              }))
            ]),
            _: 3
          })) : ae("", !0),
          N.$slots.default || N.body ? (b(), I(re(B.value), K({
            key: 1,
            class: ["toast-body", N.bodyClass],
            style: { display: "block" }
          }, O(u), {
            onClick: S[1] || (S[1] = (P) => O(i) ? F() : () => {
            })
          }), {
            default: E(() => [
              T(N.$slots, "default", { hide: F }, () => [
                ne(Y(N.body), 1)
              ])
            ]),
            _: 3
          }, 16, ["class"])) : ae("", !0),
          typeof n.value == "number" && N.progressProps !== void 0 ? (b(), I(Zo, {
            key: 2,
            animated: N.progressProps.animated,
            precision: N.progressProps.precision,
            "show-progress": N.progressProps.showProgress,
            "show-value": N.progressProps.showValue,
            striped: N.progressProps.striped,
            variant: N.progressProps.variant,
            max: n.value,
            value: O($),
            height: "4px"
          }, null, 8, ["animated", "precision", "show-progress", "show-value", "striped", "variant", "max", "value"])) : ae("", !0)
        ], 10, xr)) : ae("", !0)
      ]),
      _: 3
    }, 16, ["no-fade"]));
  }
}), jr = "top-right", qr = {
  install(t) {
    const e = bt([]), l = x(!1), a = (s) => {
      l.value = s;
    }, o = (s) => {
      const n = Symbol(), i = w(() => {
        const u = Se(s.props);
        return {
          component: Se(s.component) ?? Jo,
          props: {
            ...u,
            pos: (u == null ? void 0 : u.pos) || jr,
            _modelValue: (u == null ? void 0 : u.value) || 5e3,
            _self: n
          }
        };
      });
      return (i.value.props.appendToast !== void 0 ? i.value.props.appendToast : l.value) ? e.value = [...e.value, i] : e.value = [i, ...e.value], n;
    }, r = (s) => {
      e.value = e.value.filter((n) => n.value.props._self !== s);
    };
    t.provide(No, {
      _setIsAppend: a,
      toasts: e,
      show: o,
      remove: r
    });
  }
}, Wr = {
  install(t) {
    const e = x([]), l = () => {
      e.value.splice(0, e.value.length);
    };
    t.provide(Po, { items: e, reset: l });
  }
}, Gr = {
  install(t, e) {
    (e == null ? void 0 : e.id) instanceof Object && typeof e.id.getId == "function" && t.provide(Lo, e.id.getId);
  }
}, Ur = {
  key: 0,
  class: "visually-hidden"
}, pa = /* @__PURE__ */ H({
  __name: "BSpinner",
  props: {
    label: { default: void 0 },
    role: { default: "status" },
    small: { type: Boolean, default: !1 },
    tag: { default: "span" },
    type: { default: "border" },
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = Le(), a = w(() => [
      `spinner-${e.type}`,
      {
        [`spinner-${e.type}-sm`]: e.small,
        [`text-${e.variant}`]: e.variant !== null
      }
    ]), o = k(() => !Ae(l.label));
    return (r, s) => (b(), I(re(r.tag), {
      class: D(a.value),
      role: r.label || o.value ? r.role : null,
      "aria-hidden": r.label || o.value ? null : !0
    }, {
      default: E(() => [
        r.label || o.value ? (b(), _("span", Ur, [
          T(r.$slots, "label", {}, () => [
            ne(Y(r.label), 1)
          ])
        ])) : ae("", !0)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
}), vt = /* @__PURE__ */ H({
  __name: "BButton",
  props: /* @__PURE__ */ pe({
    loading: { type: Boolean, default: !1 },
    loadingFill: { type: Boolean, default: !1 },
    loadingText: { default: "Loading..." },
    pill: { type: Boolean, default: !1 },
    pressed: { type: Boolean },
    size: { default: "md" },
    squared: { type: Boolean, default: !1 },
    tag: { default: "button" },
    type: { default: "button" },
    variant: { default: "secondary" },
    active: { type: Boolean, default: !1 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    routerTag: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 }
  }, {
    pressed: { type: Boolean, default: void 0 },
    pressedModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["click"], ["update:pressed"]),
  setup(t, { emit: e }) {
    const l = t, a = e, o = he(t, "pressed"), { computedLink: r, computedLinkProps: s } = wt(l, [
      "active-class",
      "exact-active-class",
      "replace",
      "routerComponentName",
      "routerTag"
    ]), n = k(() => typeof l.pressed == "boolean"), i = k(
      () => l.tag === "button" && l.href === void 0 && l.to === void 0
    ), u = k(() => l.to !== void 0), d = k(() => l.href !== void 0 ? !1 : !i.value), p = w(() => u.value ? s.value : []), f = w(() => [
      [`btn-${l.size}`],
      {
        [`btn-${l.variant}`]: l.variant !== null,
        active: l.active || l.pressed,
        "rounded-pill": l.pill,
        "rounded-0": l.squared,
        disabled: l.disabled
      }
    ]), m = k(() => u.value ? ot : l.href ? "a" : l.tag), y = (h) => {
      if (l.disabled) {
        h.preventDefault(), h.stopPropagation();
        return;
      }
      a("click", h), n.value && (o.value = !l.pressed);
    };
    return (h, c) => (b(), I(re(m.value), K({ class: "btn" }, p.value, {
      class: f.value,
      "aria-disabled": d.value ? l.disabled : null,
      "aria-pressed": n.value ? l.pressed : null,
      autocomplete: n.value ? "off" : null,
      disabled: i.value ? l.disabled : null,
      href: h.href,
      rel: O(r) ? h.rel : null,
      role: d.value || O(r) ? "button" : null,
      target: O(r) ? h.target : null,
      type: i.value ? h.type : null,
      to: i.value ? null : h.to,
      append: O(r) ? h.append : null,
      onClick: y
    }), {
      default: E(() => [
        l.loading ? T(h.$slots, "loading", { key: 0 }, () => [
          l.loadingFill ? ae("", !0) : (b(), _(de, { key: 0 }, [
            ne(Y(h.loadingText), 1)
          ], 64)),
          T(h.$slots, "loading-spinner", {}, () => [
            ve(pa, {
              small: h.size !== "lg",
              label: l.loadingFill ? h.loadingText : void 0
            }, null, 8, ["small", "label"])
          ])
        ]) : T(h.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 16, ["class", "aria-disabled", "aria-pressed", "autocomplete", "disabled", "href", "rel", "role", "target", "type", "to", "append"]));
  }
}), ma = /* @__PURE__ */ H({
  __name: "BOverlay",
  props: {
    bgColor: { default: void 0 },
    blur: { default: "2px" },
    fixed: { type: Boolean, default: !1 },
    noCenter: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    noSpinner: { type: Boolean, default: !1 },
    noWrap: { type: Boolean, default: !1 },
    opacity: { default: 0.85 },
    overlayTag: { default: "div" },
    show: { type: Boolean, default: !1 },
    spinnerSmall: { type: Boolean, default: !1 },
    spinnerType: { default: "border" },
    spinnerVariant: { default: void 0 },
    variant: { default: "light" },
    wrapTag: { default: "div" },
    zIndex: { default: 10 },
    rounded: { type: [Boolean, String, Number], default: !1 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  emits: ["click", "hidden", "shown"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = { top: 0, left: 0, bottom: 0, right: 0 }, r = Qa(() => ({
      rounded: l.rounded,
      roundedTop: l.roundedTop,
      roundedBottom: l.roundedBottom,
      roundedStart: l.roundedStart,
      roundedEnd: l.roundedEnd
    })), s = k(
      () => l.variant !== null && !l.bgColor ? `bg-${l.variant}` : ""
    ), n = k(() => l.show ? !0 : null), i = w(() => ({
      type: l.spinnerType,
      variant: l.spinnerVariant,
      small: l.spinnerSmall
    })), u = w(() => ({
      ...o,
      zIndex: l.zIndex || 10
    })), d = w(() => ({
      "position-absolute": !l.noWrap || !l.fixed,
      "position-fixed": l.noWrap && l.fixed
    })), p = w(() => [s.value, r.value]), f = w(() => ({
      ...o,
      opacity: l.opacity,
      backgroundColor: l.bgColor || void 0,
      backdropFilter: l.blur ? `blur(${l.blur})` : void 0
    })), m = w(
      () => l.noCenter ? o : {
        top: "50%",
        left: "50%",
        transform: "translateX(-50%) translateY(-50%)"
      }
    );
    return (y, h) => (b(), I(re(y.wrapTag), {
      class: "b-overlay-wrap position-relative",
      "aria-busy": n.value
    }, {
      default: E(() => [
        T(y.$slots, "default"),
        ve(It, {
          "no-fade": y.noFade,
          "trans-props": { enterToClass: "show" },
          name: "fade",
          onAfterEnter: h[1] || (h[1] = (c) => a("shown")),
          onAfterLeave: h[2] || (h[2] = (c) => a("hidden"))
        }, {
          default: E(() => [
            l.show ? (b(), I(re(y.overlayTag), {
              key: 0,
              class: D(["b-overlay", d.value]),
              style: Ee(u.value),
              onClick: h[0] || (h[0] = (c) => a("click", c))
            }, {
              default: E(() => [
                J("div", {
                  class: D(["position-absolute", p.value]),
                  style: Ee(f.value)
                }, null, 6),
                J("div", {
                  class: "position-absolute",
                  style: Ee(m.value)
                }, [
                  T(y.$slots, "overlay", ge(we(i.value)), () => [
                    l.noSpinner ? ae("", !0) : (b(), I(pa, ge(K({ key: 0 }, i.value)), null, 16))
                  ])
                ], 4)
              ]),
              _: 3
            }, 8, ["class", "style"])) : ae("", !0)
          ]),
          _: 3
        }, 8, ["no-fade"])
      ]),
      _: 3
    }, 8, ["aria-busy"]));
  }
}), Kr = ["id", "aria-labelledby", "aria-describedby"], Xr = ["id"], kl = 1056, Yr = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BModal",
  props: /* @__PURE__ */ pe({
    autoFocus: { type: Boolean, default: !0 },
    autoFocusButton: { default: void 0 },
    body: { default: void 0 },
    backdropVariant: { default: void 0 },
    bodyAttrs: { default: void 0 },
    bodyBgVariant: { default: null },
    bodyClass: { default: null },
    bodyScrolling: { type: Boolean, default: !1 },
    bodyTextVariant: { default: null },
    bodyVariant: { default: null },
    busy: { type: Boolean, default: !1 },
    buttonSize: { default: "md" },
    cancelDisabled: { type: Boolean, default: !1 },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { type: Boolean, default: !1 },
    contentClass: { default: void 0 },
    dialogClass: { default: void 0 },
    footerBgVariant: { default: null },
    footerBorderVariant: { default: null },
    footerClass: { default: void 0 },
    footerTextVariant: { default: null },
    footerVariant: { default: null },
    fullscreen: { type: [Boolean, String], default: !1 },
    headerBgVariant: { default: null },
    headerBorderVariant: { default: null },
    headerClass: { default: void 0 },
    headerCloseClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseVariant: { default: "secondary" },
    headerTextVariant: { default: null },
    headerVariant: { default: null },
    hideBackdrop: { type: Boolean, default: !1 },
    hideFooter: { type: Boolean, default: !1 },
    hideHeader: { type: Boolean, default: !1 },
    hideHeaderClose: { type: Boolean, default: !1 },
    id: { default: void 0 },
    lazy: { type: Boolean, default: !1 },
    modalClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCloseOnBackdrop: { type: Boolean, default: !1 },
    noCloseOnEsc: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    okDisabled: { type: Boolean, default: !1 },
    okOnly: { type: Boolean, default: !1 },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { type: Boolean, default: !1 },
    size: { default: "md" },
    title: { default: void 0 },
    titleClass: { default: void 0 },
    titleSrOnly: { type: Boolean, default: !1 },
    titleTag: { default: "h5" },
    transProps: { default: void 0 },
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["cancel", "close", "hidden", "hide", "hide-prevented", "ok", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = Le(), s = Be(() => a.id, "modal"), n = he(t, "modelValue"), i = x(null), u = x(null), d = x(null), p = x(null), f = x(n.value), m = x(!1);
    Re(
      "Escape",
      () => {
        j("esc");
      },
      { target: i }
    ), Uo(n, () => a.bodyScrolling);
    const { focused: y } = Pe(i, {
      initialValue: n.value && a.autoFocusButton === void 0
    }), { focused: h } = Pe(u, {
      initialValue: n.value && a.autoFocusButton === "ok"
    }), { focused: c } = Pe(d, {
      initialValue: n.value && a.autoFocusButton === "cancel"
    }), { focused: g } = Pe(p, {
      initialValue: n.value && a.autoFocusButton === "close"
    }), v = w(() => [
      a.modalClass,
      {
        fade: !a.noFade,
        show: f.value
      }
    ]), $ = k(
      () => a.lazy === !1 || a.lazy === !0 && m.value === !0 || a.lazy === !0 && n.value === !0
    ), B = k(
      () => a.backdropVariant !== void 0 ? a.backdropVariant : a.hideBackdrop ? "transparent" : "dark"
    ), C = k(() => !Ae(r["header-close"])), V = w(() => [
      a.dialogClass,
      {
        "modal-fullscreen": a.fullscreen === !0,
        [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == "string",
        [`modal-${a.size}`]: a.size !== "md",
        "modal-dialog-centered": a.centered,
        "modal-dialog-scrollable": a.scrollable
      }
    ]), L = et(() => ({
      bgVariant: a.bodyBgVariant,
      textVariant: a.bodyTextVariant,
      variant: a.bodyVariant
    })), Q = w(() => [a.bodyClass, L.value]), W = et(() => ({
      bgVariant: a.headerBgVariant,
      textVariant: a.headerTextVariant,
      variant: a.headerVariant
    })), F = w(() => [
      a.headerClass,
      W.value,
      {
        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== null
      }
    ]), Z = w(() => ({
      variant: C.value ? a.headerCloseVariant : void 0,
      class: a.headerCloseClass
    })), R = et(() => ({
      bgVariant: a.footerBgVariant,
      textVariant: a.footerTextVariant,
      variant: a.footerVariant
    })), le = w(() => [
      a.footerClass,
      R.value,
      {
        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== null
      }
    ]), N = w(() => [
      a.titleClass,
      {
        "visually-hidden": a.titleSrOnly
      }
    ]), S = k(() => a.cancelDisabled || a.busy), P = k(() => a.okDisabled || a.busy), M = (U, z = {}) => new Bt(U, {
      cancelable: !1,
      target: i.value || null,
      relatedTarget: null,
      trigger: null,
      ...z,
      componentId: s.value
    });
    ue(n, (U, z) => {
      U !== z && (U === !0 ? A() : j());
    });
    const j = (U = "") => {
      if (U === "backdrop" && a.noCloseOnBackdrop || U === "esc" && a.noCloseOnEsc) {
        o("hide-prevented");
        return;
      }
      const z = M("hide", { cancelable: U !== "", trigger: U });
      if (U === "ok" && o(U, z), U === "cancel" && o(U, z), U === "close" && o(U, z), o("hide", z), z.defaultPrevented) {
        o("hide-prevented"), n.value || (n.value = !0);
        return;
      }
      n.value && (n.value = !1);
    }, A = () => {
      if (f.value)
        return;
      const U = M("show", { cancelable: !0 });
      if (o("show", U), U.defaultPrevented) {
        n.value && (n.value = !1), o("show-prevented");
        return;
      }
      n.value || (n.value = !0);
    }, X = () => {
      a.autoFocus !== !1 && (a.autoFocusButton === "ok" ? h.value = !0 : a.autoFocusButton === "close" ? g.value = !0 : a.autoFocusButton === "cancel" ? c.value = !0 : y.value = !0);
    }, G = () => {
      A();
    }, ie = () => {
      f.value = !0, X(), o("shown", M("shown")), a.lazy === !0 && (m.value = !0);
    }, q = () => {
      f.value = !1;
    }, se = () => {
      o("hidden", M("hidden")), a.lazy === !0 && (m.value = !1);
    }, { activePosition: me, activeModalCount: te } = Lr(f), ye = w(() => ({
      // Make sure that newly opened modals have a higher z-index than currently active ones.
      // All active modals have a z-index of ('defaultZIndex' - 'stackSize' - 'positionInStack').
      //
      // This means inactive modals will already be higher than active ones when opened.
      "z-index": f.value ? kl - (((te == null ? void 0 : te.value) ?? 0) - ((me == null ? void 0 : me.value) ?? 0)) : kl
    }));
    ke(i, "bv-toggle", () => {
      n.value ? j() : A();
    });
    const ee = w(() => ({
      cancel: () => {
        j("cancel");
      },
      close: () => {
        j("close");
      },
      hide: j,
      ok: () => {
        j("ok");
      },
      visible: n.value
    }));
    return e({
      hide: j,
      id: s,
      show: A
    }), (U, z) => {
      var oe;
      return b(), I(ht, {
        to: U.teleportTo,
        disabled: a.teleportDisabled
      }, [
        ve(It, K({ "no-fade": !0 }, U.transProps, {
          "trans-props": { enterToClass: "show", ...(oe = U.transProps) == null ? void 0 : oe.transProps },
          onBeforeEnter: G,
          onAfterEnter: ie,
          onLeave: q,
          onAfterLeave: se
        }), {
          default: E(() => [
            ut(J("div", K({
              id: O(s),
              ref_key: "element",
              ref: i,
              class: ["modal", v.value],
              role: "dialog",
              "aria-labelledby": a.hideHeader ? void 0 : `${O(s)}-label`,
              "aria-describedby": `${O(s)}-body`,
              tabindex: "-1"
            }, U.$attrs, { style: ye.value }), [
              J("div", {
                class: D(["modal-dialog", V.value])
              }, [
                $.value ? (b(), _("div", {
                  key: 0,
                  class: D(["modal-content", U.contentClass])
                }, [
                  a.hideHeader ? ae("", !0) : (b(), _("div", {
                    key: 0,
                    class: D(["modal-header", F.value])
                  }, [
                    T(U.$slots, "header", ge(we(ee.value)), () => [
                      (b(), I(re(U.titleTag), {
                        id: `${O(s)}-label`,
                        class: D(["modal-title", N.value])
                      }, {
                        default: E(() => [
                          T(U.$slots, "title", ge(we(ee.value)), () => [
                            ne(Y(U.title), 1)
                          ], !0)
                        ]),
                        _: 3
                      }, 8, ["id", "class"])),
                      a.hideHeaderClose ? ae("", !0) : (b(), _(de, { key: 0 }, [
                        C.value ? (b(), I(vt, K({ key: 0 }, Z.value, {
                          onClick: z[0] || (z[0] = (fe) => j("close"))
                        }), {
                          default: E(() => [
                            T(U.$slots, "header-close", {}, void 0, !0)
                          ]),
                          _: 3
                        }, 16)) : (b(), I(Pt, K({
                          key: 1,
                          "aria-label": U.headerCloseLabel
                        }, Z.value, {
                          onClick: z[1] || (z[1] = (fe) => j("close"))
                        }), null, 16, ["aria-label"]))
                      ], 64))
                    ], !0)
                  ], 2)),
                  J("div", K({
                    id: `${O(s)}-body`,
                    class: ["modal-body", Q.value]
                  }, U.bodyAttrs), [
                    T(U.$slots, "default", ge(we(ee.value)), () => [
                      ne(Y(U.body), 1)
                    ], !0)
                  ], 16, Xr),
                  a.hideFooter ? ae("", !0) : (b(), _("div", {
                    key: 1,
                    class: D(["modal-footer", le.value])
                  }, [
                    T(U.$slots, "footer", ge(we(ee.value)), () => [
                      T(U.$slots, "cancel", ge(we(ee.value)), () => [
                        a.okOnly ? ae("", !0) : (b(), I(vt, {
                          key: 0,
                          ref_key: "cancelButton",
                          ref: d,
                          disabled: S.value,
                          size: U.buttonSize,
                          variant: U.cancelVariant,
                          onClick: z[2] || (z[2] = (fe) => j("cancel"))
                        }, {
                          default: E(() => [
                            ne(Y(U.cancelTitle), 1)
                          ]),
                          _: 1
                        }, 8, ["disabled", "size", "variant"]))
                      ], !0),
                      T(U.$slots, "ok", ge(we(ee.value)), () => [
                        ve(vt, {
                          ref_key: "okButton",
                          ref: u,
                          disabled: P.value,
                          size: U.buttonSize,
                          variant: U.okVariant,
                          onClick: z[3] || (z[3] = (fe) => j("ok"))
                        }, {
                          default: E(() => [
                            ne(Y(U.okTitle), 1)
                          ]),
                          _: 1
                        }, 8, ["disabled", "size", "variant"])
                      ], !0)
                    ], !0)
                  ], 2))
                ], 2)) : ae("", !0)
              ], 2),
              T(U.$slots, "backdrop", {}, () => [
                ve(ma, {
                  variant: B.value,
                  show: n.value,
                  "no-spinner": "",
                  fixed: "",
                  "no-wrap": "",
                  blur: null,
                  onClick: z[4] || (z[4] = (fe) => j("backdrop"))
                }, null, 8, ["variant", "show"])
              ], !0)
            ], 16, Kr), [
              [xt, n.value]
            ])
          ]),
          _: 3
        }, 16, ["trans-props"])
      ], 8, ["to", "disabled"]);
    };
  }
}), qt = (t, e) => {
  const l = t.__vccOpts || t;
  for (const [a, o] of e)
    l[a] = o;
  return l;
}, _a = /* @__PURE__ */ qt(Yr, [["__scopeId", "data-v-8a2b2b28"]]), Zr = {
  install(t) {
    const e = bt([]), l = () => {
      let s = () => {
      };
      return {
        value: new Promise((i) => {
          s = i;
        }),
        resolve: s
      };
    }, a = (s) => {
      const n = l(), i = Symbol();
      return e.value = [
        ...e.value,
        w(() => ({
          component: Se(s.component) ?? _a,
          props: { ...Se(s.props), _isConfirm: !1, _promise: n, _self: i, _modelValue: !0 }
        }))
      ], n.value;
    }, o = (s) => {
      const n = l(), i = Symbol();
      return e.value = [
        ...e.value,
        w(() => ({
          component: Se(s.component) ?? _a,
          props: { ...Se(s.props), _isConfirm: !0, _promise: n, _self: i, _modelValue: !0 }
        }))
      ], n.value;
    }, r = (s) => {
      e.value = e.value.filter((n) => n.value.props._self !== s);
    };
    t.provide(Eo, {
      modals: e,
      remove: r,
      show: a,
      confirm: o
    });
  }
}, Jr = {
  install(t) {
    const e = bt([]), l = k(() => e.value.length), a = k(() => e.value[e.value.length - 1]), o = (u) => {
      e.value = [...e.value, u];
    }, r = (u) => {
      e.value = e.value.filter((d) => d.uid !== u.uid);
    }, s = bt([]), n = (u) => {
      s.value = [...s.value, u];
    }, i = (u) => {
      s.value = s.value.filter((d) => d.uid !== u.uid);
    };
    t.provide(Fo, {
      stack: e,
      countStack: l,
      lastStack: a,
      registry: s,
      pushStack: o,
      removeStack: r,
      pushRegistry: n,
      removeRegistry: i
    });
  }
}, Qr = {
  install(t, e) {
    var i, u;
    const o = typeof (e == null ? void 0 : e.rtl) == "boolean" ? !1 : ((i = e == null ? void 0 : e.rtl) == null ? void 0 : i.rtlInitial) ?? !1, r = typeof (e == null ? void 0 : e.rtl) == "boolean" ? void 0 : ((u = e == null ? void 0 : e.rtl) == null ? void 0 : u.localeInitial) ?? void 0, s = x(o), n = x(r);
    t.provide(Io, { isRtl: s, locale: n });
  }
}, ei = ["id"], ti = /* @__PURE__ */ H({
  __name: "BAccordion",
  props: /* @__PURE__ */ pe({
    flush: { type: Boolean, default: !1 },
    free: { type: Boolean, default: !1 },
    id: { default: void 0 },
    modelValue: {}
  }, {
    modelValue: {
      default: void 0
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t) {
    const e = t, l = he(t, "modelValue"), a = Be(() => e.id, "accordion"), o = w(() => ({
      "accordion-flush": e.flush
    }));
    return at(_o, {
      openItem: We(l),
      free: k(() => e.free),
      setOpenItem: (r) => {
        l.value = r;
      }
    }), (r, s) => (b(), _("div", {
      id: O(a),
      class: D(["accordion", o.value])
    }, [
      T(r.$slots, "default")
    ], 10, ei));
  }
}), Qo = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BCollapse",
  props: /* @__PURE__ */ pe({
    horizontal: { type: Boolean, default: !1 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: !1 },
    modelValue: { type: Boolean },
    skipAnimation: { type: Boolean, default: !1 },
    tag: { default: "div" },
    toggle: { type: Boolean, default: !1 },
    visible: { type: Boolean, default: !1 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = (C, V = {}) => new Bt(C, {
      cancelable: !1,
      target: i.value || null,
      relatedTarget: null,
      trigger: null,
      ...V,
      componentId: n.value
    }), s = he(t, "modelValue"), n = Be(() => a.id, "collapse"), i = x(null), u = x(!1), d = x(s.value), p = w(() => ({
      show: d.value,
      "navbar-collapse": a.isNav,
      collapsing: u.value,
      closing: d.value && !s.value,
      "collapse-horizontal": a.horizontal
    })), f = () => {
      s.value = !1;
    }, m = () => {
      s.value = !0;
    }, y = () => {
      s.value = !s.value;
    }, h = w(() => ({
      toggle: y,
      show: m,
      hide: f,
      id: n.value,
      visible: s.value
    }));
    let c, g, v = a.skipAnimation;
    const $ = () => {
      const C = r("show", { cancelable: !0 });
      if (o("show", C), C.defaultPrevented) {
        o("show-prevented");
        return;
      }
      clearTimeout(g), clearTimeout(c), d.value = !0, !v && (u.value = !0, Ve(() => {
        i.value !== null && (a.horizontal ? i.value.style.width = `${i.value.scrollWidth}px` : i.value.style.height = `${i.value.scrollHeight}px`, c = setTimeout(() => {
          u.value = !1, o("shown"), i.value !== null && (i.value.style.height = "", i.value.style.width = "");
        }, wa(i.value)));
      }));
    }, B = () => {
      const C = r("hide", { cancelable: !0 });
      if (o("hide", C), C.defaultPrevented) {
        o("hide-prevented");
        return;
      }
      if (clearTimeout(c), clearTimeout(g), i.value !== null) {
        if (v) {
          d.value = !1;
          return;
        }
        u.value ? (i.value.style.height = "", i.value.style.width = "") : a.horizontal ? i.value.style.width = `${i.value.scrollWidth}px` : i.value.style.height = `${i.value.scrollHeight}px`, i.value.offsetHeight, u.value = !0, Ve(() => {
          i.value !== null && (i.value.style.height = "", i.value.style.width = "", g = setTimeout(() => {
            d.value = !1, u.value = !1, o("hidden");
          }, wa(i.value)));
        });
      }
    };
    return ue(s, () => {
      s.value ? $() : B();
    }), Xe(() => {
      i.value !== null && !s.value && a.toggle && Ve(() => {
        s.value = !0;
      });
    }), ue(
      () => a.skipAnimation,
      (C) => {
        v = C;
      }
    ), a.visible && (v = !0, s.value = !0, Ve(() => {
      v = a.skipAnimation;
    })), ue(
      () => a.visible,
      (C) => {
        v = !0, C ? m() : f(), Ve(() => {
          v = a.skipAnimation;
        });
      }
    ), ke(i, "bv-toggle", () => {
      s.value = !s.value;
    }), e({
      hide: f,
      isNav: a.isNav,
      show: m,
      toggle: y,
      visible: We(d)
    }), at(Xa, {
      id: n,
      hide: f,
      show: m,
      toggle: y,
      visible: We(d),
      isNav: k(() => a.isNav)
    }), (C, V) => (b(), _(de, null, [
      T(C.$slots, "header", ge(we(h.value))),
      (b(), I(re(C.tag), K({
        id: O(n),
        ref_key: "element",
        ref: i,
        class: ["collapse", p.value],
        "is-nav": a.isNav
      }, C.$attrs), {
        default: E(() => [
          T(C.$slots, "default", ge(we(h.value)))
        ]),
        _: 3
      }, 16, ["id", "class", "is-nav"])),
      T(C.$slots, "footer", ge(we(h.value)))
    ], 64));
  }
}), ai = ["aria-expanded", "aria-controls", "onClick"], li = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BAccordionItem",
  props: /* @__PURE__ */ pe({
    bodyAttrs: { default: void 0 },
    bodyClass: { default: void 0 },
    buttonAttrs: { default: void 0 },
    buttonClass: { default: void 0 },
    collapseClass: { default: void 0 },
    headerAttrs: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "h2" },
    horizontal: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: void 0 },
    modelValue: { type: Boolean },
    tag: { default: void 0 },
    title: { default: void 0 },
    toggle: { type: Boolean, default: void 0 },
    visible: { type: Boolean, default: !1 },
    wrapperAttrs: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { emit: e }) {
    const { class: l, ...a } = Mt(), o = t, r = e, s = he(t, "modelValue"), n = _e(_o, null), i = Be(() => o.id, "accordion_item");
    return Xe(() => {
      s.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(i.value)), !s.value && (n == null ? void 0 : n.openItem.value) === i.value && (s.value = !0);
    }), ue(
      () => n == null ? void 0 : n.openItem.value,
      () => s.value = (n == null ? void 0 : n.openItem.value) === i.value && !(n != null && n.free.value)
    ), ue(s, () => {
      s.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(i.value));
    }), (u, d) => (b(), _("div", K({ class: "accordion-item" }, u.wrapperAttrs, { class: O(l) }), [
      ve(Qo, K({
        id: O(i),
        modelValue: s.value,
        "onUpdate:modelValue": d[0] || (d[0] = (p) => s.value = p),
        class: ["accordion-collapse", u.collapseClass],
        "aria-labelledby": `${O(i)}-heading`
      }, a, {
        tag: u.tag,
        toggle: u.toggle,
        horizontal: u.horizontal,
        visible: u.visible,
        "is-nav": u.isNav,
        onShow: d[1] || (d[1] = (p) => r("show", p)),
        onShown: d[2] || (d[2] = (p) => r("shown")),
        onHide: d[3] || (d[3] = (p) => r("hide", p)),
        onHidden: d[4] || (d[4] = (p) => r("hidden")),
        onHidePrevented: d[5] || (d[5] = (p) => r("hide-prevented")),
        onShowPrevented: d[6] || (d[6] = (p) => r("show-prevented"))
      }), {
        header: E(({ visible: p, toggle: f }) => [
          (b(), I(re(u.headerTag), K({
            id: `${O(i)}-heading`,
            class: ["accordion-header", u.headerClass]
          }, u.headerAttrs), {
            default: E(() => [
              J("button", K({ class: "accordion-button" }, u.buttonAttrs, {
                class: [{ collapsed: !p }, u.buttonClass],
                type: "button",
                "aria-expanded": p ? "true" : "false",
                "aria-controls": O(i),
                onClick: f
              }), [
                T(u.$slots, "title", {}, () => [
                  ne(Y(u.title), 1)
                ])
              ], 16, ai)
            ]),
            _: 2
          }, 1040, ["id", "class"]))
        ]),
        default: E(() => [
          J("div", K({ class: "accordion-body" }, u.bodyAttrs, { class: u.bodyClass }), [
            T(u.$slots, "default")
          ], 16)
        ]),
        _: 3
      }, 16, ["id", "modelValue", "class", "aria-labelledby", "tag", "toggle", "horizontal", "visible", "is-nav"])
    ], 16));
  }
}), oi = /* @__PURE__ */ H({
  __name: "BAlert",
  props: /* @__PURE__ */ pe({
    closeClass: { default: void 0 },
    closeContent: { default: void 0 },
    closeLabel: { default: "Close" },
    closeVariant: { default: "secondary" },
    dismissible: { type: Boolean, default: !1 },
    fade: { type: Boolean, default: !1 },
    immediate: { type: Boolean, default: !0 },
    interval: { default: 1e3 },
    modelValue: { type: [Boolean, Number] },
    noHoverPause: { type: Boolean, default: !1 },
    showOnPause: { type: Boolean, default: !0 },
    variant: { default: "info" }
  }, {
    modelValue: { type: [Boolean, Number], default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["close", "close-countdown", "closed"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = Le(), s = x(null), n = he(t, "modelValue"), i = Ua(s), u = be(() => a.interval), d = k(() => !Ae(r.close)), p = k(() => typeof n.value == "boolean" ? 0 : n.value), f = w(() => ({
      [`alert-${a.variant}`]: a.variant !== null,
      "alert-dismissible": a.dismissible
    })), m = w(() => [a.closeClass, { "btn-close-custom": d.value }]), {
      isActive: y,
      pause: h,
      restart: c,
      resume: g,
      stop: v,
      isPaused: $,
      value: B
    } = Ho(p, u, {
      immediate: typeof n.value == "number" && a.immediate
    }), C = k(
      () => typeof n.value == "boolean" ? n.value : y.value || a.showOnPause && $.value
    ), V = w(() => ({
      variant: d.value ? a.closeVariant : void 0,
      class: m.value
    }));
    Rt(() => {
      o("close-countdown", B.value);
    });
    const L = () => {
      o("close"), typeof n.value == "boolean" ? n.value = !1 : (n.value = 0, v()), o("closed");
    }, Q = () => {
      a.noHoverPause || h();
    };
    return ue(i, (W) => {
      if (W) {
        Q();
        return;
      }
      g();
    }), Fa(v), e({
      pause: h,
      restart: c,
      resume: g,
      stop: v
    }), (W, F) => (b(), I(It, {
      "no-fade": !a.fade,
      "trans-props": { enterToClass: "show" }
    }, {
      default: E(() => [
        C.value ? (b(), _("div", {
          key: 0,
          ref_key: "element",
          ref: s,
          class: D(["alert", f.value]),
          role: "alert",
          "aria-live": "polite",
          "aria-atomic": "true"
        }, [
          T(W.$slots, "default", {}, void 0, !0),
          a.dismissible ? (b(), _(de, { key: 0 }, [
            d.value || W.closeContent ? (b(), I(vt, K({ key: 0 }, V.value, { onClick: L }), {
              default: E(() => [
                T(W.$slots, "close", {}, () => [
                  ne(Y(W.closeContent), 1)
                ], !0)
              ]),
              _: 3
            }, 16)) : (b(), I(Pt, K({
              key: 1,
              "aria-label": W.closeLabel
            }, V.value, { onClick: L }), null, 16, ["aria-label"]))
          ], 64)) : ae("", !0)
        ], 2)) : ae("", !0)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
}), ni = /* @__PURE__ */ qt(oi, [["__scopeId", "data-v-30d91aa1"]]), si = {
  key: 0,
  class: "b-avatar-custom"
}, ri = {
  key: 1,
  class: "b-avatar-img"
}, ii = ["src", "alt"], $l = 0.4, ui = /* @__PURE__ */ H({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    badge: { type: [Boolean, String], default: !1 },
    badgeBgVariant: { default: null },
    badgeOffset: { default: void 0 },
    badgeStart: { type: Boolean, default: !1 },
    badgeTextVariant: { default: null },
    badgeTop: { type: Boolean, default: !1 },
    badgeVariant: { default: "primary" },
    button: { type: Boolean, default: !1 },
    buttonType: { default: "button" },
    icon: { default: void 0 },
    size: { default: void 0 },
    square: { type: Boolean, default: !1 },
    src: { default: void 0 },
    text: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: "secondary" },
    bgVariant: { default: null },
    textVariant: { default: null },
    rounded: { type: [Boolean, String, Number], default: !1 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  emits: ["click", "img-error"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = Le(), { computedLink: r, computedLinkProps: s } = wt(l), n = _e(So, null), i = ["sm", null, "lg"], u = $l * 0.7, d = k(() => !Ae(o.default)), p = k(() => !Ae(o.badge)), f = k(() => !!l.badge || l.badge === "" || p.value), m = k(() => (n == null ? void 0 : n.size.value) ?? l.square), y = ia(() => l.size), h = ia(() => n == null ? void 0 : n.size.value), c = w(() => h.value ?? y.value), g = k(() => (n == null ? void 0 : n.variant.value) ?? l.variant), v = k(() => (n == null ? void 0 : n.rounded.value) ?? l.rounded), $ = k(() => (n == null ? void 0 : n.roundedTop.value) ?? l.roundedTop), B = k(() => (n == null ? void 0 : n.roundedBottom.value) ?? l.roundedBottom), C = k(() => (n == null ? void 0 : n.roundedStart.value) ?? l.roundedStart), V = k(() => (n == null ? void 0 : n.roundedEnd.value) ?? l.roundedEnd), L = Qa(() => ({
      rounded: v.value,
      roundedTop: $.value,
      roundedBottom: B.value,
      roundedStart: C.value,
      roundedEnd: V.value
    })), Q = et(() => ({
      variant: l.badgeVariant,
      bgVariant: l.badgeBgVariant,
      textVariant: l.badgeTextVariant
    })), W = k(() => l.badge === !0 ? "" : l.badge), F = k(() => (n == null ? void 0 : n.textVariant.value) ?? l.textVariant), Z = k(() => (n == null ? void 0 : n.bgVariant.value) ?? l.bgVariant), R = et(() => ({
      bgVariant: Z.value,
      textVariant: F.value,
      variant: g.value
    })), le = w(() => [
      R.value,
      // Square overwrites all else
      m.value === !0 ? void 0 : L.value,
      {
        [`b-avatar-${l.size}`]: !!l.size && i.indexOf(y.value) !== -1,
        [`btn-${g.value}`]: l.button ? g.value !== null : !1,
        badge: !l.button && g.value !== null && d.value,
        btn: l.button,
        // Square is the same as rounded-0 class
        "rounded-0": m.value === !0
      }
    ]), N = w(() => {
      const G = l.badgeOffset || "0px";
      return {
        fontSize: (i.indexOf(c.value || null) === -1 ? `calc(${c.value} * ${u})` : "") || "",
        top: l.badgeTop ? G : "",
        bottom: l.badgeTop ? "" : G,
        left: l.badgeStart ? G : "",
        right: l.badgeStart ? "" : G
      };
    }), S = w(() => {
      const G = i.indexOf(c.value || null) === -1 ? `calc(${c.value} * ${$l})` : null;
      return G ? { fontSize: G } : {};
    }), P = w(() => {
      var q;
      const G = ((q = n == null ? void 0 : n.overlapScale) == null ? void 0 : q.value) || 0, ie = c.value && G ? `calc(${c.value} * -${G})` : null;
      return ie ? { marginLeft: ie, marginRight: ie } : {};
    }), M = k(() => r.value ? ot : l.button ? "button" : "span"), j = w(() => ({
      ...P.value,
      width: c.value ?? void 0,
      height: c.value ?? void 0
    })), A = (G) => {
      !l.disabled && (r.value || l.button) && a("click", G);
    }, X = (G) => {
      a("img-error", G);
    };
    return (G, ie) => (b(), I(re(M.value), K({
      class: ["b-avatar", le.value],
      style: j.value
    }, O(s), {
      type: l.button && !O(r) ? l.buttonType : void 0,
      disabled: l.disabled || null,
      onClick: A
    }), {
      default: E(() => [
        d.value ? (b(), _("span", si, [
          T(G.$slots, "default")
        ])) : G.src ? (b(), _("span", ri, [
          J("img", {
            src: G.src,
            alt: G.alt,
            onError: X
          }, null, 40, ii)
        ])) : G.text ? (b(), _("span", {
          key: 2,
          class: "b-avatar-text",
          style: Ee(S.value)
        }, Y(G.text), 5)) : ae("", !0),
        f.value ? (b(), _("span", {
          key: 3,
          class: D(["b-avatar-badge", O(Q)]),
          style: Ee(N.value)
        }, [
          T(G.$slots, "badge", {}, () => [
            ne(Y(W.value), 1)
          ])
        ], 6)) : ae("", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "type", "disabled"]));
  }
}), di = /* @__PURE__ */ H({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    size: { default: void 0 },
    square: { type: Boolean, default: !1 },
    tag: { default: "div" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null },
    rounded: { type: [Boolean, String, Number], default: !1 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(t) {
    const e = t, l = be(() => e.overlap), a = ia(() => e.size), o = k(() => Math.min(Math.max(l.value, 0), 1) / 2), r = w(() => {
      const s = a.value ? `calc(${a.value} * ${o.value})` : null;
      return s ? { paddingLeft: s, paddingRight: s } : {};
    });
    return at(So, {
      overlapScale: o,
      size: k(() => e.size),
      square: k(() => e.square),
      rounded: k(() => e.rounded),
      roundedTop: k(() => e.roundedTop),
      roundedBottom: k(() => e.roundedBottom),
      roundedStart: k(() => e.roundedStart),
      roundedEnd: k(() => e.roundedEnd),
      variant: k(() => e.variant),
      bgVariant: k(() => e.bgVariant),
      textVariant: k(() => e.textVariant)
    }), (s, n) => (b(), I(re(s.tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: E(() => [
        J("div", {
          class: "b-avatar-group-inner",
          style: Ee(r.value)
        }, [
          T(s.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
}), ci = /* @__PURE__ */ H({
  __name: "BBadge",
  props: {
    dotIndicator: { type: Boolean, default: !1 },
    pill: { type: Boolean, default: !1 },
    tag: { default: "span" },
    textIndicator: { type: Boolean, default: !1 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: "secondary" },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const e = t, l = et(e), { computedLink: a, computedLinkProps: o } = wt(e, [
      "active",
      "activeClass",
      "append",
      "disabled",
      "href",
      "rel",
      "replace",
      "routerComponentName",
      "target",
      "to",
      "opacity",
      "opacityHover",
      "underlineVariant",
      "underlineOffset",
      "underlineOffsetHover",
      "underlineOpacity",
      "underlineOpacityHover",
      "icon"
    ]), r = k(() => a.value ? ot : e.tag), s = w(() => [
      l.value,
      {
        active: e.active,
        disabled: e.disabled,
        "rounded-pill": e.pill,
        "position-absolute top-0 start-100 translate-middle": e.textIndicator || e.dotIndicator,
        "p-2 border border-light rounded-circle": e.dotIndicator,
        "text-decoration-none": a.value
      }
    ]);
    return (n, i) => (b(), I(re(r.value), K({
      class: ["badge", s.value]
    }, O(o)), {
      default: E(() => [
        T(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), en = /* @__PURE__ */ H({
  __name: "BBreadcrumbItem",
  props: {
    ariaCurrent: { default: "location" },
    text: { default: void 0 },
    active: { type: Boolean, default: !1 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = w(() => ({
      active: l.active
    })), r = k(() => l.active ? "span" : ot), s = k(() => l.active ? l.ariaCurrent : void 0), n = w(
      () => r.value !== "span" ? Za(l, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "icon"
      ]) : {}
    ), i = (u) => {
      if (l.disabled || l.active) {
        u.preventDefault(), u.stopImmediatePropagation();
        return;
      }
      l.disabled || a("click", u);
    };
    return (u, d) => (b(), _("li", {
      class: D(["breadcrumb-item", o.value])
    }, [
      (b(), I(re(r.value), K({ "aria-current": s.value }, n.value, { onClick: i }), {
        default: E(() => [
          T(u.$slots, "default", {}, () => [
            ne(Y(u.text), 1)
          ])
        ]),
        _: 3
      }, 16, ["aria-current"]))
    ], 2));
  }
}), fi = { "aria-label": "breadcrumb" }, vi = { class: "breadcrumb" }, pi = /* @__PURE__ */ H({
  __name: "BBreadcrumb",
  props: {
    items: { default: void 0 }
  },
  setup(t) {
    const e = t, l = zo(), a = w(() => {
      var n;
      const o = e.items || ((n = l.items) == null ? void 0 : n.value) || [];
      let r = !1;
      return o.map((i, u) => (typeof i == "string" && (i = { text: i }, u < o.length - 1 && (i.href = "#")), i.active && (r = !0), !i.active && !r && (i.active = u + 1 === o.length), i));
    });
    return (o, r) => (b(), _("nav", fi, [
      J("ol", vi, [
        T(o.$slots, "prepend"),
        (b(!0), _(de, null, Ce(a.value, (s, n) => (b(), I(en, K({
          key: n,
          ref_for: !0
        }, s), {
          default: E(() => [
            ne(Y(s.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        T(o.$slots, "default"),
        T(o.$slots, "append")
      ])
    ]));
  }
}), mi = /* @__PURE__ */ H({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: { default: "md" },
    tag: { default: "div" },
    vertical: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, l = w(() => ({
      "btn-group": !e.vertical,
      [`btn-group-${e.size}`]: e.size !== "md",
      "btn-group-vertical": e.vertical
    }));
    return (a, o) => (b(), I(re(a.tag), {
      class: D(l.value),
      role: "group",
      "aria-label": a.ariaLabel
    }, {
      default: E(() => [
        T(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
}), bi = ["role", "aria-label"], yi = /* @__PURE__ */ H({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { type: Boolean, default: !1 },
    role: { default: "toolbar" }
  },
  setup(t) {
    const e = t, l = w(() => ({
      "justify-content-between": e.justify
    }));
    return (a, o) => (b(), _("div", {
      class: D([l.value, "btn-toolbar"]),
      role: a.role,
      "aria-label": a.ariaLabel
    }, [
      T(a.$slots, "default")
    ], 10, bi));
  }
}), gi = ["src", "width", "height", "srcset", "sizes", "loading"], el = /* @__PURE__ */ H({
  __name: "BImg",
  props: {
    blank: { type: Boolean, default: !1 },
    blankColor: { default: "transparent" },
    block: { type: Boolean, default: !1 },
    center: { type: Boolean, default: !1 },
    end: { type: Boolean, default: !1 },
    fluid: { type: Boolean, default: !1 },
    fluidGrow: { type: Boolean, default: !1 },
    height: { default: void 0 },
    lazy: { type: Boolean, default: !1 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    start: { type: Boolean, default: !1 },
    thumbnail: { type: Boolean, default: !1 },
    width: { default: void 0 },
    rounded: { type: [Boolean, String, Number], default: !1 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(t) {
    const e = t, l = be(() => e.height ?? NaN), a = be(() => e.width ?? NaN), o = Qa(() => ({
      rounded: e.rounded,
      roundedTop: e.roundedTop,
      roundedBottom: e.roundedBottom,
      roundedStart: e.roundedStart,
      roundedEnd: e.roundedEnd
    })), r = w(
      () => typeof e.srcset == "string" ? e.srcset.split(",").filter((f) => f).join(",") : Array.isArray(e.srcset) ? e.srcset.filter((f) => f).join(",") : void 0
    ), s = w(
      () => typeof e.sizes == "string" ? e.sizes.split(",").filter((f) => f).join(",") : Array.isArray(e.sizes) ? e.sizes.filter((f) => f).join(",") : void 0
    ), n = w(() => {
      const f = Number.isNaN(a.value) ? void 0 : a.value, m = Number.isNaN(l.value) ? void 0 : l.value;
      return e.blank ? f !== void 0 && m === void 0 ? { height: f, width: f } : f === void 0 && m !== void 0 ? { height: m, width: m } : { height: 1, width: 1 } : {
        width: f,
        height: m
      };
    }), i = k(
      () => p(n.value.width, n.value.height, e.blankColor)
    ), u = k(
      () => e.start ? "float-start" : e.end ? "float-end" : e.center ? "mx-auto" : void 0
    ), d = w(() => [
      o.value,
      {
        "img-thumbnail": e.thumbnail,
        "img-fluid": e.fluid || e.fluidGrow,
        "w-100": e.fluidGrow,
        [`${u.value}`]: u.value !== void 0,
        "d-block": e.block || e.center
      }
    ]), p = (f, m, y) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`<svg width="${f}" height="${m}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${f} ${m}" preserveAspectRatio="none">
    <rect width="100%" height="100%" style="fill:${y};"></rect>
    </svg>`)}`;
    return (f, m) => (b(), _("img", {
      class: D(d.value),
      src: e.blank ? i.value : f.src,
      width: n.value.width || void 0,
      height: n.value.height || void 0,
      srcset: e.blank ? void 0 : r.value,
      sizes: e.blank ? void 0 : s.value,
      loading: e.lazy ? "lazy" : "eager"
    }, null, 10, gi));
  }
}), tl = /* @__PURE__ */ H({
  __name: "BCardImg",
  props: {
    bottom: { type: Boolean, default: !1 },
    top: { type: Boolean, default: !1 },
    blank: { type: Boolean, default: void 0 },
    blankColor: { default: void 0 },
    block: { type: Boolean, default: void 0 },
    center: { type: Boolean, default: void 0 },
    end: { type: Boolean, default: void 0 },
    fluid: { type: Boolean, default: void 0 },
    fluidGrow: { type: Boolean, default: void 0 },
    height: { default: void 0 },
    lazy: { type: Boolean, default: void 0 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    start: { type: Boolean, default: void 0 },
    thumbnail: { type: Boolean, default: void 0 },
    width: { default: void 0 },
    rounded: { type: [Boolean, String, Number], default: void 0 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(t) {
    const e = t, l = k(
      () => e.top ? "card-img-top" : e.end ? "card-img-right" : e.bottom ? "card-img-bottom" : e.start ? "card-img-left" : "card-img"
    ), a = w(() => va(e, ["bottom", "top", "end", "start"]));
    return (o, r) => (b(), I(el, K(a.value, { class: l.value }), null, 16, ["class"]));
  }
}), hi = ["innerHTML"], tn = /* @__PURE__ */ H({
  __name: "BCardHeadFoot",
  props: {
    borderVariant: { default: null },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const e = t, l = et(e), a = w(() => [
      l.value,
      {
        [`border-${e.borderVariant}`]: e.borderVariant !== null
      }
    ]);
    return (o, r) => (b(), I(re(o.tag), {
      class: D(a.value)
    }, {
      default: E(() => [
        o.html ? (b(), _("div", {
          key: 0,
          innerHTML: o.html
        }, null, 8, hi)) : T(o.$slots, "default", { key: 1 }, () => [
          ne(Y(o.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), an = /* @__PURE__ */ H({
  __name: "BCardHeader",
  props: {
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(t) {
    const e = t;
    return (l, a) => (b(), I(tn, K({ class: "card-header" }, e), {
      default: E(() => [
        T(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ln = /* @__PURE__ */ H({
  __name: "BCardTitle",
  props: {
    tag: { default: "h4" },
    text: { default: void 0 }
  },
  setup(t) {
    return (e, l) => (b(), I(re(e.tag), { class: "card-title" }, {
      default: E(() => [
        T(e.$slots, "default", {}, () => [
          ne(Y(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), on = /* @__PURE__ */ H({
  __name: "BCardSubtitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h6" },
    textVariant: { default: "body-secondary" }
  },
  setup(t) {
    const e = t, l = w(() => ({
      [`text-${e.textVariant}`]: e.textVariant !== null
    }));
    return (a, o) => (b(), I(re(a.tag), {
      class: D(["card-subtitle mb-2", l.value])
    }, {
      default: E(() => [
        T(a.$slots, "default", {}, () => [
          ne(Y(a.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), nn = /* @__PURE__ */ H({
  __name: "BCardBody",
  props: {
    overlay: { type: Boolean, default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h4" },
    subtitleTextVariant: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const e = t, l = Le(), a = et(e), o = k(() => !Ae(l.title)), r = k(() => !Ae(l.subtitle)), s = w(() => [
      a.value,
      {
        "card-img-overlay": e.overlay
      }
    ]);
    return (n, i) => (b(), I(re(n.tag), {
      class: D(["card-body", s.value])
    }, {
      default: E(() => [
        n.title || o.value ? (b(), I(ln, {
          key: 0,
          tag: n.titleTag
        }, {
          default: E(() => [
            T(n.$slots, "title", {}, () => [
              ne(Y(n.title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : ae("", !0),
        n.subtitle || r.value ? (b(), I(on, {
          key: 1,
          tag: n.subtitleTag,
          "text-variant": n.subtitleTextVariant
        }, {
          default: E(() => [
            T(n.$slots, "subtitle", {}, () => [
              ne(Y(n.subtitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : ae("", !0),
        T(n.$slots, "default", {}, () => [
          ne(Y(n.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), sn = /* @__PURE__ */ H({
  __name: "BCardFooter",
  props: {
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(t) {
    const e = t;
    return (l, a) => (b(), I(tn, K({ class: "card-footer" }, e), {
      default: E(() => [
        T(l.$slots, "default", {}, () => [
          ne(Y(l.text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), rn = /* @__PURE__ */ H({
  __name: "BCard",
  props: {
    align: { default: void 0 },
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTag: { default: "div" },
    bodyText: { default: "" },
    bodyTextVariant: { default: void 0 },
    borderVariant: { default: null },
    footer: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: { default: void 0 },
    footerVariant: { default: null },
    header: { default: void 0 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: { default: void 0 },
    headerVariant: { default: null },
    imgAlt: { default: void 0 },
    imgBottom: { type: Boolean, default: !1 },
    imgEnd: { type: Boolean, default: !1 },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgStart: { type: Boolean, default: !1 },
    imgTop: { type: Boolean, default: !1 },
    imgWidth: { default: void 0 },
    noBody: { type: Boolean, default: !1 },
    overlay: { type: Boolean, default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h6" },
    subtitleTextVariant: { default: "body-secondary" },
    tag: { default: "div" },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t) {
    const e = t, l = Le(), a = k(() => !Ae(l.header)), o = k(() => !Ae(l.footer)), r = et(e), s = w(() => [
      r.value,
      {
        [`text-${e.align}`]: e.align !== void 0,
        [`border-${e.borderVariant}`]: e.borderVariant !== null,
        "flex-row": e.imgStart,
        "flex-row-reverse": e.imgEnd
      }
    ]), n = w(() => ({
      src: e.imgSrc,
      alt: e.imgAlt,
      height: e.imgHeight,
      width: e.imgWidth,
      bottom: e.imgBottom,
      end: e.imgEnd,
      start: e.imgStart,
      top: e.imgTop
    })), i = zt();
    return (u, d) => (b(), I(re(u.tag), {
      class: D(["card", s.value])
    }, {
      default: E(() => [
        ve(O(i).define, null, {
          default: E(() => [
            T(u.$slots, "img", {}, () => [
              u.imgSrc ? (b(), I(tl, ge(K({ key: 0 }, n.value)), null, 16)) : ae("", !0)
            ])
          ]),
          _: 3
        }),
        e.imgBottom ? ae("", !0) : (b(), I(O(i).reuse, { key: 0 })),
        u.header || a.value || u.headerHtml ? (b(), I(an, {
          key: 1,
          "bg-variant": u.headerBgVariant,
          variant: u.headerVariant,
          "border-variant": u.headerBorderVariant,
          html: u.headerHtml,
          tag: u.headerTag,
          "text-variant": u.headerTextVariant,
          class: D(u.headerClass)
        }, {
          default: E(() => [
            T(u.$slots, "header", {}, () => [
              ne(Y(u.header), 1)
            ])
          ]),
          _: 3
        }, 8, ["bg-variant", "variant", "border-variant", "html", "tag", "text-variant", "class"])) : ae("", !0),
        e.noBody ? T(u.$slots, "default", { key: 3 }, () => [
          ne(Y(u.bodyText), 1)
        ]) : (b(), I(nn, {
          key: 2,
          overlay: u.overlay,
          "bg-variant": u.bodyBgVariant,
          tag: u.bodyTag,
          "text-variant": u.bodyTextVariant,
          subtitle: u.subtitle,
          "subtitle-tag": u.subtitleTag,
          "subtitle-text-variant": u.subtitleTextVariant,
          title: u.title,
          "title-tag": u.titleTag,
          class: D(u.bodyClass)
        }, {
          default: E(() => [
            T(u.$slots, "default", {}, () => [
              ne(Y(u.bodyText), 1)
            ])
          ]),
          _: 3
        }, 8, ["overlay", "bg-variant", "tag", "text-variant", "subtitle", "subtitle-tag", "subtitle-text-variant", "title", "title-tag", "class"])),
        u.footer || o.value || u.footerHtml ? (b(), I(sn, {
          key: 4,
          "bg-variant": u.footerBgVariant,
          "border-variant": u.footerBorderVariant,
          variant: u.footerVariant,
          html: u.footerHtml,
          tag: u.footerTag,
          "text-variant": u.footerTextVariant,
          class: D(u.footerClass)
        }, {
          default: E(() => [
            T(u.$slots, "footer", {}, () => [
              ne(Y(u.footer), 1)
            ])
          ]),
          _: 3
        }, 8, ["bg-variant", "border-variant", "variant", "html", "tag", "text-variant", "class"])) : ae("", !0),
        e.imgBottom ? (b(), I(O(i).reuse, { key: 5 })) : ae("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Bi = /* @__PURE__ */ H({
  __name: "BCardGroup",
  props: {
    columns: { type: Boolean, default: !1 },
    deck: { type: Boolean, default: !1 },
    tag: { default: "div" }
  },
  setup(t) {
    const e = t, l = k(
      () => e.deck ? "card-deck" : e.columns ? "card-columns" : "card-group"
    );
    return (a, o) => (b(), I(re(a.tag), {
      class: D(l.value)
    }, {
      default: E(() => [
        T(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), wi = /* @__PURE__ */ H({
  __name: "BCardText",
  props: {
    tag: { default: "p" },
    text: { default: void 0 }
  },
  setup(t) {
    return (e, l) => (b(), I(re(e.tag), { class: "card-text" }, {
      default: E(() => [
        T(e.$slots, "default", {}, () => [
          ne(Y(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), Ci = ["id"], ki = {
  key: 0,
  class: "carousel-indicators"
}, $i = ["aria-current", "aria-label", "onClick"], Ti = /* @__PURE__ */ J("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1), Si = { class: "visually-hidden" }, _i = /* @__PURE__ */ J("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1), Vi = { class: "visually-hidden" }, Ai = /* @__PURE__ */ H({
  __name: "BCarousel",
  props: /* @__PURE__ */ pe({
    background: { default: void 0 },
    controls: { type: Boolean, default: !1 },
    controlsNextText: { default: "Next" },
    controlsPrevText: { default: "Previous" },
    fade: { type: Boolean, default: !1 },
    id: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    indicators: { type: Boolean, default: !1 },
    indicatorsButtonLabel: { default: "Slide" },
    interval: { default: 5e3 },
    keyboard: { type: Boolean, default: !0 },
    modelValue: {},
    noHoverPause: { type: Boolean, default: !1 },
    noTouch: { type: Boolean, default: !1 },
    noWrap: { type: Boolean, default: !1 },
    ride: { type: [Boolean, String], default: !1 },
    rideReverse: { type: Boolean, default: !1 },
    touchThreshold: { default: 50 }
  }, {
    modelValue: { default: 0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["slide", "slid"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = Le(), s = Be(() => a.id, "carousel"), n = he(t, "modelValue"), i = be(() => a.touchThreshold), u = be(() => a.interval), d = x(!1), p = x(!1), f = x(!0), m = x(null), y = x(null), h = x(n.value), c = Ua(y), g = k(
      () => `carousel-item carousel-item-${f.value ? "prev" : "next"} carousel-item-${f.value ? "end" : "start"}`
    ), v = k(
      () => `carousel-item active carousel-item-${f.value ? "start" : "end"}`
    ), { pause: $, resume: B } = mo(
      () => {
        a.rideReverse ? F() : Z();
      },
      u,
      { immediate: a.ride === "carousel" }
    ), C = k(
      () => a.ride === !0 && p.value === !0 || a.ride === "carousel"
    ), V = w(() => Br(r.default, "BCarouselSlide")), L = w(() => ({ "carousel-fade": a.fade })), Q = (A) => {
      var X;
      return new ql(A, {
        componentId: s.value,
        cancelable: !1,
        target: y.value,
        direction: f.value ? "right" : "left",
        from: h.value,
        to: n.value,
        relatedTarget: ((X = m.value) == null ? void 0 : X.children[n.value]) ?? null
      });
    }, W = (A) => {
      if (d.value !== !0) {
        if (a.ride === !0 && (p.value = !0), C.value === !0 && B(), f.value = !(A < n.value), A >= V.value.length) {
          if (a.noWrap)
            return;
          n.value = 0;
          return;
        }
        if (A < 0) {
          if (a.noWrap)
            return;
          n.value = V.value.length - 1;
          return;
        }
        h.value = n.value, n.value = A;
      }
    }, F = () => {
      W(n.value - 1);
    }, Z = () => {
      W(n.value + 1);
    }, R = (A) => {
      a.keyboard !== !1 && A();
    }, le = () => {
      a.noHoverPause || $();
    }, N = () => {
      C.value && B();
    }, { lengthX: S } = cr(y, {
      passive: !0,
      onSwipeStart() {
        a.noTouch !== !0 && $();
      },
      onSwipeEnd() {
        if (a.noTouch === !0)
          return;
        const A = () => {
          C.value !== !1 && B();
        };
        if (S.value >= i.value) {
          Z(), A();
          return;
        }
        S.value <= -i.value && (F(), A());
      }
    }), P = () => {
      o("slide", Q("slide")), d.value = !0;
    }, M = () => {
      o("slid", Q("slid")), d.value = !1;
    }, j = (A) => {
      n.value !== 0 && A.classList.add("carousel-item");
    };
    return Re(
      "ArrowLeft",
      () => {
        R(F);
      },
      { target: y }
    ), Re(
      "ArrowRight",
      () => {
        R(Z);
      },
      { target: y }
    ), ue(
      () => a.ride,
      () => {
        p.value = !1;
      }
    ), ue(c, (A) => {
      if (A) {
        le();
        return;
      }
      N();
    }), e({
      next: Z,
      pause: $,
      prev: F,
      resume: B
    }), at(Co, {
      background: k(() => a.background),
      width: k(() => a.imgWidth),
      height: k(() => a.imgHeight)
    }), (A, X) => (b(), _("div", {
      id: O(s),
      ref_key: "element",
      ref: y,
      class: D(["carousel slide pointer-event", L.value])
    }, [
      a.indicators ? (b(), _("div", ki, [
        (b(!0), _(de, null, Ce(V.value.length, (G, ie) => (b(), _("button", {
          key: ie,
          type: "button",
          "data-bs-target": "",
          class: D(ie === n.value ? "active" : ""),
          "aria-current": ie === n.value ? !0 : void 0,
          "aria-label": `${A.indicatorsButtonLabel} ${ie}`,
          onClick: (q) => W(ie)
        }, null, 10, $i))), 128))
      ])) : ae("", !0),
      J("div", {
        ref_key: "relatedTarget",
        ref: m,
        class: "carousel-inner"
      }, [
        ve(jl, {
          "enter-from-class": g.value,
          "enter-active-class": g.value,
          "enter-to-class": g.value,
          "leave-from-class": v.value,
          "leave-active-class": v.value,
          "leave-to-class": v.value,
          onBeforeLeave: P,
          onAfterLeave: M,
          onAfterEnter: j
        }, {
          default: E(() => [
            (b(!0), _(de, null, Ce(V.value, (G, ie) => ut((b(), I(re(G), {
              key: ie,
              class: D({ active: ie === n.value && d.value === !1 })
            }, null, 8, ["class"])), [
              [xt, ie === n.value]
            ])), 128))
          ]),
          _: 1
        }, 8, ["enter-from-class", "enter-active-class", "enter-to-class", "leave-from-class", "leave-active-class", "leave-to-class"])
      ], 512),
      a.controls ? (b(), _(de, { key: 1 }, [
        J("button", {
          class: "carousel-control-prev",
          type: "button",
          onClick: F
        }, [
          Ti,
          J("span", Si, Y(A.controlsPrevText), 1)
        ]),
        J("button", {
          class: "carousel-control-next",
          type: "button",
          onClick: Z
        }, [
          _i,
          J("span", Vi, Y(A.controlsNextText), 1)
        ])
      ], 64)) : ae("", !0)
    ], 10, Ci));
  }
}), Oi = ["innerHTML"], Ni = { key: 1 }, Ii = ["innerHTML"], Pi = { key: 1 }, Ei = /* @__PURE__ */ H({
  __name: "BCarouselSlide",
  props: {
    background: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: { default: void 0 },
    id: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBlank: { type: Boolean, default: !1 },
    imgBlankColor: { default: "transparent" },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgSrcset: { default: void 0 },
    imgWidth: { default: void 0 },
    interval: { default: void 0 },
    text: { default: void 0 },
    textHtml: { default: void 0 },
    textTag: { default: "p" }
  },
  setup(t) {
    const e = t, l = Le(), a = _e(Co, null), o = k(() => e.text || e.textHtml || !Ae(l.text)), r = k(() => e.caption || e.captionHtml || !Ae(l.caption)), s = k(() => o.value || r.value || !Ae(l.default)), n = w(() => ({
      background: `${e.background || (a == null ? void 0 : a.background.value) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), i = w(() => ({
      "d-none": e.contentVisibleUp !== void 0,
      [`d-${e.contentVisibleUp}-block`]: e.contentVisibleUp !== void 0
    }));
    return (u, d) => (b(), _("div", {
      class: "carousel-item",
      style: Ee(n.value)
    }, [
      T(u.$slots, "img", {}, () => {
        var p, f;
        return [
          ve(el, {
            class: "d-block w-100",
            alt: u.imgAlt,
            srcset: u.imgSrcset,
            src: u.imgSrc,
            width: u.imgWidth || ((p = O(a)) == null ? void 0 : p.width.value),
            height: u.imgHeight || ((f = O(a)) == null ? void 0 : f.height.value),
            blank: u.imgBlank,
            "blank-color": u.imgBlankColor
          }, null, 8, ["alt", "srcset", "src", "width", "height", "blank", "blank-color"])
        ];
      }),
      s.value ? (b(), I(re(u.contentTag), {
        key: 0,
        class: D(["carousel-caption", i.value])
      }, {
        default: E(() => [
          r.value ? (b(), I(re(u.captionTag), { key: 0 }, {
            default: E(() => [
              T(u.$slots, "caption", {}, () => [
                u.captionHtml ? (b(), _("span", {
                  key: 0,
                  innerHTML: u.captionHtml
                }, null, 8, Oi)) : (b(), _("span", Ni, Y(u.caption), 1))
              ])
            ]),
            _: 3
          })) : ae("", !0),
          o.value ? (b(), I(re(u.textTag), { key: 1 }, {
            default: E(() => [
              T(u.$slots, "text", {}, () => [
                u.textHtml ? (b(), _("span", {
                  key: 0,
                  innerHTML: u.textHtml
                }, null, 8, Ii)) : (b(), _("span", Pi, Y(u.text), 1))
              ])
            ]),
            _: 3
          })) : ae("", !0),
          T(u.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : ae("", !0)
    ], 4));
  }
}), Tl = fa("", [], { type: [Boolean, String, Number], default: !1 }), Sl = fa("offset", [""], { type: [String, Number], default: null }), _l = fa("order", [""], { type: [String, Number], default: null }), Fi = H({
  name: "BCol",
  slots: Object,
  props: {
    col: { type: Boolean, default: !1 },
    // Generic flexbox .col (xs)
    cols: { type: [String, Number], default: null },
    // .col-[1-12]|auto (xs)
    ...Tl,
    offset: { type: [String, Number], default: null },
    ...Sl,
    order: { type: [String, Number], default: null },
    ..._l,
    alignSelf: { type: String, default: null },
    tag: { type: String, default: "div" }
  },
  setup(t) {
    const e = [
      { content: Tl, propPrefix: "cols", classPrefix: "col" },
      { content: Sl, propPrefix: "offset" },
      { content: _l, propPrefix: "order" }
    ], l = w(
      () => e.flatMap((o) => ho(t, o.content, o.propPrefix, o.classPrefix))
    );
    return {
      computedClasses: w(() => [
        l.value,
        {
          col: t.col || !l.value.some((o) => /^col-/.test(o)) && !t.cols,
          [`col-${t.cols}`]: !!t.cols,
          [`offset-${t.offset}`]: !!t.offset,
          [`order-${t.order}`]: !!t.order,
          [`align-self-${t.alignSelf}`]: !!t.alignSelf
        }
      ])
    };
  }
});
function Li(t, e, l, a, o, r) {
  return b(), I(re(t.tag), {
    class: D(t.computedClasses)
  }, {
    default: E(() => [
      T(t.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const Ft = /* @__PURE__ */ qt(Fi, [["render", Li]]), zi = /* @__PURE__ */ H({
  __name: "BContainer",
  props: {
    fluid: { type: [Boolean, String], default: !1 },
    gutterX: { default: void 0 },
    gutterY: { default: void 0 },
    tag: { default: "div" }
  },
  setup(t) {
    const e = t, l = be(() => e.gutterX ?? NaN, { method: "parseInt" }), a = be(() => e.gutterY ?? NaN, { method: "parseInt" }), o = w(() => ({
      container: e.fluid === !1,
      "container-fluid": e.fluid === !0,
      [`container-${e.fluid}`]: typeof e.fluid == "string",
      [`gx-${l.value}`]: !Number.isNaN(l.value),
      [`gy-${a.value}`]: !Number.isNaN(a.value)
    }));
    return (r, s) => (b(), I(re(r.tag), {
      class: D(o.value)
    }, {
      default: E(() => [
        T(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Hi = { class: "visually-hidden" }, Ri = ["aria-labelledby", "role"], un = /* @__PURE__ */ H({
  __name: "BDropdown",
  props: /* @__PURE__ */ pe({
    ariaLabel: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    center: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    dropend: { type: Boolean, default: !1 },
    dropstart: { type: Boolean, default: !1 },
    dropup: { type: Boolean, default: !1 },
    end: { type: Boolean, default: !1 },
    floatingMiddleware: { default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: !1 },
    lazy: { type: Boolean, default: !1 },
    menuClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCaret: { type: Boolean, default: !1 },
    noFlip: { type: Boolean, default: !1 },
    noShift: { type: Boolean, default: !1 },
    noSize: { type: Boolean, default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    size: { default: "md" },
    split: { type: Boolean, default: !1 },
    splitButtonType: { default: "button" },
    splitClass: { default: void 0 },
    splitDisabled: { type: Boolean, default: void 0 },
    splitHref: { default: void 0 },
    splitTo: { default: void 0 },
    splitVariant: { default: void 0 },
    strategy: { default: "absolute" },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" },
    teleportDisabled: { default: !1 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["click", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "toggle"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = Be(() => a.id, "dropdown"), s = he(t, "modelValue"), n = k(
      () => typeof a.offset == "string" || typeof a.offset == "number" ? a.offset : NaN
    ), i = be(n), u = x(null), d = x(null), p = x(null), f = x(null), m = w(
      () => a.boundary === "document" || a.boundary === "viewport" ? void 0 : a.boundary
    ), y = w(
      () => a.boundary === "document" || a.boundary === "viewport" ? a.boundary : void 0
    ), h = k(() => a.split ? d.value : p.value);
    Re(
      "Escape",
      () => {
        s.value = !s.value;
      },
      { target: h }
    ), Re(
      "Escape",
      () => {
        s.value = !s.value;
      },
      { target: u }
    );
    const c = (N, S) => {
      var M, j, A, X, G, ie, q;
      if ((j = u.value) != null && j.contains((M = N.target) == null ? void 0 : M.closest("form")) || /input|select|option|textarea|form/i.test((A = N.target) == null ? void 0 : A.tagName))
        return;
      if (N.preventDefault(), !s.value) {
        open(), Ve(() => c(N, S));
        return;
      }
      const P = (X = u.value) == null ? void 0 : X.querySelectorAll(".dropdown-item:not(.disabled):not(:disabled)");
      if (P)
        if ((G = u.value) != null && G.contains(document.activeElement)) {
          const se = u.value.querySelector(".dropdown-item:focus"), me = Array.prototype.indexOf.call(P, se) + S;
          me >= 0 && me < (P == null ? void 0 : P.length) && ((ie = P[me]) == null || ie.focus());
        } else
          (q = P[S === -1 ? P.length - 1 : 0]) == null || q.focus();
    };
    Re("ArrowUp", (N) => c(N, -1), { target: h }), Re("ArrowDown", (N) => c(N, 1), { target: h }), Re("ArrowUp", (N) => c(N, -1), { target: u }), Re("ArrowDown", (N) => c(N, 1), { target: u });
    const g = w(
      () => gr({
        top: a.dropup,
        start: a.dropstart,
        end: a.dropend,
        alignCenter: a.center,
        alignEnd: a.end
      })
    ), v = x({}), $ = w(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const N = typeof a.offset == "string" || typeof a.offset == "number" ? i.value : a.offset, S = [Xl(N)];
      return a.noFlip === !1 && S.push(
        no({
          boundary: m.value,
          rootBoundary: y.value,
          padding: a.boundaryPadding
        })
      ), a.noShift === !1 && S.push(
        oo({
          boundary: m.value,
          rootBoundary: y.value,
          padding: a.boundaryPadding
        })
      ), a.noSize === !1 && S.push(
        so({
          boundary: m.value,
          rootBoundary: y.value,
          padding: a.boundaryPadding,
          apply({ availableWidth: P, availableHeight: M }) {
            v.value = {
              maxHeight: M && s.value ? `${M}px` : void 0,
              maxWidth: P && s.value ? `${P}px` : void 0
            };
          }
        })
      ), S;
    }), { update: B, floatingStyles: C } = io(h, u, {
      placement: g,
      middleware: $,
      strategy: k(() => a.strategy),
      whileElementsMounted: lo
    }), V = w(() => ({
      dropup: a.dropup,
      dropend: a.dropend,
      dropstart: a.dropstart,
      "position-static": a.boundary !== "clippingAncestors" && !a.isNav
    })), L = w(() => [
      a.split ? a.splitClass : a.toggleClass,
      {
        "nav-link": a.isNav,
        "dropdown-toggle": !a.split,
        "dropdown-toggle-no-caret": a.noCaret && !a.split,
        show: a.split ? void 0 : s.value
      }
    ]), Q = () => {
      le();
    }, W = (N) => {
      a.split ? o("click", N) : Q();
    };
    bo(
      u,
      () => {
        s.value && (a.autoClose === !0 || a.autoClose === "outside") && le();
      },
      { ignore: [d, p] }
    );
    const F = () => {
      s.value && (a.autoClose === !0 || a.autoClose === "inside") && le();
    }, Z = () => {
      s.value && le();
    }, R = () => {
      s.value || le();
    }, le = () => {
      var P;
      o("toggle");
      const N = s.value, S = new Bt(N ? "hide" : "show");
      if (o(N ? "hide" : "show", S), S.defaultPrevented) {
        o(N ? "hide-prevented" : "show-prevented");
        return;
      }
      s.value = !N, o(N ? "hidden" : "shown"), (P = f.value) == null || P.dispatchEvent(new Event("forceHide"));
    };
    return ue(s, () => {
      B();
    }), e({
      hide: Z,
      show: R,
      toggle: le
    }), at(Oo, {
      id: r,
      show: R,
      hide: Z,
      toggle: le,
      visible: k(() => s.value),
      isNav: k(() => a.isNav)
    }), (N, S) => (b(), _("div", {
      ref_key: "wrapper",
      ref: f,
      class: D([V.value, "btn-group"])
    }, [
      ve(vt, {
        id: O(r),
        ref_key: "splitButton",
        ref: p,
        variant: N.splitVariant || N.variant,
        size: N.size,
        class: D(L.value),
        disabled: a.splitDisabled || N.disabled,
        type: N.splitButtonType,
        "aria-label": N.ariaLabel,
        "aria-expanded": a.split ? void 0 : s.value,
        "aria-haspopup": a.split ? void 0 : "menu",
        href: a.split ? N.splitHref : void 0,
        to: a.split && N.splitTo ? N.splitTo : void 0,
        onClick: W
      }, {
        default: E(() => [
          T(N.$slots, "button-content", {}, () => [
            ne(Y(N.text), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "variant", "size", "class", "disabled", "type", "aria-label", "aria-expanded", "aria-haspopup", "href", "to"]),
      a.split ? (b(), I(vt, {
        key: 0,
        ref_key: "button",
        ref: d,
        variant: N.variant,
        size: N.size,
        disabled: N.disabled,
        class: D([[N.toggleClass, { show: s.value }], "dropdown-toggle-split dropdown-toggle"]),
        "aria-expanded": s.value,
        "aria-haspopup": "menu",
        onClick: Q
      }, {
        default: E(() => [
          J("span", Hi, [
            T(N.$slots, "toggle-text", {}, () => [
              ne(Y(N.toggleText), 1)
            ])
          ])
        ]),
        _: 3
      }, 8, ["variant", "size", "disabled", "class", "aria-expanded"])) : ae("", !0),
      (b(), I(ht, {
        to: N.teleportTo,
        disabled: !N.teleportTo || N.teleportDisabled
      }, [
        !a.lazy || s.value ? ut((b(), _("ul", {
          key: 0,
          ref_key: "floating",
          ref: u,
          style: Ee([O(C), v.value]),
          class: D(["dropdown-menu overflow-auto", [N.menuClass, { show: s.value }]]),
          "aria-labelledby": O(r),
          role: N.role,
          onClick: F
        }, [
          T(N.$slots, "default", {
            hide: Z,
            show: R
          })
        ], 14, Ri)), [
          [xt, a.lazy || s.value]
        ]) : ae("", !0)
      ], 8, ["to", "disabled"]))
    ], 2));
  }
}), Mi = { role: "presentation" }, xi = /* @__PURE__ */ H({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(t) {
    return (e, l) => (b(), _("li", Mi, [
      (b(), I(re(e.tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
}), Di = { role: "presentation" }, ji = /* @__PURE__ */ H({
  __name: "BDropdownForm",
  setup(t) {
    return (e, l) => (b(), _("li", Di, [
      J("form", K({ class: "dropdown-item-text" }, e.$attrs), [
        T(e.$slots, "default")
      ], 16)
    ]));
  }
}), qi = { role: "presentation" }, Wi = ["id", "aria-describedby"], Gi = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BDropdownGroup",
  props: {
    ariaDescribedby: { default: void 0 },
    header: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: { default: null },
    id: { default: void 0 }
  },
  setup(t) {
    const e = t, l = k(() => e.id ? `${e.id}_group_dd_header` : void 0), a = k(() => e.headerTag === "header" ? void 0 : "heading"), o = w(() => [
      e.headerClass,
      {
        [`text-${e.headerVariant}`]: e.headerVariant !== null
      }
    ]);
    return (r, s) => (b(), _("li", qi, [
      (b(), I(re(r.headerTag), {
        id: l.value,
        class: D(["dropdown-header", o.value]),
        role: a.value
      }, {
        default: E(() => [
          T(r.$slots, "header", {}, () => [
            ne(Y(r.header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      J("ul", K({
        id: r.id,
        role: "group",
        class: "list-unstyled"
      }, r.$attrs, {
        "aria-describedby": r.ariaDescribedby || l.value
      }), [
        T(r.$slots, "default")
      ], 16, Wi)
    ]));
  }
}), Ui = { class: "dropdown-header" }, Ki = /* @__PURE__ */ H({
  __name: "BDropdownHeader",
  setup(t) {
    return (e, l) => (b(), _("li", null, [
      J("h6", Ui, [
        T(e.$slots, "default")
      ])
    ]));
  }
}), Xi = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BDropdownItem",
  props: {
    linkClass: { default: void 0 },
    wrapperAttrs: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: null }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const l = t, a = e, { class: o, ...r } = Mt(), { computedLink: s, computedLinkProps: n } = wt(l), i = w(() => [
      l.linkClass,
      {
        active: l.active,
        disabled: l.disabled,
        [`text-${l.variant}`]: l.variant !== null
      }
    ]), u = k(() => s.value ? ot : l.href ? "a" : "button"), d = _e(Xa, null), p = _e(Oo, null), f = _e(Ya, null), m = (y) => {
      var h, c, g;
      a("click", y), f !== null && ((h = f == null ? void 0 : f.autoClose) == null ? void 0 : h.value) === !0 && ((c = d == null ? void 0 : d.hide) == null || c.call(d)), (g = p == null ? void 0 : p.hide) == null || g.call(p);
    };
    return (y, h) => (b(), _("li", K({
      role: "presentation",
      class: O(o)
    }, y.wrapperAttrs), [
      (b(), I(re(u.value), K({
        class: ["dropdown-item", i.value],
        disabled: l.disabled,
        "aria-disabled": l.disabled ? !0 : null,
        "aria-current": l.active ? !0 : null,
        href: u.value === "a" ? y.href : null,
        rel: y.rel,
        role: "menuitem",
        type: u.value === "button" ? "button" : null,
        target: y.target
      }, { ...O(n), ...r }, { onClick: m }), {
        default: E(() => [
          T(y.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "disabled", "aria-disabled", "aria-current", "href", "rel", "type", "target"]))
    ], 16));
  }
}), Yi = { role: "presentation" }, Zi = ["disabled"], Ji = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BDropdownItemButton",
  props: {
    active: { type: Boolean, default: !1 },
    activeClass: { default: "active" },
    buttonClass: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    variant: { default: null }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = w(() => [
      l.buttonClass,
      {
        [l.activeClass]: l.active,
        disabled: l.disabled,
        [`text-${l.variant}`]: l.variant !== null
      }
    ]), r = (s) => {
      a("click", s);
    };
    return (s, n) => (b(), _("li", Yi, [
      J("button", {
        role: "menu",
        type: "button",
        class: D(["dropdown-item", o.value]),
        disabled: l.disabled,
        onClick: r
      }, [
        T(s.$slots, "default")
      ], 10, Zi)
    ]));
  }
}), Qi = { role: "presentation" }, eu = /* @__PURE__ */ H({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(t) {
    return (e, l) => (b(), _("li", Qi, [
      J("span", K({ class: "dropdown-item-text" }, e.$attrs), [
        T(e.$slots, "default", {}, () => [
          ne(Y(e.text), 1)
        ])
      ], 16)
    ]));
  }
}), tu = ["id", "novalidate"], dn = /* @__PURE__ */ H({
  __name: "BForm",
  props: {
    floating: { type: Boolean, default: !1 },
    id: { default: void 0 },
    novalidate: { type: Boolean, default: !1 },
    validated: { type: Boolean, default: !1 }
  },
  emits: ["submit"],
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = x(null), s = w(() => ({
      "form-floating": a.floating,
      "was-validated": a.validated
    })), n = (i) => {
      o("submit", i);
    };
    return e({
      element: r
    }), (i, u) => (b(), _("form", {
      id: i.id,
      ref_key: "element",
      ref: r,
      novalidate: a.novalidate,
      class: D(s.value),
      onSubmit: ft(n, ["prevent"])
    }, [
      T(i.$slots, "default")
    ], 42, tu));
  }
}), au = { class: "form-floating" }, lu = ["for"], ou = /* @__PURE__ */ H({
  __name: "BFormFloatingLabel",
  props: {
    label: { default: void 0 },
    labelFor: { default: void 0 },
    text: { default: void 0 }
  },
  setup(t) {
    return (e, l) => (b(), _("div", au, [
      T(e.$slots, "default", {}, () => [
        ne(Y(e.text), 1)
      ]),
      J("label", { for: e.labelFor }, [
        T(e.$slots, "label", {}, () => [
          ne(Y(e.label), 1)
        ])
      ], 8, lu)
    ]));
  }
}), Va = /* @__PURE__ */ H({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: Boolean, default: !1 },
    id: { default: void 0 },
    role: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    tag: { default: "div" },
    text: { default: void 0 },
    tooltip: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, l = k(() => e.forceShow === !0 || e.state === !1), a = w(() => ({
      "d-block": l.value,
      "invalid-feedback": !e.tooltip,
      "invalid-tooltip": e.tooltip
    }));
    return (o, r) => (b(), I(re(o.tag), {
      id: o.id,
      role: o.role,
      "aria-live": o.ariaLive,
      "aria-atomic": o.ariaLive ? !0 : void 0,
      class: D(a.value)
    }, {
      default: E(() => [
        T(o.$slots, "default", {}, () => [
          ne(Y(o.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), Qt = /* @__PURE__ */ H({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(t) {
    return (e, l) => (b(), I(re(e.tag), { class: "row d-flex flex-wrap" }, {
      default: E(() => [
        T(e.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Aa = /* @__PURE__ */ H({
  __name: "BFormText",
  props: {
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    tag: { default: "small" },
    text: { default: void 0 },
    textVariant: { default: "body-secondary" }
  },
  setup(t) {
    const e = t, l = w(() => ({
      [`text-${e.textVariant}`]: e.textVariant !== null,
      "form-text": !e.inline
    }));
    return (a, o) => (b(), I(re(a.tag), {
      id: a.id,
      class: D(l.value)
    }, {
      default: E(() => [
        T(a.$slots, "default", {}, () => [
          ne(Y(a.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Oa = /* @__PURE__ */ H({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: Boolean, default: !1 },
    id: { default: void 0 },
    role: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    tag: { default: "div" },
    text: { default: void 0 },
    tooltip: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, l = k(() => e.forceShow === !0 || e.state === !0), a = w(() => ({
      "d-block": l.value,
      "valid-feedback": !e.tooltip,
      "valid-tooltip": e.tooltip
    }));
    return (o, r) => (b(), I(re(o.tag), {
      id: o.id,
      role: o.role,
      "aria-live": o.ariaLive,
      "aria-atomic": o.ariaLive ? !0 : void 0,
      class: D(a.value)
    }, {
      default: E(() => [
        T(o.$slots, "default", {}, () => [
          ne(Y(o.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), cn = H({
  name: "ComponentOrEmpty",
  slots: Object,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    to: {
      type: [String, Object],
      default: null
    },
    skip: {
      type: Boolean,
      default: !1
    }
  },
  setup(t, { slots: e, attrs: l }) {
    return () => {
      var a, o, r;
      return t.skip ? (a = e.default) == null ? void 0 : a.call(e) : t.tag === "Teleport" ? Ne(ht, { to: t.to }, [(o = e.default) == null ? void 0 : o.call(e)]) : Ne(t.tag, { ...l }, [(r = e.default) == null ? void 0 : r.call(e)]);
    };
  }
}), nu = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "true-value", "false-value", "indeterminate"], su = ["for"], fn = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BFormCheckbox",
  props: /* @__PURE__ */ pe({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    button: { type: Boolean, default: !1 },
    buttonGroup: { type: Boolean, default: !1 },
    buttonVariant: { default: null },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    indeterminate: { type: Boolean },
    inline: { type: Boolean, default: !1 },
    modelValue: { type: [Array, Set, String, Boolean, Object, Number, null] },
    name: { default: void 0 },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: void 0 },
    reverse: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    switch: { type: Boolean, default: !1 },
    uncheckedValue: { type: [Array, Set, String, Boolean, Object, Number, null], default: !1 },
    value: { type: [String, Boolean, Array, Set, Object, Number, null], default: !0 }
  }, {
    modelValue: { type: [Array, Set, String, Boolean, Object, Number, null], default: void 0 },
    modelModifiers: {},
    indeterminate: { type: Boolean, default: !1 },
    indeterminateModifiers: {}
  }),
  emits: ["update:modelValue", "update:indeterminate"],
  setup(t, { expose: e }) {
    const l = t, a = Le(), o = he(t, "modelValue"), r = he(t, "indeterminate"), s = Be(() => l.id, "form-check"), n = _e(Vo, null), i = x(null), { focused: u } = Pe(i, {
      initialValue: l.autofocus
    }), d = k(() => !Ae(a.default)), p = w({
      get: () => (n == null ? void 0 : n.modelValue.value) ?? o.value,
      set: (v) => {
        if (v !== void 0) {
          if (r.value = !1, n !== null && Array.isArray(v)) {
            n.modelValue.value = v;
            return;
          }
          o.value = v;
        }
      }
    }), f = k(
      () => !!(l.name ?? (n == null ? void 0 : n.name.value)) && (l.required || (n == null ? void 0 : n.required.value))
    ), m = k(() => l.buttonGroup || ((n == null ? void 0 : n.buttons.value) ?? !1)), y = w(() => ({
      plain: l.plain || ((n == null ? void 0 : n.plain.value) ?? !1),
      button: l.button || ((n == null ? void 0 : n.buttons.value) ?? !1),
      inline: l.inline || ((n == null ? void 0 : n.inline.value) ?? !1),
      reverse: l.reverse || ((n == null ? void 0 : n.reverse.value) ?? !1),
      switch: l.switch || ((n == null ? void 0 : n.switch.value) ?? !1),
      state: l.state || (n == null ? void 0 : n.state.value),
      size: l.size ?? (n == null ? void 0 : n.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: l.buttonVariant ?? (n == null ? void 0 : n.buttonVariant.value) ?? "secondary",
      // This is where the true default is made
      hasDefaultSlot: d.value
    })), h = Ro(y), c = Mo(y), g = xo(y);
    return e({
      blur: () => {
        u.value = !1;
      },
      element: i,
      focus: () => {
        u.value = !0;
      }
    }), (v, $) => (b(), I(cn, {
      skip: m.value,
      class: D(O(h))
    }, {
      default: E(() => {
        var B, C, V;
        return [
          ut(J("input", K({ id: O(s) }, v.$attrs, {
            ref_key: "input",
            ref: i,
            "onUpdate:modelValue": $[0] || ($[0] = (L) => p.value = L),
            class: O(c),
            type: "checkbox",
            disabled: l.disabled || ((B = O(n)) == null ? void 0 : B.disabled.value),
            required: f.value || void 0,
            name: v.name || ((C = O(n)) == null ? void 0 : C.name.value),
            form: v.form || ((V = O(n)) == null ? void 0 : V.form.value),
            "aria-label": v.ariaLabel,
            "aria-labelledby": v.ariaLabelledby,
            "aria-required": f.value || void 0,
            value: v.value,
            "true-value": v.value,
            "false-value": v.uncheckedValue,
            indeterminate: l.indeterminate
          }), null, 16, nu), [
            [On, p.value]
          ]),
          d.value || l.plain === !1 ? (b(), _("label", {
            key: 0,
            for: O(s),
            class: D(O(g))
          }, [
            T(v.$slots, "default")
          ], 10, su)) : ae("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), ru = ["id"], iu = ["innerHTML"], uu = /* @__PURE__ */ H({
  __name: "BFormCheckboxGroup",
  props: /* @__PURE__ */ pe({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    modelValue: {},
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    reverse: { type: Boolean, default: !1 },
    size: { default: "md" },
    stacked: { type: Boolean, default: !1 },
    state: { type: [Boolean, null], default: null },
    switches: { type: Boolean, default: !1 },
    textField: { default: "text" },
    validated: { type: Boolean, default: !1 },
    valueField: { default: "value" }
  }, {
    modelValue: {
      default: () => []
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: e }) {
    const l = t, a = he(t, "modelValue"), o = Be(() => l.id, "checkbox"), r = Be(() => l.name, "checkbox"), s = x(null), { focused: n } = Pe(s, {
      initialValue: l.autofocus
    });
    at(Vo, {
      modelValue: a,
      switch: k(() => l.switches),
      buttonVariant: k(() => l.buttonVariant),
      form: k(() => l.form),
      name: r,
      state: k(() => l.state),
      plain: k(() => l.plain),
      size: k(() => l.size),
      inline: k(() => !l.stacked),
      reverse: k(() => l.reverse),
      required: k(() => l.required),
      buttons: k(() => l.buttons),
      disabled: k(() => l.disabled)
    });
    const i = w(
      () => l.options.map(
        (f, m) => typeof f == "string" || typeof f == "number" ? {
          props: {
            value: f,
            disabled: l.disabled
          },
          text: f.toString(),
          html: void 0,
          self: Symbol(`checkboxGroupOptionItem${m}`)
        } : {
          props: {
            value: f[l.valueField],
            disabled: f[l.disabledField],
            ...f.props ? f.props : {}
          },
          text: f[l.textField],
          html: f[l.htmlField],
          self: Symbol(`checkboxGroupOptionItem${m}`)
        }
      )
    ), u = w(() => ({
      required: l.required,
      ariaInvalid: l.ariaInvalid,
      state: l.state,
      validated: l.validated,
      buttons: l.buttons,
      stacked: l.stacked,
      size: l.size
    })), d = Do(u), p = jo(u);
    return e({
      blur: () => {
        n.value = !1;
      },
      focus: () => {
        n.value = !0;
      }
    }), (f, m) => (b(), _("div", K(O(d), {
      id: O(o),
      ref_key: "element",
      ref: s,
      role: "group",
      class: [O(p), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      T(f.$slots, "first"),
      (b(!0), _(de, null, Ce(i.value, (y) => (b(), I(fn, K({
        key: y.self,
        ref_for: !0
      }, y.props), {
        default: E(() => [
          y.html ? (b(), _("span", {
            key: 0,
            innerHTML: y.html
          }, null, 8, iu)) : (b(), _(de, { key: 1 }, [
            ne(Y(y.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1040))), 128)),
      T(f.$slots, "default")
    ], 16, ru));
  }
}), du = ["for"], cu = ["for"], fu = { class: "input-group form-input-file" }, vu = ["id", "form", "name", "multiple", "disabled", "capture", "accept", "required", "aria-label", "aria-labelledby", "aria-required", "directory", "webkitdirectory"], pu = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BFormFile",
  props: /* @__PURE__ */ pe({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    accept: { default: "" },
    autofocus: { type: Boolean, default: !1 },
    browserText: { default: "Choose" },
    capture: { type: [Boolean, String], default: !1 },
    directory: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    label: { default: "" },
    labelClass: { default: void 0 },
    modelValue: {},
    multiple: { type: Boolean, default: !1 },
    name: { default: void 0 },
    noDrop: { type: Boolean, default: !1 },
    noTraverse: { type: Boolean, default: !1 },
    placement: { default: "start" },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null }
  }, {
    modelValue: {
      default: null
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: e }) {
    const l = Le(), a = t, o = he(t, "modelValue"), r = Be(() => a.id), s = Ct(() => a.state), n = x(null), { focused: i } = Pe(n, { initialValue: a.autofocus }), u = k(() => !Ae(l.label)), d = k(
      () => typeof a.accept == "string" ? a.accept : a.accept.join(",")
    ), p = w(() => [
      s.value,
      {
        [`form-control-${a.size}`]: a.size !== void 0
      }
    ]), f = () => {
      var v, $;
      const g = ((v = n.value) == null ? void 0 : v.files) === null || (($ = n.value) == null ? void 0 : $.files) === void 0 ? null : [...n.value.files];
      o.value = g === null ? null : a.multiple === !0 ? g : g[0];
    }, m = (g) => {
      a.noDrop === !0 && g.preventDefault();
    }, y = () => {
      o.value = null;
    };
    ue(o, (g) => {
      g === null && n.value !== null && (n.value.value = "");
    }), e({
      blur: () => {
        i.value = !1;
      },
      element: n,
      focus: () => {
        i.value = !0;
      },
      reset: y
    });
    const [h, c] = zt();
    return (g, v) => (b(), _(de, null, [
      ve(O(h), null, {
        default: E(() => [
          J("label", {
            class: "input-group-text",
            for: O(r)
          }, Y(g.browserText), 9, du)
        ]),
        _: 1
      }),
      u.value || g.label ? (b(), _("label", {
        key: 0,
        class: D(["form-label", g.labelClass]),
        for: O(r)
      }, [
        T(g.$slots, "label", {}, () => [
          ne(Y(g.label), 1)
        ], !0)
      ], 10, cu)) : ae("", !0),
      J("div", fu, [
        g.placement === "start" ? (b(), I(O(c), { key: 0 })) : ae("", !0),
        J("input", K({ id: O(r) }, g.$attrs, {
          ref_key: "input",
          ref: n,
          type: "file",
          class: ["form-control", p.value],
          form: g.form,
          name: g.name,
          multiple: a.multiple,
          disabled: a.disabled,
          capture: a.capture,
          accept: d.value || void 0,
          required: a.required || void 0,
          "aria-label": g.ariaLabel,
          "aria-labelledby": g.ariaLabelledby,
          "aria-required": a.required || void 0,
          directory: a.directory,
          webkitdirectory: a.directory,
          onChange: f,
          onDrop: m
        }), null, 16, vu),
        g.placement === "end" ? (b(), I(O(c), { key: 1 })) : ae("", !0)
      ])
    ], 64));
  }
}), mu = /* @__PURE__ */ qt(pu, [["__scopeId", "data-v-1eb930f5"]]), vn = ["input", "select", "textarea"], bu = vn.map((t) => `${t}:not([disabled])`).join(), yu = [...vn, "a", "button", "label"], gu = "label", hu = "invalid-feedback", Bu = "valid-feedback", wu = "description", Cu = "default", ku = H({
  components: { BCol: Ft, BFormInvalidFeedback: Va, BFormRow: Qt, BFormText: Aa, BFormValidFeedback: Oa },
  props: {
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    contentCols: { type: [Boolean, String, Number], default: void 0 },
    contentColsLg: { type: [Boolean, String, Number], default: void 0 },
    contentColsMd: { type: [Boolean, String, Number], default: void 0 },
    contentColsSm: { type: [Boolean, String, Number], default: void 0 },
    contentColsXl: { type: [Boolean, String, Number], default: void 0 },
    description: { type: [String], default: void 0 },
    disabled: { type: Boolean, default: !1 },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, default: void 0 },
    invalidFeedback: { type: String, default: void 0 },
    label: { type: String, default: void 0 },
    labelAlign: { type: [Boolean, String, Number], default: void 0 },
    labelAlignLg: { type: [Boolean, String, Number], default: void 0 },
    labelAlignMd: { type: [Boolean, String, Number], default: void 0 },
    labelAlignSm: { type: [Boolean, String, Number], default: void 0 },
    labelAlignXl: { type: [Boolean, String, Number], default: void 0 },
    labelClass: { type: [Array, Object, String], default: void 0 },
    labelCols: { type: [Boolean, String, Number], default: void 0 },
    labelColsLg: { type: [Boolean, String, Number], default: void 0 },
    labelColsMd: { type: [Boolean, String, Number], default: void 0 },
    labelColsSm: { type: [Boolean, String, Number], default: void 0 },
    labelColsXl: { type: [Boolean, String, Number], default: void 0 },
    labelFor: { type: String, default: void 0 },
    labelSize: { type: String, default: void 0 },
    labelSrOnly: { type: Boolean, default: !1 },
    state: { type: Boolean, default: null },
    tooltip: { type: Boolean, default: !1 },
    validFeedback: { type: String, default: void 0 },
    validated: { type: Boolean, default: !1 },
    floating: { type: Boolean, default: !1 }
  },
  setup(t) {
    const l = ["xs", "sm", "md", "lg", "xl"], a = (y, h) => l.reduce((c, g) => {
      const v = wl(g === "xs" ? "" : g, `${h}Align`), $ = y[v] || null;
      return $ && (g === "xs" ? c.push(`text-${$}`) : c.push(`text-${g}-${$}`)), c;
    }, []), o = (y, h) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      l.reduce((c, g) => {
        const v = wl(g === "xs" ? "" : g, `${h}Cols`);
        let $ = y[v];
        if ($ = $ === "" ? !0 : $ || !1, typeof $ != "boolean" && $ !== "auto") {
          const B = Number.parseInt($);
          $ = Number.isNaN(B) ? 0 : B, $ = $ > 0 ? $ : !1;
        }
        return $ && (g === "xs" ? c[typeof $ == "boolean" ? "col" : "cols"] = $ : c[g || (typeof $ == "boolean" ? "col" : "cols")] = $), c;
      }, {})
    ), r = x(null), s = (y, h = null) => {
      if (za && t.labelFor && r.value !== null) {
        const c = r.value.querySelector(`#${CSS.escape(t.labelFor)}`);
        if (c) {
          const g = "aria-describedby", v = (y || "").split(Zt), $ = (h || "").split(Zt), B = (c.getAttribute(g) || "").split(Zt).filter((C) => !$.includes(C)).concat(v).filter((C, V, L) => L.indexOf(C) === V).filter((C) => C).join(" ").trim();
          B ? c.setAttribute(g, B) : c.removeAttribute(g);
        }
      }
    }, n = w(() => o(t, "content")), i = w(() => a(t, "label")), u = w(() => o(t, "label")), d = w(
      () => (
        // Determine if the form group will be rendered horizontal
        // based on the existence of 'content-col' or 'label-col' props
        Object.keys(n.value).length > 0 || Object.keys(u.value).length > 0
      )
    ), p = Ct(() => t.state), f = ua(
      () => t.ariaInvalid,
      () => t.state
    );
    return ue(
      () => null,
      (y, h) => {
        y !== h && s(y, h);
      }
    ), Xe(() => {
      Ve(() => {
        s(null);
      });
    }), {
      ariaDescribedby: null,
      computedAriaInvalid: f,
      contentColProps: n,
      isHorizontal: d,
      labelAlignClasses: i,
      labelColProps: u,
      onLegendClick: (y) => {
        if (t.labelFor || r.value === null)
          return;
        const { target: h } = y, c = h ? h.tagName : "";
        if (yu.indexOf(c) !== -1)
          return;
        const g = [...r.value.querySelectorAll(bu)].filter(Fn), [v] = g;
        g.length === 1 && v instanceof HTMLElement && En(v);
      },
      stateClass: p
    };
  },
  render() {
    const t = this.$props, e = this.$slots, l = Be(), a = !t.labelFor;
    let o = null;
    const r = Et(gu, {}, e) || t.label, s = r ? Be(void 0, "_BV_label_").value : null;
    if (r || this.isHorizontal) {
      const B = a ? "legend" : "label";
      if (t.labelSrOnly)
        r && (o = Ne(
          B,
          {
            class: "visually-hidden",
            id: s,
            for: t.labelFor || null
          },
          r
        )), this.isHorizontal ? o = Ne(Ft, this.labelColProps, { default: () => o }) : o = Ne("div", {}, [o]);
      else {
        const C = {
          onClick: a ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? B : null,
          id: s,
          for: t.labelFor || null,
          tabIndex: a ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": a,
              "col-form-label": this.isHorizontal || a,
              "pt-0": !this.isHorizontal && a,
              "d-block": !this.isHorizontal && !a,
              [`col-form-label-${t.labelSize}`]: !!t.labelSize
            },
            this.labelAlignClasses,
            t.labelClass
          ]
        };
        this.isHorizontal ? o = Ne(Ft, C, { default: () => r }) : o = Ne(B, C, r);
      }
    }
    let n = null;
    const i = Et(hu, {}, e) || this.invalidFeedback, u = i ? Be(void 0, "_BV_feedback_invalid_").value : void 0;
    i && (n = Ne(
      Va,
      {
        ariaLive: t.feedbackAriaLive,
        id: u,
        state: t.state,
        tooltip: t.tooltip
      },
      { default: () => i }
    ));
    let d = null;
    const p = Et(Bu, {}, e) || this.validFeedback, f = p ? Be(void 0, "_BV_feedback_valid_").value : void 0;
    p && (d = Ne(
      Oa,
      {
        ariaLive: t.feedbackAriaLive,
        id: f,
        state: t.state,
        tooltip: t.tooltip
      },
      { default: () => p }
      // validFeedbackContent
    ));
    let m = null;
    const y = Et(wu, {}, e) || this.description, h = y ? Be(void 0, "_BV_description_").value : void 0;
    y && (m = Ne(
      Aa,
      {
        id: h
      },
      { default: () => y }
    ));
    const c = this.ariaDescribedby = [
      h,
      t.state === !1 ? u : null,
      t.state === !0 ? f : null
    ].filter((B) => B).join(" ") || null, g = [
      Et(Cu, { ariaDescribedby: c, descriptionId: h, id: l, labelId: s }, e) || "",
      n,
      d,
      m
    ];
    !this.isHorizontal && t.floating && g.push(o);
    let v = Ne(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && t.floating
          }
        ]
      },
      g
    );
    this.isHorizontal && (v = Ne(Ft, { ref: "content", ...this.contentColProps }, { default: () => g }));
    const $ = {
      class: [
        this.stateClass,
        {
          "was-validated": t.validated
        }
      ],
      id: Be(() => t.id).value,
      disabled: a ? t.disabled : null,
      role: a ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      // Only apply `aria-labelledby` if we are a horizontal fieldset
      // as the legend is no longer a direct child of fieldset
      "aria-labelledby": a && this.isHorizontal ? s : null
    };
    return this.isHorizontal && !a ? Ne(Qt, $, { default: () => [o, v] }) : Ne(
      a ? "fieldset" : "div",
      $,
      this.isHorizontal && a ? [Ne(Qt, null, { default: () => [o, v] })] : this.isHorizontal || !t.floating ? [o, v] : [v]
    );
  }
}), $u = ["id", "value", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"], Tu = /* @__PURE__ */ H({
  __name: "BFormInput",
  props: {
    max: { default: void 0 },
    min: { default: void 0 },
    step: { default: void 0 },
    type: { default: "text" },
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazy: { type: Boolean, default: !1 },
    lazyFormatter: { type: Boolean, default: !1 },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    number: { type: Boolean, default: !1 },
    placeholder: { default: void 0 },
    plaintext: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    trim: { type: Boolean, default: !1 },
    debounce: { default: 0 },
    debounceMaxWait: { default: NaN }
  },
  emits: ["update:modelValue"],
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, { input: r, computedId: s, computedAriaInvalid: n, onInput: i, onChange: u, onBlur: d, focus: p, blur: f } = qo(a, o), m = Ct(() => a.state), y = x(!1), h = w(() => {
      const c = a.type === "range", g = a.type === "color";
      return [
        m.value,
        {
          "form-control-highlighted": y.value,
          "form-range": c,
          "form-control": g || !a.plaintext && !c,
          "form-control-color": g,
          "form-control-plaintext": a.plaintext && !c && !g,
          [`form-control-${a.size}`]: !!a.size
        }
      ];
    });
    return e({
      blur: f,
      element: r,
      focus: p
    }), (c, g) => (b(), _("input", {
      id: O(s),
      ref_key: "input",
      ref: r,
      value: c.modelValue,
      class: D(h.value),
      name: c.name || void 0,
      form: c.form || void 0,
      type: c.type,
      disabled: a.disabled,
      placeholder: c.placeholder,
      required: a.required || void 0,
      autocomplete: c.autocomplete || void 0,
      readonly: a.readonly || a.plaintext,
      min: c.min,
      max: c.max,
      step: c.step,
      list: c.type !== "password" ? c.list : void 0,
      "aria-required": a.required || void 0,
      "aria-invalid": O(n),
      onInput: g[0] || (g[0] = (v) => O(i)(v)),
      onChange: g[1] || (g[1] = (v) => O(u)(v)),
      onBlur: g[2] || (g[2] = (v) => O(d)(v))
    }, null, 42, $u));
  }
}), Su = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"], _u = ["for"], pn = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BFormRadio",
  props: /* @__PURE__ */ pe({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    button: { type: Boolean, default: !1 },
    buttonGroup: { type: Boolean, default: !1 },
    buttonVariant: { default: null },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    modelValue: { type: [Boolean, String, Array, Object, Number, null] },
    name: { default: void 0 },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    reverse: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    value: { type: [Boolean, String, Array, Object, Number, null], default: !0 }
  }, {
    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: void 0 },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: e }) {
    const l = t, a = Le(), o = he(t, "modelValue"), r = Be(() => l.id, "form-check"), s = _e(Ao, null), n = x(null), { focused: i } = Pe(n, {
      initialValue: l.autofocus
    }), u = k(() => !Ae(a.default)), d = w({
      get: () => (s == null ? void 0 : s.modelValue.value) ?? o.value,
      set: (g) => {
        if (g !== void 0) {
          if (s !== null) {
            s.modelValue.value = g;
            return;
          }
          o.value = g;
        }
      }
    }), p = k(
      () => !!(l.name ?? (s == null ? void 0 : s.name.value)) && (l.required || (s == null ? void 0 : s.required.value))
    ), f = k(() => l.buttonGroup || ((s == null ? void 0 : s.buttons.value) ?? !1)), m = w(() => ({
      plain: l.plain || ((s == null ? void 0 : s.plain.value) ?? !1),
      button: l.button || ((s == null ? void 0 : s.buttons.value) ?? !1),
      inline: l.inline || ((s == null ? void 0 : s.inline.value) ?? !1),
      state: l.state || (s == null ? void 0 : s.state.value),
      reverse: l.reverse || ((s == null ? void 0 : s.reverse.value) ?? !1),
      size: l.size ?? (s == null ? void 0 : s.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: l.buttonVariant ?? (s == null ? void 0 : s.buttonVariant.value) ?? "secondary",
      // This is where the true default is made
      hasDefaultSlot: u.value
    })), y = Ro(m), h = Mo(m), c = xo(m);
    return e({
      blur: () => {
        i.value = !1;
      },
      element: n,
      focus: () => {
        i.value = !0;
      }
    }), (g, v) => (b(), I(cn, {
      skip: f.value,
      class: D(O(y))
    }, {
      default: E(() => {
        var $, B, C;
        return [
          ut(J("input", K({ id: O(r) }, g.$attrs, {
            ref_key: "input",
            ref: n,
            "onUpdate:modelValue": v[0] || (v[0] = (V) => d.value = V),
            class: O(h),
            type: "radio",
            disabled: l.disabled || (($ = O(s)) == null ? void 0 : $.disabled.value),
            required: p.value || void 0,
            name: g.name || ((B = O(s)) == null ? void 0 : B.name.value),
            form: g.form || ((C = O(s)) == null ? void 0 : C.form.value),
            "aria-label": g.ariaLabel,
            "aria-labelledby": g.ariaLabelledby,
            value: g.value,
            "aria-required": p.value || void 0
          }), null, 16, Su), [
            [Nn, d.value]
          ]),
          u.value || l.plain === !1 ? (b(), _("label", {
            key: 0,
            for: O(r),
            class: D(O(c))
          }, [
            T(g.$slots, "default")
          ], 10, _u)) : ae("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), Vu = ["id"], Au = ["innerHTML"], Ou = /* @__PURE__ */ H({
  __name: "BFormRadioGroup",
  props: /* @__PURE__ */ pe({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    modelValue: { type: [Boolean, String, Array, Object, Number, null] },
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    reverse: { type: Boolean, default: !1 },
    size: { default: "md" },
    stacked: { type: Boolean, default: !1 },
    state: { type: [Boolean, null], default: null },
    textField: { default: "text" },
    validated: { type: Boolean, default: !1 },
    valueField: { default: "value" }
  }, {
    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: null },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: e }) {
    const l = t, a = he(t, "modelValue"), o = Be(() => l.id, "radio"), r = Be(() => l.name, "checkbox"), s = x(null), { focused: n } = Pe(s, {
      initialValue: l.autofocus
    });
    at(Ao, {
      modelValue: a,
      buttonVariant: k(() => l.buttonVariant),
      form: k(() => l.form),
      name: r,
      buttons: k(() => l.buttons),
      state: k(() => l.state),
      plain: k(() => l.plain),
      size: k(() => l.size),
      inline: k(() => !l.stacked),
      reverse: k(() => l.reverse),
      required: k(() => l.required),
      disabled: k(() => l.disabled)
    });
    const i = w(
      () => l.options.map(
        (f, m) => typeof f == "string" || typeof f == "number" ? {
          value: f,
          disabled: l.disabled,
          text: f.toString(),
          html: void 0,
          self: Symbol(`radioGroupOptionItem${m}`)
        } : {
          value: f[l.valueField],
          disabled: f[l.disabledField],
          ...f.props ? f.props : {},
          text: f[l.textField],
          html: f[l.htmlField],
          self: Symbol(`radioGroupOptionItem${m}`)
        }
      )
    ), u = w(() => ({
      required: l.required,
      ariaInvalid: l.ariaInvalid,
      state: l.state,
      validated: l.validated,
      buttons: l.buttons,
      stacked: l.stacked,
      size: l.size
    })), d = Do(u), p = jo(u);
    return e({
      blur: () => {
        n.value = !1;
      },
      focus: () => {
        n.value = !0;
      }
    }), (f, m) => (b(), _("div", K(O(d), {
      id: O(o),
      ref_key: "element",
      ref: s,
      role: "radiogroup",
      class: [O(p), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      T(f.$slots, "first"),
      (b(!0), _(de, null, Ce(i.value, (y) => (b(), I(pn, {
        key: y.self,
        disabled: y.disabled,
        value: y.value
      }, {
        default: E(() => [
          y.html ? (b(), _("span", {
            key: 0,
            innerHTML: y.html
          }, null, 8, Au)) : (b(), _(de, { key: 1 }, [
            ne(Y(y.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1032, ["disabled", "value"]))), 128)),
      T(f.$slots, "default")
    ], 16, Vu));
  }
}), Nu = ["value", "disabled"], al = /* @__PURE__ */ H({
  __name: "BFormSelectOption",
  props: {
    disabled: { type: Boolean, default: !1 },
    value: { default: void 0 }
  },
  setup(t) {
    const e = t;
    return (l, a) => (b(), _("option", {
      value: l.value,
      disabled: e.disabled
    }, [
      T(l.$slots, "default")
    ], 8, Nu));
  }
}), Iu = ["label"], Pu = ["innerHTML"], mn = /* @__PURE__ */ H({
  __name: "BFormSelectOptionGroup",
  props: {
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    label: { default: void 0 },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(t) {
    const e = t, { normalizedOptions: l } = Wo(() => e.options, e), a = w(() => l.value);
    return (o, r) => (b(), _("optgroup", { label: o.label }, [
      T(o.$slots, "first"),
      (b(!0), _(de, null, Ce(a.value, (s, n) => (b(), I(al, K({
        key: n,
        disabled: s.disabled,
        value: s.value,
        ref_for: !0
      }, o.$attrs), {
        default: E(() => [
          s.html ? (b(), _("span", {
            key: 0,
            innerHTML: s.html
          }, null, 8, Pu)) : (b(), _(de, { key: 1 }, [
            ne(Y(s.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1040, ["disabled", "value"]))), 128)),
      T(o.$slots, "default")
    ], 8, Iu));
  }
}), Eu = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"], Fu = ["innerHTML"], Lu = /* @__PURE__ */ H({
  __name: "BFormSelect",
  props: /* @__PURE__ */ pe({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    labelField: { default: "label" },
    modelValue: { type: [Boolean, String, Array, Object, Number, null] },
    multiple: { type: Boolean, default: !1 },
    name: { default: void 0 },
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    selectSize: { default: 0 },
    size: { default: "md" },
    state: { type: [Boolean, null], default: null },
    textField: { default: "text" },
    valueField: { default: "value" }
  }, {
    modelValue: {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      default: ""
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: e }) {
    const l = t, a = he(t, "modelValue"), o = Be(() => l.id, "input"), r = be(() => l.selectSize), s = Ct(() => l.state), n = x(null), { focused: i } = Pe(n, {
      initialValue: l.autofocus
    }), u = w(() => [
      s.value,
      {
        "form-control": l.plain,
        [`form-control-${l.size}`]: l.size !== "md" && l.plain,
        "form-select": !l.plain,
        [`form-select-${l.size}`]: l.size !== "md" && !l.plain
      }
    ]), d = k(
      () => r.value || l.plain ? r.value : void 0
    ), p = ua(
      () => l.ariaInvalid,
      () => l.state
    ), { normalizedOptions: f, isComplex: m } = Wo(() => l.options, l), y = w(
      () => f.value
    ), h = w({
      get: () => a.value,
      set: (c) => {
        a.value = c;
      }
    });
    return e({
      blur: () => {
        i.value = !1;
      },
      element: n,
      focus: () => {
        i.value = !0;
      }
    }), (c, g) => ut((b(), _("select", {
      id: O(o),
      ref_key: "input",
      ref: n,
      "onUpdate:modelValue": g[0] || (g[0] = (v) => h.value = v),
      class: D(u.value),
      name: c.name,
      form: c.form || void 0,
      multiple: l.multiple || void 0,
      size: d.value,
      disabled: l.disabled,
      required: l.required || void 0,
      "aria-required": l.required || void 0,
      "aria-invalid": O(p)
    }, [
      T(c.$slots, "first"),
      (b(!0), _(de, null, Ce(y.value, (v, $) => (b(), _(de, { key: $ }, [
        O(m)(v) ? (b(), I(mn, {
          key: 0,
          label: v.label,
          options: v.options,
          "value-field": c.valueField,
          "text-field": c.textField,
          "html-field": c.htmlField,
          "disabled-field": c.disabledField
        }, null, 8, ["label", "options", "value-field", "text-field", "html-field", "disabled-field"])) : (b(), I(al, {
          key: 1,
          value: v.value,
          disabled: v.disabled
        }, {
          default: E(() => [
            v.html ? (b(), _("span", {
              key: 0,
              innerHTML: v.html
            }, null, 8, Fu)) : (b(), _(de, { key: 1 }, [
              ne(Y(v.text), 1)
            ], 64))
          ]),
          _: 2
        }, 1032, ["value", "disabled"]))
      ], 64))), 128)),
      T(c.$slots, "default")
    ], 10, Eu)), [
      [In, h.value]
    ]);
  }
}), ha = "ArrowDown", Vl = "End", Al = "Home", Ol = "PageDown", Nl = "PageUp", Ba = "ArrowUp", zu = ["lang", "tabindex", "title"], Hu = ["name", "form", "value"], Ru = ["id", "dir", "tabindex", "aria-label", "aria-invalid", "aria-required", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext"], He = {
  min: 1,
  max: 100,
  step: 1,
  repeatDelay: 500,
  repeatInterval: 100,
  repeatThreshold: 10,
  repeatMultiplier: 4
}, Mu = /* @__PURE__ */ H({
  __name: "BFormSpinbutton",
  props: /* @__PURE__ */ pe({
    ariaControls: { default: void 0 },
    ariaLabel: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    formatterFn: { type: Function, default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    labelDecrement: { default: "Decrement" },
    labelIncrement: { default: "Increment" },
    locale: { default: void 0 },
    max: { default: He.max },
    min: { default: He.min },
    modelValue: {},
    name: { default: void 0 },
    placeholder: { default: void 0 },
    readonly: { type: Boolean, default: !1 },
    repeatDelay: { default: He.repeatDelay },
    repeatInterval: { default: He.repeatInterval },
    repeatStepMultiplier: { default: He.repeatMultiplier },
    repeatThreshold: { default: He.repeatThreshold },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    step: { default: He.step },
    vertical: { type: Boolean, default: !1 },
    wrap: { type: Boolean, default: !1 }
  }, {
    modelValue: {
      default: null
    },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["change"], ["update:modelValue"]),
  setup(t, { emit: e }) {
    const l = [Ba, ha, Al, Vl, Nl, Ol], a = t, o = e, r = he(t, "modelValue"), s = x(null), { focused: n } = Pe(s), i = Be(() => a.id, "spinbutton"), u = w(() => ({
      disabled: a.disabled,
      readonly: a.readonly,
      focus: n.value,
      "d-inline-flex": a.inline || a.vertical,
      "d-flex": !a.inline && !a.vertical,
      "align-items-stretch": !a.vertical,
      "flex-column": a.vertical,
      [`form-control-${a.size}`]: a.size !== void 0
    })), d = w(() => ({
      "d-flex": a.vertical,
      "align-self-center": !a.vertical,
      "align-items-center": a.vertical,
      "border-top": a.vertical,
      "border-bottom": a.vertical,
      "border-start": !a.vertical,
      "border-end": !a.vertical
    }));
    let p, f, m = !1;
    const y = be(() => a.step), h = k(
      () => Number.isNaN(y.value) ? He.step : y.value
    ), c = be(() => a.min), g = k(
      () => Number.isNaN(c.value) ? He.min : c.value
    ), v = be(() => a.max), $ = k(() => {
      const z = h.value, oe = g.value;
      return Math.floor((v.value - oe) / z) * z + oe;
    }), B = be(() => a.repeatDelay, {
      nanToZero: !0,
      method: "parseInt"
    }), C = k(
      () => B.value > 0 ? B.value : He.repeatDelay
    ), V = be(() => a.repeatInterval, {
      nanToZero: !0,
      method: "parseInt"
    }), L = k(
      () => V.value > 0 ? V.value : He.repeatInterval
    ), Q = be(() => a.repeatThreshold, {
      nanToZero: !0,
      method: "parseInt"
    }), W = k(
      () => Math.max(
        Number.isNaN(Q.value) ? He.repeatThreshold : Q.value,
        1
      )
    ), F = be(() => a.repeatStepMultiplier, {
      nanToZero: !0,
      method: "parseInt"
    }), Z = k(
      () => Math.max(
        Number.isNaN(F.value) ? He.repeatMultiplier : F.value,
        1
      )
    ), R = k(() => {
      const z = h.value;
      return Math.floor(z) === z ? 0 : (z.toString().split(".")[1] || "").length;
    }), le = k(() => Math.pow(10, R.value || 0)), N = k(
      () => r.value === null ? "" : r.value.toFixed(R.value)
    ), { isRtl: S, locale: P } = Hr(), M = w(() => {
      const oe = [(a.locale ?? (P == null ? void 0 : P.value)) || "locale"];
      return new Intl.NumberFormat(oe).resolvedOptions().locale;
    }), j = () => new Intl.NumberFormat(M.value, {
      style: "decimal",
      useGrouping: !1,
      minimumIntegerDigits: 1,
      minimumFractionDigits: R.value,
      maximumFractionDigits: R.value,
      notation: "standard"
    }).format, A = k(() => a.formatterFn ?? j()), X = (z) => {
      let { value: oe } = r;
      if (!a.disabled && oe !== null) {
        const fe = h.value * z, ce = g.value, Oe = $.value, $e = le.value, { wrap: Te } = a;
        oe = Math.round((oe - ce) / fe) * fe + ce + fe, oe = Math.round(oe * $e) / $e, r.value = oe > Oe ? Te ? ce : Oe : oe < ce ? Te ? Oe : ce : oe;
      }
    }, G = (z = 1) => {
      if (r.value === null) {
        r.value = g.value;
        return;
      }
      X(1 * z);
    }, ie = (z = 1) => {
      if (r.value === null) {
        r.value = a.wrap ? $.value : g.value;
        return;
      }
      X(-1 * z);
    }, q = (z) => {
      z.preventDefault(), z.stopImmediatePropagation();
    };
    Re(
      l,
      (z) => {
        const { code: oe, altKey: fe, ctrlKey: ce, metaKey: Oe } = z;
        if (!(a.disabled || a.readonly || fe || ce || Oe) && (q(z), !m)) {
          if (ee(), [Ba, ha].includes(oe)) {
            if (m = !0, oe === Ba) {
              se(z, G);
              return;
            }
            oe === ha && se(z, ie);
            return;
          }
          if (oe === Nl) {
            G(Z.value);
            return;
          }
          if (oe === Ol) {
            ie(Z.value);
            return;
          }
          if (oe === Al) {
            r.value = g.value;
            return;
          }
          oe === Vl && (r.value = $.value);
        }
      },
      { target: s, eventName: "keydown" }
    ), Re(
      l,
      (z) => {
        const { altKey: oe, ctrlKey: fe, metaKey: ce } = z;
        a.disabled || a.readonly || oe || fe || ce || (q(z), ee(), m = !1, o("change", r.value));
      },
      { target: s, eventName: "keyup" }
    );
    const se = (z, oe) => {
      const { type: fe } = z || {};
      if (!a.disabled && !a.readonly) {
        if (me(z) && fe === "mousedown" && z.button)
          return;
        ee(), oe(1);
        const ce = W.value, Oe = Z.value, $e = C.value, Te = L.value;
        p = setTimeout(() => {
          let Ye = 0;
          f = setInterval(() => {
            oe(Ye < ce ? 1 : Oe), Ye++;
          }, Te);
        }, $e);
      }
    }, me = (z) => z.type === "mouseup" || z.type === "mousedown", te = (z) => {
      me(z) && z.type === "mouseup" && z.button || (q(z), ee(), ye(!1), o("change", r.value));
    }, ye = (z) => {
      try {
        sl(z, [document.body, "mouseup", te, !1]), sl(z, [document.body, "touchend", te, !1]);
      } catch {
      }
    }, ee = () => {
      clearTimeout(p), clearInterval(f), p = void 0, f = void 0;
    }, U = w(() => {
      const z = {
        svg: {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          fill: "currentColor",
          class: "bi bi-plus",
          viewBox: "0 0 16 16"
        },
        path: {
          d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
        }
      }, oe = {
        svg: {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          fill: "currentColor",
          class: "bi bi-dash",
          viewBox: "0 0 16 16"
        },
        path: { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" }
      }, fe = {
        class: [{ "py-0": !a.vertical }, "btn", "btn-sm", "border-0", "rounded-0"],
        tabindex: "-1",
        type: "button",
        disabled: a.disabled || a.readonly,
        "aria-disabled": a.disabled || a.readonly ? !0 : void 0,
        "aria-controls": i.value
      }, ce = {
        "aria-hidden": !0,
        scale: n.value ? 1.5 : 1.25
      }, Oe = (Ye, kn) => {
        !a.disabled && !a.readonly && (q(Ye), ye(!0), n.value = !0, se(Ye, kn));
      }, $e = {
        button: {
          ...fe,
          "aria-label": a.labelIncrement || void 0,
          "aria-keyshortcuts": "ArrowUp"
        },
        svg: {
          ...ce,
          ...z.svg
        },
        path: {
          ...z.path
        },
        slot: {
          name: "increment"
        },
        handler: (Ye) => Oe(Ye, G)
      }, Te = {
        button: {
          ...fe,
          "aria-label": a.labelDecrement || void 0,
          "aria-keyshortcuts": "ArrowDown"
        },
        svg: {
          ...ce,
          ...oe.svg
        },
        path: {
          ...oe.path
        },
        slot: {
          name: "decrement"
        },
        handler: (Ye) => Oe(Ye, ie)
      };
      return {
        top: {
          ...a.vertical ? $e : Te
        },
        bottom: {
          ...a.vertical ? Te : $e
        }
      };
    });
    return (z, oe) => (b(), _("div", {
      ref_key: "element",
      ref: s,
      class: D(["b-form-spinbutton form-control", u.value]),
      role: "group",
      lang: M.value,
      tabindex: a.disabled ? void 0 : "-1",
      title: z.ariaLabel,
      onClick: oe[4] || (oe[4] = (fe) => n.value = !0)
    }, [
      T(z.$slots, U.value.top.slot.name, { hasFocus: O(n) }, () => [
        J("button", K(U.value.top.button, {
          onMousedown: oe[0] || (oe[0] = //@ts-ignore
          (...fe) => U.value.top.handler && U.value.top.handler(...fe)),
          onTouchstart: oe[1] || (oe[1] = //@ts-ignore
          (...fe) => U.value.top.handler && U.value.top.handler(...fe))
        }), [
          (b(), _("svg", ge(we(U.value.top.svg)), [
            J("path", ge(we(U.value.top.path)), null, 16)
          ], 16))
        ], 16)
      ]),
      z.name && !a.disabled ? (b(), _("input", {
        key: "hidden",
        type: "hidden",
        name: z.name,
        form: z.form,
        value: N.value
      }, null, 8, Hu)) : ae("", !0),
      J("output", {
        id: O(i),
        key: "output",
        class: D(["flex-grow-1", d.value]),
        dir: O(S) ?? !1 ? "rtl" : "ltr",
        tabindex: a.disabled ? void 0 : "0",
        role: "spinbutton",
        "aria-live": "off",
        "aria-label": z.ariaLabel || void 0,
        "aria-invalid": a.state === !1 || !r.value !== null && a.required ? !0 : void 0,
        "aria-required": a.required ? !0 : void 0,
        "aria-valuemin": g.value,
        "aria-valuemax": $.value,
        "aria-valuenow": r.value !== null ? r.value : void 0,
        "aria-valuetext": r.value !== null ? A.value(r.value) : void 0
      }, [
        J("bdi", null, Y((r.value !== null ? A.value(r.value) : z.placeholder) || ""), 1)
      ], 10, Ru),
      T(z.$slots, U.value.bottom.slot.name, { hasFocus: O(n) }, () => [
        J("button", K(U.value.bottom.button, {
          onMousedown: oe[2] || (oe[2] = //@ts-ignore
          (...fe) => U.value.bottom.handler && U.value.bottom.handler(...fe)),
          onTouchstart: oe[3] || (oe[3] = //@ts-ignore
          (...fe) => U.value.bottom.handler && U.value.bottom.handler(...fe))
        }), [
          (b(), _("svg", ge(we(U.value.bottom.svg)), [
            J("path", ge(we(U.value.bottom.path)), null, 16)
          ], 16))
        ], 16)
      ])
    ], 10, zu));
  }
}), xu = ["id"], bn = /* @__PURE__ */ H({
  __name: "BFormTag",
  props: {
    disabled: { type: Boolean, default: !1 },
    id: { default: void 0 },
    noRemove: { type: Boolean, default: !1 },
    pill: { type: Boolean, default: !1 },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    title: { default: void 0 },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = Le(), r = Be(() => l.id), s = w(
      () => {
        var u;
        return ((((u = o.default) == null ? void 0 : u.call(o, {})[0].children) ?? "").toString() || l.title) ?? "";
      }
    ), n = k(() => `${r.value}taglabel__`), i = w(() => ({
      [`text-bg-${l.variant}`]: l.variant !== null,
      "rounded-pill": l.pill,
      disabled: l.disabled
    }));
    return (u, d) => (b(), I(re(u.tag), {
      id: O(r),
      title: s.value,
      class: D(["badge b-form-tag d-inline-flex align-items-center mw-100", i.value]),
      "aria-labelledby": n.value
    }, {
      default: E(() => [
        J("span", {
          id: n.value,
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          T(u.$slots, "default", {}, () => [
            ne(Y(s.value), 1)
          ])
        ], 8, xu),
        !l.disabled && !l.noRemove ? (b(), I(Pt, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          "aria-label": u.removeLabel,
          class: "b-form-tag-remove",
          "aria-describedby": n.value,
          "aria-controls": u.id,
          onClick: d[0] || (d[0] = (p) => a("remove", s.value))
        }, null, 8, ["aria-label", "aria-describedby", "aria-controls"])) : ae("", !0)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
}), Du = ["id"], ju = ["id", "for", "aria-live"], qu = ["id", "aria-live"], Wu = ["id"], Gu = ["aria-controls"], Uu = {
  role: "group",
  class: "d-flex"
}, Ku = ["id", "disabled", "value", "type", "placeholder", "form", "required", "aria-required"], Xu = ["disabled"], Yu = {
  "aria-live": "polite",
  "aria-atomic": "true"
}, Zu = {
  key: 0,
  class: "d-block invalid-feedback"
}, Ju = {
  key: 1,
  class: "form-text text-body-secondary"
}, Qu = {
  key: 2,
  class: "form-text text-body-secondary"
}, ed = ["name", "value"], td = /* @__PURE__ */ H({
  __name: "BFormTags",
  props: /* @__PURE__ */ pe({
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { type: Boolean, default: !1 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    duplicateTagText: { default: "Duplicate tag(s)" },
    form: { default: void 0 },
    inputAttrs: { default: void 0 },
    inputClass: { default: void 0 },
    inputId: { default: void 0 },
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    limit: { default: void 0 },
    limitTagsText: { default: "Tag limit reached" },
    modelValue: {},
    name: { default: void 0 },
    noAddOnEnter: { type: Boolean, default: !1 },
    noOuterFocus: { type: Boolean, default: !1 },
    noTagRemove: { type: Boolean, default: !1 },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    separator: { default: void 0 },
    size: { default: "md" },
    state: { type: [Boolean, null], default: null },
    tagClass: { default: void 0 },
    tagPills: { type: Boolean, default: !1 },
    tagRemoveLabel: { default: void 0 },
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => !0 },
    tagVariant: { default: "secondary" }
  }, {
    modelValue: {
      default: () => []
    },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["blur", "focus", "focusin", "focusout", "tag-state"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = he(t, "modelValue"), s = Be(), n = be(() => a.limit ?? NaN), i = Ct(() => a.state), u = x(null), { focused: d } = Pe(u, {
      initialValue: a.autofocus
    }), p = k(() => a.inputId || `${s.value}input__`), f = x([...r.value]), m = x(""), y = x(r.value.length > 0), h = x(""), c = x([]), g = x([]), v = x([]);
    Sa(r, f, {
      direction: "ltr",
      transform: {
        ltr: (A) => [...A]
      }
    });
    const $ = w(() => [
      i.value,
      {
        [`form-control-${a.size}`]: a.size !== "md",
        disabled: a.disabled,
        focus: d.value
      }
    ]), B = w(() => f.value.includes(m.value)), C = w(
      () => m.value === "" ? !1 : !a.tagValidator(m.value)
    ), V = k(() => f.value.length === n.value), L = k(() => !C.value && !B.value), Q = w(() => ({
      addButtonText: a.addButtonText,
      addButtonVariant: a.addButtonVariant,
      addTag: M,
      disableAddButton: L.value,
      disabled: a.disabled,
      duplicateTagText: a.duplicateTagText,
      duplicateTags: v.value,
      form: a.form,
      inputAttrs: {
        ...a.inputAttrs,
        disabled: a.disabled,
        form: a.form,
        id: p,
        value: m
      },
      inputHandlers: {
        input: R,
        keydown: N,
        change: le
      },
      inputId: p,
      inputType: a.inputType,
      invalidTagText: a.invalidTagText,
      invalidTags: g.value,
      isDuplicate: B.value,
      isInvalid: C.value,
      isLimitReached: V.value,
      limitTagsText: a.limitTagsText,
      limit: n.value,
      noTagRemove: a.noTagRemove,
      placeholder: a.placeholder,
      removeTag: j,
      required: a.required,
      separator: a.separator,
      size: a.size,
      state: a.state,
      tagClass: a.tagClass,
      tagPills: a.tagPills,
      tagRemoveLabel: a.tagRemoveLabel,
      tagVariant: a.tagVariant,
      tags: f.value
    })), W = (A) => {
      if (a.disabled) {
        A.target.blur();
        return;
      }
      o("focusin", A);
    }, F = (A) => {
      a.disabled || a.noOuterFocus || (d.value = !0, o("focus", A));
    }, Z = (A) => {
      d.value = !1, o("blur", A);
    }, R = (A) => {
      var G, ie;
      const X = typeof A == "string" ? A : A.target.value;
      if (y.value = !1, (G = a.separator) != null && G.includes(X.charAt(0)) && X.length > 0) {
        u.value && (u.value.value = "");
        return;
      }
      if (m.value = X, (ie = a.separator) != null && ie.includes(X.charAt(X.length - 1))) {
        M(X.slice(0, X.length - 1));
        return;
      }
      c.value = a.tagValidator(X) && !B.value ? [X] : [], g.value = a.tagValidator(X) ? [] : [X], v.value = B.value ? [X] : [], o("tag-state", c.value, g.value, v.value);
    }, le = (A) => {
      a.addOnChange && (R(A), B.value || M(m.value));
    }, N = (A) => {
      if (A.key === "Enter" && !a.noAddOnEnter) {
        M(m.value);
        return;
      }
      (A.key === "Backspace" || A.key === "Delete") && a.removeOnDelete && m.value === "" && y.value && f.value.length > 0 ? j(f.value[f.value.length - 1]) : y.value = !0;
    };
    Re(N, { target: u });
    const S = w(() => {
      if (a.separator)
        return typeof a.separator == "string" ? a.separator : a.separator.join("");
    }), P = w(() => {
      if (S.value)
        return new RegExp(`[${Or(S.value)}]+`);
    }), M = (A) => {
      A = (A ?? m.value).trim();
      const X = P.value ? A.split(P.value).map((q) => q.trim()) : [A], G = [];
      for (const q of X)
        if (!(q === "" || B.value || !a.tagValidator(q))) {
          if (n.value && V.value)
            break;
          G.push(q);
        }
      const ie = [...r.value, ...G];
      m.value = "", y.value = !0, r.value = ie, d.value = !0;
    }, j = (A) => {
      const X = f.value.indexOf((A == null ? void 0 : A.toString()) ?? "");
      X !== -1 && (h.value = f.value.splice(X, 1).toString(), r.value = f.value);
    };
    return e({
      blur: () => {
        d.value = !1;
      },
      element: u,
      focus: () => {
        d.value = !0;
      }
    }), (A, X) => (b(), _("div", {
      id: O(s),
      class: D(["b-form-tags form-control h-auto", $.value]),
      role: "group",
      tabindex: "-1",
      onFocusin: W,
      onFocusout: X[1] || (X[1] = (G) => o("focusout", G))
    }, [
      J("output", {
        id: `${O(s)}selected_tags__`,
        class: "visually-hidden",
        for: p.value,
        "aria-live": O(d) ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, Y(f.value.join(", ")), 9, ju),
      J("div", {
        id: `${O(s)}removed_tags__`,
        role: "status",
        "aria-live": O(d) ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + Y(A.tagRemovedLabel) + ") " + Y(h.value), 9, qu),
      T(A.$slots, "default", ge(we(Q.value)), () => [
        J("ul", {
          id: `${O(s)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (b(!0), _(de, null, Ce(f.value, (G, ie) => T(A.$slots, "tag", {
            key: ie,
            tag: G,
            tagClass: A.tagClass,
            tagVariant: A.tagVariant,
            tagPills: a.tagPills,
            removeTag: j
          }, () => [
            (b(), I(bn, {
              key: G,
              class: D(A.tagClass),
              tag: "li",
              variant: A.tagVariant,
              pill: A.tagPills,
              onRemove: j
            }, {
              default: E(() => [
                ne(Y(G), 1)
              ]),
              _: 2
            }, 1032, ["class", "variant", "pill"]))
          ])), 128)),
          J("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${O(s)}tag_list__`
          }, [
            J("div", Uu, [
              J("input", K({
                id: p.value,
                ref_key: "input",
                ref: u,
                disabled: a.disabled,
                value: m.value,
                type: A.inputType,
                placeholder: A.placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, A.inputAttrs, {
                form: A.form,
                required: a.required || void 0,
                "aria-required": a.required || void 0,
                onInput: R,
                onChange: le,
                onFocus: F,
                onBlur: Z
              }), null, 16, Ku),
              L.value ? (b(), _("button", {
                key: 0,
                type: "button",
                class: D(["btn b-form-tags-button py-0", [
                  A.inputClass,
                  {
                    [`btn-${A.addButtonVariant}`]: A.addButtonVariant !== null,
                    "disabled invisible": m.value.length === 0
                  }
                ]]),
                style: { "font-size": "90%" },
                disabled: a.disabled || m.value.length === 0 || V.value,
                onClick: X[0] || (X[0] = (G) => M(m.value))
              }, [
                T(A.$slots, "add-button-text", {}, () => [
                  ne(Y(A.addButtonText), 1)
                ])
              ], 10, Xu)) : ae("", !0)
            ])
          ], 8, Gu)
        ], 8, Wu),
        J("div", Yu, [
          C.value ? (b(), _("div", Zu, Y(A.invalidTagText) + ": " + Y(m.value), 1)) : ae("", !0),
          B.value ? (b(), _("small", Ju, Y(A.duplicateTagText) + ": " + Y(m.value), 1)) : ae("", !0),
          f.value.length === A.limit ? (b(), _("small", Qu, Y(A.limitTagsText), 1)) : ae("", !0)
        ])
      ]),
      A.name ? (b(!0), _(de, { key: 0 }, Ce(f.value, (G, ie) => (b(), _("input", {
        key: ie,
        type: "hidden",
        name: A.name,
        value: G
      }, null, 8, ed))), 128)) : ae("", !0)
    ], 42, Du));
  }
}), ad = ["id", "name", "form", "value", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"], ld = /* @__PURE__ */ H({
  __name: "BFormTextarea",
  props: {
    noResize: { type: Boolean, default: !1 },
    rows: { default: 2 },
    wrap: { default: "soft" },
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazy: { type: Boolean, default: !1 },
    lazyFormatter: { type: Boolean, default: !1 },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    number: { type: Boolean, default: !1 },
    placeholder: { default: void 0 },
    plaintext: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    trim: { type: Boolean, default: !1 },
    debounce: { default: 0 },
    debounceMaxWait: { default: NaN }
  },
  emits: ["update:modelValue"],
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, { input: r, computedId: s, computedAriaInvalid: n, onInput: i, onChange: u, onBlur: d, focus: p, blur: f } = qo(a, o), m = Ct(() => a.state), y = w(() => [
      m.value,
      a.plaintext ? "form-control-plaintext" : "form-control",
      {
        [`form-control-${a.size}`]: !!a.size
      }
    ]), h = w(() => ({
      resize: a.noResize ? "none" : void 0
    }));
    return e({
      blur: f,
      element: r,
      focus: p
    }), (c, g) => (b(), _("textarea", {
      id: O(s),
      ref_key: "input",
      ref: r,
      class: D(y.value),
      name: c.name || void 0,
      form: c.form || void 0,
      value: c.modelValue ?? void 0,
      disabled: a.disabled,
      placeholder: c.placeholder,
      required: a.required || void 0,
      autocomplete: c.autocomplete || void 0,
      readonly: a.readonly || a.plaintext,
      "aria-required": c.required || void 0,
      "aria-invalid": O(n),
      rows: c.rows,
      style: Ee(h.value),
      wrap: c.wrap || void 0,
      onInput: g[0] || (g[0] = (v) => O(i)(v)),
      onChange: g[1] || (g[1] = (v) => O(u)(v)),
      onBlur: g[2] || (g[2] = (v) => O(d)(v))
    }, null, 46, ad));
  }
}), od = {
  key: 0,
  class: "input-group-text"
}, nd = ["innerHTML"], sd = { key: 1 }, rd = {
  key: 0,
  class: "input-group-text"
}, id = ["innerHTML"], ud = { key: 1 }, dd = /* @__PURE__ */ H({
  __name: "BInputGroup",
  props: {
    append: { default: void 0 },
    appendHtml: { default: void 0 },
    id: { default: void 0 },
    prepend: { default: void 0 },
    prependHtml: { default: void 0 },
    size: { default: "md" },
    tag: { default: "div" }
  },
  setup(t) {
    const e = t, l = w(() => ({
      [`input-group-${e.size}`]: e.size !== "md"
    })), a = k(() => !!e.append || !!e.appendHtml), o = k(() => !!e.prepend || !!e.prependHtml);
    return (r, s) => (b(), I(re(r.tag), {
      id: r.id,
      class: D(["input-group", l.value]),
      role: "group"
    }, {
      default: E(() => [
        T(r.$slots, "prepend", {}, () => [
          o.value ? (b(), _("span", od, [
            r.prependHtml ? (b(), _("span", {
              key: 0,
              innerHTML: r.prependHtml
            }, null, 8, nd)) : (b(), _("span", sd, Y(r.prepend), 1))
          ])) : ae("", !0)
        ]),
        T(r.$slots, "default"),
        T(r.$slots, "append", {}, () => [
          a.value ? (b(), _("span", rd, [
            r.appendHtml ? (b(), _("span", {
              key: 0,
              innerHTML: r.appendHtml
            }, null, 8, id)) : (b(), _("span", ud, Y(r.append), 1))
          ])) : ae("", !0)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), yn = /* @__PURE__ */ H({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: { default: void 0 }
  },
  setup(t) {
    return (e, l) => (b(), I(re(e.tag), { class: "input-group-text" }, {
      default: E(() => [
        T(e.$slots, "default", {}, () => [
          ne(Y(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), ll = /* @__PURE__ */ H({
  __name: "BInputGroupAddon",
  props: {
    isText: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t;
    return (l, a) => e.isText ? (b(), I(yn, { key: 0 }, {
      default: E(() => [
        T(l.$slots, "default")
      ]),
      _: 3
    })) : T(l.$slots, "default", { key: 1 });
  }
}), cd = /* @__PURE__ */ H({
  __name: "BInputGroupAppend",
  props: {
    isText: { type: Boolean, default: !1 }
  },
  setup(t) {
    return (e, l) => (b(), I(ll, ge(we(e.$props)), {
      default: E(() => [
        T(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), fd = /* @__PURE__ */ H({
  __name: "BInputGroupPrepend",
  props: {
    isText: { type: Boolean, default: !1 }
  },
  setup(t) {
    return (e, l) => (b(), I(ll, ge(we(e.$props)), {
      default: E(() => [
        T(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vd = /* @__PURE__ */ H({
  __name: "BListGroup",
  props: {
    flush: { type: Boolean, default: !1 },
    horizontal: { type: [Boolean, String], default: !1 },
    numbered: { type: Boolean, default: !1 },
    tag: { default: "div" }
  },
  setup(t) {
    const e = t, l = w(() => {
      const o = e.flush ? !1 : e.horizontal;
      return {
        "list-group-flush": e.flush,
        "list-group-horizontal": o === !0,
        [`list-group-horizontal-${o}`]: typeof o == "string",
        "list-group-numbered": e.numbered
      };
    }), a = k(() => e.numbered === !0 ? "ol" : e.tag);
    return at(To, {
      numbered: k(() => e.numbered)
    }), (o, r) => (b(), I(re(a.value), {
      class: D(["list-group", l.value])
    }, {
      default: E(() => [
        T(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), pd = /* @__PURE__ */ H({
  __name: "BListGroupItem",
  props: {
    action: { type: Boolean, default: !1 },
    button: { type: Boolean, default: !1 },
    tag: { default: "div" },
    active: { type: Boolean, default: !1 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  setup(t) {
    const e = t, l = Mt(), a = _e(To, null), { computedLink: o } = wt(e), r = k(() => !e.button && o.value), s = k(
      () => a != null && a.numbered.value ? "li" : e.button ? "button" : r.value ? ot : e.tag
    ), n = w(
      () => e.action || r.value || e.button || ["a", "router-link", "button", "b-link"].includes(e.tag)
    ), i = w(() => ({
      [`list-group-item-${e.variant}`]: e.variant !== null && e.variant !== void 0,
      "list-group-item-action": n.value,
      active: e.active,
      disabled: e.disabled
    })), u = w(() => {
      const d = {};
      return e.button && ((!l || !l.type) && (d.type = "button"), e.disabled && (d.disabled = !0)), d;
    });
    return (d, p) => (b(), I(re(s.value), K({
      class: ["list-group-item", i.value],
      "aria-current": e.active ? !0 : void 0,
      "aria-disabled": e.disabled ? !0 : void 0,
      target: r.value ? d.target : void 0,
      href: e.button ? void 0 : d.href,
      to: e.button ? void 0 : d.to
    }, u.value), {
      default: E(() => [
        T(d.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
}), md = { id: "__BVID__modal-container" }, bd = /* @__PURE__ */ H({
  __name: "BModalOrchestrator",
  props: {
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  },
  setup(t, { expose: e }) {
    const l = t, { modals: a, remove: o, show: r, confirm: s } = Go(), n = (i) => va(i, ["_promise", "_self", "_isConfirm", "_modelValue"]);
    return e({
      modals: a,
      show: r,
      confirm: s
    }), (i, u) => (b(), I(ht, {
      to: i.teleportTo,
      disabled: l.teleportDisabled
    }, [
      J("div", md, [
        (b(!0), _(de, null, Ce(O(a), (d, p) => (b(), I(re(d.value.component), K({
          key: p,
          modelValue: d.value.props._modelValue,
          "onUpdate:modelValue": (f) => d.value.props._modelValue = f,
          ref_for: !0
        }, n(d.value.props), {
          "teleport-disabled": !0,
          onHide: (f) => {
            if (d.value.props._isConfirm === !0) {
              if (f.trigger === "ok") {
                d.value.props._promise.resolve(!0);
                return;
              }
              if (f.trigger === "cancel") {
                d.value.props._promise.resolve(!1);
                return;
              }
              d.value.props._promise.resolve(null);
            }
            d.value.props._promise.resolve(!0);
          },
          onHidden: (f) => {
            var m;
            return (m = O(o)) == null ? void 0 : m(d.value.props._self);
          }
        }), null, 16, ["modelValue", "onUpdate:modelValue", "onHide", "onHidden"]))), 128))
      ])
    ], 8, ["to", "disabled"]));
  }
}), yd = /* @__PURE__ */ H({
  __name: "BNav",
  props: {
    align: { default: void 0 },
    cardHeader: { type: Boolean, default: !1 },
    fill: { type: Boolean, default: !1 },
    justified: { type: Boolean, default: !1 },
    pills: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    tabs: { type: Boolean, default: !1 },
    tag: { default: "ul" },
    underline: { type: Boolean, default: !1 },
    vertical: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, l = Dt(() => e.align), a = w(() => ({
      "nav-tabs": e.tabs,
      "nav-pills": e.pills && !e.tabs,
      "card-header-tabs": !e.vertical && e.cardHeader && e.tabs,
      "card-header-pills": !e.vertical && e.cardHeader && e.pills && !e.tabs,
      "flex-column": e.vertical,
      "nav-fill": !e.vertical && e.fill,
      "nav-justified": !e.vertical && e.justified,
      [l.value]: !e.vertical && e.align !== void 0,
      small: e.small,
      "nav-underline": e.underline
    }));
    return (o, r) => (b(), I(re(o.tag), {
      class: D(["nav", a.value])
    }, {
      default: E(() => [
        T(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), gd = { class: "d-flex flex-row align-items-center flex-wrap" }, hd = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BNavForm",
  props: {
    role: { default: void 0 },
    floating: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    novalidate: { type: Boolean, default: void 0 },
    validated: { type: Boolean, default: void 0 }
  },
  emits: ["submit"],
  setup(t, { emit: e }) {
    const l = e, a = (o) => {
      l("submit", o);
    };
    return (o, r) => (b(), _("li", gd, [
      ve(dn, K(o.$attrs, {
        id: o.id,
        floating: o.floating,
        role: o.role,
        novalidate: o.novalidate,
        validated: o.validated,
        class: "d-flex",
        onSubmit: ft(a, ["prevent"])
      }), {
        default: E(() => [
          T(o.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "floating", "role", "novalidate", "validated"])
    ]));
  }
}), Bd = { class: "nav-item" }, wd = /* @__PURE__ */ H({
  __name: "BNavItem",
  props: {
    linkAttrs: { default: void 0 },
    linkClass: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = w(
      () => Za(l, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "icon",
        "opacity",
        "opacityHover",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "underlineVariant",
        "variant"
      ])
    );
    return o.value.activeClass, (r, s) => (b(), _("li", Bd, [
      ve(ot, K({
        class: ["nav-link", r.linkClass],
        tabindex: l.disabled ? -1 : void 0,
        "aria-disabled": l.disabled ? !0 : void 0
      }, { ...o.value, ...r.linkAttrs }, {
        onClick: s[0] || (s[0] = (n) => a("click", n))
      }), {
        default: E(() => [
          T(r.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "tabindex", "aria-disabled"])
    ]));
  }
}), Cd = { class: "nav-item dropdown" }, kd = /* @__PURE__ */ H({
  __name: "BNavItemDropdown",
  props: /* @__PURE__ */ pe({
    ariaLabel: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    center: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    dropend: { type: Boolean, default: !1 },
    dropstart: { type: Boolean, default: !1 },
    dropup: { type: Boolean, default: !1 },
    end: { type: Boolean, default: !1 },
    floatingMiddleware: { default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: !0 },
    lazy: { type: Boolean, default: !1 },
    menuClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCaret: { type: Boolean, default: !1 },
    noFlip: { type: Boolean, default: !1 },
    noShift: { type: Boolean, default: !1 },
    noSize: { type: Boolean, default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    size: { default: "md" },
    split: { type: Boolean, default: !1 },
    splitButtonType: { default: "button" },
    splitClass: { default: void 0 },
    splitDisabled: { type: Boolean, default: void 0 },
    splitHref: { default: void 0 },
    splitTo: { default: void 0 },
    splitVariant: { default: void 0 },
    strategy: { default: "absolute" },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "link" },
    teleportDisabled: { default: !1 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["click", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "toggle"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = he(t, "modelValue"), s = x(null), n = () => {
      var d;
      (d = s.value) == null || d.hide();
    }, i = () => {
      var d;
      (d = s.value) == null || d.show();
    };
    return e({
      hide: n,
      show: i,
      toggle: () => {
        var d;
        (d = s.value) == null || d.toggle();
      }
    }), (d, p) => (b(), _("li", Cd, [
      ve(un, K({
        ref_key: "dropdown",
        ref: s
      }, a, {
        modelValue: r.value,
        "onUpdate:modelValue": p[0] || (p[0] = (f) => r.value = f),
        "is-nav": "",
        onShow: p[1] || (p[1] = (f) => o("show", f)),
        onShown: p[2] || (p[2] = (f) => o("shown")),
        onHide: p[3] || (p[3] = (f) => o("hide", f)),
        onHidden: p[4] || (p[4] = (f) => o("hidden")),
        onHidePrevented: p[5] || (p[5] = (f) => o("hide-prevented")),
        onShowPrevented: p[6] || (p[6] = (f) => o("show-prevented")),
        onClick: p[7] || (p[7] = (f) => o("click", f)),
        onToggle: p[8] || (p[8] = (f) => o("toggle"))
      }), {
        "button-content": E(() => [
          T(d.$slots, "button-content")
        ]),
        "toggle-text": E(() => [
          T(d.$slots, "toggle-text")
        ]),
        default: E(() => [
          T(d.$slots, "default", {
            hide: n,
            show: i
          })
        ]),
        _: 3
      }, 16, ["modelValue"])
    ]));
  }
}), $d = { class: "navbar-text" }, Td = /* @__PURE__ */ H({
  __name: "BNavText",
  props: {
    text: { default: void 0 }
  },
  setup(t) {
    return (e, l) => (b(), _("li", $d, [
      T(e.$slots, "default", {}, () => [
        ne(Y(e.text), 1)
      ])
    ]));
  }
}), Sd = /* @__PURE__ */ H({
  __name: "BNavbar",
  props: {
    autoClose: { type: Boolean, default: !0 },
    container: { type: [Boolean, String], default: "fluid" },
    fixed: { default: void 0 },
    print: { type: Boolean, default: !1 },
    sticky: { default: void 0 },
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: !1 },
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = k(() => e.tag === "nav" ? void 0 : "navigation"), a = Er(() => e.container), o = w(() => ({
      "d-print": e.print,
      [`sticky-${e.sticky}`]: e.sticky !== void 0,
      [`bg-${e.variant}`]: e.variant !== null,
      [`fixed-${e.fixed}`]: e.fixed !== void 0,
      "navbar-expand": e.toggleable === !1,
      [`navbar-expand-${e.toggleable}`]: typeof e.toggleable == "string"
    }));
    return at(Ya, {
      tag: k(() => e.tag),
      autoClose: k(() => e.autoClose)
    }), (r, s) => (b(), I(re(r.tag), {
      class: D(["navbar", o.value]),
      role: l.value
    }, {
      default: E(() => [
        r.container !== !1 ? (b(), _("div", {
          key: 0,
          class: D(O(a))
        }, [
          T(r.$slots, "default")
        ], 2)) : T(r.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
}), _d = /* @__PURE__ */ H({
  __name: "BNavbarBrand",
  props: {
    tag: { default: "div" },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    append: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 }
  },
  setup(t) {
    const e = t, { computedLink: l, computedLinkProps: a } = wt(e, [
      "active",
      "activeClass",
      "append",
      "disabled",
      "href",
      "rel",
      "replace",
      "routerComponentName",
      "target",
      "to",
      "variant",
      "opacity",
      "opacityHover",
      "underlineVariant",
      "underlineOffset",
      "underlineOffsetHover",
      "underlineOpacity",
      "underlineOpacityHover",
      "icon"
    ]), o = k(() => l.value ? ot : e.tag);
    return (r, s) => (b(), I(re(o.value), K({ class: "navbar-brand" }, O(a)), {
      default: E(() => [
        T(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Vd = /* @__PURE__ */ H({
  __name: "BNavbarNav",
  props: {
    align: { default: void 0 },
    fill: { type: Boolean, default: !1 },
    justified: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    tag: { default: "ul" }
  },
  setup(t) {
    const e = t, l = Dt(() => e.align), a = w(() => ({
      "nav-fill": e.fill,
      "nav-justified": e.justified,
      [l.value]: e.align !== void 0,
      small: e.small
    }));
    return (o, r) => (b(), _("ul", {
      class: D(["navbar-nav", a.value])
    }, [
      T(o.$slots, "default")
    ], 2));
  }
}), Il = (t, e) => t.setAttribute("data-bs-theme", e), Ad = {
  mounted(t, e) {
    Il(t, e.value);
  },
  updated(t, e) {
    Il(t, e.value);
  }
}, Od = (t, e) => {
  const { modifiers: l, arg: a, value: o } = t, r = Object.keys(l || {}), s = typeof o == "string" ? o.split(Zt) : o;
  if (e.tagName.toLowerCase() === "a") {
    const n = e.getAttribute("href") || "";
    Tr.test(n) && r.push(n.replace($r, ""));
  }
  return Array.prototype.concat.apply([], [a, s]).forEach((n) => typeof n == "string" && r.push(n)), r.filter((n, i, u) => n && u.indexOf(n) === i);
}, Nd = (t, e) => {
  t.forEach((l) => {
    const a = document.getElementById(l);
    a !== null && a.dispatchEvent(new Event("bv-toggle"));
  }), setTimeout(() => gn(t, e), 50);
}, gn = (t, e) => {
  let l = !1;
  t.forEach((a) => {
    const o = document.getElementById(a);
    o != null && o.classList.contains("show") && (l = !0), o != null && o.classList.contains("closing") && (l = !1);
  }), e.setAttribute("aria-expanded", l ? "true" : "false"), e.classList.remove(l ? "collapsed" : "not-collapsed"), e.classList.add(l ? "not-collapsed" : "collapsed");
}, Pl = (t, e) => {
  const l = Od(e, t);
  l.length !== 0 && (t.__toggle && t.removeEventListener("click", t.__toggle), t.__toggle = () => Nd(l, t), t.addEventListener("click", t.__toggle), t.setAttribute("aria-controls", l.join(" ")), gn(l, t));
}, Na = {
  mounted: Pl,
  updated: Pl,
  unmounted(t) {
    t.removeEventListener("click", t.__toggle), t.removeAttribute("aria-controls"), t.removeAttribute("aria-expanded");
  }
}, Id = {
  mounted(t, e) {
    if (!Ht(e.value))
      return;
    const a = oa(e.value, t);
    !a.content && !a.title || sa(t, e, {
      ...na(e, t),
      ...a
    });
  },
  updated(t, e) {
    if (!Ht(e.value))
      return;
    const a = oa(e.value, t);
    !a.content && !a.title || (ra(t), sa(t, e, {
      ...na(e, t),
      ...a
    }));
  },
  beforeUnmount(t) {
    ra(t);
  }
}, El = (t, e) => {
  t.$__scrollspy && t.$__scrollspy.cleanup();
  const { arg: l, value: a } = e, o = typeof a == "object" && a !== null, r = l || (typeof a == "string" ? a : o ? a.content || a.element : null);
  t.$__scrollspy = Ko(r, t, o ? va(a, ["content", "element"]) : {});
}, Pd = {
  mounted: El,
  updated: El,
  beforeUnmount(t) {
    t.$__scrollspy && t.$__scrollspy.cleanup();
  }
}, Ed = {
  mounted(t, e) {
    const l = Ht(e.value);
    if (!l)
      return;
    const a = oa(e.value, t);
    !a.content && !a.title || sa(t, e, {
      noninteractive: !0,
      ...na(e, t),
      title: a.title ?? a.content ?? "",
      tooltip: l
    });
  },
  updated(t, e) {
    const l = Ht(e.value);
    if (!l)
      return;
    const a = oa(e.value, t);
    !a.content && !a.title || (ra(t), sa(t, e, {
      noninteractive: !0,
      ...na(e, t),
      title: a.title ?? a.content ?? "",
      tooltip: l
    }));
  },
  beforeUnmount(t) {
    ra(t);
  }
}, Fl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  vBColorMode: Ad,
  vBModal: Na,
  vBPopover: Id,
  vBScrollspy: Pd,
  vBToggle: Na,
  vBTooltip: Ed
}, Symbol.toStringTag, { value: "Module" })), Fd = ["disabled", "aria-label"], Ld = /* @__PURE__ */ J("span", { class: "navbar-toggler-icon" }, null, -1), zd = /* @__PURE__ */ H({
  __name: "BNavbarToggle",
  props: {
    disabled: { type: Boolean, default: !1 },
    label: { default: "Toggle navigation" },
    target: { default: void 0 }
  },
  emits: ["click"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = w(() => ({
      disabled: l.disabled
    })), r = (s) => {
      l.disabled || a("click", s);
    };
    return (s, n) => ut((b(), _("button", {
      class: D(["navbar-toggler", o.value]),
      type: "button",
      disabled: l.disabled,
      "aria-label": s.label,
      onClick: r
    }, [
      T(s.$slots, "default", {}, () => [
        Ld
      ])
    ], 10, Fd)), [
      [O(Na), l.disabled ? void 0 : s.target]
    ]);
  }
}), Hd = ["id", "aria-labelledby"], Rd = ["id"], Md = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BOffcanvas",
  props: /* @__PURE__ */ pe({
    backdrop: { type: Boolean, default: !0 },
    backdropBlur: { default: void 0 },
    backdropVariant: { default: "dark" },
    bodyAttrs: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyScrolling: { type: Boolean, default: !1 },
    footerClass: { default: void 0 },
    headerClass: { default: void 0 },
    headerCloseClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseVariant: { default: "secondary" },
    id: { default: void 0 },
    lazy: { type: Boolean, default: !1 },
    modelValue: { type: Boolean },
    noCloseOnBackdrop: { type: Boolean, default: !1 },
    noCloseOnEsc: { type: Boolean, default: !1 },
    noFocus: { type: Boolean, default: !1 },
    noHeader: { type: Boolean, default: !1 },
    noHeaderClose: { type: Boolean, default: !1 },
    placement: { default: "start" },
    shadow: { type: [Object, Boolean], default: !1 },
    title: { default: void 0 },
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["close", "esc", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = Le(), s = he(t, "modelValue"), n = Be(() => a.id, "offcanvas");
    Uo(s, () => a.bodyScrolling);
    const i = x(null);
    Re(
      "Escape",
      () => {
        C("esc");
      },
      { target: i }
    );
    const { focused: u } = Pe(i, {
      initialValue: s.value && a.noFocus === !1
    }), d = x(s.value), p = x(!1), f = k(() => a.backdrop === !0 && s.value === !0), m = k(
      () => a.lazy === !1 || a.lazy === !0 && p.value === !0 || a.lazy === !0 && s.value === !0
    ), y = k(() => !Ae(r["header-close"])), h = w(() => [
      { "text-reset": !y.value },
      a.headerCloseClass
    ]), c = w(() => ({
      variant: y.value ? a.headerCloseVariant : void 0,
      class: h.value
    })), g = k(() => !Ae(r.footer)), v = w(() => [
      // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,
      "offcanvas",
      // Remove when above check is fixed
      `offcanvas-${a.placement}`,
      {
        show: s.value && d.value === !0,
        [`shadow-${a.shadow}`]: !!a.shadow
      }
    ]), $ = w(() => ({
      visible: s.value,
      placement: a.placement,
      hide: C
    })), B = (R, le = {}) => new Bt(R, {
      cancelable: !1,
      target: i.value || null,
      relatedTarget: null,
      trigger: null,
      ...le,
      componentId: n.value
    }), C = (R = "") => {
      if (R === "backdrop" && a.noCloseOnBackdrop || R === "esc" && a.noCloseOnEsc) {
        o("hide-prevented");
        return;
      }
      const le = B("hide", { cancelable: R !== "", trigger: R });
      if (R === "close" && o(R, le), R === "esc" && o(R, le), o("hide", le), le.defaultPrevented) {
        o("hide-prevented");
        return;
      }
      s.value = !1;
    }, V = () => {
      const R = B("show", { cancelable: !0 });
      if (o("show", R), R.defaultPrevented) {
        s.value = !1, o("show-prevented");
        return;
      }
      s.value = !0;
    }, L = () => {
      Ve(() => {
        a.noFocus === !1 && (u.value = !0);
      });
    }, Q = () => V(), W = () => {
      d.value = !0, L(), o("shown", B("shown")), a.lazy === !0 && (p.value = !0);
    }, F = () => {
      d.value = !1;
    }, Z = () => {
      o("hidden", B("hidden")), a.lazy === !0 && (p.value = !1);
    };
    return ke(i, "bv-toggle", () => {
      s.value ? C() : V();
    }), e({
      hide: C,
      show: V
    }), (R, le) => (b(), I(ht, {
      to: R.teleportTo,
      disabled: a.teleportDisabled
    }, [
      ve(It, {
        "no-fade": !0,
        "trans-props": {
          enterToClass: "showing",
          enterFromClass: "",
          leaveToClass: "hiding show",
          leaveFromClass: "show"
        },
        onBeforeEnter: Q,
        onAfterEnter: W,
        onLeave: F,
        onAfterLeave: Z
      }, {
        default: E(() => [
          ut(J("div", K({
            id: O(n),
            ref_key: "element",
            ref: i,
            "aria-modal": "true",
            role: "dialog",
            class: v.value,
            tabindex: "-1",
            "aria-labelledby": `${O(n)}-offcanvas-label`,
            "data-bs-backdrop": "false"
          }, R.$attrs), [
            m.value ? (b(), _(de, { key: 0 }, [
              a.noHeader ? ae("", !0) : (b(), _("div", {
                key: 0,
                class: D(["offcanvas-header", R.headerClass])
              }, [
                T(R.$slots, "header", ge(we($.value)), () => [
                  J("h5", {
                    id: `${O(n)}-offcanvas-label`,
                    class: "offcanvas-title"
                  }, [
                    T(R.$slots, "title", ge(we($.value)), () => [
                      ne(Y(R.title), 1)
                    ])
                  ], 8, Rd),
                  a.noHeaderClose ? ae("", !0) : (b(), _(de, { key: 0 }, [
                    y.value ? (b(), I(vt, K({ key: 0 }, c.value, {
                      onClick: le[0] || (le[0] = (N) => C("close"))
                    }), {
                      default: E(() => [
                        T(R.$slots, "header-close")
                      ]),
                      _: 3
                    }, 16)) : (b(), I(Pt, K({
                      key: 1,
                      "aria-label": R.headerCloseLabel
                    }, c.value, {
                      onClick: le[1] || (le[1] = (N) => C("close"))
                    }), null, 16, ["aria-label"]))
                  ], 64))
                ])
              ], 2)),
              J("div", K({
                class: ["offcanvas-body", R.bodyClass]
              }, R.bodyAttrs), [
                T(R.$slots, "default", ge(we($.value)))
              ], 16),
              g.value ? (b(), _("div", {
                key: 1,
                class: D(R.footerClass)
              }, [
                T(R.$slots, "footer", ge(we($.value)))
              ], 2)) : ae("", !0)
            ], 64)) : ae("", !0)
          ], 16, Hd), [
            [xt, s.value]
          ])
        ]),
        _: 3
      }),
      T(R.$slots, "backdrop", {}, () => [
        ve(ma, {
          blur: R.backdropBlur,
          variant: R.backdropVariant,
          show: f.value,
          fixed: "",
          "no-wrap": "",
          "no-spinner": "",
          onClick: le[2] || (le[2] = (N) => C("backdrop"))
        }, null, 8, ["blur", "variant", "show"])
      ])
    ], 8, ["to", "disabled"]));
  }
}), xd = ["aria-disabled", "aria-label"], Ll = 20, zl = 0, Dd = /* @__PURE__ */ H({
  __name: "BPagination",
  props: /* @__PURE__ */ pe({
    align: { default: "start" },
    ariaControls: { default: void 0 },
    ariaLabel: { default: "Pagination" },
    disabled: { type: Boolean, default: !1 },
    ellipsisClass: { default: void 0 },
    ellipsisText: { default: "" },
    firstClass: { default: void 0 },
    firstNumber: { type: Boolean, default: !1 },
    firstText: { default: "" },
    hideEllipsis: { type: Boolean, default: !1 },
    hideGotoEndButtons: { type: Boolean, default: !1 },
    labelFirstPage: { default: "Go to first page" },
    labelLastPage: { default: "Go to last page" },
    labelNextPage: { default: "Go to next page" },
    labelPage: { default: "Go to page" },
    labelPrevPage: { default: "Go to previous page" },
    lastClass: { default: void 0 },
    lastNumber: { type: Boolean, default: !1 },
    lastText: { default: "" },
    limit: { default: 5 },
    modelValue: {},
    nextClass: { default: void 0 },
    nextText: { default: "" },
    pageClass: { default: void 0 },
    perPage: { default: Ll },
    pills: { type: Boolean, default: !1 },
    prevClass: { default: void 0 },
    prevText: { default: "" },
    size: { default: void 0 },
    totalRows: { default: zl }
  }, {
    modelValue: { default: 1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["page-click"], ["update:modelValue"]),
  setup(t, { emit: e }) {
    const i = t, u = e, d = he(t, "modelValue"), p = be(() => i.limit, { nanToZero: !0, method: "parseInt" }), f = be(() => i.perPage, { nanToZero: !0, method: "parseInt" }), m = be(() => i.totalRows, { nanToZero: !0, method: "parseInt" }), y = be(d, { nanToZero: !0, method: "parseInt" }), h = k(() => Math.max(f.value || Ll, 1)), c = k(() => Math.max(m.value || zl, 0)), g = k(() => Math.ceil(c.value / h.value)), v = k(() => i.align === "fill"), $ = k(() => i.align === "fill" ? "start" : i.align), B = Dt($), C = (te) => te === y.value, V = (te) => i.disabled ? null : C(te) ? "0" : "-1", L = (te) => i.disabled || C(te) || y.value < 1 || // Check if the number is out of bounds
    te < 1 || te > g.value, Q = w(() => L(1)), W = w(() => L(y.value - 1)), F = w(() => L(g.value)), Z = w(() => L(y.value + 1)), R = ({
      page: te,
      classVal: ye,
      dis: ee,
      slotName: U,
      textValue: z,
      tabIndex: oe,
      label: fe,
      position: ce,
      isActive: Oe,
      role: $e,
      hidden: Te
    }) => ({
      li: {
        class: [
          "page-item",
          {
            active: Oe,
            disabled: ee,
            "flex-fill": v.value,
            "d-flex": v.value && !ee
          },
          ye
        ],
        role: $e,
        "aria-hidden": Te
      },
      button: {
        is: ee ? "span" : "button",
        class: ["page-link", { "flex-grow-1": !ee && v.value }],
        "aria-label": fe,
        "aria-controls": i.ariaControls || void 0,
        "aria-disabled": ee ? !0 : void 0,
        "aria-posinset": ce,
        "aria-setsize": ce ? g.value : void 0,
        role: "menuitem",
        type: ee ? void 0 : "button",
        tabindex: ee ? void 0 : oe
      },
      text: {
        name: U,
        active: Oe,
        value: z ?? te,
        page: te,
        disabled: ee,
        index: te - 1,
        content: z ? void 0 : te
      },
      clickHandler: (Ye) => se(Ye, te)
    }), le = ({
      page: te,
      classVal: ye,
      dis: ee,
      slotName: U,
      textValue: z,
      label: oe
    }) => R({ page: te, classVal: ye, dis: ee, slotName: U, textValue: z, label: oe, tabIndex: "-1" }), N = (te) => R({
      page: te,
      dis: i.disabled,
      classVal: i.pageClass,
      slotName: "page",
      label: i.labelPage ? `${i.labelPage} ${te}` : void 0,
      tabIndex: V(te) ?? void 0,
      position: te,
      isActive: C(te)
    }), S = w(
      () => le({
        page: 1,
        dis: Q.value,
        classVal: i.firstClass,
        slotName: "first-text",
        textValue: i.firstText,
        label: i.labelFirstPage
      })
    ), P = w(
      () => le({
        page: Math.max(y.value - 1, 1),
        dis: W.value,
        classVal: i.prevClass,
        slotName: "prev-text",
        textValue: i.prevText,
        label: i.labelPrevPage
      })
    ), M = w(
      () => le({
        page: Math.min(y.value + 1, g.value),
        dis: Z.value,
        classVal: i.nextClass,
        slotName: "next-text",
        textValue: i.nextText,
        label: i.labelNextPage
      })
    ), j = w(
      () => le({
        page: g.value,
        dis: F.value,
        classVal: i.lastClass,
        slotName: "last-text",
        textValue: i.lastText,
        label: i.labelLastPage
      })
    ), A = zt(), X = zt(), G = w(() => ({
      li: {
        class: [
          "page-item",
          "disabled",
          "bv-d-xs-down-none",
          v.value ? "flex-fill" : "",
          i.ellipsisClass
        ],
        role: "separator"
      },
      span: {
        class: ["page-link"]
      }
    })), ie = w(() => [
      B.value,
      {
        [`pagination-${i.size}`]: i.size !== void 0,
        "b-pagination-pills": i.pills
      }
    ]), q = w(() => ({
      pageSize: h.value,
      totalRows: m.value,
      numberOfPages: g.value
    })), se = (te, ye) => {
      if (ye === y.value)
        return;
      const ee = new nt("page-click", {
        cancelable: !0,
        target: te.target
      });
      u("page-click", ee, ye), !ee.defaultPrevented && (d.value = ye);
    };
    ue(y, (te) => {
      const ee = ((U, z) => {
        const oe = U || 1;
        return oe > z ? z : oe < 1 ? 1 : oe;
      })(te, g.value);
      ee !== d.value && (d.value = ee);
    }), ue(q, (te, ye) => {
      (ye.pageSize !== te.pageSize && ye.totalRows === te.totalRows || ye.numberOfPages !== te.numberOfPages && y.value > ye.numberOfPages) && (d.value = 1);
    });
    const me = w(() => {
      const te = g.value, { value: ye } = y, ee = p.value, U = i.firstNumber ? 1 : 0, z = i.lastNumber ? 1 : 0, oe = i.hideEllipsis || ee <= 3, fe = i.hideGotoEndButtons ? 1 : 0;
      if (te < ee + U + z)
        return [
          !U && !fe ? -1 : null,
          -2,
          ...Array.from({ length: te }, ($e, Te) => Te + 1),
          -3,
          !z && !fe ? -4 : null
        ].filter(($e) => $e !== null);
      const ce = Array.from({ length: ee + 4 - fe * 2 });
      fe ? (ce[0] = -2, ce[ce.length - 1] = -3) : (U ? (ce[0] = -2, ce[1] = 1) : (ce[0] = -1, ce[1] = -2), z ? (ce[ce.length - 1] = -3, ce[ce.length - 2] = te) : (ce[ce.length - 1] = -4, ce[ce.length - 2] = -3));
      const Oe = Math.floor(ee / 2);
      if (ye <= Oe + U) {
        for (let $e = 1; $e <= ee; $e++)
          ce[$e + 1 - fe] = $e + U;
        oe || (ce[ce.length - 3] = -5);
      }
      if (ye > te - Oe - z) {
        const $e = te - (ee - 1) - z;
        for (let Te = 0; Te < ee; Te++)
          ce[Te + 2 - fe] = $e + Te;
        oe || (ce[2] = -5);
      }
      if (!ce[2]) {
        const $e = ye - Math.floor(ee / 2);
        for (let Te = 0; Te < ee; Te++)
          ce[Te + 2 - fe] = $e + Te;
        oe || (ce[2] = -5, ce[ce.length - 3] = -5);
      }
      return ce;
    });
    return (te, ye) => (b(), _("ul", {
      class: D(["pagination", ie.value]),
      role: "menubar",
      "aria-disabled": i.disabled,
      "aria-label": te.ariaLabel || void 0
    }, [
      ve(O(A).define, null, {
        default: E(({ button: ee, li: U, text: z, clickHandler: oe }) => [
          J("li", ge(we(U)), [
            (b(), I(re(ee.is), K(ee, { onClick: oe }), {
              default: E(() => [
                T(te.$slots, z.name, {
                  disabled: z.disabled,
                  page: z.page,
                  index: z.index,
                  active: z.active,
                  content: z.value
                }, () => [
                  ne(Y(z.value), 1)
                ])
              ]),
              _: 2
            }, 1040, ["onClick"]))
          ], 16)
        ]),
        _: 3
      }),
      ve(O(X).define, null, {
        default: E(() => [
          J("li", ge(we(G.value.li)), [
            J("span", ge(we(G.value.span)), [
              T(te.$slots, "ellipsis-text", {}, () => [
                ne(Y(te.ellipsisText || "..."), 1)
              ])
            ], 16)
          ], 16)
        ]),
        _: 3
      }),
      (b(!0), _(de, null, Ce(me.value, (ee) => (b(), _(de, {
        key: `page-${ee.number}`
      }, [
        ee === -1 ? (b(), I(O(A).reuse, K({
          key: 0,
          ref_for: !0
        }, S.value), null, 16)) : ee === -2 ? (b(), I(O(A).reuse, K({
          key: 1,
          ref_for: !0
        }, P.value), null, 16)) : ee === -3 ? (b(), I(O(A).reuse, K({
          key: 2,
          ref_for: !0
        }, M.value), null, 16)) : ee === -4 ? (b(), I(O(A).reuse, K({
          key: 3,
          ref_for: !0
        }, j.value), null, 16)) : ee === -5 ? (b(), I(O(X).reuse, { key: 4 })) : (b(), I(O(A).reuse, K({
          key: 5,
          ref_for: !0
        }, N(ee)), null, 16))
      ], 64))), 128))
    ], 10, xd));
  }
}), je = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BPlaceholder",
  props: {
    animation: { default: void 0 },
    cols: { default: 12 },
    size: { default: "md" },
    tag: { default: "span" },
    variant: { default: null },
    width: { default: void 0 },
    wrapperTag: { default: "span" }
  },
  setup(t) {
    const e = t, l = k(
      () => e.width === void 0 ? void 0 : typeof e.width == "number" ? e.width.toString() : e.width.replace("%", "")
    ), a = k(
      () => e.cols === void 0 ? void 0 : typeof e.cols == "number" ? e.cols.toString() : e.cols
    ), o = w(() => ({
      [`col-${a.value}`]: a.value !== void 0 && l.value === void 0,
      [`bg-${e.variant}`]: e.variant !== null,
      [`placeholder-${e.size}`]: e.size !== "md"
    })), r = w(() => ({
      [`placeholder-${e.animation}`]: e.animation !== void 0
    })), s = w(() => ({
      width: l.value === void 0 ? void 0 : `${l.value}%`
    }));
    return (n, i) => (b(), I(re(n.wrapperTag), {
      class: D(r.value)
    }, {
      default: E(() => [
        (b(), I(re(n.tag), K(n.$attrs, {
          class: ["placeholder", o.value],
          style: s.value
        }), null, 16, ["class", "style"]))
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), hn = /* @__PURE__ */ H({
  __name: "BPlaceholderButton",
  props: {
    animation: { default: void 0 },
    cols: { default: void 0 },
    tag: { default: "div" },
    variant: { default: "primary" },
    width: { default: void 0 }
  },
  setup(t) {
    const e = t, l = w(() => ({
      [`btn-${e.variant}`]: e.variant !== null
    }));
    return (a, o) => (b(), I(je, {
      class: D(["btn disabled", l.value]),
      animation: a.animation,
      width: a.width,
      cols: a.cols,
      tag: a.tag,
      style: { cursor: "wait", "pointer-events": "auto" }
    }, null, 8, ["class", "animation", "width", "cols", "tag"]));
  }
}), jd = /* @__PURE__ */ H({
  __name: "BPlaceholderCard",
  props: {
    animation: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerSize: { default: "md" },
    footerVariant: { default: void 0 },
    footerWidth: { default: 100 },
    headerAnimation: { default: void 0 },
    headerSize: { default: "md" },
    headerVariant: { default: void 0 },
    headerWidth: { default: 100 },
    imgBlankColor: { default: "#868e96" },
    imgBottom: { type: Boolean, default: !1 },
    imgHeight: { default: 100 },
    imgSrc: { default: void 0 },
    noButton: { type: Boolean, default: !1 },
    noFooter: { type: Boolean, default: !1 },
    noHeader: { type: Boolean, default: !1 },
    noImg: { type: Boolean, default: !1 },
    size: { default: "md" },
    variant: { default: void 0 }
  },
  setup(t) {
    const e = t, l = w(() => ({
      animation: e.animation,
      size: e.size,
      variant: e.variant
    })), a = k(() => e.noButton ? je : hn);
    return (o, r) => (b(), I(rn, { "img-bottom": o.imgBottom }, La({
      default: E(() => [
        T(o.$slots, "default", {}, () => [
          ve(je, K({ cols: "7" }, l.value), null, 16),
          ve(je, K({ cols: "4" }, l.value), null, 16),
          ve(je, K({ cols: "4" }, l.value), null, 16),
          ve(je, K({ cols: "6" }, l.value), null, 16),
          ve(je, K({ cols: "8" }, l.value), null, 16)
        ])
      ]),
      _: 2
    }, [
      e.noImg ? void 0 : {
        name: "img",
        fn: E(() => [
          T(o.$slots, "img", {}, () => [
            ve(tl, {
              blank: !o.imgSrc,
              "blank-color": o.imgBlankColor,
              height: o.imgSrc ? void 0 : o.imgHeight,
              src: o.imgSrc,
              top: !o.imgBottom,
              bottom: o.imgBottom,
              style: { cursor: "wait" }
            }, null, 8, ["blank", "blank-color", "height", "src", "top", "bottom"])
          ])
        ]),
        key: "0"
      },
      e.noHeader ? void 0 : {
        name: "header",
        fn: E(() => [
          T(o.$slots, "header", {}, () => [
            ve(je, {
              width: o.headerWidth,
              variant: o.headerVariant,
              animation: o.headerAnimation,
              size: o.headerSize
            }, null, 8, ["width", "variant", "animation", "size"])
          ])
        ]),
        key: "1"
      },
      e.noFooter ? void 0 : {
        name: "footer",
        fn: E(() => [
          T(o.$slots, "footer", {}, () => [
            (b(), I(re(a.value), {
              width: o.footerWidth,
              animation: o.footerAnimation,
              size: e.noButton ? o.footerSize : void 0,
              variant: o.footerVariant
            }, null, 8, ["width", "animation", "size", "variant"]))
          ])
        ]),
        key: "2"
      }
    ]), 1032, ["img-bottom"]));
  }
}), qd = "300px", ol = /* @__PURE__ */ H({
  __name: "BTableSimple",
  props: {
    bordered: { type: Boolean, default: !1 },
    borderless: { type: Boolean, default: !1 },
    borderVariant: { default: null },
    captionTop: { type: Boolean, default: !1 },
    dark: { type: Boolean, default: !1 },
    fixed: { type: Boolean, default: !1 },
    hover: { type: Boolean, default: !1 },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: !1 },
    outlined: { type: Boolean, default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    small: { type: Boolean, default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    stickyHeader: { type: [Boolean, String, Number], default: !1 },
    striped: { type: Boolean, default: !1 },
    stripedColumns: { type: Boolean, default: !1 },
    tableClass: { default: void 0 },
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = w(() => [
      e.tableClass,
      "table",
      "b-table",
      {
        "table-bordered": e.bordered,
        "table-borderless": e.borderless,
        [`border-${e.borderVariant}`]: e.borderVariant !== null,
        "caption-top": e.captionTop,
        "table-dark": e.dark,
        "table-hover": e.hover,
        "b-table-stacked": e.stacked === !0,
        [`b-table-stacked-${e.stacked}`]: typeof e.stacked == "string",
        "table-striped": e.striped,
        "table-sm": e.small,
        [`table-${e.variant}`]: e.variant !== null,
        "table-striped-columns": e.stripedColumns
      }
    ]), a = w(() => ({
      id: e.id,
      class: l.value
    })), o = ia(
      w(
        () => (e.stickyHeader === !0 ? qd : e.stickyHeader) || NaN
      )
    ), r = w(() => e.stickyHeader !== !1), s = w(() => e.responsive !== !1 || r.value), n = w(
      () => r.value ? { maxHeight: o.value } : void 0
    ), i = w(() => ({
      "table-responsive": e.responsive === !0,
      [`table-responsive-${e.responsive}`]: typeof e.responsive == "string",
      "b-table-sticky-header": r.value
    }));
    return (u, d) => s.value ? (b(), _("div", {
      key: 0,
      class: D(i.value),
      style: Ee(n.value)
    }, [
      J("table", ge(we(a.value)), [
        T(u.$slots, "default")
      ], 16)
    ], 6)) : (b(), _("table", ge(K({ key: 1 }, a.value)), [
      T(u.$slots, "default")
    ], 16));
  }
}), Wd = /* @__PURE__ */ H({
  __name: "BPlaceholderTable",
  props: {
    animation: { default: void 0 },
    cellWidth: { default: 100 },
    columns: { default: 5 },
    footerAnimation: { default: void 0 },
    footerCellWidth: { default: 100 },
    footerColumns: { default: void 0 },
    footerSize: { default: "md" },
    footerVariant: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerCellWidth: { default: 100 },
    headerColumns: { default: void 0 },
    headerSize: { default: "md" },
    headerVariant: { default: void 0 },
    hideHeader: { type: Boolean, default: !1 },
    rows: { default: 3 },
    showFooter: { type: Boolean, default: !1 },
    size: { default: "md" },
    variant: { default: void 0 }
  },
  setup(t) {
    const e = t, l = be(() => e.columns), a = be(() => e.rows), o = k(() => e.headerColumns ?? NaN), r = k(() => e.footerColumns ?? NaN), s = be(o), n = be(r), i = k(() => l.value || 5), u = k(() => a.value || 3), d = k(
      () => e.headerColumns === void 0 ? i.value : s.value
    ), p = k(
      () => e.footerColumns === void 0 ? i.value : n.value
    );
    return (f, m) => (b(), I(ol, null, {
      default: E(() => [
        e.hideHeader ? ae("", !0) : T(f.$slots, "thead", { key: 0 }, () => [
          J("thead", null, [
            J("tr", null, [
              (b(!0), _(de, null, Ce(d.value, (y, h) => (b(), _("th", { key: h }, [
                ve(je, {
                  size: f.headerSize,
                  variant: f.headerVariant,
                  animation: f.headerAnimation,
                  width: f.headerCellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ])
          ])
        ]),
        T(f.$slots, "default", {}, () => [
          J("tbody", null, [
            (b(!0), _(de, null, Ce(u.value, (y, h) => (b(), _("tr", { key: h }, [
              (b(!0), _(de, null, Ce(i.value, (c, g) => (b(), _("td", { key: g }, [
                ve(je, {
                  size: f.size,
                  variant: f.variant,
                  animation: f.animation,
                  width: f.cellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ]))), 128))
          ])
        ]),
        e.showFooter ? T(f.$slots, "tfoot", { key: 1 }, () => [
          J("tfoot", null, [
            J("tr", null, [
              (b(!0), _(de, null, Ce(p.value, (y, h) => (b(), _("th", { key: h }, [
                ve(je, {
                  size: f.footerSize,
                  variant: f.footerVariant,
                  animation: f.footerAnimation,
                  width: f.footerCellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ])
          ])
        ]) : ae("", !0)
      ]),
      _: 3
    }));
  }
}), Gd = /* @__PURE__ */ H({
  __name: "BPlaceholderWrapper",
  props: {
    loading: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t;
    return (l, a) => e.loading ? T(l.$slots, "loading", { key: 0 }) : T(l.$slots, "default", { key: 1 });
  }
}), Hl = fa("cols", [""], { type: [String, Number], default: null }), Ud = H({
  name: "BRow",
  slots: Object,
  props: {
    tag: { type: String, default: "div" },
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    noGutters: { type: Boolean, default: !1 },
    alignV: { type: String, default: null },
    alignH: { type: String, default: null },
    alignContent: { type: String, default: null },
    ...Hl
  },
  setup(t) {
    const e = Dt(() => t.alignH), l = w(() => ho(t, Hl, "cols", "row-cols"));
    return {
      computedClasses: w(() => [
        l.value,
        {
          [`gx-${t.gutterX}`]: t.gutterX !== null,
          [`gy-${t.gutterY}`]: t.gutterY !== null,
          "g-0": t.noGutters,
          [`align-items-${t.alignV}`]: t.alignV !== null,
          [e.value]: t.alignH !== null,
          [`align-content-${t.alignContent}`]: t.alignContent !== null
        }
      ])
    };
  }
});
function Kd(t, e, l, a, o, r) {
  return b(), I(re(t.tag), {
    class: D(["row", t.computedClasses])
  }, {
    default: E(() => [
      T(t.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const Xd = /* @__PURE__ */ qt(Ud, [["render", Kd]]), Ze = (t) => typeof t == "object" && t !== null, Ia = (t) => typeof t == "object" && t !== null && "key" in t, Bn = /* @__PURE__ */ H({
  __name: "BTbody",
  props: {
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = w(() => ({
      [`thead-${e.variant}`]: e.variant !== null
    }));
    return (a, o) => (b(), _("tbody", {
      class: D(l.value)
    }, [
      T(a.$slots, "default")
    ], 2));
  }
}), Yd = ["scope", "colspan", "rowspan", "data-label"], Zd = { key: 0 }, St = /* @__PURE__ */ H({
  __name: "BTd",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: Boolean, default: !1 },
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = w(() => ({
      [`table-${e.variant}`]: e.variant !== null,
      "b-table-sticky-column": e.stickyColumn,
      "table-b-table-default": e.stickyColumn && e.variant === null
    })), a = k(() => e.colspan ? "colspan" : e.rowspan ? "rowspan" : "col");
    return (o, r) => (b(), _("td", {
      scope: a.value,
      class: D(l.value),
      colspan: o.colspan,
      rowspan: o.rowspan,
      "data-label": o.stackedHeading
    }, [
      o.stackedHeading ? (b(), _("div", Zd, [
        T(o.$slots, "default")
      ])) : T(o.$slots, "default", { key: 1 })
    ], 10, Yd));
  }
}), Pa = /* @__PURE__ */ H({
  __name: "BTfoot",
  props: {
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = w(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (a, o) => (b(), _("tfoot", {
      class: D(l.value)
    }, [
      T(a.$slots, "default")
    ], 2));
  }
}), Jd = ["scope", "colspan", "rowspan", "data-label"], Qd = { key: 0 }, Ea = /* @__PURE__ */ H({
  __name: "BTh",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: Boolean, default: !1 },
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = w(() => ({
      [`table-${e.variant}`]: e.variant !== null,
      "b-table-sticky-column": e.stickyColumn,
      "table-b-table-default": e.stickyColumn && e.variant === null
    })), a = k(() => e.colspan ? "colspan" : e.rowspan ? "rowspan" : "col");
    return (o, r) => (b(), _("th", {
      scope: a.value,
      class: D(l.value),
      colspan: o.colspan,
      rowspan: o.rowspan,
      "data-label": o.stackedHeading
    }, [
      o.stackedHeading !== void 0 ? (b(), _("div", Qd, [
        T(o.$slots, "default")
      ])) : T(o.$slots, "default", { key: 1 })
    ], 10, Jd));
  }
}), wn = /* @__PURE__ */ H({
  __name: "BThead",
  props: {
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = w(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (a, o) => (b(), _("thead", {
      class: D(l.value)
    }, [
      T(a.$slots, "default")
    ], 2));
  }
}), Je = /* @__PURE__ */ H({
  __name: "BTr",
  props: {
    variant: { default: null }
  },
  setup(t) {
    const e = t, l = w(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (a, o) => (b(), _("tr", {
      class: D(l.value)
    }, [
      T(a.$slots, "default")
    ], 2));
  }
}), ec = {
  key: 0,
  class: "b-table-stacked-label"
}, tc = { class: "d-inline-flex flex-nowrap align-items-center gap-1" }, ac = { key: 2 }, Cn = /* @__PURE__ */ H({
  __name: "BTableLite",
  props: {
    align: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    detailsTdClass: { default: void 0 },
    emptyFilteredText: { default: "There are no records matching your request" },
    emptyText: { default: "There are no records to show" },
    fieldColumnClass: { type: [Function, String, Object, Array], default: void 0 },
    fields: { default: () => [] },
    footClone: { type: Boolean, default: !1 },
    footRowVariant: { default: void 0 },
    footVariant: { default: void 0 },
    headRowVariant: { default: void 0 },
    headVariant: { default: void 0 },
    items: { default: () => [] },
    labelStacked: { type: Boolean, default: !1 },
    modelValue: { default: void 0 },
    primaryKey: { default: void 0 },
    showEmpty: { type: Boolean, default: !1 },
    tbodyClass: { default: void 0 },
    tbodyTrAttr: { default: void 0 },
    tbodyTrClass: { type: [Function, String, Object, Array], default: void 0 },
    tfootClass: { default: void 0 },
    tfootTrClass: { default: void 0 },
    theadClass: { default: void 0 },
    theadTrClass: { default: void 0 },
    bordered: { type: Boolean, default: void 0 },
    borderless: { type: Boolean, default: void 0 },
    borderVariant: { default: void 0 },
    captionTop: { type: Boolean, default: void 0 },
    dark: { type: Boolean, default: void 0 },
    fixed: { type: Boolean, default: void 0 },
    hover: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: void 0 },
    outlined: { type: Boolean, default: void 0 },
    responsive: { type: [Boolean, String], default: void 0 },
    small: { type: Boolean, default: void 0 },
    stacked: { type: [Boolean, String], default: void 0 },
    stickyHeader: { type: [Boolean, String, Number], default: void 0 },
    striped: { type: Boolean, default: void 0 },
    stripedColumns: { type: Boolean, default: void 0 },
    tableClass: { default: void 0 },
    variant: { default: void 0 }
  },
  emits: ["head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered"],
  setup(t, { emit: e }) {
    const l = t, a = e, o = (c) => [
      c,
      c._showDetails
    ], r = x(
      new WeakMap(
        l.items.reduce(
          (c, g) => (Ze(g) && c.push(o(g)), c),
          []
        )
      )
    );
    ue(
      () => l.items,
      (c) => {
        c.forEach((g) => {
          if (!Ze(g))
            return;
          const v = o(g);
          r.value.set(v[0], v[1]);
        });
      },
      { deep: !0 }
    );
    const s = w(() => [
      l.tableClass,
      {
        [`align-${l.align}`]: l.align !== void 0
      }
    ]), n = w(() => {
      if (!l.fields.length && l.items.length) {
        const [c] = l.items;
        return Ze(c) || Array.isArray(c) ? Object.keys(c).map((g) => {
          const v = ya(g);
          return {
            key: g,
            label: v,
            tdAttr: l.stacked === !0 ? { "data-label": v } : void 0
          };
        }) : [{ key: "", _noHeader: !0 }];
      }
      return l.fields.map((c) => {
        if (Ia(c))
          return {
            ...c,
            tdAttr: l.stacked === !0 ? { "data-label": ya(c.key), ...c.tdAttr } : c.tdAttr
          };
        const g = ya(c);
        return {
          key: c,
          label: g,
          tdAttr: l.stacked === !0 ? { "data-label": g } : void 0
        };
      });
    }), i = k(() => n.value.length), u = w(() => !(n.value.length > 0 && n.value.every((c) => c._noHeader === !0))), d = (c, g, v) => {
      const $ = qe(c, g);
      return v && typeof v == "function" ? v($, g, c) : v;
    }, p = (c, g, v = !1) => {
      a("head-clicked", c.key, c, g, v);
    }, f = (c) => {
      if (Ze(c)) {
        const g = r.value.get(c);
        r.value.set(c, !g);
      }
    }, m = (c) => [
      c.class,
      c.thClass,
      {
        "b-table-sticky-column": c.stickyColumn
      },
      l.fieldColumnClass ? typeof l.fieldColumnClass == "function" ? l.fieldColumnClass(c) : l.fieldColumnClass : null
    ], y = (c, g) => {
      var v, $;
      return [
        c.class,
        c.tdClass,
        Ze(g) && (v = g._cellVariants) != null && v[c.key] ? `table-${($ = g._cellVariants) == null ? void 0 : $[c.key]}` : null,
        {
          "b-table-sticky-column": c.stickyColumn
        }
      ];
    }, h = (c, g) => l.tbodyTrClass ? typeof l.tbodyTrClass == "function" ? l.tbodyTrClass(c, g) : l.tbodyTrClass : null;
    return (c, g) => (b(), I(ol, {
      id: c.id,
      bordered: c.bordered,
      borderless: c.borderless,
      "border-variant": c.borderVariant,
      "caption-top": c.captionTop,
      dark: c.dark,
      fixed: c.fixed,
      hover: c.hover,
      "no-border-collapse": c.noBorderCollapse,
      outlined: c.outlined,
      responsive: c.responsive,
      small: c.small,
      stacked: l.stacked,
      "sticky-header": c.stickyHeader,
      striped: c.striped,
      "table-class": s.value,
      variant: c.variant,
      "striped-columns": c.stripedColumns
    }, {
      default: E(() => [
        ut(ve(wn, {
          variant: c.headVariant,
          class: D(c.theadClass)
        }, {
          default: E(() => [
            c.$slots["thead-top"] ? T(c.$slots, "thead-top", { key: 0 }) : ae("", !0),
            ve(Je, {
              variant: c.headRowVariant,
              class: D(c.theadTrClass)
            }, {
              default: E(() => [
                (b(!0), _(de, null, Ce(n.value, (v) => (b(), I(Ea, K({
                  key: v.key,
                  scope: "col",
                  class: m(v),
                  title: v.headerTitle,
                  variant: v.variant,
                  abbr: v.headerAbbr,
                  style: v.thStyle,
                  ref_for: !0
                }, v.thAttr, {
                  onClick: ($) => p(v, $)
                }), {
                  default: E(() => [
                    T(c.$slots, c.$slots[`head(${String(v.key)})`] ? `head(${String(v.key)})` : "head()", {
                      label: v.label,
                      column: v.key,
                      field: v,
                      isFoot: !1
                    }, () => [
                      ne(Y(O(Jt)(v)), 1)
                    ])
                  ]),
                  _: 2
                }, 1040, ["class", "title", "variant", "abbr", "style", "onClick"]))), 128))
              ]),
              _: 3
            }, 8, ["variant", "class"]),
            c.$slots["thead-sub"] ? (b(), I(Je, { key: 1 }, {
              default: E(() => [
                (b(!0), _(de, null, Ce(n.value, (v) => (b(), I(St, {
                  key: v.key,
                  scope: "col",
                  variant: v.variant,
                  class: D([v.class, v.thClass])
                }, {
                  default: E(() => [
                    T(c.$slots, "thead-sub", K({
                      items: n.value,
                      ref_for: !0
                    }, v), () => [
                      ne(Y(v.label), 1)
                    ])
                  ]),
                  _: 2
                }, 1032, ["variant", "class"]))), 128))
              ]),
              _: 3
            })) : ae("", !0)
          ]),
          _: 3
        }, 8, ["variant", "class"]), [
          [xt, u.value]
        ]),
        ve(Bn, {
          class: D(c.tbodyClass)
        }, {
          default: E(() => [
            T(c.$slots, "custom-body", {
              fields: n.value,
              items: c.items,
              columns: n.value.length
            }, () => [
              !l.stacked && c.$slots["top-row"] ? (b(), I(Je, { key: 0 }, {
                default: E(() => [
                  T(c.$slots, "top-row")
                ]),
                _: 3
              })) : ae("", !0),
              (b(!0), _(de, null, Ce(c.items, (v, $) => (b(), _(de, { key: $ }, [
                ve(Je, {
                  class: D(h(v, "row")),
                  variant: O(Ze)(v) ? v._rowVariant : void 0,
                  onClick: (B) => !O(Gt)(B) && a("row-clicked", v, $, B),
                  onDblclick: (B) => !O(Gt)(B) && a("row-dbl-clicked", v, $, B),
                  onMouseenter: (B) => !O(Gt)(B) && a("row-hovered", v, $, B),
                  onMouseleave: (B) => !O(Gt)(B) && a("row-unhovered", v, $, B)
                }, {
                  default: E(() => [
                    (b(!0), _(de, null, Ce(n.value, (B) => {
                      var C;
                      return b(), I(St, K({
                        key: B.key,
                        variant: O(Ze)(v) && (C = v._cellVariants) != null && C[B.key] ? null : B.variant,
                        class: y(B, v),
                        ref_for: !0
                      }, d(v, String(B.key), B.tdAttr)), {
                        default: E(() => [
                          l.stacked && l.labelStacked ? (b(), _("label", ec, Y(O(Jt)(B)), 1)) : ae("", !0),
                          T(
                            c.$slots,
                            c.$slots[`cell(${String(B.key)})`] ? `cell(${String(B.key)})` : "cell()",
                            {
                              value: O(qe)(v, String(B.key)),
                              index: $,
                              item: v,
                              field: B,
                              items: c.items,
                              toggleDetails: () => {
                                f(v);
                              },
                              detailsShowing: O(Ze)(v) ? r.value.get(v) ?? !1 : !1
                            },
                            () => [
                              !c.$slots[`cell(${String(B.key)})`] && !c.$slots["cell()"] ? (b(), _(de, { key: 0 }, [
                                ne(Y(O(go)(v, String(B.key), B.formatter)), 1)
                              ], 64)) : ae("", !0)
                            ]
                          )
                        ]),
                        _: 2
                      }, 1040, ["variant", "class"]);
                    }), 128))
                  ]),
                  _: 2
                }, 1032, ["class", "variant", "onClick", "onDblclick", "onMouseenter", "onMouseleave"]),
                O(Ze)(v) && r.value.get(v) === !0 && c.$slots["row-details"] ? (b(), _(de, { key: 0 }, [
                  ve(Je, {
                    "aria-hidden": "true",
                    role: "presentation",
                    class: "d-none"
                  }),
                  ve(Je, {
                    class: D(h(v, "row-details")),
                    variant: v._rowVariant
                  }, {
                    default: E(() => [
                      ve(St, { colspan: i.value }, {
                        default: E(() => [
                          T(c.$slots, "row-details", {
                            item: v,
                            toggleDetails: () => {
                              f(v);
                            },
                            fields: c.fields,
                            index: $
                          })
                        ]),
                        _: 2
                      }, 1032, ["colspan"])
                    ]),
                    _: 2
                  }, 1032, ["class", "variant"])
                ], 64)) : ae("", !0)
              ], 64))), 128)),
              l.showEmpty && c.items.length === 0 ? (b(), I(Je, {
                key: 1,
                class: "b-table-empty-slot"
              }, {
                default: E(() => [
                  ve(St, { colspan: i.value }, {
                    default: E(() => [
                      T(c.$slots, "empty", { items: c.items }, () => [
                        ne(Y(c.emptyText), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["colspan"])
                ]),
                _: 3
              })) : ae("", !0),
              !l.stacked && c.$slots["bottom-row"] ? (b(), I(Je, { key: 2 }, {
                default: E(() => [
                  T(c.$slots, "bottom-row")
                ]),
                _: 3
              })) : ae("", !0)
            ])
          ]),
          _: 3
        }, 8, ["class"]),
        l.footClone ? (b(), I(Pa, {
          key: 0,
          variant: c.footVariant,
          class: D(c.tfootClass)
        }, {
          default: E(() => [
            ve(Je, {
              variant: c.footRowVariant,
              class: D(c.tfootTrClass)
            }, {
              default: E(() => [
                (b(!0), _(de, null, Ce(n.value, (v) => (b(), I(Ea, K({
                  key: v.key,
                  scope: "col",
                  class: m(v),
                  title: v.headerTitle,
                  abbr: v.headerAbbr,
                  style: v.thStyle,
                  variant: v.variant,
                  ref_for: !0
                }, v.thAttr, {
                  onClick: ($) => p(v, $, !0)
                }), {
                  default: E(() => [
                    J("div", tc, [
                      J("div", null, [
                        T(
                          c.$slots,
                          c.$slots[`foot(${String(v.key)})`] ? `foot(${String(v.key)})` : "foot()",
                          {
                            label: v.label,
                            column: v.key,
                            field: v,
                            isFoot: !0
                          },
                          () => [
                            ne(Y(O(Jt)(v)), 1)
                          ]
                        )
                      ])
                    ])
                  ]),
                  _: 2
                }, 1040, ["class", "title", "abbr", "style", "variant", "onClick"]))), 128))
              ]),
              _: 3
            }, 8, ["variant", "class"])
          ]),
          _: 3
        }, 8, ["variant", "class"])) : c.$slots["custom-foot"] ? (b(), I(Pa, { key: 1 }, {
          default: E(() => [
            T(c.$slots, "custom-foot", {
              fields: n.value,
              items: c.items,
              columns: n.value.length
            })
          ]),
          _: 3
        })) : ae("", !0),
        c.$slots["table-caption"] || c.caption ? (b(), _("caption", ac, [
          T(c.$slots, "table-caption", {}, () => [
            ne(Y(c.caption), 1)
          ])
        ])) : ae("", !0)
      ]),
      _: 3
    }, 8, ["id", "bordered", "borderless", "border-variant", "caption-top", "dark", "fixed", "hover", "no-border-collapse", "outlined", "responsive", "small", "stacked", "sticky-header", "striped", "table-class", "variant", "striped-columns"]));
  }
}), lc = /* @__PURE__ */ J("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-up-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
}, [
  /* @__PURE__ */ J("path", {
    "fill-rule": "evenodd",
    d: "M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"
  })
], -1), oc = /* @__PURE__ */ J("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-down-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
}, [
  /* @__PURE__ */ J("path", {
    "fill-rule": "evenodd",
    d: "M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z"
  })
], -1), nc = {
  style: { opacity: 0.4 },
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-up-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
}, sc = /* @__PURE__ */ J("path", {
  "fill-rule": "evenodd",
  d: "M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"
}, null, -1), rc = [
  sc
], ic = { class: "d-flex align-items-center gap-2 mt-5" }, uc = /* @__PURE__ */ H({
  __name: "BTable",
  props: /* @__PURE__ */ pe({
    provider: { default: void 0 },
    noProvider: { default: void 0 },
    noProviderPaging: { type: Boolean, default: !1 },
    noProviderSorting: { type: Boolean, default: !1 },
    noProviderFiltering: { type: Boolean, default: !1 },
    sortBy: {},
    mustSort: { type: [Boolean, Array], default: !1 },
    noSortReset: { type: Boolean },
    selectable: { type: Boolean, default: !1 },
    multisort: { type: Boolean, default: !1 },
    stickySelect: { type: Boolean, default: !1 },
    selectHead: { type: [Boolean, String], default: !0 },
    selectMode: { default: "multi" },
    selectionVariant: { default: "primary" },
    busy: { type: Boolean },
    busyLoadingText: { default: "Loading..." },
    perPage: { default: Number.POSITIVE_INFINITY },
    currentPage: { default: 1 },
    filter: { default: void 0 },
    filterable: { default: void 0 },
    noLocalSorting: { type: Boolean, default: !1 },
    noSelectOnClick: { type: Boolean, default: !1 },
    selectedItems: {},
    noSortableIcon: { type: Boolean, default: !1 },
    align: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    detailsTdClass: { default: void 0 },
    emptyFilteredText: { default: void 0 },
    emptyText: { default: void 0 },
    fieldColumnClass: { type: [Function, String, Object, Array], default: void 0 },
    fields: { default: () => [] },
    footClone: { type: Boolean, default: void 0 },
    footRowVariant: { default: void 0 },
    footVariant: { default: void 0 },
    headRowVariant: { default: void 0 },
    headVariant: { default: void 0 },
    items: { default: () => [] },
    labelStacked: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    primaryKey: { default: void 0 },
    showEmpty: { type: Boolean, default: void 0 },
    tbodyClass: { default: void 0 },
    tbodyTrAttr: { default: void 0 },
    tbodyTrClass: { type: [Function, String, Object, Array], default: void 0 },
    tfootClass: { default: void 0 },
    tfootTrClass: { default: void 0 },
    theadClass: { default: void 0 },
    theadTrClass: { default: void 0 },
    bordered: { type: Boolean, default: void 0 },
    borderless: { type: Boolean, default: void 0 },
    borderVariant: { default: void 0 },
    captionTop: { type: Boolean, default: void 0 },
    dark: { type: Boolean, default: void 0 },
    fixed: { type: Boolean, default: void 0 },
    hover: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: void 0 },
    outlined: { type: Boolean, default: void 0 },
    responsive: { type: [Boolean, String], default: void 0 },
    small: { type: Boolean, default: void 0 },
    stacked: { type: [Boolean, String], default: void 0 },
    stickyHeader: { type: [Boolean, String, Number], default: void 0 },
    striped: { type: Boolean, default: void 0 },
    stripedColumns: { type: Boolean, default: void 0 },
    variant: { default: void 0 }
  }, {
    sortBy: {
      default: void 0
    },
    sortByModifiers: {},
    busy: { type: Boolean, default: !1 },
    busyModifiers: {},
    selectedItems: {
      default: () => []
    },
    selectedItemsModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["filtered", "head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered", "row-selected", "row-unselected", "selection", "sorted", "change"], ["update:sortBy", "update:busy", "update:selectedItems"]),
  setup(t, { expose: e, emit: l }) {
    const a = t, o = l, r = he(t, "sortBy"), s = he(t, "busy"), n = he(t, "selectedItems"), i = w({
      get: () => /* @__PURE__ */ new Set([...n.value]),
      set: (S) => {
        n.value = [...S];
      }
    }), u = {
      add: (S) => {
        const P = new Set(i.value);
        P.add(S), i.value = P, o("row-selected", S);
      },
      clear: () => {
        i.value.forEach((S) => {
          u.delete(S);
        });
      },
      delete: (S) => {
        const P = new Set(i.value);
        P.delete(S), i.value = P, o("row-unselected", S);
      },
      set: (S) => {
        i.value = new Set(S), i.value.forEach((P) => {
          o("row-unselected", P);
        });
      },
      /* TODO
      This has method and the delete method suffer from an error when using a non-reactive source as the items prop
      ```ts
      const items = [{first_name: 'Geneva', last_name: 'Wilson', age: 89},{first_name: 'Jami', last_name: 'Carney', age: 38}]
      ```
      For some reason, the reference of the object gets lost. However, when you use an actual ref(), it works just fine
      Getting the reference properly will fix all outstanding issues
      */
      has: (S) => {
        if (!a.primaryKey)
          return i.value.has(S);
        const P = a.primaryKey;
        for (const M of i.value) {
          const j = qe(M, P), A = qe(S, P);
          if (j && A && j === A)
            return !0;
        }
        return !1;
      }
    }, d = x([]), p = be(() => a.perPage, { method: "parseInt" }), f = be(() => a.currentPage, { method: "parseInt" }), m = k(() => !!a.filter), y = k(() => a.provider !== void 0), h = k(() => i.value.size > 0), c = w(
      () => r.value !== void 0 || a.fields.some(
        (S) => typeof S == "object" && S !== null && S.sortable === !0
      )
    ), g = w(
      () => a.fields.map((S) => {
        var j;
        if (!(typeof S == "object" && S !== null))
          return S;
        const P = (j = r.value) == null ? void 0 : j.find((A) => S.key === A.key), M = c.value === !1 ? void 0 : P === void 0 ? "none" : P.order === "desc" ? "descending" : "ascending";
        return {
          ...S,
          thAttr: {
            "aria-sort": M,
            ...S.thAttr
          }
        };
      })
    ), v = w(() => ({
      "b-table-busy": s.value,
      "b-table-selectable": a.selectable,
      "user-select-none": a.selectable && h.value
    })), $ = w(() => [
      a.tbodyTrClass ? typeof a.tbodyTrClass == "function" ? a.tbodyTrClass(null, "table-busy") : a.tbodyTrClass : null
    ]), B = (S) => [
      {
        "b-table-sortable-column": c.value && S.sortable
      }
    ], C = (S, P) => [
      {
        [`selected table-${a.selectionVariant}`]: a.selectable && S && u.has(S)
      },
      a.tbodyTrClass ? typeof a.tbodyTrClass == "function" ? a.tbodyTrClass(S, P) : a.tbodyTrClass : null
    ], V = w(() => {
      const S = (j) => {
        var X;
        const A = (X = r.value) == null ? void 0 : X.filter((G) => !!G.order);
        return !A || A.length === 0 ? j : [...j].sort((G, ie) => {
          for (let q = 0; q < (A.length ?? 0); q++) {
            const se = A[q], me = (U) => {
              if (!Ze(U))
                return String(U);
              const z = g.value.find((fe) => Ia(fe) ? fe.key === se.key : !1), oe = qe(U, se.key);
              if (Ia(z) && z.sortByFormatted) {
                const fe = typeof z.sortByFormatted == "function" ? z.sortByFormatted : z.formatter;
                if (fe)
                  return go(U, String(z.key), fe);
              }
              return typeof oe == "object" && oe !== null ? JSON.stringify(oe) : (oe == null ? void 0 : oe.toString()) ?? "";
            }, te = me(G), ye = me(ie), ee = se.comparer ? se.comparer(te, ye) : te.localeCompare(ye, void 0, { numeric: !0 });
            if (ee !== 0)
              return se.order === "asc" ? ee : -ee;
          }
          return 0;
        });
      }, P = (j) => j.filter(
        (A) => Ze(A) ? Object.entries(A).some(([X, G]) => {
          var q, se, me;
          return G == null || X[0] === "_" || !((q = a.filterable) != null && q.includes(X)) && ((se = a.filterable) != null && se.length) ? !1 : (typeof G == "object" ? JSON.stringify(Object.values(G)) : G.toString()).toLowerCase().includes(((me = a.filter) == null ? void 0 : me.toLowerCase()) ?? "");
        }) : !0
      );
      let M = y.value ? d.value : a.items;
      return M = M.map((j) => {
        if (typeof j == "object" && j !== null && Object.keys(j).some((A) => A.includes("."))) {
          let A = {};
          for (const X in j)
            X.includes(".") ? A = Ir(A, X, j[X]) : A[X] = j[X];
          return A;
        }
        return j;
      }), (m.value === !0 && !y.value || m.value === !0 && y.value && a.noProviderFiltering) && (M = P(M)), (c.value === !0 && !y.value && !a.noLocalSorting || c.value === !0 && y.value && a.noProviderSorting) && (M = S(M)), M;
    }), L = w(() => Number.isNaN(p.value) || y.value && !a.noProviderPaging ? V.value : V.value.slice(
      (f.value - 1) * (p.value || Number.POSITIVE_INFINITY),
      f.value * (p.value || Number.POSITIVE_INFINITY)
    ));
    ue(L, (S) => {
      o("change", S);
    });
    const Q = (S, P, M = !1, j = !1, A = !1) => {
      if (a.selectable) {
        if (a.selectMode === "single" || a.selectMode === "multi") {
          if (M || j)
            return;
          u.has(S) ? u.delete(S) : a.selectMode === "single" ? u.set([S]) : u.add(S);
        } else if (j || A)
          u.has(S) ? u.delete(S) : u.add(S);
        else if (M) {
          const X = [...i.value].pop(), G = a.items.findIndex((me) => me === X), ie = Math.min(G, P), q = Math.max(G, P), se = a.items.slice(ie, q + 1);
          u.set(se);
        } else
          u.set([S]);
        le();
      }
    }, W = (S, P, M) => {
      a.noSelectOnClick === !1 && Q(S, P, M.shiftKey, M.ctrlKey, M.metaKey), o("row-clicked", S, P, M);
    }, F = (S) => {
      var se, me;
      if (!c.value)
        return;
      const P = typeof S == "object" && S !== null ? S.key : S, M = typeof S == "object" && S !== null ? S.sortable : !1;
      if (!(c.value === !0 && M === !0))
        return;
      const j = (te) => {
        if (te === "asc")
          return "desc";
        if (te === void 0 || a.mustSort === !0 || Array.isArray(a.mustSort) && a.mustSort.includes(P))
          return "asc";
      }, A = ((se = r.value) == null ? void 0 : se.findIndex((te) => te.key === P)) ?? -1, X = (me = r.value) == null ? void 0 : me[A], G = (
        // If value is new, we default to ascending
        // Otherwise we make a temp copy of the value
        A === -1 || !X ? { key: P, order: "asc" } : { ...X }
      ), ie = () => {
        var ye, ee;
        let te = G;
        if (A === -1)
          r.value = [...r.value ?? [], G];
        else {
          const U = j(G.order);
          te = { ...G, order: U }, r.value = U ? (ye = r.value) == null ? void 0 : ye.map((z) => z.key === te.key ? te : z) : (ee = r.value) == null ? void 0 : ee.filter((z) => z.key !== te.key);
        }
        return te;
      }, q = () => {
        const te = {
          ...G,
          order: A === -1 ? G.order : j(G.order)
        };
        return r.value = [te], te;
      };
      o("sorted", a.multisort === !0 ? ie() : q());
    }, Z = (S, P, M, j = !1) => {
      o("head-clicked", S, P, M, j), F(P);
    }, R = async () => {
      if (!y.value || a.provider === void 0 || s.value)
        return;
      s.value = !0;
      const S = a.provider({
        currentPage: f.value,
        filter: a.filter,
        sortBy: r.value,
        perPage: p.value
      });
      try {
        const P = S instanceof Promise ? await S : S;
        if (P === void 0)
          return;
        d.value = P;
      } finally {
        s.value = !1;
      }
    }, le = () => {
      a.selectable && o("selection", [...i.value]);
    }, N = async (S, P, M) => {
      if (P === M)
        return;
      const j = (ie) => {
        var q;
        return ((q = a.noProvider) == null ? void 0 : q.includes(ie)) === !0;
      }, A = (S === "currentPage" || S === "perPage") && (j("paging") || a.noProviderPaging === !0), X = S === "filter" && (j("filtering") || a.noProviderFiltering === !0), G = (S === "sortBy" || S === "sortDesc") && (j("sorting") || a.noProviderSorting === !0);
      A || X || G || (y.value === !0 && await R(), S === "currentPage" || S === "perPage" || o("filtered", [...V.value]));
    };
    return ue(
      () => a.filter,
      (S, P) => {
        N("filter", S, P), !(S === P || y.value) && (S || o("filtered", [...V.value]));
      }
    ), ue(f, (S, P) => {
      N("currentPage", S, P);
    }), ue(p, (S, P) => {
      N("perPage", S, P);
    }), ue(
      r,
      (S, P) => {
        N("sortBy", S, P);
      },
      { deep: !0 }
    ), ue(
      () => a.provider,
      (S) => {
        if (S === void 0) {
          d.value = [];
          return;
        }
        R();
      }
    ), Xe(R), e({
      // The row selection methods are really for compat. Users should probably use the v-model though
      clearSelected: () => {
        a.selectable && (u.clear(), le());
      },
      refresh: R,
      selectAllRows: () => {
        if (!a.selectable)
          return;
        const S = i.value.size > 0 ? [...i.value] : [];
        i.value = /* @__PURE__ */ new Set([...V.value]), i.value.forEach((P) => {
          S.includes(P) || o("row-selected", P);
        }), le();
      },
      selectRow: (S) => {
        if (!a.selectable)
          return;
        const P = V.value[S];
        !P || u.has(P) || (u.add(P), le());
      },
      unselectRow: (S) => {
        if (!a.selectable)
          return;
        const P = V.value[S];
        !P || !u.has(P) || (u.delete(P), le());
      }
    }), (S, P) => (b(), I(Cn, K(a, {
      "aria-busy": s.value,
      items: L.value,
      fields: g.value,
      "table-class": v.value,
      "tbody-tr-class": C,
      "field-column-class": B,
      onHeadClicked: Z,
      onRowDblClicked: P[0] || (P[0] = (M, j, A) => {
        o("row-dbl-clicked", M, j, A);
      }),
      onRowClicked: W,
      onRowHovered: P[1] || (P[1] = (M, j, A) => {
        o("row-hovered", M, j, A);
      }),
      onRowUnhovered: P[2] || (P[2] = (M, j, A) => {
        o("row-unhovered", M, j, A);
      })
    }), La({
      "head()": E((M) => {
        var j, A, X, G;
        return [
          ne(Y(O(Jt)(M.field)) + " ", 1),
          c.value && M.field.sortable && a.noSortableIcon === !1 ? (b(), _(de, { key: 0 }, [
            ((A = (j = r.value) == null ? void 0 : j.find((ie) => ie.key === M.field.key)) == null ? void 0 : A.order) === "asc" ? T(
              S.$slots,
              S.$slots[`sortAsc(${String(M.field.key)})`] ? `sortAsc(${String(M.field.key)})` : "sortAsc()",
              ge(K({ key: 0 }, { ...M })),
              () => [
                lc
              ]
            ) : ((G = (X = r.value) == null ? void 0 : X.find((ie) => ie.key === M.field.key)) == null ? void 0 : G.order) === "desc" ? T(
              S.$slots,
              S.$slots[`sortDesc(${String(M.field.key)})`] ? `sortDesc(${String(M.field.key)})` : "sortDesc()",
              ge(K({ key: 1 }, { ...M })),
              () => [
                oc
              ]
            ) : T(
              S.$slots,
              S.$slots[`sortDefault(${String(M.field.key)})`] ? `sortDefault(${String(M.field.key)})` : "sortDefault()",
              ge(K({ key: 2 }, { ...M })),
              () => [
                (b(), _("svg", nc, rc))
              ]
            )
          ], 64)) : ae("", !0)
        ];
      }),
      "custom-body": E((M) => [
        s.value ? (b(), I(Je, {
          key: 0,
          class: D(["b-table-busy-slot", $.value])
        }, {
          default: E(() => [
            ve(St, {
              colspan: M.fields.length
            }, {
              default: E(() => [
                T(S.$slots, "table-busy", {}, () => [
                  ve(ma, { show: "" }, {
                    overlay: E(() => [
                      J("div", ic, [
                        ve(pa),
                        J("strong", null, Y(S.busyLoadingText), 1)
                      ])
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 2
            }, 1032, ["colspan"])
          ]),
          _: 2
        }, 1032, ["class"])) : ae("", !0)
      ]),
      _: 2
    }, [
      Ce(S.$slots, (M, j) => ({
        name: j,
        fn: E((A) => [
          T(S.$slots, j, ge(we(A)))
        ])
      }))
    ]), 1040, ["aria-busy", "items", "fields", "table-class"]));
  }
}), dc = /* @__PURE__ */ H({
  inheritAttrs: !1,
  __name: "BTab",
  props: /* @__PURE__ */ pe({
    active: { type: Boolean },
    buttonId: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    id: { default: void 0 },
    lazy: { type: Boolean, default: void 0 },
    lazyOnce: { type: Boolean, default: void 0 },
    noBody: { type: Boolean, default: !1 },
    tag: { default: "div" },
    title: { default: void 0 },
    titleItemClass: { default: void 0 },
    titleLinkAttrs: { default: void 0 },
    titleLinkClass: { default: void 0 }
  }, {
    active: { type: Boolean, default: !1 },
    activeModifiers: {}
  }),
  emits: ["update:active"],
  setup(t) {
    const e = t, l = Le(), a = he(t, "active"), o = _e(ko, null), r = Be(() => e.id, "tabpane"), s = Be(() => e.buttonId, "tab"), n = x(!1), i = x(null), { onClick: u, ...d } = Mt(), p = w(
      () => ({
        id: r.value,
        buttonId: s.value,
        disabled: e.disabled,
        title: e.title,
        titleComponent: l.title,
        titleItemClass: e.titleItemClass,
        titleLinkAttrs: e.titleLinkAttrs,
        titleLinkClass: e.titleLinkClass,
        onClick: u,
        el: i.value
      })
    );
    Xe(() => {
      o && (o.registerTab(p), e.active && o.activateTab(r.value));
    }), Pn(() => {
      o && o.unregisterTab(r.value);
    });
    const f = k(() => (o == null ? void 0 : o.activeId.value) === r.value), m = x(f.value), y = k(() => !!(o != null && o.lazy.value || (e.lazyOnce ?? e.lazy))), h = k(() => e.lazyOnce !== void 0), c = k(() => f.value && !e.disabled), g = k(
      () => c.value || !y.value || y.value && h.value && n.value
    );
    ue(f, ($) => {
      if ($) {
        a.value = !0, setTimeout(() => {
          m.value = !0;
        }, 0);
        return;
      }
      m.value = !1, a.value = !1;
    }), ue(
      () => e.active,
      ($) => {
        if (o) {
          if (!$) {
            f.value && o.activateTab(void 0);
            return;
          }
          o.activateTab(r.value);
        }
      }
    );
    const v = w(() => [
      {
        active: f.value,
        show: m.value,
        "card-body": (o == null ? void 0 : o.card.value) && e.noBody === !1,
        fade: !(o != null && o.noFade.value)
      },
      m.value ? o == null ? void 0 : o.activeTabClass : o == null ? void 0 : o.inactiveTabClass,
      o == null ? void 0 : o.tabClass
    ]);
    return ue(g, ($) => {
      $ && !n.value && (n.value = !0);
    }), ($, B) => (b(), I(re($.tag), K({
      id: O(r),
      ref_key: "el",
      ref: i,
      class: ["tab-pane", v.value],
      role: "tabpanel",
      "aria-labelledby": O(s)
    }, d), {
      default: E(() => [
        g.value ? T($.$slots, "default", { key: 0 }) : ae("", !0)
      ]),
      _: 3
    }, 16, ["id", "class", "aria-labelledby"]));
  }
}), cc = ["aria-orientation"], fc = ["id", "aria-controls", "aria-selected", "onClick"], vc = /* @__PURE__ */ H({
  __name: "BTabs",
  props: /* @__PURE__ */ pe({
    activeId: {},
    activeNavItemClass: { default: void 0 },
    activeTabClass: { default: void 0 },
    align: { default: void 0 },
    card: { type: Boolean, default: !1 },
    contentClass: { default: void 0 },
    end: { type: Boolean, default: !1 },
    fill: { type: Boolean, default: !1 },
    id: { default: void 0 },
    inactiveNavItemClass: { default: void 0 },
    inactiveTabClass: { default: void 0 },
    justified: { type: Boolean, default: !1 },
    lazy: { type: Boolean, default: !1 },
    modelValue: {},
    navClass: { default: void 0 },
    navItemClass: { default: void 0 },
    navWrapperClass: { default: void 0 },
    noFade: { type: Boolean, default: !1 },
    noNavStyle: { type: Boolean, default: !1 },
    pills: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    tag: { default: "div" },
    tabClass: { default: void 0 },
    vertical: { type: Boolean, default: !1 }
  }, {
    modelValue: {
      default: -1
    },
    modelModifiers: {},
    activeId: {
      default: void 0
    },
    activeIdModifiers: {}
  }),
  emits: /* @__PURE__ */ pe(["activate-tab", "click"], ["update:modelValue", "update:activeId"]),
  setup(t, { emit: e }) {
    const l = t, a = e, o = he(t, "modelValue"), r = he(t, "activeId"), s = zt(), n = x([]), i = w(
      () => n.value.map((B) => {
        const C = O(B), V = C.id === r.value;
        return {
          ...C,
          active: V,
          navItemClasses: [
            {
              active: V,
              disabled: C.disabled
            },
            V ? l.activeNavItemClass : l.inactiveNavItemClass,
            l.navItemClass,
            C.titleLinkClass
          ]
        };
      })
    ), u = k(() => !(i != null && i.value && i.value.length > 0)), d = w(() => ({
      "d-flex": l.vertical,
      "align-items-start": l.vertical
    })), p = Dt(() => l.align), f = w(() => ({
      "nav-pills": l.pills,
      "flex-column me-3": l.vertical,
      [p.value]: l.align !== void 0,
      "nav-fill": l.fill,
      "card-header-tabs": l.card,
      "nav-justified": l.justified,
      "nav-tabs": !l.noNavStyle && !l.pills,
      small: l.small
    })), m = (B) => {
      var C;
      if (B !== void 0) {
        const V = (C = i.value[B]) == null ? void 0 : C.id;
        if (B > -1 && B < i.value.length && !i.value[B].disabled && (o.value < 0 || r.value !== V || o.value !== B)) {
          const L = new nt("activate-tab", { cancelable: !0 });
          a("activate-tab", B, o.value, L), L.defaultPrevented || (r.value !== V && (r.value = V), o.value !== B && (o.value = B));
        }
      }
    }, y = (B, C) => {
      var V, L, Q;
      m(C), C >= 0 && !i.value[C].disabled && ((V = i.value[C]) != null && V.onClick) && typeof i.value[C].onClick == "function" && ((Q = (L = i.value[C]).onClick) == null || Q.call(L, B));
    }, h = (B) => {
      var C, V;
      i.value.length <= 0 || (o.value = c(o.value + B, B), (V = document.getElementById((C = i.value[o.value]) == null ? void 0 : C.buttonId)) == null || V.focus());
    }, c = (B, C) => {
      let V = B, L = -1, Q = -1;
      for (let W = 0; W < i.value.length; W++)
        i.value[W].disabled || (L === -1 && (L = W), Q = W);
      for (; V >= L && V <= Q && i.value[V].disabled; )
        V += C;
      return V < L && (V = L), V > Q && (V = Q), V;
    };
    ue(o, (B, C) => {
      if (B === C || i.value.length <= 0)
        return;
      const V = c(B, B > C ? 1 : -1);
      Ve(() => {
        m(V);
      });
    }), ue(r, (B, C) => {
      const V = i.value.findIndex((L) => L.id === B);
      if (B !== C && !(i.value.length <= 0)) {
        if (V === -1) {
          m(c(0, 1));
          return;
        }
        m(V);
      }
    });
    const g = (B) => {
      n.value.find((C) => C.value.id === B.value.id) ? n.value[n.value.findIndex((C) => C.value.id === B.value.id)] = B : n.value.push(B), n.value.sort((C, V) => {
        if (!Node || !C.value.el || !V.value.el)
          return 0;
        const L = C.value.el.compareDocumentPosition(V.value.el);
        return L & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : L & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
      });
    }, v = (B) => {
      n.value = n.value.filter((C) => C.value.id !== B);
    };
    ue(
      n,
      () => {
        $();
      },
      { deep: !0 }
    );
    const $ = () => {
      var B;
      if (i.value.length === 0) {
        o.value = -1, r.value = void 0;
        return;
      }
      if (o.value >= 0 && !r.value && (r.value = (B = i.value[o.value]) == null ? void 0 : B.id), i.value.find((C) => C.id === r.value)) {
        m(i.value.findIndex((C) => C.id === r.value));
        return;
      }
      m(i.value.map((C) => !C.disabled).indexOf(!0));
    };
    return at(ko, {
      lazy: k(() => l.lazy),
      card: k(() => l.card),
      noFade: k(() => l.noFade),
      activeTabClass: k(() => l.activeTabClass),
      inactiveTabClass: k(() => l.inactiveTabClass),
      tabClass: k(() => l.tabClass),
      registerTab: g,
      unregisterTab: v,
      activeId: r,
      activateTab: (B) => {
        const C = i.value.findIndex((V) => V.id === B);
        if (B === void 0 || C === -1) {
          m(c(0, 1));
          return;
        }
        m(C);
      }
    }), (B, C) => (b(), I(re(B.tag), {
      id: B.id,
      class: D(["tabs", d.value])
    }, {
      default: E(() => [
        ve(O(s).define, null, {
          default: E(() => [
            J("div", {
              class: D(["tab-content", B.contentClass])
            }, [
              T(B.$slots, "default"),
              u.value ? (b(), _("div", {
                key: "bv-empty-tab",
                class: D(["tab-pane active", { "card-body": l.card }])
              }, [
                T(B.$slots, "empty")
              ], 2)) : ae("", !0)
            ], 2)
          ]),
          _: 3
        }),
        l.end ? (b(), I(O(s).reuse, { key: 0 })) : ae("", !0),
        J("div", {
          class: D([B.navWrapperClass, { "card-header": l.card, "ms-auto": B.vertical && l.end }])
        }, [
          J("ul", {
            class: D(["nav", [f.value, B.navClass]]),
            role: "tablist",
            "aria-orientation": B.vertical ? "vertical" : "horizontal"
          }, [
            T(B.$slots, "tabs-start"),
            (b(!0), _(de, null, Ce(i.value, (V, L) => (b(), _("li", {
              key: V.id,
              class: D(["nav-item", V.titleItemClass]),
              role: "presentation"
            }, [
              J("button", K({
                id: V.buttonId,
                class: ["nav-link", V.navItemClasses],
                role: "tab",
                "aria-controls": V.id,
                "aria-selected": V.active,
                ref_for: !0
              }, V.titleLinkAttrs, {
                onKeydown: [
                  C[0] || (C[0] = Wt(ft((Q) => h(-1), ["stop", "prevent"]), ["left"])),
                  C[1] || (C[1] = Wt(ft((Q) => h(1), ["stop", "prevent"]), ["right"])),
                  C[2] || (C[2] = Wt(ft((Q) => h(-999), ["stop", "prevent"]), ["page-up"])),
                  C[3] || (C[3] = Wt(ft((Q) => h(999), ["stop", "prevent"]), ["page-down"]))
                ],
                onClick: ft((Q) => y(Q, L), ["stop", "prevent"])
              }), [
                V.titleComponent ? (b(), I(re(V.titleComponent), { key: 0 })) : (b(), _(de, { key: 1 }, [
                  ne(Y(V.title), 1)
                ], 64))
              ], 16, fc)
            ], 2))), 128)),
            T(B.$slots, "tabs-end")
          ], 10, cc)
        ], 2),
        l.end ? ae("", !0) : (b(), I(O(s).reuse, { key: 1 }))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), pc = { id: "__BVID__toaster-container" }, mc = /* @__PURE__ */ H({
  __name: "BToastOrchestrator",
  props: {
    appendToast: { type: Boolean, default: !1 },
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  },
  setup(t, { expose: e }) {
    const l = t, a = {
      "top-left": "top-0 start-0",
      "top-center": "top-0 start-50 translate-middle-x",
      "top-right": "top-0 end-0",
      "middle-left": "top-50 start-0 translate-middle-y",
      "middle-center": "top-50 start-50 translate-middle",
      "middle-right": "top-50 end-0 translate-middle-y",
      "bottom-left": "bottom-0 start-0",
      "bottom-center": "bottom-0 start-50 translate-middle-x",
      "bottom-right": "bottom-0 end-0"
    }, { remove: o, toasts: r, show: s, _setIsAppend: n } = Xo();
    ue(
      () => l.appendToast,
      (u) => {
        n == null || n(u);
      },
      { immediate: !0 }
    );
    const i = (u) => va(u, ["_modelValue", "_self", "pos"]);
    return e({
      remove: o,
      show: s,
      toasts: r
    }), (u, d) => (b(), I(ht, {
      to: u.teleportTo,
      disabled: l.teleportDisabled
    }, [
      J("div", pc, [
        (b(), _(de, null, Ce(a, (p, f) => J("div", {
          key: f,
          class: D([p, "toast-container position-fixed p-3"])
        }, [
          ve(jl, { name: "b-list" }, {
            default: E(() => {
              var m;
              return [
                (b(!0), _(de, null, Ce((m = O(r)) == null ? void 0 : m.filter((y) => y.value.props.pos === f), (y) => (b(), I(re(y.value.component), K({
                  key: y.value.props._self,
                  ref_for: !0
                }, i(y.value.props), {
                  modelValue: y.value.props._modelValue,
                  "onUpdate:modelValue": (h) => y.value.props._modelValue = h,
                  "trans-props": { ...y.value.props.transProps, appear: !0 },
                  onHide: ft((h) => {
                    var c;
                    return (c = O(o)) == null ? void 0 : c(y.value.props._self);
                  }, ["prevent"])
                }), null, 16, ["modelValue", "onUpdate:modelValue", "trans-props", "onHide"]))), 128))
              ];
            }),
            _: 2
          }, 1024)
        ], 2)), 64))
      ])
    ], 8, ["to", "disabled"]));
  }
}), bc = /* @__PURE__ */ H({
  __name: "BTooltip",
  props: /* @__PURE__ */ pe({
    interactive: { type: Boolean, default: void 0 },
    boundary: {},
    boundaryPadding: {},
    click: { type: Boolean, default: void 0 },
    content: { default: void 0 },
    customClass: { default: void 0 },
    delay: { default: void 0 },
    floatingMiddleware: { default: void 0 },
    hide: { type: Boolean, default: void 0 },
    html: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: void 0 },
    manual: { type: Boolean, default: void 0 },
    modelValue: { type: Boolean },
    noAutoClose: { type: Boolean, default: void 0 },
    noFade: { type: Boolean, default: void 0 },
    noFlip: { type: Boolean, default: void 0 },
    noHide: { type: Boolean, default: void 0 },
    noShift: { type: Boolean, default: void 0 },
    noSize: { type: Boolean },
    noninteractive: { type: Boolean, default: void 0 },
    offset: { default: void 0 },
    placement: { default: void 0 },
    persistent: { type: Boolean },
    realtime: { type: Boolean, default: void 0 },
    reference: { default: void 0 },
    strategy: { default: void 0 },
    target: { default: void 0 },
    title: { default: void 0 },
    variant: { default: void 0 },
    teleportDisabled: { default: void 0 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: void 0 },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t, { expose: e }) {
    var s, n, i;
    const l = t, a = he(t, "modelValue"), o = w(() => {
      const { interactive: u, noninteractive: d, ...p } = l;
      return { noninteractive: d !== void 0 ? d : !u, ...p };
    }), r = x(null);
    return e({
      hide: (s = r.value) == null ? void 0 : s.hide,
      show: (n = r.value) == null ? void 0 : n.show,
      toggle: (i = r.value) == null ? void 0 : i.toggle
    }), (u, d) => (b(), I(Ka, K({
      ref_key: "popover",
      ref: r
    }, o.value, {
      modelValue: a.value,
      "onUpdate:modelValue": d[0] || (d[0] = (p) => a.value = p),
      tooltip: ""
    }), La({ _: 2 }, [
      Ce(u.$slots, (p, f) => ({
        name: f,
        fn: E((m) => [
          T(u.$slots, f, ge(we(m)))
        ])
      }))
    ]), 1040, ["modelValue"]));
  }
}), Rl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BAccordion: ti,
  BAccordionItem: li,
  BAlert: ni,
  BAvatar: ui,
  BAvatarGroup: di,
  BBadge: ci,
  BBreadcrumb: pi,
  BBreadcrumbItem: en,
  BButton: vt,
  BButtonGroup: mi,
  BButtonToolbar: yi,
  BCard: rn,
  BCardBody: nn,
  BCardFooter: sn,
  BCardGroup: Bi,
  BCardHeader: an,
  BCardImg: tl,
  BCardSubtitle: on,
  BCardText: wi,
  BCardTitle: ln,
  BCarousel: Ai,
  BCarouselSlide: Ei,
  BCloseButton: Pt,
  BCol: Ft,
  BCollapse: Qo,
  BContainer: zi,
  BDropdown: un,
  BDropdownDivider: xi,
  BDropdownForm: ji,
  BDropdownGroup: Gi,
  BDropdownHeader: Ki,
  BDropdownItem: Xi,
  BDropdownItemButton: Ji,
  BDropdownText: eu,
  BForm: dn,
  BFormCheckbox: fn,
  BFormCheckboxGroup: uu,
  BFormFile: mu,
  BFormFloatingLabel: ou,
  BFormGroup: ku,
  BFormInput: Tu,
  BFormInvalidFeedback: Va,
  BFormRadio: pn,
  BFormRadioGroup: Ou,
  BFormRow: Qt,
  BFormSelect: Lu,
  BFormSelectOption: al,
  BFormSelectOptionGroup: mn,
  BFormSpinbutton: Mu,
  BFormTag: bn,
  BFormTags: td,
  BFormText: Aa,
  BFormTextarea: ld,
  BFormValidFeedback: Oa,
  BImg: el,
  BInputGroup: dd,
  BInputGroupAddon: ll,
  BInputGroupAppend: cd,
  BInputGroupPrepend: fd,
  BInputGroupText: yn,
  BLink: ot,
  BListGroup: vd,
  BListGroupItem: pd,
  BModal: _a,
  BModalOrchestrator: bd,
  BNav: yd,
  BNavForm: hd,
  BNavItem: wd,
  BNavItemDropdown: kd,
  BNavText: Td,
  BNavbar: Sd,
  BNavbarBrand: _d,
  BNavbarNav: Vd,
  BNavbarToggle: zd,
  BOffcanvas: Md,
  BOverlay: ma,
  BPagination: Dd,
  BPlaceholder: je,
  BPlaceholderButton: hn,
  BPlaceholderCard: jd,
  BPlaceholderTable: Wd,
  BPlaceholderWrapper: Gd,
  BPopover: Ka,
  BProgress: Zo,
  BProgressBar: Yo,
  BRow: Xd,
  BSpinner: pa,
  BTab: dc,
  BTable: uc,
  BTableLite: Cn,
  BTableSimple: ol,
  BTabs: vc,
  BTbody: Bn,
  BTd: St,
  BTfoot: Pa,
  BTh: Ea,
  BThead: wn,
  BToast: Jo,
  BToastOrchestrator: mc,
  BTooltip: bc,
  BTr: Je,
  BTransition: It
}, Symbol.toStringTag, { value: "Module" })), hc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useBreadcrumb: zo,
  useColorMode: Pr,
  useModal: zr,
  useModalController: Go,
  useScrollspy: Ko,
  useToast: Xo
}, Symbol.toStringTag, { value: "Module" })), Bc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BvCarouselEvent: ql,
  BvEvent: nt,
  BvTriggerableEvent: Bt
}, Symbol.toStringTag, { value: "Module" })), wc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Cc = ({
  components: t = !1,
  directives: e = !1,
  plugins: l = {}
} = {}) => ({
  install(a) {
    const o = typeof t == "boolean" ? { all: t } : t, r = Object.keys(Rl);
    Bl(o, r).forEach((u) => {
      const d = Rl[u];
      a.component(u, d);
    });
    const s = typeof e == "boolean" ? { all: e } : e, n = Object.keys(Fl), i = (u) => u.toLowerCase().startsWith("v") ? u.slice(1) : u;
    Bl(s, n).forEach((u) => {
      const d = i(u), p = Fl[u];
      a.directive(d, p);
    }), ((l == null ? void 0 : l.breadcrumb) ?? !0) && a.use(Wr), (((l == null ? void 0 : l.id) ?? !0) || typeof l.id == "object") && a.use(Gr, l), ((l == null ? void 0 : l.modalController) ?? !0) && a.use(Zr), ((l == null ? void 0 : l.modalManager) ?? !0) && a.use(Jr), (((l == null ? void 0 : l.rtl) ?? !0) || typeof l.rtl == "object") && a.use(Qr, l), ((l == null ? void 0 : l.toast) ?? !0) && a.use(qr);
  }
});
export {
  ti as BAccordion,
  li as BAccordionItem,
  ni as BAlert,
  ui as BAvatar,
  di as BAvatarGroup,
  ci as BBadge,
  pi as BBreadcrumb,
  en as BBreadcrumbItem,
  vt as BButton,
  mi as BButtonGroup,
  yi as BButtonToolbar,
  rn as BCard,
  nn as BCardBody,
  sn as BCardFooter,
  Bi as BCardGroup,
  an as BCardHeader,
  tl as BCardImg,
  on as BCardSubtitle,
  wi as BCardText,
  ln as BCardTitle,
  Ai as BCarousel,
  Ei as BCarouselSlide,
  Pt as BCloseButton,
  Ft as BCol,
  Qo as BCollapse,
  zi as BContainer,
  un as BDropdown,
  xi as BDropdownDivider,
  ji as BDropdownForm,
  Gi as BDropdownGroup,
  Ki as BDropdownHeader,
  Xi as BDropdownItem,
  Ji as BDropdownItemButton,
  eu as BDropdownText,
  dn as BForm,
  fn as BFormCheckbox,
  uu as BFormCheckboxGroup,
  mu as BFormFile,
  ou as BFormFloatingLabel,
  ku as BFormGroup,
  Tu as BFormInput,
  Va as BFormInvalidFeedback,
  pn as BFormRadio,
  Ou as BFormRadioGroup,
  Qt as BFormRow,
  Lu as BFormSelect,
  al as BFormSelectOption,
  mn as BFormSelectOptionGroup,
  Mu as BFormSpinbutton,
  bn as BFormTag,
  td as BFormTags,
  Aa as BFormText,
  ld as BFormTextarea,
  Oa as BFormValidFeedback,
  el as BImg,
  dd as BInputGroup,
  ll as BInputGroupAddon,
  cd as BInputGroupAppend,
  fd as BInputGroupPrepend,
  yn as BInputGroupText,
  ot as BLink,
  vd as BListGroup,
  pd as BListGroupItem,
  _a as BModal,
  bd as BModalOrchestrator,
  yd as BNav,
  hd as BNavForm,
  wd as BNavItem,
  kd as BNavItemDropdown,
  Td as BNavText,
  Sd as BNavbar,
  _d as BNavbarBrand,
  Vd as BNavbarNav,
  zd as BNavbarToggle,
  Md as BOffcanvas,
  ma as BOverlay,
  Dd as BPagination,
  je as BPlaceholder,
  hn as BPlaceholderButton,
  jd as BPlaceholderCard,
  Wd as BPlaceholderTable,
  Gd as BPlaceholderWrapper,
  Ka as BPopover,
  Zo as BProgress,
  Yo as BProgressBar,
  Xd as BRow,
  pa as BSpinner,
  dc as BTab,
  uc as BTable,
  Cn as BTableLite,
  ol as BTableSimple,
  vc as BTabs,
  Bn as BTbody,
  St as BTd,
  Pa as BTfoot,
  Ea as BTh,
  wn as BThead,
  Jo as BToast,
  mc as BToastOrchestrator,
  bc as BTooltip,
  Je as BTr,
  It as BTransition,
  ql as BvCarouselEvent,
  nt as BvEvent,
  Bt as BvTriggerableEvent,
  Rl as Components,
  hc as Composables,
  Fl as Directives,
  wc as Types,
  Bc as Utils,
  Cc as createBootstrap,
  Cc as default,
  zo as useBreadcrumb,
  Pr as useColorMode,
  zr as useModal,
  Go as useModalController,
  Ko as useScrollspy,
  Xo as useToast,
  Ad as vBColorMode,
  Na as vBModal,
  Id as vBPopover,
  Pd as vBScrollspy,
  Na as vBToggle,
  Ed as vBTooltip
};
//# sourceMappingURL=bootstrap-vue-next.mjs.map
